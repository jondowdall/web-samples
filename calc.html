<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>calculator</title>
    <style>
        html {
            height: 100vh;
            width: 100vw;
            font-family: math;
            height: -webkit-fill-available;
        }

        body {
            margin: 0;
            overflow: hidden;
            padding: 0;
        }

        button {
            font-family: math;
        }

        .active {
            background: lightyellow;
        }

        .replace {
            background: pink;
        }

        .function,
        .action {
            border: 2px outset lightblue;
            border-radius: 0.5em;
            text-align: center;
            vertical-align: middle;
            font-size: 200%;
            line-height: 2em;
            /*box-shadow: 0.5em 0.5em 0.6em 0.3em rgba(150, 150, 150, 0.8);*/
            box-shadow: 5px 5px 6px 3px rgba(150, 150, 150, 0.8);
        }

        sup,
        sub {
            font-size: 50%;
        }

        .function {
            background: darkblue;
            color: lightblue;
            margin: 3px;
        }

        .action {
            background: linear-gradient(170deg, darkblue, lightblue 75%, blue);
            color: white;
            margin: 3px;

        }

        #layout {
            border: none;
            overflow: hidden;
            display: grid;
            grid-template-rows: min-content 1fr 1fr min-content repeat(8, 1fr);
            grid-template-columns: repeat(7, 1fr);
            min-height: -webkit-fill-available;
        }

        #status {
            grid-column: 1 / -1;
            grid-row: 1 / 2;
        }


        #expression {
            grid-column: 1 / -1;
            grid-row: 2 / 3;
            font-size: 200%;
            padding: 0.2em 0.4em;
        }

        #svg {
            position: fixed;
            top: 0;
            right: 0;
            padding: 0.2em 0.4em;
            border: 1px solid gray;
        }

        #sub-answer {
            grid-column: 1 / 4;
            grid-row: 3 / 4;
            padding: 0 0.5em;
        }

        #answer {
            grid-column: 4 / -1;
            grid-row: 3 / 4;
            text-align: right;
            font-size: 200%;
            padding: 0 0.5em;
        }

        #settings {
            grid-column: 1 / -1;
            grid-row: 4 / 5;
        }

        #buttons {
            grid-column: 1 / -1;
            grid-row: 5 / -1;
        }

        .collapsed {
            font-weight: bold;
            color: blue;
        }

        #debug {
            position: fixed;
            top: 0;
            left: 0;
            width: 25vw;
            /*height: 25vh;*/
            background: white;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="debug"></div>
    <div id="layout">
        <div id="status"></div>
        <div id="expression"></div>
        <div id="svg"></div>
        <div id="sub-answer"></div>
        <div id="answer"></div>
        <div id="settings"></div>
        <div id="buttons"></div>
        <script>
            const digit = (value) => (event) => {
                active.expression.addDigit(value);
                update();
            };

            const buttons = [
                { id: 'collapse', html: '&asymp;', x: 1, y: 6, action: collapse, class: 'function', },
                { id: 'edit', html: '&#9998;', x: 2, y: 6, action: changeMode, class: 'function', },
                { id: 'up', html: '&#8612;&#8614;', x: 3, y: 6, action: up, class: 'function', },
                { id: 'down', html: '&#8614;&#8612;', x: 4, y: 6, action: down, class: 'function', },
                { id: 'left', html: '&larr;', x: 5, y: 6, action: left, class: 'function', },
                { id: 'right', html: '&rarr;', x: 6, y: 6, action: right, class: 'function', },
                { id: 'braces', html: '()', x: 1, y: 5, action: braces, class: 'function', },
                { id: 'previous', html: '&#8679;', x: 2, y: 5, action: previous, class: 'function', },
                { id: 'next', html: '&#8681;', x: 3, y: 5, action: next, class: 'function', },
                { id: 'sign', html: '<sup>+</sup>/<sub>&#8722</sub>', x: 1, y: 11, action: sign, class: 'function', },
                { id: 'square', html: 'x<sup>2</sup>', x: 1, y: 7, action: square, class: 'function', },
                { id: 'cube', html: 'x<sup>3</sup>', x: 2, y: 7, action: cube, class: 'function', },
                { id: 'power', html: 'x<sup>y</sup>', x: 3, y: 7, action: power, class: 'function', },
                { id: 'square-root', html: '&#8730x', x: 4, y: 7, action: squareRoot, class: 'function', },
                { id: 'cube-root', html: '&#8731x', x: 5, y: 7, action: cubeRoot, class: 'function', },
                { id: 'root', html: '<sup>y</sup>&#8730x', x: 6, y: 7, action: root, class: 'function', },
                { id: 'sin', html: 'sin', althtml: 'sin<sup>-1</sup>', x: 1, y: 8, action: sine, class: 'function', },
                { id: 'cos', html: 'cos', althtml: 'cos<sup>-1</sup>', x: 2, y: 8, action: cosine, class: 'function', },
                { id: 'tan', html: 'tan', althtml: 'tan<sup>-1</sup>', x: 3, y: 8, action: tangent, class: 'function', },
                { id: 'sinh', html: 'sinh', althtml: 'sinh<sup>-1</sup>', x: 1, y: 9, action: sinh, class: 'function', },
                { id: 'cosh', html: 'cosh', althtml: 'cosh<sup>-1</sup>', x: 2, y: 9, action: cosh, class: 'function', },
                { id: 'tanh', html: 'tanh', althtml: 'tanh<sup>-1</sup>', x: 3, y: 9, action: tanh, class: 'function', },
                { id: 'ln', html: 'ln', x: 1, y: 10, action: ln, class: 'function', },
                { id: 'exp', html: 'exp', x: 2, y: 10, action: exp, class: 'function', },
                { id: 'log', html: 'log', x: 3, y: 10, action: log, class: 'function', },
                { id: 'ee', html: 'EE', x: 7, y: 6, action: EE, class: 'function', },
                { id: 'inv', html: '<sup>1</sup>/<sub>x</sub>', x: 2, y: 11, action: inv, class: 'function', },
                { id: 'e', html: 'e', x: 3, y: 11, action: e, class: 'function', },
                { id: 'alt', html: 'alt', x: 1, y: 12, action: alt, class: 'function', },
                { id: 'angle', html: 'deg', x: 2, y: 12, action: changeAngleUnits, class: 'function', },
                { id: 'pi', html: '\u03C0', x: 3, y: 12, action: pi, class: 'function', },

                { id: 'clear', html: 'C', x: 4, y: 8, action: clear, class: 'action', },
                { id: 'del', html: 'del', x: 7, y: 7, action: del, class: 'action', },

                { id: 'percent', html: '%', x: 5, y: 8, action: percent, class: 'action', },
                { id: 'divide', html: '&#247', x: 6, y: 8, action: divide, class: 'action', },
                { id: 'multiply', html: '&#215', x: 7, y: 8, action: multiply, class: 'action', },

                { id: 'subtraction', html: '-', x: 7, y: 9, action: subtraction, class: 'action', },
                { id: 'addition', html: '+', x: 7, y: 10, action: addition, class: 'action', },

                { id: 'equal', html: '=', x: 7, y: 11, action: equal, class: 'action', },
                { id: 'enter', html: '&#9166;', x: 7, y: 12, action: enter, class: 'action', },

                { id: 'decimal', html: '.', x: 6, y: 12, action: point, class: 'action', },

                { id: 'zero', html: '0', x: 4, y: 12, width: 2, action: digit(0), class: 'action', },
                { id: 'one', html: '1', x: 4, y: 11, action: digit(1), class: 'action', },
                { id: 'two', html: '2', x: 5, y: 11, action: digit(2), class: 'action', },
                { id: 'three', html: '3', x: 6, y: 11, action: digit(3), class: 'action', },
                { id: 'four', html: '4', x: 4, y: 10, action: digit(4), class: 'action', },
                { id: 'five', html: '5', x: 5, y: 10, action: digit(5), class: 'action', },
                { id: 'six', html: '6', x: 6, y: 10, action: digit(6), class: 'action', },
                { id: 'seven', html: '7', x: 4, y: 9, action: digit(7), class: 'action', },
                { id: 'eight', html: '8', x: 5, y: 9, action: digit(8), class: 'action', },
                { id: 'nine', html: '9', x: 6, y: 9, action: digit(9), class: 'action', },
            ];

            addEventListener('load', function (e) {
                addButtonActions();
                addKeyActions();
            });

            let debug = document.getElementById('debug');
            let gap = 0;

            let angleScale = Math.PI / 180;
            let angleUnits = 'deg';
            let altMode = false;
            const stack = [];
            const precision = (value, places = 14) => Math.round(value * Math.pow(10, places)) / Math.pow(10, places);

            /**
             * Return an svg element of the given types with the attribtutes specified.
             */
            function svgElement(element, attributes = {}, content) {
                const node = document.createElementNS('http://www.w3.org/2000/svg', element);

                for (const [attribute, value] of Object.entries(attributes)) {
                    node.setAttribute(attribute, value);
                }

                if (content !== undefined) {
                    node.textContent = content;
                }
                return node;
            }

            /**
             * Draw a root operator in svg adjusting to the size of the elements
             */
            function drawRoot(svg, value, root) {
                /*
                 * Create a group node to hold symbol and children.
                 */
                const group = svgElement('g');

                const rootBox = root ? root.getBBox() : { x: 0, y: 0, width: 5, height: 5 };
                const valueBox = value.getBBox();

                const height = valueBox.height + gap;
                const width = valueBox.width + gap;
                const x = 0.75 * rootBox.width - 6;
                const y = 0.75 * rootBox.height - 2;
                const w2 = height / 5;

                const points = [
                    [x, 5 + y],
                    [x + 5, y],
                    [x + 5 + w2, height],
                    [x + 5 + 2 * w2, 0],
                    [x + 5 + 2 * w2 + width, 0],
                    [x + 5 + 2 * w2 + width, 1],
                    [x + 5 + 2 * w2, 1],
                    [x + 5 + w2 - 0.5, height + 3],
                    [x + 5, y + 1],
                ];
                const path = points.map((p) => `${p[0]}, ${p[1]}`).join(' L');
                console.log(path);

                const symbol = svgElement('path', {
                    d: `M${path} z`,
                    stroke: 'none', fill: 'black', 'stroke-width': 1,
                });

                group.appendChild(symbol);
                group.appendChild(value);
                setPosition(value, x + 5 + 2 * w2, 2);
                if (root) {
                    group.appendChild(root);
                    setPosition(root, 0, 0);
                    setScale(root, 0.75);
                }
                svg.append(group);
                return group;
            }

            /**
             * Draw a binary operator in svg adjusting to the size of the elements
             */
            function drawBinaryOperator(svg, value1, value2, operator) {
                /*
                 * Create a group node to hold symbol and children.
                 */
                const group = svgElement('g');

                const symbol = svgElement('text',
                    {
                        x: 0, y: 0,
                        'font-family': 'math',
                        'font-size': '12pt',
                        'dominant-baseline': 'hanging'
                    },
                    operator);
                svg.appendChild(symbol);

                const value1Box = value1.getBBox();
                const value2Box = value2.getBBox();
                const symbolBox = symbol.getBBox();

                const height = Math.max(value1Box.height, value2Box.height, symbolBox.height);
                const symbolX = value1Box.width + gap;
                const value2X = symbolX + symbolBox.width + gap;
                const value1Y = (height - value1Box.height) / 2;
                const symbolY = (height - symbolBox.height) / 2;
                const value2Y = (height - value2Box.height) / 2;

                group.appendChild(value1);
                setPosition(value1, 0, value1Y);
                group.appendChild(symbol);
                setPosition(symbol, symbolX, symbolY);
                group.appendChild(value2);
                setPosition(value2, value2X, value2Y);

                svg.append(group);
                return group;
            }

            /**
             * Draw a unary operator in svg adjusting to the size of the element
             */
            function drawUnaryOperator(svg, value, symbol) {
                /*
                 * Create a group node to hold symbol and children.
                 */
                const group = svgElement('g');

                const symbolBox = symbol.getBBox();
                const valueBox = value.getBBox();

                const height = Math.max(symbolBox.height, valueBox.height);

                const openBrace = drawValue(svg, '(');
                svg.appendChild(openBrace);
                const openBraceBox = openBrace.getBBox();
                setScale(openBrace, 1, height / openBraceBox.height);

                const closeBrace = drawValue(svg, ')');
                svg.appendChild(closeBrace);
                const closeBraceBox = closeBrace.getBBox();
                setScale(closeBrace, 1, height / closeBraceBox.height);

                const openBraceX = symbolBox.width + gap;
                const valueX = openBraceX + openBraceBox.width + gap;
                const closeBraceX = valueX + valueBox.width + gap;

                const symbolY = (height - symbolBox.height) / 2;
                const valueY = (height - valueBox.height) / 2;

                group.appendChild(symbol);
                setPosition(symbol, 0, symbolY);

                group.appendChild(openBrace);
                setPosition(openBrace, openBraceX, 0);

                group.appendChild(value);
                setPosition(value, valueX, valueY);

                group.appendChild(closeBrace);
                setPosition(closeBrace, closeBraceX, 0);

                svg.append(group);
                return group;
            }

            /**
             * Draw a simple value
             */
            function drawValue(svg, value) {
                const symbol = svgElement('text',
                    {
                        x: 0, y: 0,
                        'font-family': 'math',
                        'font-size': '12pt',
                        'dominant-baseline': 'hanging'
                    },
                    `${value}`);
                svg.appendChild(symbol);
                return symbol;
            }

            /**
             * Draw a division operator in svg adjust to the size of the elements
             */
            function drawDivision(svg, dividend, divisor) {
                /*
                 * Create a group node to hold symbol and children.
                 */
                const group = svgElement('g');

                const dividendBox = dividend.getBBox();
                const divisorBox = divisor.getBBox();

                const width = Math.max(dividendBox.width, divisorBox.width);
                const position = dividendBox.height;

                const line = svgElement('path', {
                    d: `M0, ${position} L${width}, ${position}`,
                    stroke: 'black', fill: 'none', 'stroke-width': 2,
                });
                group.appendChild(line);

                group.appendChild(dividend);
                setPosition(dividend, (width - dividendBox.width) / 2, 0);

                group.appendChild(divisor);
                setPosition(divisor, (width - divisorBox.width) / 2, position + 3);

                svg.append(group);

                return group;
            }
            /**
             * Set the position of an svg element or group
             */
            function setPosition(element, x, y) {
                if (element.getAttribute('x') === null) {
                    element.setAttribute('transform', `translate(${x}, ${y})`);
                } else {
                    element.setAttribute('x', `${x}`);
                    element.setAttribute('y', `${y}`);
                }
            }

            /**
             * Set the scale of an svg element or group
             */
            function setScale(element, scaleX, scaleY = '') {
                element.setAttribute('transform', `scale(${scaleX} ${scaleY})`);
            }

            /**
             * Test function to check svg code
             */
            function renderSvg(expression) {
                const container = document.getElementById('svg');
                const svg = svgElement('svg');//, {viewBox: '0 0 100 100'});
                container.innerHTML = '';
                container.append(svg);

                return expression.renderSvg(svg);
                svg.appendChild()
                const value = drawValue(svg, '56223');
                const add = drawValue(svg, '\u03C0');
                const divisor = drawValue(svg, '5.897');
                const root = drawValue(svg, '2.56');
                const operator = drawValue(svg, 'cos');

                svg.appendChild(drawUnaryOperator(svg, drawDivision(svg, drawBinaryOperator(svg, drawRoot(svg, value, root), add, '\u00d7'), divisor), operator));
                //svg.appendChild(drawDivision(svg, drawRoot(svg, value, root), add));
            }

            function newExpression(value = null) {
                return {
                    input: [],
                    value: value,
                    decimal: (value && Math.trunc(value) !== value) ? (value + '').replace(/^[0-9]*\./, '').length : 0,
                    valueOf() {
                        return this.value || 0;
                    },
                    asString() {
                        return this.value === null ? '_' : `${this.value}`;
                    },
                    addDigit(digit) {
                        if (replace) {
                            this.value = digit;
                            this.decimal = 0;
                            replace = false;
                        } else {
                            this.value = this.value || 0;
                            if (this.decimal) {
                                this.value += digit * Math.pow(10, -this.decimal);
                                this.decimal += 1;
                            } else {
                                this.value = this.value * 10 + digit;
                            }
                        }
                    },
                    htmlNodes() {
                        return this.asString();
                    },
                    renderSvg(svg) {
                        if (this.operator && this.operator.renderSvg) {
                            return this.operator.renderSvg(svg);
                        }
                        return drawValue(svg, this.valueOf());
                    },
                };
            }

            function constant(name, value, symbol) {
                active.expression = {
                    operator: { name },
                    input: [],
                    valueOf() {
                        return value;
                    },
                    asString() {
                        return symbol;
                    },
                    htmlNodes() {
                        const fragment = document.createDocumentFragment();
                        const label = document.createElement('span');
                        fragment.append(label);
                        label.innerHTML = symbol;
                        return fragment;
                    },
                    renderSvg(svg) {
                        return drawValue(svg, this.symbol);
                    },
                }
                return active.expression;
            }

            function unaryOperator(operator, asString, prefix, postfix) {
                let input = [newNode(active.expression, active)];
                if (replace && active.expression.input.length === 1) {
                    input = [active.expression.input[0]];
                }

                const expression = {
                    input,
                    operator,
                    valueOf() {
                        return this.operator.fn(...this.input.map((input) => input.expression));//evaluate(this.input[0].expression);
                    },
                    asString() {
                        return asString(this.input[0].asString);
                    },
                    addDigit(digit) {
                        if (replace) {
                            active.expression = newExpression(digit);
                            replace = false;
                        } else {
                            const symbol = document.createElement('span');
                            symbol.innerHTML = ' &#xD7; ';
                            binaryOperator(
                                operatorByName('multiplication'),
                                (str1, str2) => `${str1} &#xD7; ${str2}`,
                                '(', symbol, ')');
                            active.expression.input = [active.expression.input[1], active.expression.input[0]];
                            active = active.expression.input[0];
                            active.expression.addDigit(digit);
                        }
                    },
                    htmlNodes() {
                        const fragment = document.createDocumentFragment();
                        if (prefix) {
                            fragment.append(prefix);
                        }
                        fragment.append(this.input[0].getNode());
                        if (postfix) {
                            fragment.append(postfix);
                        }
                        return fragment;
                    },
                    renderSvg(svg) {
                        if (this.operator.renderSvg) {
                            const value = this.input[0].expression.renderSvg(svg);
                            return this.operator.renderSvg(svg, value);
                        }
                        /*
                         * Create a group node to hold symbol and children.
                         */
                        const group = svgElement('g');
                        const prefixSymbol = drawValue(svg, prefix);
                        const value = this.input[0].expression.renderSvg(svg);
                        const postfixSymbol = drawValue(svg, postfix);

                        const prefixBox = prefixSymbol.getBBox();
                        const postfixBox = postfixSymbol.getBBox();
                        const valueBox = value.getBBox();

                        const height = Math.max(prefixBox.height, postfixBox.height, valueBox.height);
                        const valueX = prefixBox.width + gap;
                        const postfixX = valueX + valueBox.width + gap;
                        const prefixY = (height - prefixBox.height) / 2;
                        const valueY = (height - valueBox.height) / 2;
                        const postfixY = (height - postfixBox.height) / 2;

                        group.appendChild(prefixSymbol);
                        setPosition(prefixSymbol, 0, prefixY);
                        group.appendChild(value);
                        setPosition(value, valueX, valueY);
                        group.appendChild(postfixSymbol);
                        setPosition(postfixSymbol, postfixX, postfixY);

                        svg.append(group);
                        return group;
                    },
                };
                active.expression = expression;
                if (expression.input[0].expression.value === null) {
                    active = active.expression.input[0];
                }
                replace = false;
                return expression;
            }

            function binaryOperator(operator, asString, prefix, symbol, postfix) {
                let input = [newNode(active.expression, active), newNode(undefined, active)];
                if (replace && active.expression.input.length === 2) {
                    input = [active.expression.input[0], active.expression.input[1]];
                }

                const expression = {
                    input,
                    operator,
                    valueOf() {
                        return this.operator.fn(...this.input.map((input) => input.expression));//(this.input[0].expression, this.input[1].expression);
                    },
                    asString() {
                        return asString(this.input[0].asString, this.input[1].asString);
                    },
                    addDigit(digit) {
                        if (replace) {
                            active.expression = newExpression(digit);
                            replace = false;
                        } else {
                            const symbol = document.createElement('span');
                            symbol.innerHTML = ' &#xD7; ';
                            binaryOperator(
                                operatorByName('multiplication'),
                                (str1, str2) => `${str1} &#xD7; ${str2}`,
                                '(', symbol, ')');
                            active.expression.input = [active.expression.input[1], active.expression.input[0]];
                            active = active.expression.input[0];
                            active.expression.addDigit(digit);
                        }
                    },
                    htmlNodes() {
                        const fragment = document.createDocumentFragment();
                        if (prefix) {
                            fragment.append(prefix);
                        }
                        fragment.append(this.input[0].getNode());
                        if (symbol) {
                            fragment.append(symbol);
                        }
                        fragment.append(this.input[1].getNode());
                        if (postfix) {
                            fragment.append(postfix);
                        }
                        return fragment;
                    },
                    renderSvg(svg) {
                        if (this.operator.renderSvg) {
                            const value1 = this.input[0].expression.renderSvg(svg);
                            const value2 = this.input[1].expression.renderSvg(svg);
                            return this.operator.renderSvg(svg, value1, value2);
                        }
                        /*
                         * Create a group node to hold symbol and children.
                         */
                        const group = svgElement('g');
                        const value1 = this.input[0].expression.renderSvg(svg);
                        const symbol = drawValue(svg, this.operator.symbol);
                        const value2 = this.input[1].expression.renderSvg(svg);


                        const value1Box = value1.getBBox();
                        const symbolBox = symbol.getBBox();
                        const value2Box = value2.getBBox();

                        const height = Math.max(value1Box.height, value2Box.height, symbolBox.height);
                        const symbolX = value1Box.width + gap;
                        const value2X = symbolX + symbolBox.width + gap;
                        const value1Y = (height - value1Box.height) / 2;
                        const symbolY = (height - symbolBox.height) / 2;
                        const value2Y = (height - value2Box.height) / 2;

                        group.appendChild(value1);
                        setPosition(value1, 0, value1Y);
                        group.appendChild(symbol);
                        setPosition(symbol, symbolX, symbolY);
                        group.appendChild(value2);
                        setPosition(value2, value2X, value2Y);

                        svg.append(group);
                        return group;
                    },

                };
                active.expression = expression;
                replace = false;
                return expression;
            }

            function newNode(expression = newExpression(), parent) {
                const newNode = {
                    parent,
                    expression: expression || newExpression(),
                    node: document.createElement('span'),
                    getNode() {
                        this.node.innerHTML = '';
                        if (this.collapsed) {
                            this.node.innerHTML = `<span class: "collapsed">${this.expression.valueOf()}</span>`;
                        } else {
                            this.node.append(this.expression.htmlNodes());
                        }
                        return this.node;
                    },
                    render(container) {
                        var element;
                        if (this.collapsed) {
                            element = drawValue(container, `${this.expression.valueOf()}`);
                        } else {
                            element = expression.svg(container);
                        }
                        container.appendChild(element);
                        return element;
                    },
                };
                expression.node = newNode;
                newNode.node.addEventListener('click', (event) => {
                    active = newNode;
                    update();
                    event.stopPropagation();
                });
                newNode.node.addEventListener('dblclick', (event) => {
                    active = newNode;
                    replace = !replace;
                    update();
                    event.stopPropagation();
                });
                return newNode;
            }

            const history = [];
            let position = null;

            let active;
            let replace = false;

            function setRoot(root) {
                expressionRoot = root;
                const node = document.getElementById('expression');
                node.innerHTML = '';
                node.append(expressionRoot.node);
                active = expressionRoot;
            }

            setRoot(newNode(newExpression()));

            function update() {
                expressionRoot.getNode();
                for (const node of document.querySelectorAll('.active')) {
                    node.classList.remove('active');
                }
                for (const node of document.querySelectorAll('.replace')) {
                    node.classList.remove('replace');
                }
                active.node.classList.add(replace ? 'replace' : 'active');
                const node = document.getElementById("answer");
                node.innerHTML = '' + expressionRoot.expression;

                const subAnswer = document.getElementById("sub-answer");
                if (active) {
                    subAnswer.innerHTML = '' + active.expression;
                } else {
                    subAnswer.innerHTML = '';
                }
                renderSvg(expressionRoot.expression);
            }

            update();

            function braces(event) {
                update();
            }

            function changeMode(event) {
                replace = !replace
                update();
            }

            function previous(event) {
                if (history.length > 0) {
                    if (!position) {
                        position = history.length;
                    }
                    position -= 1;
                    setRoot(history[position]);
                }
                update();
            }
            function next(event) {
                if (history.length > 0) {
                    if (!position) {
                        position = -1;
                    }
                    position += 1;
                    setRoot(history[position]);
                }
                update();
            }

            function up(event) {
                if (active.parent) {
                    active = active.parent;
                }
                update();
            }

            function down(event) {
                if (active.expression.input[0]) {
                    active = active.expression.input[0];
                }
                update();
            }

            function left(event) {
                let node = active;
                const leaf = node.expression.input === undefined || node.expression.input.length === 0;
                while (node.parent) {
                    const index = node.parent.expression.input.indexOf(node) - 1;
                    if (index > -1) {
                        active = node = node.parent.expression.input[index];
                        break;
                    }
                    node = node.parent;
                }
                if (leaf) {
                    while (node.expression.input && node.expression.input.length && !node.collapsed) {
                        node = node.expression.input[node.expression.input.length - 1];
                    }
                    active = node;
                }
                update();
            }

            function right(event) {
                let node = active;
                const leaf = node.expression.input === undefined || node.expression.input.length === 0;
                while (node.parent) {
                    const index = node.parent.expression.input.indexOf(node) + 1;
                    if (index < node.parent.expression.input.length) {
                        active = node = node.parent.expression.input[index];
                        break;
                    } else {
                        node = node.parent;
                    }
                }
                if (leaf) {
                    while (node.expression.input && node.expression.input.length && !node.collapsed) {
                        node = node.expression.input[0];
                    }
                    active = node;
                }
                update();
            }

            function sign(event) {
                if (active.expression?.operator?.name === 'negate') {
                    active.expression = active.expression.input[0].expression;
                } else {
                    unaryOperator(
                        operatorByName('negate'),
                        (str) => `\u2212${str}`,
                        '\u2212', '');
                }
                update();
            }
            function square(event) {
                power(event)
                active.expression.value = 2;
                up();
            }
            function cube(event) {
                power(event)
                active.expression.value = 3;
                update();
            }
            function power(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = ' &#xD7; ';
                const expression = binaryOperator(
                    operatorByName('exponentiation'),
                    (str1, str2) => `${str1} &#xD7; ${str2}`,
                    '(', symbol, ')');
                Object.assign(expression, {
                    htmlNodes() {
                        const fragment = document.createDocumentFragment();
                        fragment.append(this.input[0].getNode());
                        const pow = document.createElement('sup');
                        fragment.append(pow);
                        pow.append(this.input[1].getNode());
                        return fragment;
                    },
                });
                active = active.expression.input[1];
                update();
            }
            function squareRoot(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = '&#8730(';
                unaryOperator(
                    operatorByName('square root'),
                    (str) => `&#8730(${str})`,
                    symbol, ')');
                update();
            }
            function cubeRoot(event) {
                root(event)
                active.expression.value = 3;
                up();
            }
            function root(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = ' &#xD7; ';
                const expression = binaryOperator(
                    operatorByName('root'),
                    (str1, str2) => `root(${str1}, ${str2})`,
                    '(', symbol, ')');
                Object.assign(expression, {
                    htmlNodes() {
                        const fragment = document.createDocumentFragment();
                        const pow = document.createElement('sup');
                        fragment.append(pow);
                        pow.append(this.input[1].getNode());
                        const symbol = document.createElement('span');
                        fragment.append(symbol);
                        symbol.innerHTML = '&#8730';
                        fragment.append(this.input[0].getNode());
                        return fragment;
                    },
                });
                active = active.expression.input[1];
                update();
            }
            function deg(event) {
                if (active.expression.name !== 'radians') {
                    const symbol = document.createElement('span');
                    symbol.innerHTML = '&deg;';
                    unaryOperator(
                        operatorByName('radians'),
                        (str) => `${str}&deg;`,
                        '', symbol);
                }
            }
            function adeg(event) {
                unaryOperator(
                    operatorByName('degrees'),
                    (str) => `degrees(${str})`,
                    'degrees(', ')');
            }

            function sine(event) {
                if (altMode) {
                    asin();
                    altMode = false;
                } else {
                    sin();
                }
                update();
            }
            function sin(event) {
                if (angleUnits === 'deg' && active.expression.value !== null) {
                    deg(event);
                }
                unaryOperator(
                    operatorByName('sine'),
                    (str) => `sin(${str})`,
                    'sin(', ')');
                if (angleUnits === 'deg' && active.expression.value === null) {
                    deg(event);
                }
            }
            function asin(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = 'sin<sup>-1</sup>(';
                unaryOperator(
                    operatorByName('inverse sine'),
                    (str) => `asin(${str})`,
                    symbol, ')');
                if (angleUnits === 'deg') {
                    adeg(event);
                }
            }
            function cosine(event) {
                if (altMode) {
                    acos();
                    altMode = false;
                } else {
                    cos();
                }
                update();
            }
            function cos(event) {
                if (angleUnits === 'deg' && active.expression.value !== null) {
                    deg(event);
                }
                unaryOperator(
                    operatorByName('cosine'),
                    (str) => `cos(${str})`,
                    'cos(', ')');

                if (angleUnits === 'deg' && active.expression.value === null) {
                    deg(event);
                }
                update();
            }
            function acos(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = 'cos<sup>-1</sup>(';
                unaryOperator(
                    operatorByName('inverse cosine'),
                    (str) => `acos(${str})`,
                    symbol, ')');

                if (angleUnits === 'deg') {
                    adeg(event);
                }
                update();
            }
            function tangent(event) {
                if (altMode) {
                    atan();
                    altMode = false;
                } else {
                    tan();
                }
                update();
            }
            function tan(event) {
                if (angleUnits === 'deg' && active.expression.value !== null) {
                    deg(event);
                }
                unaryOperator(
                    operatorByName('tan'),
                    (str) => `tan(${str})`,
                    'tan(', ')');
                if (angleUnits === 'deg' && active.expression.value === null) {
                    deg(event);
                }
                update();
            }
            function atan(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = 'tan<sup>-1</sup>(';
                unaryOperator(
                    operatorByName('tan'),
                    (str) => `atan(${str})`,
                    symbol, ')');
                if (angleUnits === 'deg' && active.expression.value === null) {
                    deg(event);
                }
            }
            function sinh(event) {
                unaryOperator(
                    operatorByName('hyperbolic sine'),
                    (str) => `sinh(${str})`,
                    'sinh(', ')');
                update();
            }
            function cosh(event) {
                unaryOperator(
                    operatorByName('hyperbolic cosine'),
                    (str) => `cosh(${str})`,
                    'cosh(', ')');
                update();
            }
            function tanh(event) {
                unaryOperator(
                    operatorByName('hyperbolic tan'),
                    (str) => `tanh(${str})`,
                    'tanh(', ')');
                update();
            }
            function ln(event) {
                unaryOperator(
                    operatorByName('natural log'),
                    (str) => `ln(${str})`,
                    'ln(', ')');
                update();
            }
            function exp(event) {
                const expression = unaryOperator(
                    operatorByName('10 to the power of x'),
                    (str) => `10 ** (${str})`,
                    '10 ** (', ')');
                Object.assign(expression, {
                    htmlNodes() {
                        const fragment = document.createDocumentFragment();
                        fragment.append('10');
                        const pow = document.createElement('sup');
                        fragment.append(pow);
                        pow.append(this.input[0].getNode());
                        return fragment;
                    },
                });
                update();
            }
            function log(event) {
                unaryOperator(
                    operatorByName('log'),
                    (str) => `log(${str})`,
                    'log(', ')');
                update();
            }
            function EE(event) {
                binaryOperator(
                    operatorByName('scientific notation'),
                    (str1, str2) => `${str1}E${str2}`,
                    '', 'E', '');
                active = active.expression.input[1];
                update();
            }

            function inv(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = ' &#xF7; ';
                binaryOperator(
                    operatorByName('division'),
                    (str1, str2) => `${str1} &#xF7; ${str2}`,
                    '(', symbol, ')');
                [active.expression.input[0], active.expression.input[1]] = [active.expression.input[1], active.expression.input[0]]
                active.expression.input[0].expression.value = 1;
                active = active.expression.input[1];
                update();
            }
            function e(event) {
                const expression = unaryOperator(
                    operatorByName('e to the power of x'),
                    (str) => `e ** (${str})`,
                    'e ** (', ')');
                Object.assign(expression, {
                    htmlNodes() {
                        const fragment = document.createDocumentFragment();
                        fragment.append('e');
                        const pow = document.createElement('sup');
                        fragment.append(pow);
                        pow.append(this.input[0].getNode());
                        return fragment;
                    },
                });
                update();
            }
            function alt(event) {
                altMode = !altMode;
                buttons.filter((button) => button.althtml).forEach((button) => {
                    const node = document.getElementById(button.id);
                    node.innerHTML = altMode ? button.althtml : button.html;
                });
            }
            function changeAngleUnits(event) {
                node = document.getElementById("angle");
                if (angleUnits === 'deg') {
                    angleUnits = 'rad';
                    angleScale = 1;
                } else if (angleUnits === 'rad') {
                    angleUnits = 'gra';
                    angleScale = Math.PI / 200;
                } else {
                    angleUnits = 'deg';
                    angleScale = Math.PI / 180;
                }
                console.log(angleUnits);
                node.innerHTML = angleUnits;
            }
            function pi(event) {
                constant('pi', Math.PI, `\u03C0`);
                update();
            }

            function del(event) {
                if (active.expression.input[0]) {
                    active.expression = active.expression.input[0].expression;
                } else {
                    if (active.expression.decimal) {
                        active.expression.decimal -= 1;
                        const pow = Math.pow(10, active.expression.decimal - 1);
                        active.expression.value = Math.trunc(pow * active.expression.value) / pow;
                    } else {
                        active.expression.value = Math.trunc(active.expression.value / 10);
                    }
                }
                replace = false;
                update();
            }

            function clear(event) {
                expressionRoot = newNode();
                active = expressionRoot;
                replace = false;
                const expressionNode = document.getElementById("expression");
                expressionNode.innerHTML = '';
                expressionNode.append(expressionRoot.node);
                update();
            }
            function percent(event) {
                update();
            }
            function divide(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = ' &#xF7; ';
                binaryOperator(
                    operatorByName('division'),
                    (str1, str2) => `${str1} &#xF7; ${str2}`,
                    '(', symbol, ')');
                active = active.expression.input[1];
                update();
            }
            function multiply(event) {
                const symbol = document.createElement('span');
                symbol.innerHTML = ' &#xD7; ';
                binaryOperator(
                    operatorByName('multiplication'),
                    (str1, str2) => `${str1} &#xD7; ${str2}`,
                    '(', symbol, ')');
                active = active.expression.input[1];
                update();
            }
            function subtraction(event) {
                binaryOperator(
                    operatorByName('subtraction'),
                    (str1, str2) => `${str1} \u2212 ${str2}`,
                    '(', ' \u2212 ', ')');
                active = active.expression.input[1];
                update();
            }
            function addition(event) {
                binaryOperator(
                    operatorByName('addition'),
                    (str1, str2) => `${str1} + ${str2}`,
                    '(', ' + ', ')');
                active = active.expression.input[1];
                update();
            }

            function equal(event) {
                binaryOperator(
                    operatorByName('comparrison'),
                    (str1, str2) => `${str1} = ${str2}`,
                    '(', ' = ', ')');
                active = active.expression.input[1];
                update();
            }

            function collapse(event) {
                if (active.expression.input && active.expression.input.length) {
                    active.collapsed = !active.collapsed;
                }
                replace = false;
                update();
            }

            function enter(event) {
                if (active === expressionRoot) {
                    history.push(expressionRoot);
                    setRoot(newNode(newExpression(expressionRoot.expression.valueOf())));
                }
                active = expressionRoot;
                replace = false;
                update();
            }

            function point(event) {
                if (!active.expression.decimal) {
                    active.expression.decimal = 1;
                    update();
                }
            }

            const operators = [
                { name: 'negate', operands: 2, fn: (a) => -a, symbol: '-', rank: 14, },
                { name: 'addition', operands: 2, fn: (a, b) => a + b, symbol: '+', rank: 11, },
                { name: 'subtraction', operands: 2, fn: (a, b) => a - b, symbol: '-', rank: 11, },
                { name: 'multiplication', operands: 2, fn: (a, b) => a * b, symbol: '\u00D7', rank: 12, },
                { name: 'division', operands: 2, fn: (a, b) => a / b, symbol: '\u00F7', rank: 12, renderSvg: drawDivision, },
                { name: 'remainder', operands: 2, fn: (a, b) => a % b, symbol: '%', rank: 12, },
                { name: 'exponentiation', operands: 2, fn: (a, b) => a ** b, symbol: '^', rank: 13, },
                { name: 'scientific notation', operands: 2, fn: (mantissa, exponent) => mantissa * 10 ** exponent, symbol: '^', rank: 13, },
                { name: 'square root', operands: 1, fn: (x) => Math.sqrt(x), symbol: '\u221A', rank: 13, renderSvg: drawRoot, },
                { name: 'root', operands: 2, fn: (a, b) => a ** (1 / b), symbol: '\u221A', rank: 13, renderSvg: drawRoot, },
                { name: 'logarithm', operands: 2, fn: (a, b) => Math.log(a) / Math.log(b), symbol: 'log', rank: 1, },
                { name: 'comparrison', operands: 2, fn: (a, b) => a === b, symbol: '=', rank: 1, },

                { name: 'natural log', operands: 1, fn: (a) => Math.log(a), symbol: 'ln', rank: 1, },
                { name: 'e to the power of x', operands: 1, fn: (x) => Math.exp(x), symbol: 'ln', rank: 1, },
                { name: 'log 10', operands: 1, fn: (x) => Math.log10(x), symbol: 'log', rank: 1, },
                { name: '10 to the power of x', fn: (x) => 10 ** x, symbol: '10^', rank: 1, },

                { name: 'degrees', operands: 1, fn: (a) => precision(a * 180 / Math.PI, 13), symbol: '\u00B0', rank: 1, },
                { name: 'radians', operands: 1, fn: (a) => a * Math.PI / 180, symbol: '', rank: 1, },

                { name: 'sine', operands: 1, fn: (a) => Math.sin(a), symbol: 'sin', rank: 1, },
                { name: 'cosine', operands: 1, fn: (a) => precision(Math.cos(a), 14), symbol: 'cos', rank: 1, },
                { name: 'tan', operands: 1, fn: (a) => Math.tan(a), symbol: 'tan', rank: 1, },

                { name: 'inverse sine', operands: 1, fn: (a) => Math.asin(a), symbol: 'sin<sup>-1</sup>', rank: 1, },
                { name: 'inverse cosine', operands: 1, fn: (a) => Math.acos(a), symbol: 'acos<sup>-1</sup>', rank: 1, },
                { name: 'inverse tan', operands: 1, fn: (a) => Math.atan(a), symbol: 'atan<sup>-1</sup>', rank: 1, },

                { name: 'hyperbolic sine', operands: 1, fn: (a) => Math.sinh(a), symbol: 'sinh', rank: 1, },
                { name: 'hyperbolic cosine', operands: 1, fn: (a) => Math.cosh(a), symbol: 'cosh', rank: 1, },
                { name: 'hyperbolic tan', operands: 1, fn: (a) => Math.tanh(a), symbol: 'tanh', rank: 1, },

                { name: 'inverse hyperbolic sine', operands: 1, fn: (a) => Math.asinh(a), symbol: 'sinh<sup>-1</sup>', rank: 1, },
                { name: 'inverse hyperbolic cosine', operands: 1, fn: (a) => Math.acosh(a), symbol: 'cosh<sup>-1</sup>', rank: 1, },
                { name: 'inverse hyperbolic tan', operands: 1, fn: (a) => Math.atanh(a), symbol: 'tanh<sup>-1</sup>', rank: 1, },
            ];
            const operatorByName = (name) => operators.find((operator) => operator.name === name);


            function addButtonActions() {
                const layout = document.getElementById('layout');
                buttons.forEach((button) => {
                    const node = document.createElement('button');
                    layout.append(node);
                    node.id = button.id;
                    node.innerHTML = button.html;
                    node.classList.add(button.class);
                    node.addEventListener('click', button.action);
                    if (button.x) {
                        node.style.gridColumn = `${button.x} / ${button.x + (button.width || 1)}`;
                    }
                    if (button.y) {
                        node.style.gridRow = `${button.y} / ${button.y + (button.height || 1)}`;
                    }
                });
            }

            function addKeyActions() {
                const keys = {
                    '0': { action: digit(0) },
                    '1': { action: digit(1) },
                    '2': { action: digit(2) },
                    '3': { action: digit(3) },
                    '4': { action: digit(4) },
                    '5': { action: digit(5) },
                    '6': { action: digit(6) },
                    '7': { action: digit(7) },
                    '8': { action: digit(8) },
                    '9': { action: digit(9) },

                    '.': { action: point },

                    '+': { action: addition },
                    '-': { action: subtraction },
                    '*': { action: multiply },
                    '/': { action: divide },

                    'Enter': { action: enter },

                    'ArrowUp': { action: up },
                    'ArrowDown': { action: down },
                    'ArrowLeft': { action: left },
                    'ArrowRight': { action: right },

                    'PageUp': { action: previous },
                    'PageDown': { action: previous },

                    'Delete': { action: del },
                    'Escape': { action: clear },
                }

                document.body.addEventListener('keydown', (event) => {
                    const key = keys[event.key];
                    if (key?.action) {
                        key.action(event);
                    }
                });
            }
        </script>
</body>

</html>
