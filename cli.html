<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width" />
  <title>js-notepad</title>
  <link rel="stylesheet" href="style.css" />
  <style>
  body {
    width: 100%;
    height: 100dvh;
    background: lightgray;
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr min-content;
}

#results {
    overflow: auto;
}

.index {
    display: inline-block;
    padding: 0.1rem 0.5rem;
    border: 1px solid black;
    border-radius: 1rem;
    min-width: 0.5rem;
    font-weight: bold;
}

.raw {
    color: dray;
    font-size: 80%;
}


.resolved {
    color: dray;
    font-size: 80%;
    font-style: italic;
}

.result {
    border: 1px solid black;
    border-radius: 0.5rem;
    padding: 0.5rem;
    background-color: white;
}

#command-entry {
    width: 100%;
    margin: 0.5rem;
}
  </style>
</head>
<body>
  <div id="results"></div>
  <div id="input">
    <input id="command-entry" type="text">
  </div>
  
  <script>
  const inputNode = document.getElementById('command-entry');

const context = {
    args: {},
    history: [],
    position: 0,
};

Object.getOwnPropertyNames(Math).forEach((prop) =>
    context.args[prop] = Math[prop]);


const ignore = Symbol('ignore');

/**
 * Process an input string
 */
function execute(raw) {
    const getIndex = (str) => isNaN(parseInt(str)) ? -1 : parseInt(str) % context.history.length; 
    const expr = raw.replace(/<(-?[0-9]*)>/g, (match, index) =>
        `context.history.at(${getIndex(index)}).result`);
    const resolved = raw.replace(/<(-?[0-9]*)>/g, (match, index) =>
        `${context.history.at(getIndex(index)).result}`);
	let result;
    try {
        const func = new Function(...Object.keys(context.args), `return ${expr}`);
        result = func(...Object.values(context.args));
    } catch(error) {
        result = error.message;
    }

    return {result, raw, expr, resolved};
}

/**
 * Add the results to the output
 */
function showResults(output, index) {
    const resultsNode = document.getElementById('results');

    const indexNode = document.createElement('span');
    indexNode.classList.add('index');
    indexNode.innerHTML = index;
    resultsNode.appendChild(indexNode);
    resultsNode.append(' ');

    const rawNode = document.createElement('span');
    rawNode.classList.add('raw');
    rawNode.innerHTML = output.raw;
    resultsNode.appendChild(rawNode);


    if (output.raw !== output.resolved) {
        resultsNode.append(' ');
        const resolvedNode = document.createElement('span');
        resolvedNode.classList.add('resolved');
        resolvedNode.innerHTML = output.resolved;
        resultsNode.appendChild(resolvedNode);
    }

    const resultNode = document.createElement('div');
    resultNode.classList.add('result');
    resultNode.innerHTML = output.result;
    resultsNode.appendChild(resultNode);
}

/**
 * Process the input
 */
function process(event) {
    const str = inputNode.value;
    const output = execute(str);
    if (output !== ignore) {
        showResults(output, context.history.length);
        context.history.push(output);
    }
    inputNode.value = '';
}


inputNode.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
        event.preventDefault();
        process(event);
    }
    if (event.key === 'ArrowUp') {
        if (context.position === context.history.length) {
            context.draft = input.value;
        }
        context.position -= 1;
        if (context.position < 0) {
            context.position = context.history.length;
            input.value = context.draft;
        } else {
            input.value = context.history[context.position];
        }
    }
    if (event.key === 'ArrowDown') {
        if (context.position === context.history.length) {
            context.draft = input.value;
            context.position = -1;
        }
        context.position += 1;
        if (context.position === context.history.lenght) {
            input.value = context.draft;
        } else {
            input.value = context.history[context.position];
        }
    }
});

inputNode.focus();

</script>
</body>
</html>