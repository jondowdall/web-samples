<!DOCTYPE html>
<html>
<!--
TODO:
indicate change of state when input cell changes
cell from sequence
side widgets: notes
cell types?
background colour
markdown
better handling of file access when api not present
web midi

amending config files
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>js-notepad</title>
    <link href="styles/noia-workbench-1.3.css" rel="stylesheet" />

</head>

<body>
    <div id="header"></div>
    <div id="workspace" contenteditable="plaintext-only" autocorrect="off" autocapitalize="none">
    </div>
    <div id="widgets"></div>
    <div id="footer"></div>
    <div id="status" class="fade"></div>
    <div id="placeholder"></div>
    <script type="module">
        const themes = ['vt-220', 'workbench-1.3', 'workbench-4.1'];

        const workspaceNode = document.getElementById('workspace');


        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: false });


        /**
         * Manage a line and its nodes
         */
        class Cell {
            makeLineNumber(index) {
                const lineNumber = document.createElement('div');
                lineNumber.contentEditable = false;
                lineNumber.innerText = index ?? '';
                lineNumber.classList.add('line-number');
                return lineNumber;
            }
            makeLine(content) {
                const line = document.createElement('div');
                if (content) {
                    line.append(content)
                }
                return line;
            }
            constructor(lineNumber, line) {
                this.lineNumber = this.makeLineNumber(lineNumber);
                this.content = this.makeLine(line);
                this.state = 'in-line';
                this.input = new Set();
                this.output = new Set();
            }
            remove() {
                this.content?.remove();
                this.lineNumber?.remove();

                this.input.forEach((input) => input.output.delete(this));
                this.input.clear();

                this.output.forEach((output) => output.input.delete(this));
                this.output.clear();

                this.state = 'removed';
            }
            get text() {
                return this.content.innerText;
            }
            get value() {
                return this._value || this.content.innerText;
            }
            set value(value) {
                this._value = value;
            }
            get index() {
                return nodes.indexOf(this);
            }
            removeOutput(output) {
                this.output = this.output.filter((cell) => cell !== output);
            }
            inline() {
                this.lineNumber.after(this.content);
                this.state = 'in-line';
            }
            stick() {
                if (!this.content.classList.contains('sticky')) {
                    const stuck = Array.from(document.getElementById('workspace').querySelectorAll('.sticky'));
                    const bottom = (node) => {
                        const box = node.getBoundingClientRect();
                        return box.y + box.height;
                    };
                    let y = Math.max(0, ...stuck.map((node) => bottom(node)));
                    this.content.classList.add('sticky');
                    this.content.style.top = `${y}px`;
                    y += this.content.getBoundingClientRect().height;
                    if (this.output) {
                        this.output.classList.add('sticky');
                        this.output.style.top = `${y}px`;
                        y += this.output.getBoundingClientRect().height;
                    }
                }
                this.state = 'stick';
            }
            unstick() {
                this.content.classList.remove('sticky');
            }
            widget() {
                if (this.output) {
                    document.getElementById('widgets').append(this.output);
                    this.state = 'widget';
                }
            }
            collapse() {
                this.output?.forEach((cell) => cell.hide());
                this.collapsed = true;

            }
            expand() {
                this.output?.forEach((cell) => cell.show());
                this.collapsed = false;
            }
            hide() {
                this.content.classList.add('hidden');
                this.lineNumber.classList.add('hidden');
            }
            show() {
                this.content.classList.remove('hidden');
                this.lineNumber.classList.remove('hidden');
            }
            getOutput() {
                if (this.output) {
                    return this.output[0];
                }
                const output = new Output(this.index + 1);
                this.output = [output];
                if (this.defaultState === 'widget') {
                    this.content.after(output.lineNumber);
                    document.getElementById('widgets').append(output.content);
                    this.output.state = 'widget';
                } else {
                    this.content.after(output.lineNumber, output.content);
                }
                nodes.splice(this.index + 1, 0, output);
                return output;
            }
            scrollTo(options = { behavior: 'smooth', block: 'center', inline: 'start' }) {
                this.content.scrollIntoView(options);
            }
            after(...cells) {
                cells = cells.flatMap((cell) => cell);
                const domNodes = cells.flatMap((cell) => [cell.lineNumber, cell.content]).filter((n) => n);

                if (this.state === 'widget' || this.state === 'window') {
                    this.content.after(...domNodes);
                } else {
                    this.content.after(...domNodes);
                }
                nodes.splice(this.index + 1, 0, ...cells);
            }
            /**
             * Update the output for this lines with the provided text
             */
            updateTextOutput(text) {
                const lines = getLines(text);
                const oldOutput = Array.from(this.output);
                while (oldOutput.length > 0 && lines.length > 0) {
                    oldOutput.shift().content.innerText = lines.shift();
                }
                while (oldOutput.length) {
                    oldOutput.shift().remove();
                }

                if (lines.length) {
                    const ref = oldOutput.at(-1) || this;
                    const pos = ref.index + 1;
                    const newOutput = lines.map((line, index) => new TextOutput(pos + index, line, this));
                    ref.after(newOutput);
                    newOutput.forEach((output) => this.output.add(output));
                }
            }
            /**
             * Update the output for this lines with the provided nodes
             */
            updateOutput(...nodes) {
                const oldOutput = Array.from(this.output);
                while (oldOutput.length > 0 && lines.length > 0) {
                    oldOutput.shift().content.append(nodes.shift());
                }
                while (oldOutput.length) {
                    oldOutput.shift().remove();
                }

                if (nodes.length) {
                    const ref = oldOutput.at(-1) || this;
                    const pos = ref.index + 1;
                    const newOutput = nodes.map((node, index) => new Output(pos + index, node, this));
                    if (this.state === 'widget') {
                        document.getElementById('widgets').append(...nodes);
                        nodes.splice(pos, newOutput);
                    } else {
                        ref.after(newOutput);
                    }
                    newOutput.forEach((output) => this.output.add(output));
                }
            }
        }

        class Text extends (Cell) {
            constructor(lineNumber, line) {
                super(lineNumber, line);
                this.content.classList.add('line');
            }
        }

        class TextOutput extends (Cell) {
            constructor(lineNumber, line, ...input) {
                super(lineNumber, line);
                input.flatMap((input) => input).forEach((input) => this.input.add(input));
                this.lineNumber.classList.add('output-line');
                this.content.classList.add('output');
            }
        }

        class Widget extends (Cell) {
            constructor(lineNumber, line) {
                super(lineNumber, line);
                this.content.contentEditable = false;
                this.lineNumber.addEventListener('mousedown', (event) => {
                    const mouseStart = { x: event.clientX, y: event.clientY };
                    const start = this.content.getBoundingClientRect();
                    action.move = (event) => {
                        if (!this.window) {
                            this.makeWindow(start.x, start.y);
                        }
                        const x = start.x + event.clientX - mouseStart.x;
                        const y = start.y + event.clientY - mouseStart.y;
                        this.window.style.left = `${x}px`;
                        this.window.style.top = `${y}px`;
                    };
                });
            }
            makeWindow(x, y) {
                if (!this.window) {
                    this.window = document.createElement('div');
                    this.window.classList.add('window');
                }
                this.window.classList.remove('hidden');
                this.window.innerHTML = '';
                this.title = document.createElement('div');
                this.title.addEventListener('mousedown', (event) => {
                    const mouseStart = { x: event.clientX, y: event.clientY };
                    const start = this.window.getBoundingClientRect();
                    action.move = (event) => {
                        const x = start.x + event.clientX - mouseStart.x;
                        const y = start.y + event.clientY - mouseStart.y;
                        this.window.style.left = `${x}px`;
                        this.window.style.top = `${y}px`;
                    };
                });
                this.title.classList.add('window-title');
                this.title.innerText = `${this.index + 1}: ${this.name || ''}`;
                if (x) {
                    this.window.style.left = `${x}px`;
                }
                if (y) {
                    this.window.style.top = `${y}px`;
                }
                this.window.append(this.title, this.content);
                document.body.append(this.window);
                this.state = 'window';
            }
        }

        class Control extends (Widget) {
            constructor(lineNumber, line) {
                super(lineNumber, line);
                this.lineNumber.classList.add('control-line');
                this.content.classList.add('control');
            }
        }

        class Output extends (Widget) {
            constructor(lineNumber, line) {
                super(lineNumber, line);
                this.lineNumber.classList.add('output-line');
                this.content.classList.add('output');
            }
        }


        class Container {
            constructor() {
                this.content = document.createElement('div');
            }
        }


        class Table extends (Container) {
            constructor(input) {
                super();
                this.content.classList.add('table');
                const background = document.createElement('div');
                background.classList.add('grid');
                this.content.appendChild(background);

                const getCell = () => {
                    let cell = document.activeElement;
                    while (!cell.classList.contains('table-cell') && cell.parentElement) {
                        cell = cell.parentElement;
                    }
                    return cell;
                }
                this.content.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        //inputNode.focus();
                    }
                    const cell = getCell();
                    const col = parseInt(cell.dataset.col);
                    const row = parseInt(cell.dataset.row);
                    if (event.ctrlKey) {
                        if (event.key === 'Delete') {
                            if (isNaN(col) && !isNaN(row)) {
                                const deleted = {};
                                deleted.rows = this.rows.splice(row, 1);
                                deleted.content = this.data.splice(row, 1);
                                this.deleted.push(deleted);
                                this.update(true);
                                if (row <= this.rows.length) {
                                    this.view.result.querySelector(`.cell-0-${row}`).focus();
                                } else if (this.rows.length > 1) {
                                    this.view.result.querySelector(`.cell-0-${row - 1}`).focus();
                                } else {
                                    //inputNode.focus();
                                }
                            }
                            if (!isNaN(col) && isNaN(row)) {
                                const deleted = {};
                                deleted.cols = this.cols.splice(col, 1);
                                deleted.content = this.data.map((row) => row.splice(col, 1));
                                this.deleted.push(deleted);
                                this.update(true);
                                if (col <= this.cols.length) {
                                    this.view.result.querySelector(`.cell-${col}-0`).focus();
                                } else if (this.cols.length > 1) {
                                    this.view.result.querySelector(`.cell-${col - 1}-0`).focus();
                                } else {
                                    //inputNode.focus();
                                }
                            }
                            event.preventDefault();
                        }
                    }
                    if (event.altKey) {
                        event.preventDefault();
                        if (event.key === 'ArrowRight') {
                            const newCol = col ?? 0;
                            if (!isNaN(col) && !isNaN(row)) {
                                this.data[row][col] = cell.innerText;
                            }
                            if (event.shiftKey) {
                                this.cols.splice(newCol, 0, { size: 'max-content' });
                                this.data.forEach((row) => row.splice(newCol, 0, ''));
                                this.update(true);
                            }
                            if (isNaN(col)) {
                                this.view.result.querySelector(`.cell-0-${row}`).focus();
                            } else if (isNaN(row)) {
                                this.view.result.querySelector(`.table-column-${(col + 1) % this.cols.length}`).focus();
                            } else {
                                this.view.result.querySelector(`.cell-${((isNaN(col) ? -1 : col) + 1) % this.cols.length}-${row}`).focus();
                            }
                            saveState();
                        }
                        if (event.key === 'ArrowLeft') {
                            if (!isNaN(col) && !isNaN(row)) {
                                this.data[row][col] = cell.innerText;
                                if (event.shiftKey) {
                                    this.cols.splice(col, 0, { size: 'max-content' });
                                    this.data.forEach((row) => row.splice(col, 0, ''));
                                    this.update(true);
                                    this.view.result.querySelector(`.cell-${col}-${row}`).focus();
                                } else if (col === 0) {
                                    this.view.result.querySelector(`.table-row-${row}`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-${col - 1}-${row}`).focus();
                                }
                                saveState();
                            } else if (isNaN(row)) {
                                this.view.result.querySelector(`.table-column-${(col > 0 ? col : this.cols.length) - 1}`).focus();
                            } else {
                                this.view.result.querySelector(`.cell-${this.cols.length - 1}-${row}`).focus();
                            }
                        }
                        if (event.key === 'ArrowUp') {
                            if (!isNaN(row) && !isNaN(col)) {
                                this.data[row][col] = cell.innerText;
                                if (event.shiftKey) {
                                    this.rows.splice(row, 0, { size: 'max-content' });
                                    this.data.splice(row, 0, []);
                                    this.update(true);
                                    this.view.result.querySelector(`.cell-${col}-${row}`).focus();
                                } else if (row === 0) {
                                    this.view.result.querySelector(`.table-column-${col}`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-${col}-${row - 1}`).focus();
                                }
                                saveState();
                            } else if (isNaN(col)) {
                                this.view.result.querySelector(`.table-row-${(row > 0 ? row : this.data.length) - 1}`).focus();
                            } else {
                                this.view.result.querySelector(`.cell-${col}-${this.data.length - 1}`).focus();
                            }
                        }
                        if (event.key === 'ArrowDown') {
                            const newRow = row ?? 0;
                            if (!isNaN(row) && !isNaN(col)) {
                                this.data[row][col] = cell.innerText;
                            }
                            if (event.shiftKey) {
                                this.rows.splice(row, 0, { size: 'max-content' });
                                this.data.splice(row, 0, []);
                                this.update(true);
                            }
                            if (isNaN(row)) {
                                this.view.result.querySelector(`.cell-${col}-0`).focus();
                            } else if (isNaN(col)) {
                                this.view.result.querySelector(`.table-row-${(row + 1) % this.data.length}`).focus();
                            } else {
                                this.view.result.querySelector(`.cell-${col}-${((isNaN(row) ? -1 : row) + 1) % this.data.length}`).focus();
                            }
                            saveState();
                        }
                        event.preventDefault();
                    }
                });
                this.setContent(input);
                this.update();
            }
            setContent(data) {
                let table = {};
                if (data instanceof String) {
                    data = data.split(/\r?\n/);
                }

                table.data = data.map((line) => line.split(/\s*,\s*/g));
                table.cols = table.data.shift().map((value) => ({ name: value }));
                table.rows = table.data.map((row) => ({ name: row[0] }));

                const nRows = table.rows?.length || table.data?.length || 1;
                const nCols = table.cols?.length || Math.max(0, ...(table.data?.map((row) => row.length) || [])) || 1;

                this.data = Array.isArray(table.data) ? table.data : (table.data ? [[table.data]] : []);
                this.cols = [];
                this.rows = [];
                this.deleted = [];

                for (let x = 0; x < nCols; ++x) {
                    const col = table.cols?.[x] || {};
                    this.cols.push({ name: col.name, size: col.size || 'max-content' });
                }
                for (let y = 0; y < nRows; ++y) {
                    const row = table.rows?.[y] || {};
                    this.rows.push({ name: row.name, size: row.size || 'max-content' });
                }
                this.update();
            }
            update(clear) {
                const makeTemplate = (definition) => `max-content ${definition.map((col) => col.size).join(' ')}`;
                this.content.classList.add('table');

                this.content.style.gridTemplateColumns = makeTemplate(this.cols);
                this.content.style.gridTemplateRows = makeTemplate(this.rows);
                if (!Array.isArray(this.data)) {
                    this.data = this.data ? [[this.data]] : [];
                }
                if (clear) {
                    for (const node of this.content.querySelectorAll('.table-cell')) {
                        node.remove();
                    }
                }
                const updateCell = (cell, x, y) => {
                    const cls = `cell-${x}-${y}`;
                    const node = this.content.querySelector(`.${cls}`) || editableSpan(
                        () => this.data[y][x] || '',
                        (node) => this.data[y][x] = node.innerText);

                    if (!node.classList.contains(cls)) {
                        node.style.gridColumn = x + 1; // Grid column is 1-based and allow column for row names
                        node.style.gridRow = y + 2; // Grid row is 1-based and allow row for column names
                        node.classList.add('table-cell', 'table-body-cell', cls);
                        node.dataset.col = x;
                        node.dataset.row = y;
                        this.content.appendChild(node);
                    }

                    node.innerText = this.data[y]?.[x] ?? '';
                    node.title = `cell[${this.rows?.[y].name || y}][${this.cols?.[x].name || x}]`;
                    node.classList.add('table-data');
                }

                const cols = [{ name: '' }, ...this.cols];
                const rows = [{ name: '' }, ...this.rows];

                if (0 && this.name) {
                    const titleNode = this.content.querySelector(`.title-cell`) || document.createElement('span');
                    titleNode.title = `Table Name: ${this.name || "Unnamed"}`;
                    titleNode.innerText = this.name;
                    if (!titleNode.classList.contains('titleNode')) {
                        titleNode.style.gridColumn = 1;
                        titleNode.style.gridRow = 1;
                        titleNode.classList.add('table-cell', 'table-header', 'table-name');
                        this.content.appendChild(titleNode);
                    }
                }

                this.data.forEach((row, rowIndex) =>
                    row.forEach((cell, columnIndex) => updateCell(cell, columnIndex, rowIndex)));

                this.cols.forEach((column, index) => {
                    const cls = `table-column-${index}`;
                    const node = this.content.querySelector(`.${cls}`) || editableSpan(
                        () => this.cols[index].name || '',
                        (node) => {
                            this.cols[index].name = node.innerText;
                            node.innerText = node.innerText || index;
                        });
                    node.title = `Column: ${column.name || index}`;
                    node.innerText = column.name || index;
                    if (!node.classList.contains('titleNode')) {
                        node.style.gridColumn = index + 1; // Grid column is 1-based and allow a column for row names
                        node.style.gridRow = 1;
                        node.dataset.col = index;
                        node.classList.add('table-cell', 'table-header', 'table-column-header', cls);
                        this.content.appendChild(node);
                    }
                });
            }
        }


        class TreeTable extends (Container) {
            constructor(tree) {
                super();
                this.deleted = [];
                this.data = tree.content;
                this.all = tree.all;
                this.cols = tree.cols;
                this.rows = tree.rows;
                this.keys = tree.keys;
                this.model = tree.model;

                this.content.classList.add('table');
                const background = document.createElement('div');
                background.classList.add('grid');
                this.content.appendChild(background);

                const getCell = () => {
                    let cell = document.activeElement;
                    while (!(cell.classList.contains('tree-table-cell') || cell.classList.contains('tree-table-header')) && cell.parentElement) {
                        cell = cell.parentElement;
                    }
                    return cell;
                }
                this.content.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        //inputNode.focus();
                    }
                    const cell = getCell();
                    const col = parseInt(cell.dataset.col);
                    const row = parseInt(cell.dataset.row);
                    if (event.key === 'Tab' && col === 0 && row > 0) {
                        const node = this.all[row];
                        const parent = this.all.find((parent) => parent[meta].parts?.includes(node));
                        if (event.shiftKey) { // move item up in level
                            if (parent) {
                                parent[meta].parts.splice(parent[meta].parts.indexOf(node), 1);
                                const newParent = this.all.find((node) => node[meta].parts?.includes(parent));
                                if (newParent) {
                                    const position = newParent[meta].parts.indexOf(parent);
                                    newParent[meta].parts.splice(position + 1, 0, node);
                                } else {
                                    const position = this.content.indexOf(parent) + 1;
                                    this.content.splice(position, 0, node);
                                }
                            }
                        } else {
                            const container = parent ? parent[meta].parts : this.data;
                            const position = container.indexOf(node);
                            const previous = container[position - 1];
                            if (previous) {
                                container.splice(position, 1);
                                previous[meta].parts.push(node)
                            }
                        }
                        this.update();
                        this.content.querySelector(`.cell-content-${col}-${row}`).focus();
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    if (event.ctrlKey) {
                        if (event.key === 'Delete') {
                            if (isNaN(row) && this.keys.length > 1) {
                                cell.blur();
                                const key = this.keys[col];
                                const deleted = { key };
                                this.keys.splice(col, 1);
                                this.update(true);
                                if (col < this.keys.length) {
                                    this.content.querySelector(`.tree-table-column-${col}`).focus();
                                } else {
                                    this.content.querySelector(`.tree-table-column-${col - 1}`).focus();
                                }
                            } else {
                                const item = this.all[row];
                                const parent = this.all.find((node) => node[meta].parts.includes(item));
                                const position = (parent ? parent[meta].parts : this.data).indexOf(item);
                                const deleted = { item, parent, position };
                                this.deleted.push(deleted);
                                this.all.splice(row, 1);
                                this.rows.splice(row, 1);
                                if (item?.[meta].parts.length) {
                                    (parent ? parent[meta].parts : this.data).splice(position, 1, ...item[meta].parts);
                                } else {
                                    (parent ? parent[meta].parts : this.data).splice(position, 1);
                                }
                                this.model.delete(item);
                                this.update();
                                if (row < this.rows.length) {
                                    this.content.querySelector(`.cell-content-${col}-${row}`).focus();
                                } else if (this.rows.length > 0) {
                                    this.content.querySelector(`.cell-content-${col}-${row - 1}`).focus();
                                } else {
                                    this.content.querySelector(`.tree-table-column-${col}`).focus();
                                }
                            }
                            event.preventDefault();
                        }
                    }
                    if (event.altKey) {
                        event.preventDefault();
                        if (event.key === 'ArrowRight') {
                            if (event.shiftKey) {
                                this.keys.splice(col + 1, 0, null);
                                this.update();
                                this.content.querySelector(`.tree-table-column-${(col + 1) % this.keys.length}`).focus();
                            } else {
                                if (isNaN(row)) {
                                    this.content.querySelector(`.tree-table-column-${(col + 1) % this.cols.length}`).focus();
                                } else {
                                    this.content.querySelector(`.cell-content-${(col + 1) % this.cols.length}-${row}`).focus();
                                }
                            }
                        }
                        if (event.key === 'ArrowLeft') {
                            if (event.shiftKey) {
                                this.keys.splice(col + 1, 0, null);
                                this.update();
                                this.content.querySelector(`.tree-table-column-${col}`).focus();
                            } else {
                                if (isNaN(row)) {
                                    this.content.querySelector(`.tree-table-column-${(col > 0 ? col : this.cols.length) - 1}`).focus();
                                } else {
                                    this.content.querySelector(`.cell-content-${(col > 0 ? col : this.cols.length) - 1}-${row}`).focus();
                                }
                            }
                        }
                        if (event.key === 'ArrowUp') {
                            if (event.shiftKey && !isNaN(row)) {
                                // Add a new item before the current item
                                const current = this.all[row];
                                const newItem = {};
                                this.model.set(newItem, modelNode(newItem));
                                const parent = this.all.find((node) => node['childrent'].includes(current));
                                if (parent) {
                                    const position = node['childrent'].indexOf(current);
                                    parent.splice(position, 0, newItem);
                                } else {
                                    const postion = this.data.indexOf(current);
                                    this.data.splice(position, 0, newItem);
                                }
                                this.all.splice(row, 0, newItem);
                                this.rows.splice(row, 0, { size: 'max-content' });

                                this.update();
                                this.content.querySelector(`.cell-content-${col}-${row}`).focus();

                            } else if (row > 0) {
                                this.content.querySelector(`.cell-content-${col}-${row - 1}`).focus();
                            } else {
                                this.content.querySelector(`.cell-content-${col}-${this.rows.length - 1}`).focus();
                            }
                        }
                        if (event.key === 'ArrowDown') {
                            if (event.shiftKey) {
                                const newItem = {};
                                this.model.set(newItem, modelNode(newItem));
                                if (isNaN(row)) {
                                    // Add a new item as the first child
                                    this.data.unshift(newItem);
                                    this.all.unshift(newItem);
                                    this.rows.unshift({ size: 'max-content' });
                                } else {
                                    // Add a new item as a child of the item at the current row
                                    const current = this.all[row];
                                    this.all.splice(row + 1, 0, newItem);
                                    this.rows.splice(row + 1, 0, { size: 'max-content' });
                                    current[meta].parts = current[meta].parts || [];
                                    current[meta].parts.unshift(newItem);
                                }
                                this.update();
                            }

                            if (isNaN(row)) {
                                this.content.querySelector(`.cell-${col}-0`).focus();
                            } else {
                                this.content.querySelector(`.cell-content-${col}-${(row + 1) % this.all.length}`).focus();
                            }
                        }
                        saveState();
                        event.preventDefault();
                    }
                });
                this.update();
            }
            clearUpdate() {
                for (const node of this.content.querySelectorAll('.tree-table-cell')) {
                    node.remove();
                }
                update();
            }
            setContent(tree) {
                this.data = tree.content;
                this.all = tree.all;
                this.cols = tree.cols;
                this.rows = tree.rows;
                this.keys = tree.keys;
                this.model = tree.model;
                this.update();
            }
            update() {
                this.content.innerHTML = '';
                this.content.classList.add('table');

                const makeTemplate = (definition) => `${definition.map((col) => col.size).join(' ')}`;
                this.content.style.gridTemplateColumns = makeTemplate(this.cols);
                this.content.style.gridTemplateRows = makeTemplate(this.rows);

                let row = 2;
                const addNode = (node, level = 0) => {
                    this.keys.forEach((key, index) => {
                        const cell = document.createElement('div');
                        cell.classList.add('tree-table-cell', `cell-${index}-${row - 2}`);
                        cell.style.gridRow = row;
                        cell.style.gridCol = index + 1;
                        cell.dataset.row = this.all.indexOf(node);
                        cell.dataset.col = index;
                        if (index === 0) {
                            cell.innerHTML = '&nbsp;'.repeat(level * 2);
                            const meta = this.model.get(node);
                            const expand = expander(() => meta.getState(), (event) => { meta.expand(event); this.update(); }, (event) => { meta.collapse(event); this.update(); });
                            cell.appendChild(expand);
                            cell.appendChild(editableSpan(() => node[key] ?? '', (span) => node[key] = span.innerText));
                            cell.classList.add('tree-table-header');
                        } else {
                            cell.appendChild(editableSpan(() => node[key] ?? '', (span) => node[key] = span.innerText));
                        }
                        cell.lastElementChild.classList.add(`cell-content-${index}-${row - 2}`)
                        this.content.append(cell);
                    });
                    row += 1;
                    if (this.model.get(node).getState() === 'expanded') {
                        node[meta].parts?.forEach((child) => addNode(child, level + 1));
                    }
                }

                this.data.forEach((node) => addNode(node));
                this.keys.forEach((key, index) => {
                    const cell = editableSpan(() => this.keys[index], (node) => this.keys[index] = node.innerText);
                    cell.classList.add('tree-table-header', `tree-table-column-${index}`);
                    cell.innerHTML = key || '<new key>';
                    cell.dataset.col = index;
                    cell.style.gridRow = 1;
                    cell.style.gridColumn = index + 1;
                    this.content.append(cell);
                });
            }
            serialiseContent() {
                const nodes = this.all.map((source) => ({
                    data: source,
                    parts: source[meta].parts?.map((part) => this.all.indexOf(part)),
                }));
                return nodes;
            }
            deserialiseContent(nodes) {
                nodes.forEach((node) => {
                    if (!node.data) {
                        node = { date: node, parts: [] };
                    }
                    node.data = node.data || {};
                    node.data[meta] = {};
                });

                const all = nodes.map((source) => {
                    const node = source.data || source;
                    node[meta] = node[meta] || {};
                    node[meta].parts = source.parts?.map((part) => nodes[part].data) || [];
                    node[meta].parts.forEach((part) => part[meta].parent = node);
                    return node;
                });
                const roots = all.filter((node) => node[meta].parent === undefined);
                return roots;
            }
        }


        /**
         * Make a window containing lines from the buffer
         */
        function makeWindow(x, y, content) {
            if (!this.window) {
                this.window = document.createElement('div');
                this.window.classList.add('window');
            }
            this.window.classList.remove('hidden');
            this.window.innerHTML = '';
            this.title = document.createElement('div');
            this.title.addEventListener('mousedown', (event) => {
                const mouseStart = { x: event.clientX, y: event.clientY };
                const start = this.window.getBoundingClientRect();
                action.move = (event) => {
                    const x = start.x + event.clientX - mouseStart.x;
                    const y = start.y + event.clientY - mouseStart.y;
                    this.window.style.left = `${x}px`;
                    this.window.style.top = `${y}px`;
                };
            });
            this.title.classList.add('window-title');
            this.title.innerText = `${this.index + 1}: ${this.content.innerText}`;
            if (x) {
                this.window.style.left = `${x}px`;
            }
            if (y) {
                this.window.style.top = `${y}px`;
            }
            this.window.append(this.title, this.content);
            document.body.append(this.window);
            this.state = 'window';
        }

        /**
         * Utility functions
         */
        function sameDay(date1, date2) {
            return date1.getDate() === date2.getDate() &&
                date1.getMonth() === date2.getMonth() &&
                date1.getFullYear() === date2.getFullYear();
        }

        /**
         * Add an item to the list used for completions
         */
        function addNamedItem(name, type) {
            const list = document.getElementById('named-items');
            const item = document.createElement('option');
            item.innerText = name;
            //list.appendChild(item);
        }

        /**
         * Add a date to the named items
         */
        function getDate(string) {
            if (string instanceof Date) {
                return new Date(string.getTime());
            }
            const [p1, p2, p3] = string.trim().split(/[-/_]/g).map((s) => parseInt(s));
            const [day, month, year] = (p1 > 1000) ? [p3, p2, p1] : [p1, p2, p3];
            return new Date(year < 2000 ? year + 2000 : year, month - 1, day);
        }

        /**
         *  Helper function to get list of items from a string
         */
        function getList_old(string, sep = " ", start = "<", end = ">") {
            const list = [];
            const quoted = (char) => {
                if (char === end) {
                    return init;
                }
                list.at(-1).push(char);
            };
            const unquoted = (char) => {
                if (char === sep) {
                    return init;
                }
                list.at(-1).push(char);
            }
            const init = (char) => {
                if (char === start) {
                    list.push(['']);
                    return quoted;
                } else if (char !== sep) {
                    list.push([char]);
                    return unquoted
                }
            }
            let action = init
            for (let i = 0; i < string.length; ++i) {
                action = action(string[i]) || action;
            }
            return list.map((item) => item.join(''));
        }

        /**
         *  Helper function to get list of items from a string
         */
        function getList(string, sep = ' ', start = '<', end = '>', esc = '\\') {
            const list = [];
            const invalid = [];
            const escaped = (char) => {
                list.at(-1).push(char);
                return escaped.next;
            };
            const quoted = (char) => {
                if (char === esc) {
                    escaped.next = quoted;
                    return escaped;
                }
                if (char === end) {
                    return init;
                }
                list.at(-1).push(char);
            };
            const unquoted = (char) => {
                if (char === esc) {
                    escaped.next = unquoted;
                    return escaped;
                }
                if (char === sep) {
                    if (list.at(-1))
                        return init;
                }
                list.at(-1).push(char);
            }
            const init = (char) => {
                if (char === esc) {
                    escaped.next = unquoted;
                    return escaped;
                }
                if (char === start) {
                    list.push(['']);
                    return quoted;
                } else if (char !== sep) {
                    list.push([char]);
                    return unquoted
                }
            }

            let action = init
            for (let i = 0; i < string.length; ++i) {
                action = action(string[i]) || action;
            }
            return list.map((item) => item.join(''));
        }

        /**
         *  Helper function to get list of cells from input string
         */
        function getCells(string) {
            if (string) {
                const list = getList(string);
                const cells = list.map((index) => app.namedCells[index] ?? nodes.at(parseInt(index) - 1));
                return cells.filter((cell) => cell);
            }
            return [app.cells.at(-1)];
        }


        /**
         *  Helper function to get list of cells from input string and set up input / output relationships
         */
        function getReferences(string, cell) {
            const inputs = getCells(string);
            inputs.forEach((input) => {
                input.outputs.add(cell);
                cell.input.add(input);
            });
            return inputs;
        }


        /**
         * calendar functions
         */
        const calendar = {
            holidays: [],
            // Offset of time from UCT so that day number is consistent even if date includes time information
            offset: (new Date(1970, 0, 4, 23)).getTime(),
            dayNumber: (date) => Math.floor((date.getTime() - calendar.offset) / (24 * 60 * 60 * 1000)),
            setStart: (date) => {
                date.setHours(8);
                date.setMinutes(0);
                date.setSeconds(0);
                date.setMilliseconds(0);
                return date;
            },
            setFinish: (date) => {
                date.setHours(18);
                date.setMinutes(0);
                date.setSeconds(0);
                date.setMilliseconds(0);
                return date;
            },
            days(start, end) {
                start = getDate(start);
                end = getDate(end);
                return Math.abs(calendar.dayNumber(end) - calendar.dayNumber(start));
            },
            isWorkingDay(date) {
                const day = calendar.dayNumber(date);
                return ((day % 7) < 5 && !calendar.holidays.includes(day));
            },
            workingDays(start, end) {
                start = getDate(start);
                end = getDate(end);

                if (isNaN(start) || isNaN(end)) return;
                if (start > end) {
                    [end, start] = [start, end];
                }
                calendar.setStart(start);
                calendar.setFinish(end);
                let days = 0;
                const day = new Date(start.getTime());
                if (day.getHours() > 12) {
                    day.setDate(day.getDate() + 1);
                }
                while (!calendar.isWorkingDay(day)) {
                    day.setDate(day.getDate() + 1);
                }
                while (day < end) {
                    days += 1;
                    day.setDate(day.getDate() + 1);
                    while (!calendar.isWorkingDay(day)) {
                        day.setDate(day.getDate() + 1);
                    }
                }
                return days;
            },

            getTimeToGo(start, end) {
                const workingDays = calendar.workingDays(start, end);
                let timeToGo = `${workingDays} working days`
                if (workingDays > 5) {
                    const weeks = Math.floor(workingDays / 5);
                    timeToGo += ` (${weeks} weeks)`;
                }
                return timeToGo;
            },

            /**
             * Get the end date of an activity based on its start and duration, assumes monday to friday minus public holidays.
             * Start assumed to be start of day, end is COB, hence start and end will be same date for single day task.
             */
            getEndDate(start, duration) {
                const end = new Date(start.getTime());
                --duration;
                while (!calendar.isWorkingDay(end)) {
                    end.setDate(end.getDate() + 1);
                }
                while (duration > 0) {
                    --duration;
                    end.setDate(end.getDate() + 1);
                    while (!calendar.isWorkingDay(end)) {
                        end.setDate(end.getDate() + 1);
                    }
                }
                calendar.setFinish(end);
                return end;
            },

            /**
             * Update a date by the given number of working days
             */
            offsetDate(date, workingDays = 0) {
                if (isNaN(date) || isNaN(workingDays)) {
                    return date;
                }
                workingDays = Math.round(workingDays);
                const delta = Math.sign(workingDays);
                while (workingDays !== 0) {
                    date.setDate(date.getDate() + delta);
                    while (!calendar.isWorkingDay(date)) {
                        date.setDate(date.getDate() + delta);
                    }
                    workingDays -= delta;
                }
                return date;
            },

            /**
             * Get the start date of an activity based on its finish and duration, assumes monday to friday minus public holidays.
             * Start assumed to be start of day, end is COB, hence start and end will be same date for single day task.
             */
            getStartDate(finish, duration) {
                const start = new Date(finish.getTime());
                --duration;
                while ((start.getDay() === 0) || (start.getDay() === 6) || calendar.holidays.includes(calendar.dayNumber(start))) {
                    start.setDate(start.getDate() - 1);
                }
                while (duration > 0) {
                    --duration;
                    start.setDate(start.getDate() - 1);
                    while ((start.getDay() === 0) || (start.getDay() === 6) || calendar.holidays.includes(calendar.dayNumber(start))) {
                        start.setDate(start.getDate() - 1);
                    }
                }
                calendar.setStart(start);
                return start;
            },

            /**
             * Return the financial month end for a given date.
             */
            getMonthEnd(date) {
                const year = date.getFullYear();
                const monthEnd = new Date(date.getMonth() < 5 ? year - 1 : year, 6, 1, 23, 59, 59, 999);
                const sequence = [28, 28, 35];
                let next = 0;
                if (monthEnd.getDay() < 4) {
                    next = 28;
                } else {
                    next = 35;
                }
                let i = 0;
                while (monthEnd <= date) {
                    monthEnd.setDate(monthEnd.getDate() + (next || sequence[i]) - monthEnd.getDay());
                    next = 0;
                    if (monthEnd.getMonth() === 11) {
                        monthEnd.setDate(31);
                        if (monthEnd.getDay() > 3) {
                            next = 35
                        }
                    }
                    if (monthEnd.getMonth() === 0 && monthEnd.getDate() < 7) {
                        monthEnd.setDate(0);
                        if (monthEnd.getDay() > 3) {
                            next = 35
                        }
                    }
                    if (monthEnd.getMonth() === 5) {
                        monthEnd.setDate(31);
                    }
                    if (monthEnd.getMonth() === 0 && monthEnd.getDate() < 7) {
                        console.log('> ' + monthEnd.toLocaleDateString());
                        monthEnd.setDate(0);
                        console.log(monthEnd.toLocaleDateString());
                    }
                    i = (i + 1) % 3;
                }
                return monthEnd;
            }
        };



        /**
         * Utility function to support downloading generated content.
         */
        function downloadText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }

        /**
         * Utility function to support downloading generated content.
         */
        function loadText(name = '', action) {
            const link = document.createElement('input');
            link.style.display = 'none';
            link.type = 'file';
            /*
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);
            */
            document.body.appendChild(link);
            link.click();
            link.addEventListener('change', (event) => {
                for (const file of link.files) {
                    app.setStatus(`loading ${file.name}`);
                    // Read the file
                    const reader = new FileReader();
                    reader.onload = () => {
                        if (action) {
                            action(reader.result, file.name);
                        } else {
                            console.log(reader.result);
                        }
                    };
                    reader.onerror = () => {
                        app.setStatus('Error reading the file. Please try again.');
                    };
                    reader.readAsText(file);
                }
                link.remove();
            });
        }


        /**
         * Make a list of names that will be inserted at the cursor when clicked
         */
        function makeInsertionList(items, container) {
            items.forEach((item) => {
                const node = document.createElement('div');
                node.innerText = item;
                node.addEventListener('mousedown', (event) => {
                    event.preventDefault();
                    const range = document.getSelection().getRangeAt(0);
                    if (range) {
                        range.deleteContents();
                        range.insertNode(document.createTextNode(item));
                    }
                });
                container.appendChild(node);
            });
        }

        /**
         * Get the source data for this action from the preceding lines
         */
        function getSource(cell, test = (cell) => !(cell.output.size || (cell.text.trim().startsWith('#') && cell.text.trim().endsWith('#')))) {
            const cells = [];
            let index = nodes.indexOf(cell) - 1;
            while (nodes[index] && test(nodes[index])) {
                cells.unshift(nodes[index]);
                index -= 1;
            }
            return cells;
        }


        /**
         * Custom Actions
         *
         */
        const actions = {
            /**
             * List the available actions.
             */
            actions(cell) {
                const output = Object.keys(actions).map((action, index) => {
                    const output = new Output(cell.index + 1 + index);
                    output.content.innerText = action;
                    output.content.addEventListener('mousedown', (event) => {
                        event.preventDefault();
                        const range = document.getSelection().getRangeAt(0);
                        if (range) {
                            range.deleteContents();
                            range.insertNode(document.createTextNode(action));
                        }
                    });
                    return output;
                });
                cell.after(output);
            },

            /**
             * Toggle fullscreen mode
             */
            fullscreen(cell) {
                if (!navigator.userActivation.isActive) {
                    return { message: 'fullscreen request ignored in script' };
                }
                if (document.body.webkitRequestFullscreen) {
                    if (document.webkitIsFullScreen) {
                        document.webkitCancelFullScreen();
                        return { message: 'exit fullscreen' };
                    } else {
                        document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                        return { message: 'enter fullscreen' };
                    }
                }
                if (document.body.requestFullscreen) {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                        return { message: 'exit fullscreen' };
                    } else {
                        document.body.requestFullscreen();
                        return { message: 'enter fullscreen' };
                    }
                }
                cell.action = true;
            },

            /**
             * Clear the screen
             */
            cls(cell) {
                cell.action = true;
            },

            /**
             * Reload the page
             */
            reload(cell) {
                if (!app.loaded) {
                    return { message: 'reload request ignored until app initialised' };
                }
                location.reload();
                return {};
            },

            /**
             * Change the theme
             */
            theme(cell) {
                const themeName = cell.text.replace(/^\s*theme\s+/, '').trim();
                document.documentElement.setAttribute('data-theme', themeName);
                const result = { message: `theme set to ${themeName}` };
                if (!themes.includes(themeName)) {
                    result.message += ' (unknown theme)!';
                }
                app.state.theme = themeName;
                cell.action = true;
            },

            /**
             * List the themes
             */
            themes(cell) {
                const themeName = document.documentElement.getAttribute('data-theme');
                const themeNames = themes.map((name) => name === themeName ? name + ' *' : name);
                const output = [cell.getOutput()];
                makeInsertionList(themeNames, output);
                cell.action = true;
            },

            /**
             * Show the command history
             */
            history(cell) {
                cell.update = (time) => {
                    const output = [cell.getOutput()];
                    output.innerHTML = '';
                    makeInsertionList(app.history, output);
                }
                app.events.historyChange.add(cell);
                const output = [cell.getOutput()];
                makeInsertionList(app.history, output);
                cell.action = true;
            },

            /**
             * Show the details of a cell
             */
            cell(cell) {
                const string = cell.content.innerText.replace(/\s*cell\s*/, '');

                const args = getList(string);
                const { cells, values } = args.reduce((results, value) => {
                    const index = Number(value) - 1;
                    if (app.namedCells[value] !== undefined) {
                        results.cells.push(app.namedCells[value]);
                    } else if (!isNaN(index) && index > -nodes.length && index < nodes.length) {
                        results.cells.push(nodes.at(index));
                    } else {
                        results.values.push(value);
                    }
                    return results;
                }, { cells: [], values: [] });

                const output = Array.from(cell.output || []);
                while (output.length > 0 && cells.length > 0) {
                    const current = output.shift();
                    const cell = cells.shift()
                    current.content.innerText = cell.content.innerText;
                }
                while (output.length) {
                    output.remove();
                }

                if (cells.length) {
                    cell.output = cell.output || [];
                    const ref = cell.output?.at(-1) || cell;
                    const pos = ref.index + 1;
                    const remaining = cells.map((cell, index) => {
                        const output = new Output(pos + index);
                        output.content.innerText = cell.content.innerText;
                        return output;
                    });
                    ref.after(remaining);
                    cell.output.push(...remaining);
                }
            },

            /**
             * Show the list of cells
             */
            cells(cell) {
                //cell.output = new Output(cell.index + 1);
                console.log(nodes.map((cell, index) => `${index + 1}: ${cell.content.innerText}`));
            },

            /**
             * perform a google search
             */
            google(cell) {
                const string = cell.text.replace(/google\s+/, '');
                const pattern = string.replace(/\s+/g, '+');
                const url = `https://www.google.com/search?q=${pattern}`;
                window.open(url, string, 'pop');
                const output = cell.getOutput();
                output.innerHTML = `<a href="${url}">${url}</a>`;
                cell.action = true;
            },

            /**
             * Download a resource from the net
             */
            wget(cell) {
                const url = cell.text.replace(/wget\s+/, '').replace(/\s+/g, '%20');
                const name = url.split(/\//g).at(-1);
                const link = document.createElement("a");
                link.href = url;
                link.download = name;
                link.click();
                cell.action = true;
            },

            /**
             * Set a cell size to its content
             */
            fit(cell) {
                const string = cell.text.replace(/\s*fit\s*/, '');

                const cells = getCells(string);
                const result = [];

                const fit = (cell) => {
                    const origin = cell.view.cell.getBoundingClientRect();

                    const size = {
                        width: 0, height: 0,
                    };
                    for (let child of cell.view.cell.childNodes) {
                        const box = child.getBoundingClientRect();
                        size.width = Math.max(size.width, child.scrollWidth);
                        size.height = Math.max(size.height, child.scrollHeight);
                    }
                    const name = cell.name || cell.index;
                    cell.view.cell.style.width = `${size.width}px`;
                    cell.view.cell.style.height = `${size.height}px`;
                    cell.view.cell.style.maxWidth = `100dvw`;
                    cell.view.cell.style.maxheight = `100dvh`;

                    result.push(`<${name}> now hidden`);
                };

                cells.forEach((cell) => {
                    fit(cell);
                    result.push(`<${name}> now hidden`);
                });
                return { message: result.join('<br>') };
            },

            /**
             * Set the 'hide' state for cells
             */
            hide(cell) {
                const string = cell.text.replace(/\s*hide\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    cell.setMode('hidden');
                    result.push(`<${cell.name || cell.index}> now hidden`);
                });
                cell.action = true;
            },

            /**
             * Toggle the 'hide' state for a cell
             */
            unhide(cell) {
                const string = cell.text.replace(/\s*unhide\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    cell.clearMode('hidden');
                    result.push(`<${cell.name || cell.index}> now unhidden`);
                });
                cell.action = true;
            },

            /**
             * Set the 'collapse' state for cell(s)
             */
            collapse(cell) {
                const string = cell.text.replace(/\s*collapse\s*/, '');

                const cells = getCells(string);
                cells.forEach((cell) => cell.collapse());
                cell.action = true;
            },

            /**
             * clear the 'collapse' state for cell(s)
             */
            expand(cell) {
                const string = cell.replace(/\s*expand\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => cell.expand());
                cell.action = true;
            },

            /**
             * Toggle the 'widget' state for a cell
             */
            widget(cell) {
                const string = cell.text.replace(/\s*widget\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    if (cell.state === 'window') {
                        cell.window.classList.add('hidden');
                    }
                    cell.widget();
                });
                cell.action = true;
            },

            /**
             * display the cell in line with the other cells
             */
            inline(cell) {
                const string = cell.text.replace(/\s*inline\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    if (cell.window) {
                        cell.window.classList.add('hidden');
                    }
                    cell.unstick();
                    cell.inline();
                });
                cell.action = true;
            },

            /**
             * Toggle the 'sticky' state for a cell
             */
            stick(cell) {
                const string = cell.text.replace(/\s*stick\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => cell.stick());
                app.layoutChange();
                cell.action = true;
            },

            /**
             * Convert a cell to a window and set it's position
             */
            window(cell) {
                const string = cell.content.innerText.replace(/\s*window\s*/, '');

                const args = getList(string);
                const { cells, values } = args.reduce((results, value) => {
                    const index = Number(value) - 1;
                    if (app.namedCells[value] !== undefined) {
                        results.cells.push(app.namedCells[value]);
                    } else if (!isNaN(index) && index > -nodes.length && index < nodes.length) {
                        results.cells.push(nodes.at(index));
                    } else {
                        results.values.push(value);
                    }
                    return results;
                }, { cells: [], values: [] });

                const pos = values.map((val) => Number(val));
                const result = [];
                cells.filter((cell) => cell.makeWindow).forEach((cell) => {
                    cell.makeWindow();
                    if (!isNaN(pos[0])) {
                        cell.window.style.left = `${pos[0]}px`;
                    }
                    if (!isNaN(pos[1])) {
                        cell.window.style.top = `${pos[1]}px`;
                    }
                });
                app.layoutChange();
                cell.action = true;
            },

            /**
             * Set a background image
             */
            background(cell) {
                const isCSSColour = (strColor) => {
                    const s = new Option().style;
                    s.color = strColor;
                    return s.color !== '';
                }

                const string = cell.text.replace(/\s*background\s*/, '');
                if (isCSSColour(string)) {
                    document.body.style.backgroundColor = string;
                } else if (string) {
                    const url = string.startsWith('https://') ? string : `https://${url}`;
                    if (url === 'none') {
                        document.body.style.backgroundImage = `none`;
                    } else {
                        document.body.style.backgroundImage = `url("${url}")`;
                    }
                    app.state.background = url;
                } else {
                    app.state.background = 'none';
                    document.body.style.backgroundImage = 'none';
                    document.body.style.backgroundColor = 'none';
                }
                cell.action = true;
            },

            /**
             * Log the content of the specified cell(s)
             */
            log(cell) {
                const string = cell.text.replace(/^\s*log\s*/, '');
                const output = cell.getOutput();
                const cells = getCells(string);
                if (cells.length === 0) {
                    output.content.innerHTML = `No cells logged!`;
                } else if (cells.length === 1) {
                    output.content.innerHTML = `log cell ${cellName(cells[0])}`;
                } else {
                    output.content.innerHTML = `log cells ${cells.map((cell) => cellName(cell)).join()}`;
                }
                cells.forEach((cell) => console.log(cell));
            },

            /**
             * Delete a cell
             */
            delete(cell) {
                if (!navigator.userActivation.isActive) {
                    return { message: 'delete ignored when reloading state' };
                }
                if (!app.interactive) {
                    return { message: 'delete ignored in non-interactive mode' };
                }

                const string = cell.text.replace(/^\s*delete\s*/, '');
                const len = app.cells.length;
                const cells = getCells(string);

                if (cells.length === 0) {
                    return { message: `No cells deleted!` };
                } else {
                    app.cells = app.cells.filter((cell) => !cells.includes(cell));
                    cells.forEach((cell) => cell.remove());
                    return { message: cells.map((cell) => `Deleted cell ${cell.index}` + cell.name ? ` (${cell.name})` : '') };
                }
                cell.action = true;
            },

            /**
             * List the known files
             */
            files(cell) {
                const output = cell.getOutput();
                makeInsertionList(Object.keys(named.files), output);
                cell.action = true;
            },

            /**
             * Create a notes cell
             */
            html(cell) {
                const output = cell.getOutput();

                cell.update = async (time) => {
                    const cells = getSource(cell);
                    cells.forEach((input) => cell.input.add(input));
                    const source = cells.map((input) => input.content.innerText).join('\n');
                    output.content.innerHTML = source;
                }

                cell.update();
            },

            /**
             * Create a mermaid diagram cell
             */
            diagram(cell) {
                const output = new Output(cell.index + 1);
                cell.after(output);
                const string = cell.text.replace(/^diagram\s*/, '');
                const index = app.mermaidCount++;

                output.content.classList.add('mermaid');
                output.content.addEventListener('click', (event) => diagram.classList.toggle('focused'));

                output.update = async (time) => {
                    const cells = getSource(cell);
                    cells.forEach((input) => cell.input.add(input));
                    const source = cells.map((input) => input.content.innerText).join('\n');
                    try {
                        const { svg } = await mermaid.render(`graph_${index}`, source);
                        output.content.innerHTML = svg;
                    } catch (error) {
                        output.content.innerHTML = error.message;
                    }
                }
                output.update();
            },

            /**
             * Create a js cell
             */
            js(cell) {
                const cells = getSource(cell);
                cells.forEach((input) => cell.input.add(input));
                const text = cells.map((cell) => cell.content.innerText).join('\n');
                try {
                    const func = new Function('store', text);
                    const result = func(app.store);
                    cell.updateTextOutput(result);
                } catch (error) {
                    cell.updateTextOutput(error.message);
                }
            },

            /**
             * Create a js cell
             */
            js2(cell) {
                const cells = getSource(cell);
                cells.forEach((input) => cell.input.add(input));
                const text = cells.map((cell) => cell.content.innerText).join('\n');
                try {
                    const func = new Function('store', text);
                    const result = func(app.store);
                    cell.updateTextOutput(result);
                } catch (error) {
                    cell.updateTextOutput(error.message);
                }
            },

            /**
             * Reset command history
             */
            'clear history'(cell) {
                app.history = [];
                cell.action = true;
            },

            /**
             * Add a date to the named items
             */
            date(cell) {
                const string = cell.content.innerText.replace(/date\s*/, '');
                const parts = string.split(/(\s+)/g);
                const date = parts.pop();
                const name = parts.join('').trim();
                const [day, month, year] = date.split(/[-/_]/g).map((s) => parseInt(s));
                named.dates[name] = named.dates[name] || {
                    eval(cell) {
                        cell.value = this.value[0];
                    },
                    value: [],
                };
                named.dates[name].value.push(new Date(year < 2000 ? year + 2000 : year, month - 1, day));
                addNamedItem(name);
                app.notifyListeners('dates', { action: 'add', value: { name: named.dates[name] } });
                cell.action = true;
            },

            /**
             * List dates
             */
            dates(cell) {
                const output = cell.getOutput();
                const dates = Object.entries(named.dates).map(([name, date]) => `${name}: ${date.toDateString()}`)
                makeInsertionList(dates, output);
            },

            /**
             * Add a site to the named items
             */
            site(cell) {
                const string = cell.content.innerText.replace(/site\s*/, '');
                const [name, addr] = string.split(/\s*http/);
                const url = `http${addr}`;
                named.sites[name] = {
                    eval(cell) {
                        const windowReference = window.open(url, name, 'pop');
                        named.sites[name] = url;
                        if (windowReference) {
                            windowReference.focus();
                        }
                        cell.type = Status;
                        cell.value = `<a href="url">${name}</a>`;
                    },
                    url,
                };
                addNamedItem(name);
                saveState();
                cell.action = true;
            },

            /**
             * List sites
             */
            sites(cell) {
                const output = cell.getOutput();
                const sites = Object.entries(named.sites).map(([name, item]) => `${name}: <a href="${item.url}">${item.url}</a>`);
                makeInsertionList(sites, output);
            },

            /**
             * Add an abbreviation
             */
            abbr(cell) {
                const string = cell.content.innerText.replace(/abbr\s*/, '');
                const parts = string.split(/(\s+)/);
                const name = parts.shift();
                const expansion = parts.join('').trim();
                named.abbreviations[name] = {
                    eval(cell) {
                        cell.value = expansion
                    },
                };
                addNamedItem(name);
                cell.action = true;
            },

            /**
             * List abbreviations
             */
            abbreviations(cell) {
                const output = cell.getOutput();
                const abbreviations = Object.entries(named.abbreviations).map(([name, expansion]) => `${name}: ${expansion}`);
                makeInsertionList(abbreviations, output);
            },

            /**
             * Load a file using a handle in the database
             */
            load(cell) {
                const output = cell.getOutput();

                if (!navigator.userActivation.isActive) {
                    app.setStatus('load request ignored in script');
                    return;
                }

                const chooseFile = async () => {
                    if ('showOpenFilePicker' in self) {
                        const [fileHandle] = await window.showOpenFilePicker();
                        if (fileHandle) {
                            output.innerHTML = `Loading...`;
                            const file = await fileHandle.getFile();
                            const content = await file.text();
                            cell.updateTextOutput(content);
                            cell.content = file.name;
                            output.innerHTML = `${file.name}:`;
                            saveFileHandles([{ name: file.name, handle: fileHandle }]);
                            updateLineNumbers();
                        }
                    }
                };

                const file = cell.content.innerText.replace(/^\s*load\s*/, '');
                if (file) {
                    load(cell, file, (contents) => output.innerHTML = `<pre>${contents}</pre>`);
                } else {
                    app.setStatus(`Select File...`);
                    chooseFile();
                }
                cell.action = true;
            },

            /**
             * Save the contents of the specified cells
             */
            save(cell) {
                const string = cell.content.innerText.replace(/^\s*save\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]
                const cells = getReferences(string.replace(pattern, ''), cell);

                let fileHandle;
                const save = async () => {
                    if (fileHandle) {
                        const contents = cells.map((cell) => cell.value).join('\n');
                        // Create a FileSystemWritableFileStream to write to.
                        const writable = await fileHandle.createWritable();
                        // Write the contents of the file to the stream.
                        await writable.write(contents);
                        // Close the file and write the contents to disk.
                        await writable.close();
                    }
                }

                const pickfile = async () => {
                    fileHandle = await window.showSaveFilePicker(options);
                    const file = await fileHandle.getFile();
                    cell.contents = file.name;
                    input += ` as ${file.name}`;
                    saveFileHandles([{ name: file.name, handle: fileHandle }]);
                }

                if (filename && named.files[filename]) {
                    fileHandle = named.files[filename];
                } else {
                    const options = {
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                    };
                    pickfile();
                }
                save();

                return { messsage: `Saving ${cells.map((cell) => cell.index).join(', ')}` };
            },

            /**
             * Save the session
             */
            'save session'(cell) {
                const string = cell.content.innerText.replace(/^\s*save session\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1];
                const content = JSON.stringify({ app, named }, null, 2);
                downloadText(content, filename);
                return { message: 'Session saved' };
            },

            /**
             * Load a session
             */
            'load session'(cell) {
                const string = cell.content.innerText.replace(/^\s*load session\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1];
                loadText(filename);
                return { message: 'Loading session' };
            },

            /**
             * Save the session
             */
            'watch session'(cell) {
                const string = cell.content.innerText.replace(/^\s*save session\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1];
                let fileHandle;

                const save = async () => {
                    if (fileHandle) {
                        const contents = JSON.stringify({ app, named });
                        // Create a FileSystemWritableFileStream to write to.
                        const writable = await fileHandle.createWritable();
                        // Write the contents of the file to the stream.
                        await writable.write(contents);
                        // Close the file and write the contents to disk.
                        await writable.close();
                        app.setStatus(`Saved session to ${fileHandle.name}`);
                    }
                }

                const pickfile = async (options) => {
                    fileHandle = await window.showSaveFilePicker(options);
                    const file = await fileHandle.getFile();
                    raw += ` as ${file.name}`;
                    saveFileHandles([{ name: file.name, handle: fileHandle }]);
                    update();
                }

                if (filename && named.files[filename]) {
                    fileHandle = named.files[filename];
                    save();
                } else {
                    const options = {
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.json'],
                                },
                            },
                        ],
                    };
                    pickfile(options);
                }
                save();
                return { message: 'Session saved' };
            },

            /**
             * Show a status bar
             */
            'status bar'(cell) {
                const string = cell.content.innerText.replace(/^\s*status bar\s*/, '');

                let update;

                if (document.getElementById('status-bar')) {
                    document.getElementById('status-bar').remove();
                    update = false;
                    app.statusBar = false;
                } else {
                    const bar = document.createElement('div');
                    bar.id = 'status-bar';
                    document.getElementById('header').appendChild(bar);
                    update = true;
                    app.statusBar = true;


                    const node = document.getElementById('status-bar');

                    const position = document.createElement('div');
                    position.classList.add('status-bar-position');
                    node.appendChild(position);

                    const network = document.createElement('div');
                    network.classList.add('status-bar-time');
                    node.appendChild(network);

                    const time = document.createElement('div');
                    time.classList.add('status-bar-time');
                    node.appendChild(time);

                    const refresh = () => {
                        position.innerHTML = `Line: ${app.content} / ${nodes.length}`;
                        network.innerHTML = navigator.connection.type || '';
                        const now = new Date();
                        time.innerHTML = now.toLocaleTimeString();
                        if (update) {
                            requestAnimationFrame(refresh);
                        }
                    }
                    refresh();
                }
            },


            /**
             * Load a session
             */
            'read session'(cell) {
                const string = cell.content.innerText.replace(/^\s*load session\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]

                const load = async () => {
                    if (filename && named.files[filename]) {
                        const handle = named.files[filename];
                        if (await verifyPermission(handle)) {
                            const file = await handle.getFile();
                            const content = await file.text();
                            try {
                                const state = JSON.parse(content);
                                restoreState(state);
                            } catch (error) {
                                app.setStatus(error.message);
                            }
                        } else {
                            console.log('Permission not granted for file :(');
                        }
                    }
                }

                const chooseFile = async () => {
                    const [fileHandle] = await window.showOpenFilePicker();
                    if (fileHandle) {
                        cell.filename = fileHandle.name;
                        named.files[cell.filename] = fileHandle;
                        const file = await fileHandle.getFile();
                        input += ` ${cell.filename}`;
                        saveFileHandles([{ name: cell.filename, handle: fileHandle }]);
                        update();
                    }
                }

                if (cell.filename && named.files[cell.filename]) {
                    update();
                } else if ('showOpenFilePicker' in self) {
                    chooseFile();
                }
                return { message: 'Loading session' };
            },

            saveSvg(cell) {
                const string = cell.content.innerText.replace(/^\s*saveSvg\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]
                const cells = getReferences(string.replace(pattern, ''), cell);

                const update = () => {
                    cells.filter((cell) => cell.svg).forEach((cell, index) =>
                        cells.length > 1 ? convertSVGtoImg(cell.svg, `${filename}_${index}.png`) : convertSVGtoImg(cell.svg, `${filename}.png`));
                };

                update();
                return { message: 'Svg saved' };
            },

            /**
             * Load user specified data file
             */
            'load data'(cell) {
                const file = cell.content.innerText.replace(/^\s*load data\s*/, '');
                const process = (content) => {
                    cell.updateTextOutput(content);

                    let sectionName;
                    let current;
                    const section = /^[^\s]+[^:]*:\s*$/;
                    const data = {};
                    content.split(/\r?\n/g).forEach((line) => {
                        if (section.test(line)) {
                            sectionName = line.replace(/:\s*$/, '');
                            data[sectionName] = named[sectionName] || {};
                        } else if (sectionName && line.trim() !== '') {
                            const [pre, ...values] = line.split(/:/);
                            const name = pre.trim();
                            const value = values.join(':').trim();
                            data[sectionName][name] = data[sectionName][name] || [];
                            data[sectionName][name].push(value);
                        }
                    });
                    if (data.abbreviations) {
                        Object.entries(data.abbreviations).forEach(([name, expansion]) => {
                            named.abbreviations[name] = {
                                eval(cell) {
                                    cell.value = expansion
                                },
                            };
                            addNamedItem(name);
                        });
                    }
                    if (data.dates) {
                        Object.entries(data.dates).forEach(([name, dates]) => {
                            named.dates[name] = {
                                eval(cell) {
                                    cell.value = getDate(dates[0])
                                },
                                value: getDate(dates[0]),
                            };
                            addNamedItem(name);
                        });
                    }
                    if (data.sites) {
                        Object.entries(data.sites).forEach(([name, urls]) => {
                            const url = urls[0];
                            named.sites[name] = {
                                eval(cell) {
                                    const windowReference = window.open(url, name, 'pop');
                                    named.sites[name] = url;
                                    if (windowReference) {
                                        windowReference.focus();
                                    }
                                    cell.type = Status;
                                    cell.value = `<a href="url">${name}</a>`;
                                },
                                url,
                            };
                            addNamedItem(name);
                        });
                    }
                    if (data.holidays) {
                        Object.entries(data.holidays).forEach(([date, name]) => {
                            calendar.holidays.push(calendar.dayNumber(getDate(date)));
                            if (name) {
                                named.holidays[name] = named.holidays[name] || {
                                    eval(cell) {
                                        cell.value = date[0];
                                    },
                                    dates: [],
                                }
                                named.holidays[name].dates.push(date);
                                addNamedItem(name);
                            }
                        });
                    }
                    app.notifyListeners('dates', { action: 'added', values: data.dates });
                    //cell.output.forEach((output) => output.update());
                    updateLineNumbers();
                }

                const chooseFile = async () => {
                    const [fileHandle] = await window.showOpenFilePicker();
                    if (fileHandle) {
                        const file = await fileHandle.getFile();
                        cell.content.append(` ${file.name}`);
                        cell.content = file.name;
                        const contents = await file.text();
                        process(contents);
                        saveFileHandles([{ name: file.name, handle: fileHandle }]);
                        saveState();
                    }
                }

                if (file) {
                    load(cell, file, process);
                } else {
                    if ('showOpenFilePicker' in self) {
                        chooseFile();
                    }
                }

            },
        }

        const named = {
            dates: {},
            holidays: {},
            sites: {},
            abbreviations: {},
            files: {},
        }
        Object.defineProperties(named, {
            all: {
                get() {
                    return Object.values(this).reduce((all, value) => Object.assign(all, value), {});
                },
            }
        })

        Object.keys(actions).forEach(addNamedItem);

        //const inputNode = document.getElementById('command-entry');

        const action = {};
        document.body.addEventListener('mousemove', (event) => {
            if (action.move) {
                action.move(event);
            }
        });
        document.body.addEventListener('mouseup', (event) => {
            if (action.move) {
                action.move = null;
                //inputNode.focus();
            }
            document.body.classList.remove('noselect');
            saveState();
            for (const node of document.querySelectorAll('.dragging')) {
                node.classList.remove('dragging');
            }
        });

        document.body.addEventListener('focusin', () => {
            const cell = app.cells.find((cell) => cell.view?.cell?.contains(document.activeElement));
            app.setCurrentCell(cell);
        });

        document.body.addEventListener('focusout', () => {
            setTimeout(() => {
                if (document.activeElement === document.body) {
                    //inputNode.focus();
                }
            }, 10);
        });


        class Cell_old {
            static id = 0;
            constructor(raw, content, expr, resolved, uses = []) {
                input = raw;
                this.timestamp = new Date();
                this.expr = expr ?? raw;
                this.resolved = resolved ?? raw;
                this.content = content;
                this.value = content;
                this.input = new Set(uses);
                this.users = new Set();
                this.view = {};
                this.modes = new Set();
                this.index = Cell.id++;
            }
            /*
            get index() {
                return this.index;
            }
                */
            getName() {
                const name = [];
                name.push(`${this.index}:`);
                if (this.name) {
                    name.push(this.name);
                }
                name.push(this.content.innerText);
                return name.join(' ');
            }
            getResultNode() {
                const node = document.createElement('div');
                node.classList.add('result');
                node.innerHTML = this.value ?? '';
                return node;
            }
            makeView() {
                this.view.cell = document.createElement('div');
                this.view.cell.addEventListener('click', (event) => app.setCurrentCell(this));
                this.view.cell.classList.add('cell');

                this.view.index = document.createElement('span');
                this.view.index.classList.add('index');
                this.view.cell.appendChild(this.view.index);
                this.view.index.addEventListener('click', (event) => {
                    const str = ` <${this.index}>`;
                    const pos = inputNode.selectionStart;
                    inputNode.value = inputNode.value.slice(0, pos) + str + inputNode.value.slice(pos);
                    inputNode.focus();
                    inputNode.selectionStart = inputNode.selectionEnd = pos + str.length;
                });

                this.view.input = this.view.input || document.createElement('div');
                this.view.input.classList.add('input');
                this.view.cell.appendChild(this.view.input);

                this.view.container = document.createElement('div');
                this.view.container.classList.add('result-box');
                this.view.cell.appendChild(this.view.container);

                const references = {
                    x: [],
                    y: [],
                };
                const mousemove = (event) => {
                    event.preventDefault();
                    this.setState('floating');

                    action.node.classList.add('dragging');

                    const x = event.clientX - action.start.x + action.pos.x;
                    const y = event.clientY - action.start.y + action.pos.y;
                    if (!event.ctrlKey) {
                        const x2 = references.x.reduce((x, rx) =>
                            Math.abs(rx - x) < 10 ? rx : x, x);
                        const y2 = references.y.reduce((y, ry) =>
                            Math.abs(ry - y) < 10 ? ry : y, y);
                        action.node.style.left = `${x2}px`
                        action.node.style.top = `${y2}px`;
                    } else {
                        action.node.style.left = `${x}px`
                        action.node.style.top = `${y}px`;
                    }
                    app.layoutChange();
                };

                this.view.input.addEventListener('mousedown', (event) => {
                    references.x.length = 0;
                    references.y.length = 0;
                    for (const node of document.querySelectorAll('.floating .result-box')) {
                        if (node !== this.view.result.parentElement) {
                            const box = node.getBoundingClientRect();
                            references.x.push(box.x, box.x + box.width, box.x - this.view.result.clientWidth);
                            references.y.push(box.y, box.y + box.height, box.y - this.view.result.clientHeight);
                        }
                    }
                    if (this.view.cell.classList.contains('sticky') ||
                        this.view.cell.classList.contains('floating')) {
                        action.node = this.view.cell;
                        action.move = mousemove;
                        action.start = { x: event.clientX, y: event.clientY };
                        action.pos = action.node.getBoundingClientRect();
                        document.body.classList.add('noselect');
                        document.getElementById('results').appendChild(this.view.cell);
                    }
                });

                this.view.raw = this.view.raw || document.createElement('span');
                this.view.raw.classList.add('raw');
                this.view.raw.innerText = input;
                this.view.input.appendChild(this.view.raw);
                this.view.raw.addEventListener('dblclick', (event) => {
                    if (event.ctrlKey) {
                        this.view.raw.contentEditable = true;
                        this.view.raw.focus();
                    } else {
                        if (this.state === 'hidden') {
                            this.setState('normal');
                        } else {
                            this.setState('hidden');
                        }
                        /*
                        this.view.result.classList.toggle('hidden');
                        this.view.input.classList.toggle('dim');
                        */
                    }
                });
                this.view.raw.addEventListener('blur', (event) => {
                    this.view.raw.contentEditable = false;
                    input = this.view.raw.innerText;
                });

                if (input !== this.resolved) {
                    const arrow = document.createElement('span');
                    arrow.innerHTML = ' &rarr; ';
                    this.view.input.appendChild(arrow);

                    this.view.resolved = this.view.resolved || document.createElement('span');
                    this.view.resolved.classList.add('resolved');
                    this.view.resolved.innerHTML = this.resolved;
                    this.view.input.appendChild(resolvedNode);
                }
                this.view.result = this.view.result || this.getResultNode();
                this.view.result.draggable = true;
                this.view.result.addEventListener('dragstart', (event) => {
                    event.dataTransfer.setData('text/plain', this.value);
                    const box = this.view.result.getBoundingClientRect();
                    const placeholder = document.getElementById('placeholder');
                    placeholder.style.width = `${box.width}px`;
                    placeholder.style.height = `${box.height}px`;
                    app.dragging = this.view.result;
                });
                this.view.result.addEventListener('dragover', (event) => {
                    if (event.dataTransfer.types.includes('Files')) {
                    } else {
                        const placeholder = document.getElementById('placeholder');
                        placeholder.classList.remove('hidden');
                        const parent = this.view.result.parentElement;
                        //app.dragging.replaceWith(placeholder);
                        const box = this.view.result.getBoundingClientRect();
                        if (event.clientY < box.y + box.height / 2) {
                            parent.insertBefore(app.dragging, this.view.result);
                        } else {
                            parent.insertBefore(app.dragging, this.view.result.nextSibling)
                        }
                    }
                });
                this.view.result.addEventListener('dragend', (event) => {
                    placeholder.classList.add('hidden');
                });
                /*
            this.view.result.addEventListener('dragover', (event) => {
                event.preventDefault();
            });
            */
                this.view.container.appendChild(this.view.result);
            }
            getSettings() {
                return undefined;
            }
            serialiseContent() {
                return this.content;
            }
            toJSON(key) {
                if (this.type === Status) {
                    return undefined;
                }
                const state = {};
                const view = {};
                if (this.view) {
                    const box = this.view.cell.getBoundingClientRect();

                    view.state = this.state;
                    if (this.state === 'floating') {
                        view.box = this.view.box || { x: box.x, y: box.y, width: box.width, height: box.height };
                    }
                    view.modes = Array.from(this.modes).filter((mode) => mode);
                }

                return {
                    raw: input,
                    timestamp: this.timestamp.getTime(),
                    content: this.serialiseContent(),
                    view,
                    settings: this.getSettings(),
                }
            }
            changeState(state) {
                this.state = state;
                const states = ['normal', 'sticky', 'floating', 'widget', 'collapsed', 'hidden'];

                this.view.cell.style.top = '';
                this.view.cell.style.left = '';
                this.view.cell.style.bottom = '';

                if (state === 'sticky') {
                    const top = Math.max(0, ...Array.from(document.querySelectorAll('.sticky'))
                        .map((node) => {
                            const box = node.getBoundingClientRect();
                            return box.y + box.height;
                        })
                    );
                    this.view.cell.style.top = `${top}px`;
                    this.view.cell.style.left = 0;
                    this.view.cell.style.bottom = 0;
                } else if (this.lastState === 'sticky') {
                    const box = this.view.cell.getBoundingClientRect();
                    this.view.cell.classList.remove('sticky');
                    Array.from(document.querySelectorAll('.sticky'))
                        .filter((node) => node.getBoundingClientRect().y > box.y)
                        .forEach((node) => node.style.top = `${node.getBoundingClientRect().y - box.height}px`);
                }

                if ((state === 'floating' || state === 'widget') && !(this.lastState === 'floating' || this.lastState === 'widget')) {
                    this.view.placeholder = this.view.placeholder || document.createElement('div');
                    this.view.cell.replaceWith(this.view.placeholder);
                } else if (!(state === 'floating' || state === 'widget') && (this.lastState === 'floating' || this.state === 'widget')) {
                    this.view.placeholder.replaceWith(this.view.cell);
                }

                if (state === 'widget') {
                    document.getElementById('widgets').appendChild(this.view.cell);
                    this.view.cell.title = `${this.index}: ${input}`;
                }

                if (state === 'floating') {
                    document.getElementById('results').appendChild(this.view.cell);
                    if (this.view.box) {
                        this.view.cell.style.top = `${this.view.box.top}px`;
                        this.view.cell.style.left = `${this.view.box.left}px`;
                        this.view.cell.style.width = `${this.view.box.width}px`;
                        this.view.cell.style.height = `${this.view.box.height}px`;
                    } else {
                        this.view.cell.style.top = '20%';
                        this.view.cell.style.left = '20%';
                    }
                } else if (this.lastState === 'floating') {
                    this.view.box = this.view.cell.getBoundingClientRect();
                }

                const classes = this.view.cell.classList;
                states.forEach((possibleState) => possibleState === state ? classes.add(state) : classes.remove(possibleState));

                if (state === 'normal') {
                    this.view.cell.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
                }
            }
            setState(state) {
                if (state !== this.state) {
                    this.lastState = this.state;
                    this.changeState(state);
                }
            }
            lastState() {
                const state = this.lastState || this.defaultState || 'normal';
                this.changeState(state);
            }
            setMode(mode) {
                this.modes.add(mode);
                this.view.cell.classList.add(mode);
            }
            clearMode(mode) {
                this.modes.delete(mode);
                this.view.cell.classList.remove(mode);
            }
            remove() {
                if (this.view.cell) {
                    this.view.cell.remove();
                }
                this.input.forEach((input) => input.users.delete(this));
                this.users.forEach((user) => user.input.delete(this));
            }
        }


        /**
         * Create an editable span.
         */
        function editableSpan(get, set) {
            const node = document.createElement('span');
            node.contentEditable = true;
            node.innerText = get();
            node.addEventListener('blur', (event) => set(node));
            let previous;
            node.addEventListener('focus', (event) => {
                node.innerText = get();
                previous = node.innerText;
            });
            node.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    set(node);
                }
                if (event.key === 'escape') {
                    node.innerText = previous;
                }
            });

            return node;
        }

        /**
         * Create an expansion widget for trees.
         */
        function expander(getState, expand, collapse) {
            const node = document.createElement('span');
            node.classList.add('expander');

            const toggle = (event) => {
                if (getState() === 'expanded') {
                    node.innerHTML = '&#128449;';//'&#9654;';
                    collapse(event);
                } else if (getState() === 'collapsed') {
                    node.innerHTML = '&#128448;';//'&#9660;';
                    expand(event);
                } else {
                    node.innerHTML = '&#128462;';
                }
            };

            if (getState() === 'expanded') {
                node.innerHTML = '&#128449;';//'&#9660;';
            } else if (getState() === 'collapsed') {
                node.innerHTML = '&#128448;';//'&#9654;';
            } else {
                node.innerHTML = '&#128462;';
            }

            node.addEventListener('click', (event) => toggle(event));
            return node;
        }

        /**
         * Flatten a tree to a set of nodes
         */
        function flatten(node, getParts = (node) => node[meta].parts, expanded = new Set()) {
            if (expanded.has(node)) {
                console.log('tree contains circular relationship');
                return expanded;
            }
            expanded.add(node);
            if (Array.isArray(getParts(node))) {
                getParts(node).forEach((node) => flatten(node, getParts, expanded));
            }
            return expanded;
        }


        /**
         * Data for simple todos
         */
        class ToDo {
            constructor(detail, raised, done, title) {
                this.update(detail, raised, done, title);
                // Add to the global list of todos.
                app.addTyped(this);
                app.notifyListeners('todos', { action: 'new', todo: this });
            }
            update(detail, raised, done, title) {
                raised = detail.raised ?? raised;
                this.raised = raised ? new Date(raised) : new Date();

                done = detail.done ?? done;
                this.done = done ? new Date(done) : null;

                this.title = detail.title ?? title;
                this.detail = detail.detail ?? detail;
            }
            toString() {
                return this.detail;
            }
            complete(done) {
                this.done = done ? new Date(done) : new Date();
                app.notifyListeners('todos', { action: 'complete', todo: this });
            }
            toShortHTML() {
                if (this.done) {
                    return `<span class="dim"><s>${this.title || this.detail}</s></span>`;
                }
                return `<span>${this.title || this.detail}</span>`;
            }
        }


        const meta = Symbol('meta');

        /**
         * Convert a tree that uses symbol keys into a plain tree
         */
        function serialiseTree(all) {
            return all.map((source) => ({ parts: source[meta].parts.map((part) => all.indexOf(part)), data: source }));
        }

        /**
         * Convert a tree that uses symbol keys into a plain tree
         */
        function makeTree(all) {
            return all.map((source) => {
                source.data[meta] = {
                    parts: source.parts.map((part) => all[part].data),
                };
                source.data[meta].parts.forEach((part) => part[meta].parent = source.data);
                return source.data;
            }).filter((node) => !node.parent);
        }


        /**
         * Return a div containing a calendar
         */
        function makeCalendar(cell, date) {
            this.calendarDate = date;
            const calendarWidget = document.createElement('div');
            calendarWidget.classList.add('calendar');

            const previousMonth = document.createElement('span');
            previousMonth.innerHTML = '&lt;';
            previousMonth.classList.add('calendar-day');
            calendarWidget.appendChild(previousMonth);
            previousMonth.addEventListener('click', (event) => {
                this.calendarDate.setMonth(this.calendarDate.getMonth() - 1);
                update()
            });

            const monthName = document.createElement('span');
            monthName.classList.add('calendar-month-name');
            calendarWidget.appendChild(monthName);

            const nextMonth = document.createElement('span');
            nextMonth.innerHTML = '&gt;';
            nextMonth.classList.add('calendar-day');
            calendarWidget.appendChild(nextMonth);
            nextMonth.addEventListener('click', (event) => {
                this.calendarDate.setMonth(this.calendarDate.getMonth() + 1);
                update()
            });

            'SMTWTFS'.split('').forEach((c) => {
                const day = document.createElement('span');
                day.classList.add('calendar-day');
                day.innerHTML = c;
                calendarWidget.appendChild(day);
            });
            const days = [];
            for (let i = 0; i < 42; ++i) {
                const day = document.createElement('span');
                day.classList.add('calendar-day');
                calendarWidget.appendChild(day);
                days.push(day);
            }

            const update = () => {
                const today = new Date();
                monthName.innerHTML = this.calendarDate.toLocaleDateString('en-AU', { month: 'long' });
                const month = this.calendarDate.getMonth();
                const year = this.calendarDate.getFullYear();
                const date = new Date(year, month, 1);
                date.setDate(date.getDate() - date.getDay());
                const end = new Date(year, month + 1, 0);
                end.setDate(end.getDate() + 7 - end.getDay());
                days.forEach((day) => {
                    if (sameDay(today, date)) {
                        day.classList.add('calendar-day-today');
                    } else {
                        day.classList.remove('calendar-day-today');
                    }
                    if (date.getMonth() === month) {
                        day.classList.remove('calendar-day-fade');
                    } else {
                        day.classList.add('calendar-day-fade');
                    }
                    if (date < end) {
                        day.innerHTML = ('' + date.getDate()).padStart(2, '0');
                    } else {
                        day.innerHTML = '';
                    }
                    date.setDate(date.getDate() + 1);
                });
            }
            update();
            return calendarWidget;
        }


        function modelNode(node) {
            return {
                getState() {
                    if (node[meta].parts?.length) {
                        return this.state;
                    }
                },
                state: 'expanded',
                expand(event) {
                    this.state = 'expanded';
                    if (event.ctrlKey && node[meta].parts) {
                        node[meta].parts.forEach((child) => model.get(child).expand(event));
                    }
                },
                collapse(event) {
                    this.state = 'collapsed';
                    if (event.ctrlKey && node[meta].parts) {
                        node[meta].parts.forEach((child) => model.get(child).collapse(event));
                    }
                },
                nodes: [],
            }
        }


        /**
         * Cell types applied to a cell after creation.
         */
        const cellTypes = {
            /**
             * Add a clock to the widget area
             */
            clock: {
                init(input) {
                    if (!this.canvas) {
                        this.state = 'widget';
                        this.canvas = document.createElement('canvas');
                        this.canvas.classList.add('clock');
                        this.context = this.canvas.getContext('2d');
                        this.updateOutput(this.canvas);
                        this.update();
                    }
                },
                update() {
                    //this.value = new Date();

                    const width = this.context.width = this.context.canvas.clientWidth;
                    const height = this.context.height = this.context.canvas.clientHeight;
                    const radius = Math.min(width, height) / 2;

                    const dayStart = new Date();
                    dayStart.setHours(0);
                    dayStart.setMinutes(0);
                    dayStart.setSeconds(0);
                    dayStart.setMilliseconds(0);
                    const style = window.getComputedStyle(document.body);

                    const colour = style.getPropertyValue('--colour');
                    const dim = style.getPropertyValue('--dim');
                    //this.value = new Date();
                    const now = new Date()
                    const time = (now.getTime() - dayStart.getTime()) / 1000;
                    this.context.clearRect(0, 0, width, height);
                    this.context.fillStyle = colour;
                    this.context.strokeStyle = colour;
                    this.context.beginPath();
                    for (let i = 0; i < 12; ++i) {
                        const x1 = width / 2 + radius * Math.sin(i * 2 * Math.PI / 12);
                        const y1 = height / 2 - radius * Math.cos(i * 2 * Math.PI / 12);
                        this.context.moveTo(x1, y1);
                        const x2 = width / 2 + (radius - 5) * Math.sin(i * 2 * Math.PI / 12);
                        const y2 = height / 2 - (radius - 5) * Math.cos(i * 2 * Math.PI / 12);
                        this.context.lineTo(x2, y2);
                    }
                    const x2 = width / 2 + 0.8 * radius * Math.sin(time * 2 * Math.PI / 3600);
                    const y2 = height / 2 - 0.8 * radius * Math.cos(time * 2 * Math.PI / 3600);
                    this.context.moveTo(width / 2, height / 2);
                    this.context.lineTo(x2, y2);
                    const x3 = width / 2 + 0.6 * radius * Math.sin(time * 2 * Math.PI / (12 * 3600));
                    const y3 = height / 2 - 0.6 * radius * Math.cos(time * 2 * Math.PI / (12 * 3600));
                    this.context.moveTo(width / 2, height / 2);
                    this.context.lineTo(x3, y3);
                    this.context.stroke();

                    this.context.fillStyle = dim;
                    this.context.strokeStyle = dim;
                    this.context.beginPath();

                    const seconds = Math.floor(time);
                    const x1 = width / 2 + 0.95 * radius * Math.sin(seconds * 2 * Math.PI / 60);
                    const y1 = height / 2 - 0.95 * radius * Math.cos(seconds * 2 * Math.PI / 60);
                    this.context.moveTo(width / 2, height / 2);
                    this.context.lineTo(x1, y1);
                    this.context.stroke();

                    requestAnimationFrame(() => this.update());
                }
            },

            calendar: {
                init(input) {
                    this.state = 'widget';
                    const parameters = input.replace(/\s*calendar\s*/, '');
                    const pattern = /((?<day>[0-9]{1,2})[-\/\._])?(?<month>[0-9]{1,2})[-\/\._](?<year>[0-9]{1,4})[-\/\._]/;
                    const match = parameters.match(pattern);
                    const now = new Date();
                    if (match) {
                        const day = parseInt(match.groups.day) || 1;
                        const month = parseInt(match.groups.month) || 1;
                        const year = parseInt(match.groups.year) || now.getFullYear();
                        this.calendarDate = new Date(Year < 2000 ? year + 2000 : year, month - 1, day);
                    } else {
                        this.calendarDate = now;
                    }

                    if (this.output.size === 0) {
                        const calendarWidget = document.createElement('div');
                        calendarWidget.classList.add('calendar');

                        const previousMonth = document.createElement('span');
                        previousMonth.innerHTML = '&lt;';
                        previousMonth.classList.add('calendar-day');
                        calendarWidget.appendChild(previousMonth);
                        previousMonth.addEventListener('click', (event) => {
                            this.calendarDate.setMonth(this.calendarDate.getMonth() - 1);
                            update()
                        });

                        const monthName = document.createElement('span');
                        monthName.classList.add('calendar-month-name');
                        calendarWidget.appendChild(monthName);

                        const nextMonth = document.createElement('span');
                        nextMonth.innerHTML = '&gt;';
                        nextMonth.classList.add('calendar-day');
                        calendarWidget.appendChild(nextMonth);
                        nextMonth.addEventListener('click', (event) => {
                            this.calendarDate.setMonth(this.calendarDate.getMonth() + 1);
                            update()
                        });

                        'SMTWTFS'.split('').forEach((c) => {
                            const day = document.createElement('span');
                            day.classList.add('calendar-day');
                            day.innerHTML = c;
                            calendarWidget.appendChild(day);
                        });
                        const days = [];
                        for (let i = 0; i < 42; ++i) {
                            const day = document.createElement('span');
                            day.classList.add('calendar-day');
                            calendarWidget.appendChild(day);
                            days.push(day);
                        }

                        const update = () => {
                            const today = new Date();
                            monthName.innerHTML = this.calendarDate.toLocaleDateString('en-AU', { month: 'long' });
                            const month = this.calendarDate.getMonth();
                            const year = this.calendarDate.getFullYear();
                            const date = new Date(year, month, 1);
                            date.setDate(date.getDate() - date.getDay());
                            const end = new Date(year, month + 1, 0);
                            end.setDate(end.getDate() + 7 - end.getDay());
                            days.forEach((day) => {
                                if (sameDay(today, date)) {
                                    day.classList.add('calendar-day-today');
                                } else {
                                    day.classList.remove('calendar-day-today');
                                }
                                if (date.getMonth() === month) {
                                    day.classList.remove('calendar-day-fade');
                                } else {
                                    day.classList.add('calendar-day-fade');
                                }
                                if (date < end) {
                                    day.innerHTML = ('' + date.getDate()).padStart(2, '0');
                                } else {
                                    day.innerHTML = '';
                                }
                                date.setDate(date.getDate() + 1);
                            });
                        }
                        update();
                        this.updateOutput(calendarWidget);
                    }
                }
            },
            text: {
                setContent(content) {
                    this.value = this.content = content;
                },
                init(string, cells, parameters) {
                    if (named.files[parameters[0]]) {
                        load(this, parameters[0], (content) => {
                            this.value = content;
                            this.update();
                        });
                    } else {
                        this.content = cells.map((cell) => cell.value).join('\n');
                    }
                },
                getResultNode() {
                    return document.createElement('pre');
                },
                update() {
                    this.view.result.innerHTML = this.value;
                }
            },
            replace: {
                init() {
                    const parameters = this.text.replace(/^\s*<[^>]+>[:#=]\s*/).replace(/^replace\s*/, '');
                    if (parameters) {
                        const link = (from, to) => {
                            from.output.add(to);
                            to.input.add(from);
                        };
                        const args = getList(parameters);
                        const { cells, values } = args.reduce((results, value) => {
                            const index = Number(value);
                            if (app.namedCells[value] !== undefined) {
                                results.cells.push(app.namedCells[value]);
                                link(app.namedCells[value], this);
                            } else if (!isNaN(index) && index > -app.cells.length && index < app.cells.length) {
                                results.cells.push(app.cells.at(index));
                                link(app.cells.at(index), this);
                            } else {
                                results.values.push(value);
                            }
                            return results;
                        }, { cells: [], values: [] });
                        this.cells = cells;
                        this.pattern = values[0];
                        this.replacement = values[1];
                    }

                    const dynamicUpdate = (event) => {
                        if (this.dynamic.checked) {
                            this.update();
                        }
                    }
                    const update = (event) => {
                        this.update();
                    }


                    if (this.output.size === 0) {
                        const pattern = new Control();
                        this.pattern = document.createElement('input');
                        this.pattern.type = 'text';
                        pattern.content.append('Pattern: ', this.pattern);
                        this.pattern.addEventListener('input', (event) => dynamicUpdate(event));
                        this.pattern.addEventListener('change', (event) => this.update());
                        this.output.add(pattern);

                        const replacement = new Control();
                        this.replacement = document.createElement('input');
                        this.replacement.type = 'text';
                        replacement.content.append('Replacement ', this.replacement);
                        this.replacement.addEventListener('input', (event) => dynamicUpdate(event));
                        this.replacement.addEventListener('change', (event) => this.update());
                        this.output.add(replacement);

                        this.controls = new Control();
                        this.dynamic = document.createElement('input');
                        this.dynamic.type = 'checkbox';
                        this.dynamic.checked = 'true';

                        const update = document.createElement('button');
                        update.innerText = 'Update';
                        update.addEventListener('click', (event) => this.update());
                        this.controls.content.append('Dynamic: ', this.dynamic, update);
                        this.output.add(this.controls);

                        this.after(pattern, replacement, this.controls);
                    }
                },
                update() {
                    const input = getSource(this);
                    input.forEach((cell) => this.input.add(cell));
                    const text = input.map((cell) => cell.text).join('\n');

                    try {
                        const pattern = new RegExp(this.pattern.value, 'g');
                        const replacement = this.replacement.value;
                        const result = text.replace(pattern, replacement);
                        this.controls.updateTextOutput(result);
                    } catch (error) {
                        this.controls.updateTextOutput(error.message);
                    }
                    saveState();
                },
                getSettings() {
                    return {
                        pattern: this.patternNode?.value,
                        replacement: this.replacementNode?.value,
                        live: this.dynamicUpdate?.checked,
                    };
                },
                setSettings(settings) {
                    this.pattern = settings.pattern;
                    this.replacement = settings.replacement;
                    this.live = settings.live;
                },
            },
            todo: {
                defaultState: 'widget',
                init(input) {
                    const string = input.replace(/^\s*todo\s*/, '');
                    this.todo = new ToDo(string);
                    this.update();
                },
                update() {
                    const output = this.getOutput();
                    output.innerHTML = `<span class="raised">${this.todo.raised.toDateString()}</span><br><span class="details">${this.todo.detail}</span>`;
                    if (this.todo.done) {
                        output.innerHTML += `<br><span class="done">${this.todo.done.toDateString()}</span>`;
                    }
                    if (!this.checkbox) {
                        this.checkbox = document.createElement('input');
                        this.checkbox.type = 'checkbox';
                        this.checkbox.classList.add('top-right');
                        this.checkbox.checked = this.todo.done;
                        this.checkbox.addEventListener('change', (event) => {
                            if (this.checkbox.checked) {
                                this.todo.complete();
                            } else {
                                this.todo.done = null;
                                app.notifyListeners('todos', { action: 'uncomplete', todo: this });
                            }
                            this.update();
                        });
                    }
                    output.appendChild(this.checkbox);
                    output.classList.add('todo');
                    if (this.checkbox.checked) {
                        output.classList.add('done');
                    } else {
                        output.classList.remove('done');
                    }
                }
            },
            todos: {
                defaultState: 'floating',
                init(input) {
                    const string = input.replace(/^\s*todo\s*/, '');
                    app.addListener('todos', this);
                    this.update();
                },
                update() {
                    const todos = app.types.get(ToDo) || [];
                    this.getOutput().innerHTML = '<ul>' + todos.map((todo) => `<li>${todo.toShortHTML()}</li>`).join('') + '</ul>';
                }
            },
            table: {
                init(input) {
                    const inputs = getSource(this);
                    inputs.forEach((input) => this.input.add(input));

                    if (this.table) {
                        this.table.setContent(inputs.map((cell) => cell.content.innerText));
                    } else {
                        this.table = new Table(inputs.map((cell) => cell.content.innerText));
                        this.updateOutput(this.table.content);
                    }
                },
                update() {
                },
            },
            'working days': {
                init(input) {
                    const eventNames = Object.keys(named.dates);
                    eventNames.sort((a, b) => a.localeCompare(b));
                    if (this.output.size === 0) {
                        const from = new Control();
                        const to = new Control();
                        this.output.add(from);
                        this.output.add(to);
                        const controls = {};

                        controls.update = function (event) {
                            const eventNames = Object.keys(named.dates);
                            eventNames.sort((a, b) => a.localeCompare(b));

                            if (this.fromEvent.value === 'Custom Date') {
                                this.from.disabled = false;
                            } else if (this.fromEvent.value === 'Today' || named.dates[this.toEvent.value]) {
                                this.from.disabled = true;
                                const date = this.fromEvent.value === 'Today' ? new Date() : named.dates[this.toEvent.value].value;
                                this.from.value = `${date.getFullYear()}-${(date.getMonth() + 1 + '').padStart(2, '0')}-${(date.getDate() + '').padStart(2, '0')}`;
                            }

                            const fromEvent = this.fromEvent.value;
                            this.fromEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                            this.fromEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                            this.fromEvent.value = fromEvent;

                            if (this.toEvent.value === 'Custom Date') {
                                this.to.disabled = false;
                            } else if (this.toEvent.value === 'Today' || named.dates[this.toEvent.value]) {
                                this.to.disabled = true;
                                const date = this.toEvent.value === 'Today' ? new Date() : named.dates[this.toEvent.value].value;
                                this.to.value = `${date.getFullYear()}-${(date.getMonth() + 1 + '').padStart(2, '0')}-${(date.getDate() + '').padStart(2, '0')}`;
                            }

                            const toEvent = this.toEvent.value;
                            this.toEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                            this.toEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                            this.toEvent.value = toEvent;

                            if (this.from.value && this.to.value) {
                                if (!this.output) {
                                    this.output = [new Output(to.index + 1)];
                                    to.after(this.output[0]);
                                }
                                this.output[0].content.innerHTML = calendar.workingDays(this.from.value, this.to.value);
                            }
                        }

                        app.addListener('dates', controls);

                        from.content.append('From: ')
                        controls.fromEvent = document.createElement('select');
                        controls.fromEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                        controls.fromEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                        from.content.appendChild(controls.fromEvent);

                        controls.from = document.createElement('input');
                        controls.from.type = 'date';
                        from.content.appendChild(controls.from);

                        controls.from.addEventListener('change', (event) => controls.update(event));
                        controls.fromEvent.addEventListener('change', (event) => controls.update(event));

                        to.content.append('To: ')
                        controls.toEvent = document.createElement('select');
                        controls.toEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                        controls.toEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                        to.content.appendChild(controls.toEvent);

                        controls.to = document.createElement('input');
                        controls.to.type = 'date';
                        to.content.appendChild(controls.to);

                        controls.to.addEventListener('change', (event) => controls.update(event));
                        controls.toEvent.addEventListener('change', (event) => controls.update(event));

                        this.after(from, to);
                    }
                },

            },
            'tree table': {
                setData() {
                    this.keys = [];
                    this.all = this.data.flatMap((item) => Array.from(flatten(item)));
                    this.all.forEach((node) => this.keys.push(...Object.keys(node).filter((key) => !(this.keys.includes(key)))));
                    this.rows = this.all.map((row) => ({ size: 'minmax(1em, max-content)' }));
                    this.cols = this.keys.map((key) => ({ size: 'minmax(min-content, max-content)' }));
                    this.model = new Map();
                    const model = this.model;
                    this.all.forEach((node) => this.model.set(node, modelNode(node)));
                },
                setContent(content) {
                    this.data = this.deserialiseContent(content);
                    this.setData();
                },
                linesToTree() {
                    // Check for indented lines
                    const lines = this.data.map((line) => line.split(/\s*[,\|;\t]\s*/g))
                    const indents = lines.map((line) => line[0].length - line[0].trimStart().length);
                    this.data = [];
                    if (indents.some((indent) => indent !== indent[0])) {
                        const stack = [];
                        const indent = (line) => line[0].length - line[0].trimStart().length;
                        lines.forEach((line) => {
                            while (stack.length && indent(stack[0]) >= indent(line)) {
                                stack.shift();
                            }
                            if (stack.length) {
                                stack[0][meta].parts.push(line);
                            } else {
                                this.data.push(line);
                            }
                            line[meta] = { parts: [] };
                            stack.unshift(line);
                        });
                        lines.forEach((line) => line[0] = line[0].trim());
                    } else {
                        // Assume line starts with 'path' string
                        lines.sort((a, b) => b[0].length - a[0].length);
                        lines.forEach((line) => {
                            const parent = lines.findLast((parent) => parent[0] !== line[0] && line[0].startsWith(parent[0]));
                            if (parent) {
                                parent[meta] = parent[meta] || { parts: [] };
                                parent[meta].parts.push(parent);
                            } else {
                                this.data.push(line);
                            }
                        });
                        this.data.sort((a, b) => a[0].localeCompare(b[0]));
                    }
                },
                init(string) {
                    const inputs = getSource(this);
                    inputs.forEach((input) => this.input.add(input));
                    this.data = inputs.map((input) => input.content.innerText);

                    this.linesToTree();
                    this.setData();
                    this.deleted = [];

                    const tree = {
                        content: this.data,
                        all: this.all,
                        cols: this.cols,
                        rows: this.rows,
                        keys: this.keys,
                        model: this.model,
                    }
                    if (this.tree) {
                        this.tree.setContent(tree);
                    } else {
                        this.tree = new TreeTable(tree);
                        this.updateOutput(this.tree.content);
                    }
                }
            },
            'make tree': {
                init(string, cells = [], parameters) {
                    if (cells.length === 0) {
                        cells = [app.cells.at(-1)];
                    }
                    this.input = cells.map((cell) => cell.value).join('');

                    const lines = this.input.split(/\r?\n/g).filter((line) => line.trim() !== '')
                        .map((line) => line.split(/\t/g).map((item) => item.trim()));

                    const headers = lines.shift();
                    const items = lines.map((line) => line.reduce((item, value, index) => {
                        item[headers[index]] = value;
                        return item;
                    }, { [meta]: {} }));

                    // Assume the first col contains id
                    const sorted = items.sort((a, b) => b[headers[0]].length - a[headers[0]].length);
                    sorted.forEach((item) => {
                        item[meta].parts = sorted.filter((other) => (other[meta].parent === undefined) && (other[headers[0]].length > item[headers[0]].length) && other[headers[0]].startsWith(item[headers[0]]));
                        item[meta].parts.forEach((part) => part[meta].parent = item);
                    });
                    this.value = sorted.filter((item) => item[meta].parent === undefined);
                },
                update() {
                    this.view.result.innerHTML = `<pre>${JSON.stringify(this.value, null, 2)}</pre>`;
                }
            },
            'current cell': {
                init(input) {
                    app.events.currentCellChange.add(this);
                },
                update() {
                    const lines = [];
                    lines.push(`${app.currentCell?.raw}`);
                    if (app.currentCell) {
                        for (const input of app.currentCell.input) {
                            lines.push(`${input.index} ${input.name} --> ${app.currentCell.index} ${app.currentCell.name}`);
                        }
                        for (const output of app.currentCell.output) {
                            lines.push(`${app.currentCell.index} ${app.currentCell.name} --> ${output.index} ${output.name}`);
                        }
                    }
                    const output = this.getOutput();
                    output.innerHTML = lines.join('<br>');
                }
            },
            windows: { // Display dynamic list of windows
                init(input) {
                    app.events.layoutChange.add(this);
                },
                getResultNode() {
                    const resultNode = document.createElement('div');
                    resultNode.classList.add('result', 'table');
                    resultNode.style.gridTemplateColumns = 'repeat(7, minmax(min-content, 1fr))';
                    return resultNode;
                },
                update() {
                    const output = this.getOutput();
                    output.innerHTML = '';
                    const windows = app.cells.filter((cell) => cell.view?.cell?.classList.contains('floating'));
                    const makeSpan = (text) => {
                        const node = document.createElement('span');
                        node.innerText = text;
                        node.classList.add('table-cell');
                        return node;
                    }
                    windows.forEach((cell) => {
                        const box = cell.view.cell.getBoundingClientRect();
                        output.appendChild(makeSpan(`${cell.index}:`));
                        output.appendChild(makeSpan(cell.name || ''));
                        output.appendChild(makeSpan(cell.command));
                        output.appendChild(makeSpan(box.x));
                        output.appendChild(makeSpan(box.y));
                        output.appendChild(makeSpan(box.width));
                        output.appendChild(makeSpan(box.height));
                    });
                },
            },
            messages: { // Display dynamic list of messages
                init(input) {
                    app.events.statusChange.add(this);
                    this.update();
                },
                update() {
                    this.getOutput().innerHTML = app.statusHistory.join('<br>');
                },
            }
        }


        function copyStylesInline(destinationNode, sourceNode) {
            var containerElements = ["svg", "g"];
            for (var cd = 0; cd < destinationNode.childNodes.length; cd++) {
                var child = destinationNode.childNodes[cd];
                if (containerElements.indexOf(child.tagName) != -1) {
                    copyStylesInline(child, sourceNode.childNodes[cd]);
                    continue;
                }
                var style = sourceNode.childNodes[cd].currentStyle || window.getComputedStyle(sourceNode.childNodes[cd]);
                if (style == "undefined" || style == null) continue;
                for (var st = 0; st < style.length; st++) {
                    child.style.setProperty(style[st], style.getPropertyValue(style[st]));
                }
            }
        }

        // https://stackoverflow.com/questions/3975499/convert-svg-to-image-jpeg-png-etc-in-the-browser
        const dataHeader = 'data:image/svg+xml;charset=utf-8';

        const loadImage = async url => {
            const img = document.createElement('img');
            img.src = url;
            return new Promise((resolve, reject) => {
                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        }

        const serializeAsXML = (e) => (new XMLSerializer()).serializeToString(e);

        const encodeAsUTF8 = (str) => `${dataHeader},${encodeURIComponent(str)}`;
        const encodeAsB64 = (str) => `${dataHeader};base64,${btoa(str)}`;

        /**
         * Extract SVG data and paste image to canvas to download
         */
        const convertSVGtoImg = async (svg, filename, format = 'png') => {
            const copy = svg.cloneNode(true);
            copyStylesInline(copy, svg);
            const svgData = encodeAsUTF8(serializeAsXML(copy));

            const img = await loadImage(svgData);

            const canvas = document.createElement('canvas');
            canvas.width = svg.clientWidth;
            canvas.height = svg.clientHeight;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgb(240, 248, 255)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.drawImage(img, 0, 0, svg.clientWidth, svg.clientHeight);

            const dataURL = await canvas.toDataURL(`image/${format}`, 1.0);
            triggerDownload(dataURL, filename);
        }

        /**
         * Create link and click it to trigger download
         */
        function triggerDownload(imgURI, fileName) {
            const event = new MouseEvent('click', {
                view: window,
                bubbles: false,
                cancelable: true
            });
            const link = document.createElement('a');
            link.setAttribute('download', fileName);
            link.setAttribute('href', imgURI);
            link.setAttribute('target', '_blank');
            link.dispatchEvent(event);
        }

        const app = {
            store: {},
            context: {},
            loaded: false,
            content: [''],
            activeEditor: null,
            editors: [],
            line: 0,
            char: 0,
            history: [],
            saveCommand(command) {
                this.history.push(command);
                this.historyIndex = this.history.length;
                this.historyChange();
            },
            cells: [],
            namedCells: {},
            managedTypes: [ToDo],
            types: new Map(),
            addTyped(item) {
                this.managedTypes.forEach((type) => {
                    if (item instanceof type) {
                        const list = this.types.get(type);
                        if (list) {
                            list.push(item);
                        } else {
                            this.types.set(type, [item]);
                        }
                    }
                });
            },
            index: 0,
            events: {
                historyChange: new Set(),
                layoutChange: new Set(),
                statusChange: new Set(),
                currentCellChange: new Set(),
            },
            historyChange() {
                this.events.historyChange.forEach((cell) => cell.update());
            },
            layoutChange() {
                for (const cell of this.events.layoutChange) {
                    cell.update();
                }
            },
            statusChange() {
                for (const cell of this.events.statusChange) {
                    cell.update();
                }
            },
            listeners: new Map(),
            addListener(event, listener) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).push(listener);
                } else {
                    this.listeners.set(event, [listener]);
                }
            },
            notifyListeners(event, detail) {
                const listeners = this.listeners.get(event) || [];
                listeners.forEach((listener) => listener.update(detail));
            },
            setCurrentCell(cell) {
                if (this.currentCell !== cell) {
                    this.currentCell = cell;
                    for (const cell of this.events.currentCellChange) {
                        cell.update();
                    }
                    for (const node of document.querySelectorAll('.input')) {
                        node.classList.remove('source');
                    }
                    for (const node of document.querySelectorAll('.sink')) {
                        node.classList.remove('sink');
                    }
                    if (cell) {
                        for (const input of cell.input) {
                            input.content.classList.add('source');
                        }
                        for (const output of cell.output) {
                            output.content.classList.add('sink');
                        }
                        app.setStatus(`${cell.name || ''}: ${cell.raw}`);
                    }

                }
            },
            state: {},
            mermaidCount: 0,
            setPrompt(prompt) {
                let node = document.getElementById('prompt');
                if (!node) {
                    currentLine = currentLine || nodes.at(-1);
                    node = document.createElement('span');
                    node.id = 'prompt';
                    currentLine.lineNumber.appendChild(node);
                }
                node.innerHTML = prompt;
            },
            status: [],
            statusHistory: [],
            setStatus(text, timeout = 3) {
                if (text === undefined || text.trim() == '') {
                    return;
                }
                this.statusHistory.push(text);
                this.status.push(text);

                const statusNode = document.getElementById('status');
                statusNode.innerHTML = this.status.join('<br>');
                statusNode.classList.remove('fade');
                const remove = () => {
                    const pos = this.status.indexOf(text);
                    this.status.splice(pos, 1);
                    if (this.status.length < 1) {
                        statusNode.classList.add('fade');
                    } else {
                        statusNode.innerHTML = this.status.join('<br>');
                    }
                }
                app.timeout = setTimeout(remove, timeout * 1000);
                this.statusChange();
            }
        };

        const start = 0;
        const content = [];
        let nodes = [new Text(1)];
        workspaceNode.append(nodes[0].lineNumber, nodes[0].content);
        const global = {};
        let cellIndex = 0;
        let currentLine = nodes[cellIndex];

        app.setPrompt('Load previous state (Y/n)');
        addMainEventListeners();
        app.processKey = (event, line) => {
            if (event.key !== 'n') {
                loadState();
            }
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
            app.processKey = null;
            app.loaded = true;
            app.setPrompt('');
        };



        /**
         * Update dynamic cells of display
         */
        function update(time) {
            window.requestAnimationFrame(update);
        }
        //update();

        /**
         * Return the predefined functions passed to expressions
         */
        function getPredefined() {
            const predefined = {
                names: [],
                values: [],
            };
            Object.getOwnPropertyNames(Math).forEach((prop) => {
                predefined.names.push(prop);
                predefined.values.push(Math[prop]);
            });
            Object.getOwnPropertyNames(calendar).forEach((prop) => {
                predefined.names.push(prop);
                predefined.values.push(calendar[prop]);
            });
            return predefined;
        }

        const Status = Symbol('status');

        /**
         * Evaluate an input string
         * 
         * <name>[:#=] command parameters
         */
        function evaluate(raw) {
            /*
            {
                const command = any(commands);
                const name = repeat(any('abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_ '));
                const type = any(':#=}');
                const named = sequence('<', name, '>', optional(type));
                const args = sequence(name, repeat(sequence(', ', named)));
                const commandLine = sequence(optional(named), command, args);
            }
            */
            const result = {};

            const cell = new Cell_old(raw);
            const namePattern = /^\s*<([^>]+)>([:#=])\s*/;
            cell.name = raw.match(namePattern)?.[1];
            const command = {
                ':': 'notes',
                '#': 'table',
                '=': 'evaluate',
                undefined: raw.replace(namePattern, ''),
            }[raw.match(namePattern)?.[2]];
            cell.command = command;

            if (actions[command]) {
                return actions[command](raw) ?? cell;
            } else {
                const commands = Object.getOwnPropertyNames(actions).sort((a, b) => b.length - a.length);
                const match = commands.find((match) => command.startsWith(match));
                if (match) {
                    return actions[match](raw) ?? cell;
                }
            }

            const cellTypeNames = Object.getOwnPropertyNames(cellTypes).sort((a, b) => b.length - a.length);
            const cellTypeMatch = cellTypeNames.find((match) => command.startsWith(match));
            if (0 && cellTypeMatch) {
                Object.assign(cell, cellTypes[cellTypeMatch]);
                const pattern = new RegExp(`^\\s*${cellTypeMatch}\\s*`);
                const string = cell.raw.replace(pattern, '');

                const args = getList(string);
                const { cells, values } = args.reduce((results, value) => {
                    const index = Number(value);
                    if (app.namedCells[value] !== undefined) {
                        results.cells.push(app.namedCells[value]);
                    } else if (!isNaN(index) && index > -app.cells.length && index < app.cells.length) {
                        results.cells.push(app.cells.at(index));
                    } else {
                        results.values.push(value);
                    }
                    return results;
                }, { cells: [], values: [] });

                cell.init(string, cells, values);
                result.cell = cell;
                return result;
            }
            if (named.all[command]) {
                named.all[command].eval(cell);
                result.cell = cell;
                return result;
            }
            const getIndex = (str) => isNaN(parseInt(str)) ? -1 : parseInt(str) % app.cells.length;
            const link = (from, to) => {
                from.output.add(to);
                to.input.add(from);
            };
            const expr = command.replace(/^\\/, '')
                .replace(/<(-?[^>]*)>/g, (match, name) => {
                    if (app.namedCells[name]?.value !== undefined) {
                        link(app.namedCells[name], cell);
                        return `app.namedCells['${name}''].value`;
                    } else if (named.all[name] !== undefined) {
                        return `named['${name}']`;
                    } else if (app.cells.at(getIndex(name)) !== undefined) {
                        link(app.cells.at(getIndex(name)), cell);
                        return `app.cells.at(${getIndex(name)}).value`;
                    }
                    return match;
                });
            const references = [];
            const resolved = command.replace(/^\\/, '').replace(/<(-?[0-9]*)>/g, (match, index) => {
                const referenced = app.cells.at(getIndex(index));
                referenced.output.add(cell);
                cell.input.add(referenced);
                return `${referenced.value}`;
            });
            cell.update = () => {
                const predefined = getPredefined();
                try {
                    if (app.action) {
                        const func = new Function('app', ...predefined.names, 'named', `return app.action(${expr})`);
                    }
                    const func = new Function('app', ...predefined.names, 'named', `return ${expr}`);

                    cell.value = func(app, ...predefined.values, named.all);
                } catch (error) {
                    cell.value = error.message;
                }
                if (cell.action) {
                    app.action === cell.action();
                }
            }
            cell.update();

            result.cell = cell;
            return result;
        }

        /**
         * Add the results to the output
         */
        function showCell(cell, index) {
            const resultsNode = document.getElementById('results');

            cell.makeView();

            cell.view.index.innerHTML = `${index}: `;

            resultsNode.appendChild(cell.view.cell);
            if (cell.defaultState) {
                cell.setState(cell.defaultState);
            }
            cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
            app.show = () => cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
        }

        /**
         * Add a cell to the session
         */
        function addCell(cell) {
            showCell(cell, app.cells.length);
            app.namedCells[cell.name] = cell;
            app.cells.push(cell);
            if (cell.update) {
                cell.update();
            }
            app.setPrompt(cell.prompt);
            if (cell.focus) {
                cell.focus.focus();
            }
        }

        /**
         * Process the input
         */
        function process(event) {
            if (inputNode.value !== app.history.at(-1)) {
                app.saveCommand(inputNode.value);
            }
            const str = (app.cellIndex === app.cells.length && inputNode.value === '') ? app.cells.at(-1).raw : inputNode.value;
            app.interactive = true;
            const result = evaluate(str);
            app.interactive = false;

            if (result.message) {
                app.setStatus(result.messgae);
            }
            if (result.cell) {
                addCell(result.cell);
            }

            app.events.historyChange.forEach((cell) => cell.update());

            if (event.ctrlKey && (app.historyIndex < (app.cells.length - 1))) {
                app.historyIndex += 1;
                inputNode.value = app.history.at(app.historyIndex).raw;
            } else {
                app.historyIndex = app.history.length;
                inputNode.value = '';
            }
            saveState();
            inputNode.removeAttribute('list');
        }


        /**
         * Previous command
         */
        function previousCommand(event) {
            if (app.historyIndex === app.history.length) {
                app.draft = inputNode.value;
            }
            app.historyIndex -= 1;
            if (app.historyIndex < 0) {
                app.historyIndex = app.history.length;
                inputNode.value = app.draft;
            }
            if (event.ctrlKey) {
                const command = app.history[app.historyIndex];
                const start = inputNode.selectionStart;
                const end = inputNode.selectionEnd ?? start;
                inputNode.value = inputNode.value.slice(0, start) + command + inputNode.value.slice(end);
                inputNode.setSelectionRange(start, start + command.length);
            } else {
                inputNode.value = app.history[app.historyIndex];
            }
        }


        /**
         * Previous command
         */
        function nextCommand(event) {
            if (app.historyIndex === app.history.length) {
                app.draft = inputNode.value;
            }
            app.historyIndex = app.historyIndex += 1;
            if (event.ctrlKey) {
                app.historyIndex %= app.history.length;
                const command = app.history[app.historyIndex];
                const start = inputNode.selectionStart;
                const end = inputNode.selectionEnd ?? start;
                inputNode.value = inputNode.value.slice(0, start) + command + inputNode.value.slice(end);
                inputNode.setSelectionRange(start, start + command.length);
            } else {
                app.historyIndex %= (app.history.length + 1);
                if (app.historyIndex === app.history.length) {
                    inputNode.value = app.draft;
                } else {
                    inputNode.value = app.history[app.historyIndex];
                }
            }
        }


        /**
         * Save the current state to local storage
         */
        function saveState() {
            if (app.save) {
                const state = { app, named };
                const stateString = JSON.stringify(state);
                localStorage.setItem('noia-state', stateString);
            }
        }

        /**
         * Reload the state from local storage
         */
        function reloadCells(state) {
            state.app = state.app ?? state.context;

            state.app.cells.filter((cell) => cell && cell.raw).forEach((storedCell) => {
                const result = evaluate(storedCell.raw);
                const cell = result.cell;
                if (cell) {
                    if (storedCell.content) {
                        if (cell.setContent) {
                            cell.setContent(storedCell.content);
                        } else {
                            cell.content = storedCell.content;
                        }
                    }
                    if (storedCell.settings) {
                        cell.setSettings(storedCell.settings);
                    }

                    cell.timestamp = new Date(storedCell.timestamp);
                    if (cell.type === Status) {
                        app.setStatus(cell.value);
                    } else {
                        showCell(cell, app.cells.length);
                        app.cells.push(cell);
                        app.namedCells[cell.name] = cell;
                        if (storedCell.view) {
                            cell.setState(storedCell.view.state);
                            if (storedCell.view.box) {
                                cell.view.cell.style.left = `${storedCell.view.box.x}px`;
                                cell.view.cell.style.top = `${storedCell.view.box.y}px`;
                                cell.view.cell.style.width = `${Math.max(storedCell.view.box.width, 100)}px`;
                                cell.view.cell.style.height = `${Math.max(storedCell.view.box.height, 100)}px`;
                            }
                            if (storedCell.view.modes) {
                                storedCell.view.modes.forEach((mode) => cell.setMode(mode));
                            }
                        }
                    }
                    if (cell.update) {
                        cell.update();
                    }
                }
            });
        }

        /**
         * Reload the state from local storage
         */
        function restoreState(state) {
            state.app = state.app ?? state.context;
            app.cellIndex = app.cells.length;
            const currentIndex = Array.from(document.querySelectorAll('.line-number')).at(-1);
            currentIndex.innerHTML = app.cells.length;
            app.events.historyChange.forEach((cell) => cell.update());
            Object.assign(app.state, state.app.state);
            if (app.state.theme) {
                document.documentElement.setAttribute('data-theme', app.state.theme);
            }
            if (app.state.background) {
                document.body.style.backgroundImage = `url("${app.state.background}")`;
            }
            app.history.push(...state.app.history);
            app.historyIndex = app.history.length;
            app.historyChange();

            const savedLines = localStorage.getItem('noia-lines');
            if (savedLines) {
                parseLines(JSON.parse(savedLines));
            }

            if (nodes.length === 0) {
                nodes.push(new Text(1));
            }

            updateLineNumbers();
            workspaceNode.focus();
            cellIndex = nodes.length - 1;
            currentLine = nodes[cellIndex];
            currentLine.show();
            document.getSelection().setPosition(currentLine.content, 0);
            currentLine.content.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
        }

        /**
         * Reload the state from local storage
         */
        function loadState() {
            const stateStr = localStorage.getItem('noia-state');
            if (stateStr) {
                app.save = false;
                const state = JSON.parse(stateStr);
                restoreState(state);
                app.save = true;
            }
            //inputNode.focus();
        }

        (function loadFileList() {
            const request = window.indexedDB.open('NoaiDatabase', 1);

            // Handle a failure
            request.onerror = (event) => {
                console.error(`Database error: ${event.target.error?.message}`);
            };

            // save the files
            request.onsuccess = (event) => {
                const db = event.target.result;

                if (db.objectStoreNames.contains('files')) {
                    const transaction = db.transaction(['files']);
                    const objectStore = transaction.objectStore('files');
                    const request = objectStore.getAll();
                    request.onerror = (event) => {
                        console.error(`Database error: ${event.target.error?.message}`);
                    };
                    request.onsuccess = async (event) => {
                        event.target.result.forEach((file) =>
                            named.files[file.name] = file.handle);
                    };
                }
            };

            request.onupgradeneeded = (event) => {
                // Save the IDBDatabase interface
                const db = event.target.result;

                // Create an objectStore for this database
                const objectStore = db.createObjectStore('files', { keyPath: 'name' });
            };
        })();

        /**
         * Check the permissions for the file to load
         */
        async function verifyPermission(fileHandle, readWrite) {
            const options = {};
            if (readWrite) {
                options.mode = 'readwrite';
            }
            // Check if permission was already granted. If so, return true.
            if ((await fileHandle.queryPermission(options)) === 'granted') {
                return true;
            }
            // Request permission. If the user grants permission, return true.
            if ((await fileHandle.requestPermission(options)) === 'granted') {
                return true;
            }
            // The user didn't grant permission, so return false.
            return false;
        }

        /**
         * Load a file from a handle in an indexeddb database
         */
        async function load(cell, filename, process) {
            if (named.files[filename]) {
                const handle = named.files[filename];
                if (await verifyPermission(handle)) {
                    const file = await handle.getFile();
                    const content = await file.text();
                    if (process) {
                        process(content);
                    } else {
                        cell.content = content;
                    }
                } else {
                    console.log('Permission not granted for file :(');
                }
            }
        }

        /**
         * Save the value of a cell to a file
         */
        async function save(cell, filename) {
            if (named.files[filename]) {
                const handle = named.files[filename];
                if (verifyPermission(handle, true)) {
                    const file = await handle.getFile();
                    if (process) {
                        process(contents);
                    }
                } else {
                    console.log('Permission not granted for file :(');
                }
            }
        }


        /**
         * Save a list of file handles to a indexeddb database
         */
        function saveFileHandles(files) {
            // Open the database
            const request = window.indexedDB.open('NoaiDatabase', 1);

            // Handle a failure
            request.onerror = (event) => {
                console.error(`Database error: ${event.target.error?.message}`);
            };

            // save the files
            request.onsuccess = (event) => {
                const db = event.target.result;

                const transaction = db.transaction(['files'], 'readwrite');
                // Do something with request.result!
                // Do something when all the data is added to the database.
                transaction.oncomplete = (event) => {
                    console.log('All done!');
                };

                transaction.onerror = (event) => {
                    // Don't forget to handle errors!
                };

                const fileHandleStore = transaction.objectStore('files');
                files.forEach((file) => {
                    named.files[file.name] = file.handle;
                    const request = fileHandleStore.put(file);
                    request.onsuccess = (event) => {
                        console.log(`stored handle for ${file.name}`);
                    };
                    request.onerror = (event) => {
                        console.log(`Database error: ${event.target.error?.message}`);
                    };
                });
            };

            request.onupgradeneeded = (event) => {
                // Save the IDBDatabase interface
                const db = event.target.result;

                // Create an objectStore for this database
                const objectStore = db.createObjectStore('files', { keyPath: 'name' });

                // Use transaction oncomplete to make sure the objectStore creation is
                // finished before adding data into it.
                objectStore.transaction.oncomplete = (event) => {
                    // Store values in the newly created objectStore.
                    const fileHandleStore = db
                        .transaction('files', 'readwrite')
                        .objectStore('files');
                    files.forEach((file) => {
                        fileHandleStore.add(file);
                    });
                };
            };
        }


        function dropHandler(event) {
            event.preventDefault();

            function loadFile(file) {
                const reader = new FileReader();
                reader.addEventListener('load', (event) => {
                    insertBefore(file.name, currentLine);
                    insertBefore(reader.result, currentLine);
                    currentLine.content.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
                });
                reader.readAsText(file);
                //saveState();
            }

            if (event.dataTransfer.items) {
                [...event.dataTransfer.items].forEach((item, index) => {
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        loadFile(file);
                        item.getAsFileSystemHandle().then((handle) => {
                            saveFileHandles([{ name: file.name, handle }]);
                        });
                    }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
            }
        }

        function dragOverHandler(event) {
            // Prevent default behavior (Prevent file from being opened)
            event.preventDefault();
        }

        /**
         * Process a key press in the input box
         */
        function processInputBoxKey(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                app.context.at(-1).process(event);
            }
            if (event.key === 'ArrowUp') {
                event.preventDefault();
                cursorUp(event);
            }
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                cursorDown(event);
            }
            if (event.target.value) {
                const list = document.getElementById('named-items');
                event.target.setAttribute('list', 'named-items');
            }
        }


        //const results = document.getElementById('results');
        workspaceNode.addEventListener('dragover', dragOverHandler);
        workspaceNode.addEventListener('drop', dropHandler);
        //results.addEventListener('drop', dragOverHandler);
        //results.addEventListener('drop', dropHandler);

        workspaceNode.focus();


        //inputNode.addEventListener('keydown', processInputBoxKey);

        /*
        results.addEventListener('click', (event) => {
            if (event.target === results) {
                //inputNode.focus();
            }
        });
        */
        //inputNode.focus();

        /**
         * Return the line element of the current line
         */
        function getCurrentLine() {
            const selection = document.getSelection();
            if (selection.getRangeAt && selection.rangeCount) {
                const range = selection.getRangeAt(0);
                const element = range.startContainer.closest ? range.startContainer : range.startContainer.parentElement;
                return element.closest('.line,.control,.output');
            }
        }

        /**
         * Return the cell for the current line.
         */
        function getCurrentCell() {
            const line = getCurrentLine();
            if (line) {
                return nodes.find((node) => node.content === line);
            }
        }

        /**
         * Insert a line break at the selection
         */
        function breakAtCursor() {
            const selection = document.getSelection();
            if (selection.getRangeAt && selection.rangeCount) {
                const range = selection.getRangeAt(0);
                if (!range.collapsed) {
                    range.deleteContents();
                }
                if (currentLine) {
                    const indent = currentLine.content.innerText.replace(/\S.*/, '');
                    const range = selection.getRangeAt(0);
                    range.setEndAfter(currentLine.content);
                    const line = indent + range.toString().trimEnd();
                    range.deleteContents();
                    const cell = new Text('--', line);
                    currentLine.after(cell);
                    const pos = nodes.indexOf(currentLine);
                    nodes.splice(pos + 1, 0, cell);
                    updateLineNumbers();
                    selection.setPosition(cell.content);
                    if (cell.content.innerText === '') {
                        cell.content.appendChild(document.createElement('br'));
                    }
                    cell.scrollTo();
                }
            }
        }

        /**
         * Get representation of the input as an array of lines
         */
        function getLines(value) {
            if (Array.isArray(value)) {
                return value;
            }
            if (typeof value === 'number') {
                return [value];
            }
            if (typeof value === 'string' || value instanceof String) {
                return value.split(/\r?\n/g);
            }
            return Object.entries(value).map(([key, value]) => `${key}: ${value}`);
        }


        /**
         * Insert a block of text before the given reference
         */
        function insertBefore(text, reference) {
            const lines = getLines(text);
            const pos = nodes.indexOf(reference);
            const cells = lines.map((text, index) => {
                const cell = new Text(pos + index, text);
                reference.lineNumber.before(cell.lineNumber, cell.content);
                return cell;
            });
            nodes.splice(pos, 0, ...cells);
            return cells;
        }

        /**
         * Insert a block of text after the given reference
         */
        function insertAfter(text, reference) {
            const lines = getLines(text);
            const pos = nodes.indexOf(reference);
            const cells = lines.map((text, index) => new Text(pos + index + 1, text));
            reference.after(cells);
            return cells;
        }

        function updateLineNumbers(start) {
            observer.disconnect();
            if (start) {
                const lines = document.querySelectorAll('.line-number');
                for (let i = start; i < lines.length; ++i) {
                    const node = lines[i];
                    node.innerText = i + 1;
                }
            } else {
                let lineNumber = 0;
                for (const node of document.querySelectorAll('.line-number')) {
                    node.innerText = ++lineNumber;
                }
            }
            observer.observe(workspaceNode, observerOptions);
        }


        /**
         * Return the name of the cell or it's index if it doesn't have a name
         */
        function cellName(cell) {
            return cell.name ?? nodes.indexOf(cell);
        }



        /**
         * Go to the next cell, creating it if needed
         */
        function nextLine(cell) {
            let line = cell.content.nextElementSibling;
            while (line && !line.classList.contains('line')) {
                line = line.nextElementSibling;
            }
            if (!line) {
                const index = nodes.indexOf(cell) + 1;
                const newCell = new Text(index);
                cell.after(newCell);
                line = newCell.content;
            }
            document.getSelection().setPosition(line, 0);
            line.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
        }

        /**
         * Update the current line and highlight it whenever the selection changes.
         */
        document.addEventListener('selectionchange', (event) => {
            const newLine = getCurrentCell();
            if (newLine !== currentLine) {
                for (const highlighted of workspaceNode.querySelectorAll('.highlight')) {
                    highlighted.classList.remove('highlight');
                }

                for (const sources of document.querySelectorAll('.input')) {
                    sources.classList.remove('uses');
                }

                if (newLine) {
                    const prompt = document.getElementById('prompt');
                    if (prompt) {
                        newLine.lineNumber.appendChild(prompt);
                    }
                    newLine.input.forEach((cell) => cell.content.classList.add('uses'));

                    newLine.content.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });

                    newLine.content.classList.add('highlight');

                    currentLine = newLine;
                    cellIndex = nodes.indexOf(currentLine);
                    app.content = cellIndex + 1;
                }
            }
        });

        const contentNode = document.getElementById('content');

        /**
         * Parse the content of the cell.
         */
        function parseLines(lines, reference = currentLine) {
            const cells = insertBefore(lines, reference);
            cells.forEach((cell) => parseCell(cell));
            return;
            let lineNumber = reference.index;
            lines.forEach((text) => {
                const cell = new Text(lineNumber, text);
                reference.lineNumber.before(cell.lineNumber, cell.content);
                nodes.splice(lineNumber, 0, cell);
                if (text.trim() !== 'reload') {
                    // ToDo: fix code that assumes parsing only evver occurs for the current cell
                    parseCell(cell);
                }
                lineNumber += 1; // ToDo: ParseCell may have added lines so lineNumber may be wrong!
            });
        }

        /**
         * Evaluate a string
         */
        function evaluateString(string) {
            const predefined = getPredefined();

            try {
                const func = new Function('store', ...predefined.names, `return ${string}`);
                return func(app.store, ...predefined.values);
            } catch (error) {
                app['last error'] = error.message;
            }
        }

        /**
         * Parse the content of the cell.
         */
        function parseCell(cell) {
            const action = cell.content.innerText;
            const value = Number(action);

            const commands = Object.getOwnPropertyNames(actions).sort((a, b) => b.length - a.length);
            const command = commands.find((match) => action.startsWith(match));

            const cellTypeNames = Object.getOwnPropertyNames(cellTypes).sort((a, b) => b.length - a.length);
            const cellTypeMatch = cellTypeNames.find((match) => action.startsWith(match));

            app.setStatus(command);

            if (actions[action]) {
                actions[action](cell);
            } else if (command) {
                actions[command](cell);
            } else if (cellTypeMatch) {
                Object.assign(cell, cellTypes[cellTypeMatch]);
                const pattern = new RegExp(`^\\s*${cellTypeMatch}\\s*`);
                const string = action.replace(pattern, '');

                const args = getList(string);
                const { cells, values } = args.reduce((results, value) => {
                    const index = Number(value);
                    if (app.namedCells[value] !== undefined) {
                        results.cells.push(app.namedCells[value]);
                    } else if (!isNaN(index) && index > -app.cells.length && index < app.cells.length) {
                        results.cells.push(app.cells.at(index));
                    } else {
                        results.values.push(value);
                    }
                    return results;
                }, { cells: [], values: [] });
                cell.init(string, cells, values);
            } else if (named.all[action]) {
                named.all[action].eval(cell);
            } else if (action.trim().startsWith('#') && action.trim().endsWith('#')) {
                cell.block = action.replace(/^\s*#\s*/, '').replace(/\s*#\s*$/, '');
            } else if (isNaN(value) && currentLine.content.classList.contains('line')) {
                const result = evaluateString(action);
                if (result !== undefined) {
                    cell.updateTextOutput(result);
                } else {
                    return true;
                }
            } else {
                return true;
            }
        }


        /**
         * Process a key press within a line element
         */
        function processKey(event, line) {
            if (event.key === 'ArrowUp') {
                if (event.altKey) {
                    previousCommand(event);
                    event.preventDefault();
                }
            }
            if (event.key === 'ArrowDown') {
                if (event.altKey) {
                    nextCommand(event);
                    event.preventDefault();
                }
            }
            if (event.target.value) {
                const list = document.getElementById('named-items');
                event.target.setAttribute('list', 'named-items');
            }

            if (event.key === 'Enter') {
                event.preventDefault();
                if (event.ctrlKey) {
                    const selection = document.getSelection();
                    if (!selection.isCollapsed) {
                        for (let r = 0; r < selection.rangeCount; ++r) {
                            const range = selection.getRangeAt(r);
                            const text = range.toString();
                            try {
                                const func = new Function(`return ${text}`);
                                const value = func();
                                range.deleteContents();
                                range.insertNode(document.createTextNode(value));
                            } catch (e) {
                                currentLine.content.title = e.message;
                            }
                        }
                    } else {
                        breakAtCursor();
                    }
                } else {
                    if (parseCell(currentLine)) {
                        breakAtCursor();
                    } else {
                        nextLine(currentLine);
                    }
                }
                // Remove empty lines at end of list
                let hasContent = false;
                const cells = nodes.toReversed().filter((cell) => hasContent = hasContent || cell.content.innerText.trim().length > 0);
                cells.reverse();

                const lines = Array.from(workspaceNode.querySelectorAll('.line'));
                const content = lines.map((line) => line.innerText.trimEnd());
                if (app.save) {
                    localStorage.setItem('noia-lines', JSON.stringify(content));
                }
            }
        }

        function addMainEventListeners() {
            const workspace = document.getElementById('workspace');

            workspace.addEventListener('keydown', (event) => {
                if (app.processKey) {
                    if (!app.processKey(event)) {
                        return;
                    };
                }

                const line = getCurrentLine();
                if (line) {
                    processKey(event, line);
                }
            });
        }

        /**
         * Make a line number node
         */
        function makeLineNumberNode() {
            lineNumber = document.createElement('div');
            lineNumber.classList.add('line-number');
            lineNumber.contentEditable = false;
            return lineNumber;
        }

        /**
         * Process lines edits of the workspace
         */
        function processEdits(records, observer) {
            const removedTextLines = [];
            const removedControlLines = [];
            const removedOutputLines = [];
            for (const record of records) {
                for (const addedNode of record.addedNodes) {
                    if (addedNode.nodeType === 1 && addedNode.closest('.line')) {
                        const line = addedNode.closest('.line');
                        const node = nodes.find((node) => node.content === line);
                        if (node && !node.lineNumber) {
                            node.lineNumber = makeLineNumberNode();
                            line.before(node.lineNumber);
                        }
                    }
                }

                if (record.removedNodes.length > 0) {
                    removedTextLines.push(...Array.from(record.removedNodes).filter((node) => node.classList?.contains('line')));
                    removedControlLines.push(...Array.from(record.removedNodes).filter((node) => node.classList?.contains('control')));
                    removedOutputLines.push(...Array.from(record.removedNodes).filter((node) => node.classList?.contains('output')));
                }
            }
            if (removedTextLines.length) {
                nodes = nodes.filter((node) => !removedTextLines.includes(node.content));
                // Clean up double line breaks
                nodes.filter((node) => node.content.innerText.match(/\r?\n\r?\n/))
                    .forEach((node) => node.content.innerText = node.content.innerText.replace(/(\r?\n)+/, '\n'));
                updateLineNumbers();
            }
            if (removedOutputLines.length) {
                removedOutputLines.map((output) => nodes.find((cell) => cell.content === output))
                    .forEach((output) => output.remove());
            }
        }

        const observerOptions = {
            childList: true,
            subtree: true,
        };

        const observer = new MutationObserver(processEdits);
        observer.observe(workspaceNode, observerOptions);

    </script>
</body>

</html>