<!DOCTYPE html>
<html>
<!--
TODO:
indicate change of state when input cell changes
named cells
add timestamps to cells
pass cell to actions to avoid promise return
change code cell to use details tag
calendar functions
cell from sequence
side widgets: todos, notes
cell types?
background colour / picture
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>js-notepad</title>
    <link href="styles/noia-vt220.css" rel="stylesheet" />
</head>

<body>
    <div id="results"></div>
    <div id="widgets"></div>
    <div id="input-area">
        <span id="current-index">0</span><span>&gt; </span>
        <datalist id="named-items"></datalist>
        <input id="command-entry" type="text" autocorrect="off" autocapitalize="none"><!-- list="named-items"> -->
    </div>
    <div id="status" class="fade"></div>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: false });

        /**
         * Utility functions
         */
        function sameDay(date1, date2) {
            return date1.getDate() === date2.getDate() &&
                date1.getMonth() === date2.getMonth() &&
                date1.getFullYear() === date2.getFullYear();
        }

        /**
         * Add an item to the list used for completions
         */
        function addNamedItem(name) {
            const list = document.getElementById('named-items');
            const item = document.createElement('option');
            item.innerText = name;
            list.appendChild(item);
        }

        /**
         * Add a date to the named items
         */
        function getDate(string) {
            const [day, month, year] = string.trim().split(/[-/_]/g).map((s) => parseInt(s));
            return new Date(year < 2000 ? year + 2000 : year, month - 1, day);
        }

        /**
         *  Helper function to get list of cells from input string
         */
        function getCells(string) {
            return string ? string.split(/\s+/g).map((cell) =>
                app.cells.at(cell.replace(/^</, '').replace(/>$/, ''))).filter((cell) => cell) :
                [app.cells.at(-1)];
        }

        /**
         * Custom Actions
         *
         */
        const actions = {
            /**
             * Toggle fullscreen mode
             */
            fullscreen(cell) {
                if (!navigator.userActivation.isActive) {
                    cell.value = 'fullscreen request ignored in script';
                    return;
                }
                if (document.body.webkitRequestFullscreen) {
                    if (document.body.webkitIsFullScreen) {
                        document.body.webkitCancelFullScreen();
                        cell.value = 'exit fullscreen';
                    } else {
                        document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                        cell.value = 'enter fullscreen';
                    }
                }
                if (document.body.requestFullscreen) {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                        cell.value = 'exit fullscreen';
                    } else {
                        document.body.requestFullscreen();
                        cell.value = 'enter fullscreen';
                    }
                }
                cell.type = Status;
            },

            /**
             * Clear the screen
             */
            cls(cell) {
                const results = document.getElementById('results');
                results.innerHTML = '';
                return Ignore;
            },

            /**
             * Show the command history
             */
            history(cell) {
                cell.value = app.history.map((command, index) => `${index}: ${command}`).join('<br>');
                cell.update = (time) => {
                    cell.value = app.history.map((command, index) => `${index}: ${command}`).join('<br>');
                    cell.view.result.innerHTML = cell.value;
                    if (app.show) {
                        app.show();
                    }
                }
                app.events.historyChange.add(cell);
            },

            /**
             * Show the list of cells
             */
            cells(cell) {
                cell.value = app.cells.map((cell, index) => `${index}: ${cell.raw}${cell?.users?.size ? ' (' + cell.users.size + ')' : ''}`).join('<br>');
                cell.update = (time) => {
                    cell.value = app.cells.map((cell, index) => `${index}: ${cell.raw}${cell?.users?.size ? ' (' + cell.users.size + ')' : ''}`).join('<br>');
                    cell.view.result.innerHTML = cell.value;
                }
                app.events.historyChange.add(cell);
            },

            /**
             * Add a clock to the widget area
             */
            clock(cell) {
                this.now = new Date();
                cell.value = this.now;
                cell.update = (time) => cell.view.result.innerHTML = this.now;

                if (app.clockWidget) {
                    app.clockWidget.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                    cell.view.widget = app.clockWidget;
                    return cell;
                }

                app.clockWidget = document.createElement('canvas');
                app.clockWidget.id = 'clock';
                document.getElementById('widgets').appendChild(app.clockWidget);

                cell.view.widget = app.clockWidget;

                const ctx = app.clockWidget.getContext('2d');
                const width = ctx.width = app.clockWidget.clientWidth;
                const height = ctx.height = app.clockWidget.clientHeight;
                const radius = Math.min(width, height) / 2;

                const dayStart = new Date();
                dayStart.setHours(0);
                dayStart.setMinutes(0);
                dayStart.setSeconds(0);
                dayStart.setMilliseconds(0);
                const update = (timer) => {
                    this.now = new Date();
                    const time = (this.now.getTime() - dayStart.getTime()) / 1000;
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'lightgreen';
                    ctx.strokeStyle = 'lightgreen';
                    ctx.beginPath();
                    for (let i = 0; i < 12; ++i) {
                        const x1 = width / 2 + radius * Math.sin(i * 2 * Math.PI / 12);
                        const y1 = height / 2 - radius * Math.cos(i * 2 * Math.PI / 12);
                        ctx.moveTo(x1, y1);
                        const x2 = width / 2 + (radius - 2) * Math.sin(i * 2 * Math.PI / 12);
                        const y2 = height / 2 - (radius - 2) * Math.cos(i * 2 * Math.PI / 12);
                        ctx.lineTo(x2, y2);
                    }
                    const seconds = Math.floor(time);
                    const x1 = width / 2 + radius * Math.sin(seconds * 2 * Math.PI / 60);
                    const y1 = height / 2 - radius * Math.cos(seconds * 2 * Math.PI / 60);
                    ctx.moveTo(width / 2, height / 2);
                    ctx.lineTo(x1, y1);
                    const x2 = width / 2 + 0.8 * radius * Math.sin(time * 2 * Math.PI / 3600);
                    const y2 = height / 2 - 0.8 * radius * Math.cos(time * 2 * Math.PI / 3600);
                    ctx.moveTo(width / 2, height / 2);
                    ctx.lineTo(x2, y2);
                    const x3 = width / 2 + 0.6 * radius * Math.sin(time * 2 * Math.PI / (12 * 3600));
                    const y3 = height / 2 - 0.6 * radius * Math.cos(time * 2 * Math.PI / (12 * 3600));
                    ctx.moveTo(width / 2, height / 2);
                    ctx.lineTo(x3, y3);
                    ctx.stroke();
                    requestAnimationFrame(update);
                }
                update();
            },

            calendar(cell) {
                cell.update = (time) => cell.view.result.innerHTML = this.calendarDate.toDateString();

                if (app.calendarWidget) {
                    cell.value = this.calendarDate;
                    cell.view.widget = app.calendarWidget;
                    app.calendarWidget.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                    return;
                }
                this.calendarDate = new Date();
                cell.value = this.calendarDate;
                app.calendarWidget = document.createElement('div');
                cell.view.widget = app.calendarWidget;
                app.calendarWidget.classList.add('calendar');
                document.getElementById('widgets').appendChild(app.calendarWidget);

                const previousMonth = document.createElement('span');
                previousMonth.innerHTML = '&lt;';
                previousMonth.classList.add('calendar-day');
                app.calendarWidget.appendChild(previousMonth);
                previousMonth.addEventListener('click', (event) => {
                    this.calendarDate.setMonth(this.calendarDate.getMonth() - 1);
                    update()
                });

                const monthName = document.createElement('span');
                monthName.classList.add('calendar-month-name');
                app.calendarWidget.appendChild(monthName);

                const nextMonth = document.createElement('span');
                nextMonth.innerHTML = '&gt;';
                nextMonth.classList.add('calendar-day');
                app.calendarWidget.appendChild(nextMonth);
                nextMonth.addEventListener('click', (event) => {
                    this.calendarDate.setMonth(this.calendarDate.getMonth() + 1);
                    update()
                });

                'SMTWTFS'.split('').forEach((c) => {
                    const day = document.createElement('span');
                    day.classList.add('calendar-day');
                    day.innerHTML = c;
                    app.calendarWidget.appendChild(day);
                });
                const days = [];
                for (let i = 0; i < 42; ++i) {
                    const day = document.createElement('span');
                    day.classList.add('calendar-day');
                    app.calendarWidget.appendChild(day);
                    days.push(day);
                }

                const update = () => {
                    const today = new Date();
                    monthName.innerHTML = this.calendarDate.toLocaleDateString('en-AU', { month: 'long' });
                    const month = this.calendarDate.getMonth();
                    const year = this.calendarDate.getFullYear();
                    const date = new Date(year, month, 1);
                    date.setDate(date.getDate() - date.getDay());
                    const end = new Date(year, month + 1, 0);
                    end.setDate(end.getDate() + 7 - end.getDay());
                    days.forEach((day) => {
                        if (sameDay(today, date)) {
                            day.classList.add('calendar-day-today');
                        } else {
                            day.classList.remove('calendar-day-today');
                        }
                        if (date.getMonth() === month) {
                            day.classList.remove('calendar-day-fade');
                        } else {
                            day.classList.add('calendar-day-fade');
                        }
                        if (date < end) {
                            day.innerHTML = ('' + date.getDate()).padStart(2, '0');
                        } else {
                            day.innerHTML = '';
                        }
                        date.setDate(date.getDate() + 1);
                    });
                }
                update();

                return app.calendarWidget;
            },

            /**
             * perform a google search
             */
            google(cell) {
                const string = cell.raw.replace(/google\s+/, '').replace(/\s+/g, '+');
                const url = `https://www.google.com/search?q=${string}`;
                window.open(url, '_blank');
                cell.value = `<a href="${url}>google ${cell.raw.replace(/google\s+/, '')}</a>`;
            },

            /**
             * Toggle the 'hide' state for a cell
             */
            hide(cell) {
                const string = cell.raw.replace(/\s*hide\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    cell.view.result.classList.toggle('hidden');
                    cell.view.input.classList.toggle('dim');
                    const index = app.cells.indexOf(cell);
                    const hidden = cell.view.result.classList.contains('hidden');
                    result.push(`<${index}> now ${hidden ? 'hidden' : 'visible'}`);
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * Toggle the 'widget' state for a cell
             */
            widget(cell) {
                const string = cell.raw.replace(/\s*widget\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    const node = cell.view.result;
                    if (node.classList.contains('widget')) {
                        cell.view.container.appendChild(node);
                        node.classList.remove('widget');
                        result.push(`<${app.cells.indexOf(cell)}> no longer a widget`);

                    } else {
                        document.getElementById('widgets').appendChild(node);
                        node.classList.add('widget');
                        result.push(`<${app.cells.indexOf(cell)}> now a widget`);

                    }
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },


            /**
             * Toggle the 'sticky' state for a cell
             */
            keep(cell) {
                const string = cell.raw.replace(/\s*keep\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    const node = cell.view.result.parentElement;
                    if (node.classList.contains('sticky')) {
                        const box = node.getBoundingClientRect();
                        Array.from(document.querySelectorAll('.sticky'))
                            .filter((node) => node.getBoundingClientRect().y > box.y)
                            .forEach((node) => node.style.top = `${node.getBoundingClientRect().y - box.height}px`);
                        node.classList.remove('sticky');
                        result.push(`<${app.cells.indexOf(cell)}> now unstuck`);
                    } else {
                        const top = Math.max(0, ...Array.from(document.querySelectorAll('.sticky'))
                            .map((node) => {
                                const box = node.getBoundingClientRect();
                                return box.y + box.height;
                            })
                        );
                        node.classList.add('sticky');
                        node.style.top = `${top}px`;
                        result.push(`<${app.cells.indexOf(cell)}> now stuck`);
                    }
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * Delete a cell
             */
            delete(cell) {
                if (!navigator.userActivation.isActive) {
                    cell.value = 'delete ignored when reloading state';
                    return;
                }
                const string = cell.raw.replace(/^\s*delete\s*/, '');
                const len = app.cells.length;
                const cells = getCells(string);
                if (cells.length === 0) {
                    cell.value = `No cells deleted!`;
                } else if (cells.length === 1) {
                    cell.value = `deleted cell ${app.cells.indexOf(cells[0])}`;
                } else {
                    cell.value = `deleted cells ${cells.map((cell) => app.cells.indexOf(cell)).join()}`;
                }
                app.cells = app.cells.filter((cell) => !cells.includes(cell));
                cells.forEach((cell) => cell.remove());
                cell.type = Status;
            },

            /**
             * List the known commands
             */
            actions(cell) {
                cell.value = Object.keys(actions).map((action, index) => `${index}: ${action}`).join('<br>')
            },

            /**
             * List the known files
             */
            files(cell) {
                cell.value = Object.keys(named.files).map((file, index) => `${index}: ${file}`).join('<br>')
            },

            /**
             * Create a notes cell
             */
            notes(cell) {
                const string = cell.raw.replace(/^\s*notes\s*/, '');
                const index = app.cells.length;

                const cells = string ? string.split(/\s+/g).map((cell) =>
                    app.cells.at(cell.replace(/^</, '').replace(/>$/, ''))) :
                    [app.cells.at(-1)];

                const content = cells.map((cell) => cell.value).join('\n');

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                }

                const resolve = (str) => {
                    const allNamed = Object.values(named)
                        .reduce((all, value) => Object.assign(all, value), {});
                    return str.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            `app.cells.at(${getIndex(index)}).value`)
                        .replace(/<([^>]+)>/g, (match, name) =>
                            allNamed[name] ?? match);
                }

                cell.view.result = document.createElement('div');
                cell.view.result.classList.add('notes');
                cell.view.result.contentEditable = true;
                cell.content = content;
                cell.view.result.innerText = content || '<enter notes>';
                cell.view.result.addEventListener('blur', (event) => {
                    cell.content = cell.view.result.innerText;
                    cell.view.result.innerText = resolve(cell.content) || `<enter note>`;
                    saveState();
                    inputNode.focus();
                });
                cell.view.result.addEventListener('focus', (event) => {
                    cell.view.result.innerText = cell.content;
                });
                cell.view.result.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        cell.view.result.blur();
                    }
                });
                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: () => resolve(cell.content),
                    },
                    content: {
                        enumerable: true,
                        get: () => cell.view.result.innerText,
                        set: (value) => {
                            cell.view.result.innerText = value;
                            const users = Array.from(cell.users);
                            users.forEach((user) => user.update());
                        },
                    },
                });
                cell.focus = cell.view.result;
            },

            /**
             * Create a notes cell
             */
            html(cell) {
                const string = cell.raw.replace(/^html\s*/, '');
                const index = app.cells.length;

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                }

                const resolve = (str) => {
                    const allNamed = Object.values(named)
                        .reduce((all, value) => Object.assign(all, value), {});
                    return str.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            `app.cells.at(${getIndex(index)}).value`)
                        .replace(/<([^>]+)>/g, (match, name) =>
                            allNamed[name] ?? match);
                }

                cell.view.result = document.createElement('div');
                cell.view.result.classList.add('notes');
                cell.view.result.contentEditable = true;
                cell.view.result.innerText = 'notes';
                cell.content = '';
                cell.view.result.addEventListener('blur', (event) => {
                    cell.content = cell.view.result.innerText;
                    cell.view.result.innerHTML = resolve(cell.content) || `<i>&lt;enter note&gt;</i>`;
                    saveState();
                });
                cell.view.result.addEventListener('focus', (event) => {
                    cell.view.result.innerText = cell.content;
                });
                cell.view.result.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        cell.view.result.blur();
                    }
                });
                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: () => resolve(cell.content),
                    },
                });
            },

            /**
             * Create a mermaid diagram cell
             */
            diagram(cell) {

                const string = cell.raw.replace(/^diagram\s*/, '');
                const index = app.mermaidCount++;

                const cells = getCells(string);
                cells.forEach((input) => {
                    input.users.add(cell);
                    cell.uses.add(input);
                });

                cell.content = string || '<-1>';

                cell.view.result = document.createElement('div');
                cell.view.result.classList.add('mermaid-cell');

                const diagram = document.createElement('div');

                diagram.classList.add('mermaid');
                cell.view.result.appendChild(diagram);
                diagram.addEventListener('click', (event) => diagram.classList.toggle('focused'));

                cell.update = async (time) => {
                    const source = cells.map((input) => input.value).join('\n');
                    try {
                        const { svg } = await mermaid.render(`graph_${index}`, source);
                        diagram.innerHTML = svg;
                        cell.svg = diagram.firstElementChild;
                    } catch (error) {
                        diagram.innerHTML = error.message;

                    }
                    cell.users.forEach((user) => user.update());
                    if (cell.users.size === 0) {
                        saveState();
                    }
                }

                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: () => diagram.innerHTML,
                    },
                });
                cell.update();
            },

            /**
             * Create a mermaid diagram cell
             */
            mermaid(cell) {
                const string = cell.raw.replace(/^mermaid\s*/, '');
                const idx = app.mermaidCount++;
                const index = app.cells.length;

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                }

                const resolve = (str) => {
                    const allNamed = Object.values(named)
                        .reduce((all, value) => Object.assign(all, value), {});
                    return str.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            `app.cells.at(${getIndex(index)}).value`)
                        .replace(/<([^>]+)>/g, (match, name) =>
                            allNamed[name] ?? match);
                }

                cell.view.result = document.createElement('div');
                cell.view.result.classList.add('mermaid-cell');

                const definition = document.createElement('textarea');
                definition.classList.add('code-area');
                definition.rows = 10;
                definition.value = ''

                const diagram = document.createElement('div');
                cell.view.result.appendChild(definition);

                diagram.classList.add('mermaid');
                document.getElementById('widgets').appendChild(diagram);
                diagram.addEventListener('click', (event) => diagram.classList.toggle('focused'));
                cell.content = '';

                async function update() {
                    try {
                        const { svg } = await mermaid.render(`graph_${idx}`, resolve(cell.content));
                        diagram.innerHTML = svg;
                        cell.svg = diagram.firstElementChild;
                    } catch (error) {
                        diagram.innerHTML = error.message;

                    }
                    saveState();
                }

                definition.addEventListener('blur', (event) => update());
                definition.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        definition.blur();
                    }
                });
                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: () => resolve(cell.content),
                    },
                    content: {
                        enumerable: true,
                        get: () => definition.value,
                        set: (value) => {
                            definition.value = resolve(value);
                            update();
                        },
                    },
                });
            },

            /**
             * Create a js cell
             */
            js(cell) {
                const string = cell.raw.replace(/^js\s*/, '');
                const index = app.cells.length;

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                }

                cell.view.result = document.createElement('div');
                const node = document.createElement('textarea');
                node.rows = 20;
                node.value = string;
                node.classList.add('code-area');
                node.addEventListener('blur', (event) => {
                    evaluate();
                    cell.users.entries().filter((cell) => cell.update).forEach((cell) => cell.update);
                    saveState();
                    inputNode.focus();
                });
                node.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        node.blur();
                    }
                });
                cell.view.result.appendChild(node);
                const evaluate = () => {
                    const expr = node.value.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            `app.cells.at(${getIndex(index)}).value`);
                    try {
                        const args = string.split(/[\s+]/);
                        const func = new Function('app', ...args, `${expr}`);
                        const result = func(app);
                        app.setStatus(result);
                        return result;
                    } catch (error) {
                        app.setStatus(error.message);
                        return error.message;
                    }
                };
                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: evaluate,
                    },
                    content: {
                        enumerable: true,
                        get: () => node.value,
                        set: (value) => node.value = value,
                    },
                });
                cell.focus = node;
                return cell;
            },

            /**
             * Reset command history
             */
            reset(cell) {
                cell.prompt = 'Reset all? (Y/n)';
                cell.action = (input) => {
                    app.action = null;
                };
            },

            /**
             * Add a date to the named items
             */
            date(cell) {
                const string = cell.raw.replace(/date\s*/, '');
                const parts = string.split(/(\s+)/g);
                const date = parts.pop();
                const name = parts.join('').trim();
                const [day, month, year] = date.split(/[-/_]/g).map((s) => parseInt(s));
                named.dates[name] = new Date(year < 2000 ? year + 2000 : year, month - 1, day);
                addNamedItem(name);
                cell.value = named.dates[name];
            },

            /**
             * List dates
             */
            dates(cell) {
                cell.value = Object.entries(named.dates)
                    .map(([name, date]) => `${name}: ${date.toDateString()}`)
                    .join('<br>');
            },


            /**
             * Add a site to the named items
             */
            site(cell) {
                const string = cell.raw.replace(/site\s*/, '');
                const [name, addr] = string.split(/\s*http/);
                const url = `http${addr}`;
                this[name] = (cell) => {
                    window.open(url, '_blank');
                    named.sites[name] = url;
                    cell.value = `<a href="url">${name}</a>`;
                };
                addNamedItem(name);
                cell.value = `added shortcut ${name} -> ${url}`;
            },

            /**
             * List sites
             */
            sites(cell) {
                cell.value = Object.entries(named.sites)
                    .map(([name, url]) => `${name}: <a href="${url}">${url}</a>`)
                    .join('<br>');
            },

            /**
             * perform a google search
             */
            abbr(cell) {
                const string = cell.raw.replace(/abbr\s*/, '');
                const parts = string.split(/(\s+)/);
                const name = parts.shift();
                const expansion = parts.join('').trim();
                named.abbreviations[name] = expansion;
                addNamedItem(name);
                cell.value = `${name} -> ${expansion}`;
            },

            /**
             * List abbreviations
             */
            abbreviations(cell) {
                cell.value = Object.entries(named.abbreviations)
                    .map(([name, expansion]) => `${name}: ${expansion}`)
                    .join('<br>');
            },

            /**
             * Load a file using a handle in the database
             */
            async load(cell) {
                if (!navigator.userActivation.isActive) {
                    cell.value = 'loadData request ignored in script';
                    return;
                }

                const file = cell.raw.replace(/^\s*load\s*/, '');
                if (file) {
                    load(cell, file, (contents) => cell.view.result.innerHTML = `<pre>${contents}</pre>`);
                } else {
                    cell.value = `Select File...`;
                    if ('showOpenFilePicker' in self) {
                        const [fileHandle] = await window.showOpenFilePicker();
                        if (fileHandle) {
                            cell.view.result.innerHTML = `Loading...`;
                            const file = await fileHandle.getFile();
                            cell.content = file.name;
                            cell.value = await file.text();
                            cell.view.result.innerHTML = `<pre>${cell.value}</pre>`;
                            saveFileHandles([{ name: file.name, handle: fileHandle }]);
                        }
                    }
                }
            },

            /**
             * Save the contents of the specified files
             */
            async save(cell) {
                const string = cell.raw.replace(/^\s*save\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]
                const cells = getCells(string.replace(pattern, ''));

                cells.forEach((input) => {
                    input.users.add(cell);
                    cell.uses.add(input);
                });

                let fileHandle;
                cell.update = async () => {
                    if (fileHandle) {
                        const contents = cells.map((cell) => cell.value).join('\n');
                        // Create a FileSystemWritableFileStream to write to.
                        const writable = await fileHandle.createWritable();
                        // Write the contents of the file to the stream.
                        await writable.write(contents);
                        // Close the file and write the contents to disk.
                        await writable.close();
                    }
                }

                if (filename && named.files[filename]) {
                    fileHandle = named.files[filename];
                } else {
                    const options = {
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                    };
                    fileHandle = await window.showSaveFilePicker(options);
                    const file = await fileHandle.getFile();
                    cell.contents = file.name;
                    cell.raw += ` as ${file.name}`;
                    saveFileHandles([{ name: file.name, handle: fileHandle }]);
                }
                cell.update();
            },

            saveSvg(cell) {
                const string = cell.raw.replace(/^\s*saveSvg\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]
                const cells = getCells(string.replace(pattern, ''));

                cells.forEach((input) => {
                    input.users.add(cell);
                    cell.uses.add(input);
                });

                cell.update = () => {
                    cells.filter((cell) => cell.svg).forEach((cell, index) =>
                        cells.length > 1 ? convertSVGtoImg(cell.svg, `${filename}_${index}.png`) : convertSVGtoImg(cell.svg, `${filename}.png`));
                };

                cell.update();
            },

            /**
             * Load user specified data file
             */
            async loadData(cell) {
                if (!navigator.userActivation.isActive) {
                    cell.value = 'loadData request ignored in script';
                    return;
                }
                const file = cell.raw.replace(/^\s*loadData\s*/, '');

                const process = (contents) => {
                    cell.value = contents;
                    cell.view.result.innerHTML = `<pre>${cell.value}</pre>`;

                    let sectionName;
                    let current;
                    const section = /^[^\s]+[^:]*:\s*$/;
                    cell.value.split(/\r?\n/g).forEach((line) => {
                        if (section.test(line)) {
                            sectionName = line.replace(/:\s*$/, '');
                            named[sectionName] = named[sectionName] || {};
                        } else if (sectionName && line.trim() !== '') {
                            const [pre, ...values] = line.split(/:/);
                            const name = pre.trim();
                            const value = values.join(':').trim();
                            named[sectionName][name] = named[sectionName][name] || [];
                            named[sectionName][name].push(value);
                        }
                    });
                    Object.entries(named.abbreviations).forEach(([name, expansion]) => {
                        this[name] = (cell) => cell.value = expansion;
                        named.abbreviations[name] = expansion;
                        addNamedItem(name);
                    });
                    Object.entries(named.dates).forEach(([name, date]) => {
                        named.dates[name] = getDate(date[0]);
                        this[name] = (cell) => cell.value = named.dates[name];
                        addNamedItem(name);
                    });
                    Object.entries(named.sites).forEach(([name, urls]) => {
                        named.sites[name] = urls;
                        const url = urls[0];
                        this[name] = (cell) => {
                            const windowReference = window.open(url, name, 'pop');
                            named.sites[name] = url;
                            if (windowReference) {
                                windowReference.focus();
                            }
                            cell.value = `<a href="url">${name}</a>`;
                        };
                        addNamedItem(name);
                    });
                    cell.users.forEach((user) => user.update());
                }

                if (file) {
                    load(cell, file, process);
                } else {
                    if ('showOpenFilePicker' in self) {
                        const [fileHandle] = await window.showOpenFilePicker();
                        if (fileHandle) {
                            const file = await fileHandle.getFile();
                            cell.raw += ` ${file.name}`;
                            cell.content = file.name;
                            const contents = await file.text();
                            process(contents);
                            saveFileHandles([{ name: file.name, handle: fileHandle }]);
                            saveState();
                        }
                    }
                }
            },
        }

        const named = {
            dates: [],
            sites: [],
            abbreviations: [],
            files: [],
        }

        Object.keys(actions).forEach(addNamedItem);

        const inputNode = document.getElementById('command-entry');

        class Cell {
            constructor(raw, content, expr, resolved, uses = []) {
                this.raw = raw;
                this.timestamp = new Date();
                this.expr = expr ?? raw;
                this.resolved = resolved ?? raw;
                this.content = content;
                this.value = content;
                this.uses = new Set(uses);
                this.users = new Set();
                this.view = {};
            }
            getResultNode() {
                const node = document.createElement('div');
                node.classList.add('result');
                node.innerHTML = this.value ?? '';
                return node;
            }
            makeView() {
                this.view.container = document.createElement('div');
                this.view.container.classList.add('result-box');

                this.view.input = this.view.input || document.createElement('div');
                this.view.input.classList.add('input');
                this.view.container.appendChild(this.view.input);

                this.view.raw = this.view.raw || document.createElement('span');
                this.view.raw.classList.add('raw');
                this.view.raw.innerHTML = this.raw;
                this.view.input.appendChild(this.view.raw);
                this.view.raw.addEventListener('dblclick', (event) => {
                    if (event.ctrlKey) {
                        this.view.raw.contentEditable = true;
                        this.view.raw.focus();
                    } else {
                        this.view.result.classList.toggle('hidden');
                        this.view.input.classList.toggle('dim');
                    }
                });
                this.view.raw.addEventListener('blur', (event) => {
                    this.view.raw.contentEditable = false;
                    this.raw = this.view.raw.innerText;
                });

                if (this.raw !== this.resolved) {
                    const arrow = document.createElement('span');
                    arrow.innerHTML = ' &rarr; ';
                    this.view.input.appendChild(arrow);

                    this.view.resolved = this.view.resolved || document.createElement('span');
                    this.view.resolved.classList.add('resolved');
                    this.view.resolved.innerHTML = this.resolved;
                    this.view.input.appendChild(resolvedNode);
                }
                this.view.result = this.view.result || this.getResultNode();
                this.view.container.appendChild(this.view.result);
            }
            toJSON(key) {
                return {
                    raw: this.raw,
                    timestamp: this.timestamp.getTime(),
                    expr: this.expr !== this.raw ? this.expr : undefined,
                    resolved: this.resolved !== this.raw ? this.resolved : undefined,
                    content: this.content,
                    value: this.value,
                    uses: this.uses.entries().map((cell) => app.cells.indexOf(cell)),
                    users: this.users.entries().map((cell) => app.cells.indexOf(cell)),
                }
            }
            remove() {
                this.view.index.remove();
                this.view.container.remove();
                this.uses.forEach((input) => input.users.delete(this));
                this.users.forEach((user) => user.uses.delete(this));
            }
        }

        function copyStylesInline(destinationNode, sourceNode) {
            var containerElements = ["svg", "g"];
            for (var cd = 0; cd < destinationNode.childNodes.length; cd++) {
                var child = destinationNode.childNodes[cd];
                if (containerElements.indexOf(child.tagName) != -1) {
                    copyStylesInline(child, sourceNode.childNodes[cd]);
                    continue;
                }
                var style = sourceNode.childNodes[cd].currentStyle || window.getComputedStyle(sourceNode.childNodes[cd]);
                if (style == "undefined" || style == null) continue;
                for (var st = 0; st < style.length; st++) {
                    child.style.setProperty(style[st], style.getPropertyValue(style[st]));
                }
            }
        }

        const dataHeader = 'data:image/svg+xml;charset=utf-8';

        const loadImage = async url => {
            const img = document.createElement('img');
            img.src = url;
            return new Promise((resolve, reject) => {
                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        }

        const serializeAsXML = (e) => (new XMLSerializer()).serializeToString(e);

        const encodeAsUTF8 = (str) => `${dataHeader},${encodeURIComponent(str)}`;
        const encodeAsB64 = (str) => `${dataHeader};base64,${btoa(str)}`;

        /**
         * Extract SVG data and paste image to canvas to download
         */
        const convertSVGtoImg = async (svg, filename, format = 'png') => {
            const copy = svg.cloneNode(true);
            copyStylesInline(copy, svg);
            const svgData = encodeAsUTF8(serializeAsXML(copy));

            const img = await loadImage(svgData);

            const canvas = document.createElement('canvas');
            canvas.width = svg.clientWidth;
            canvas.height = svg.clientHeight;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgb(240, 248, 255)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.drawImage(img, 0, 0, svg.clientWidth, svg.clientHeight);

            const dataURL = await canvas.toDataURL(`image/${format}`, 1.0);
            triggerDownload(dataURL, filename);
        }

        /**
         * Create link and click it to trigger download
         */
        function triggerDownload(imgURI, fileName) {
            const event = new MouseEvent('click', {
                view: window,
                bubbles: false,
                cancelable: true
            });
            const link = document.createElement('a');
            link.setAttribute('download', fileName);
            link.setAttribute('href', imgURI);
            link.setAttribute('target', '_blank');
            link.dispatchEvent(event);
        }

        const app = {
            args: {},
            history: [],
            cells: [],
            index: 0,
            events: {
                historyChange: new Set(),
            },
            context: [{ process }],
            mermaidCount: 0,
            setPrompt(prompt) {
                const currentIndex = document.getElementById('current-index');
                if (prompt) {
                    currentIndex.innerHTML = prompt;
                } else {
                    currentIndex.innerHTML = this.cells.length;
                }
            },
            setStatus(text, timeout = 3) {
                const statusNode = document.getElementById('status');
                statusNode.innerHTML = text;
                statusNode.classList.remove('fade');
                if (app.timeout) {
                    clearTimeout(app.timeout);
                }
                const fade = () => {
                    statusNode.classList.add('fade');
                    app.timeout = null;
                }
                app.timeout = setTimeout(fade, timeout * 1000);
            }
        };

        /**
         * Update dynamic cells of display
         */
        function update(time) {
            window.requestAnimationFrame(update);
        }
        //update();

        Object.getOwnPropertyNames(Math).forEach((prop) => app.args[prop] = Math[prop]);

        const Ignore = Symbol('ignore');
        const Status = Symbol('status');

        /**
         * Evaluate an input string
         */
        function evaluate(raw) {
            const cell = new Cell(raw);
            if (actions[raw] !== undefined) {
                actions[raw](cell);
                return cell;
            } else if (actions[raw.split(' ')[0]]) {
                actions[raw.split(' ')[0]](cell);
                return cell;
            }
            const names = [named.abbreviations[raw], named.dates[raw], named.sites[raw]].filter((i) => i);
            if (names.length) {
                cell.value = names.join('<br>');
                return cell;
            }
            const getIndex = (str) => isNaN(parseInt(str)) ? -1 : parseInt(str) % app.cells.length;
            const expr = raw.replace(/^\\/, '').replace(/<(-?[0-9]*)>/g, (match, index) =>
                `app.cells.at(${getIndex(index)}).value`);
            const references = [];
            const resolved = raw.replace(/^\\/, '').replace(/<(-?[0-9]*)>/g, (match, index) => {
                const referenced = app.cells.at(getIndex(index));
                referenced.users.add(cell);
                cell.uses.add(referenced);
                return `${referenced.value}`;
            });
            cell.update = () => {
                try {
                    if (app.action) {
                        const func = new Function('app', ...Object.keys(app.args), `return app.action(${expr})`);
                    }
                    const func = new Function('app', ...Object.keys(app.args), `return ${expr}`);

                    cell.value = func(app, ...Object.values(app.args));
                } catch (error) {
                    cell.value = error.message;
                }
                if (cell.action) {
                    app.action === cell.action();
                }
            }
            cell.update();

            return cell;
        }

        /**
         * Add the results to the output
         */
        function showResults(cell, index) {
            const resultsNode = document.getElementById('results');

            const indexNode = document.createElement('span');
            indexNode.classList.add('index');
            indexNode.innerHTML = `${index}: `;
            resultsNode.appendChild(indexNode);

            cell.view.index = indexNode;

            cell.makeView();

            resultsNode.appendChild(cell.view.container);
            cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
            app.show = () => cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
        }

        /**
         * Process the input
         */
        function process(event) {
            app.history.push(inputNode.value);
            const str = (app.index === app.cells.length && inputNode.value === '') ? app.cells.at(-1).raw : inputNode.value;
            const cell = evaluate(str);
            if (cell !== Ignore) {
                if (cell.type === Status) {
                    app.setStatus(cell.value);
                } else {
                    showResults(cell, app.cells.length);
                    app.cells.push(cell);
                }
            }
            app.events.historyChange.forEach((cell) => cell.update());

            if (event.ctrlKey && (app.index < (app.cells.length - 1))) {
                app.index += 1;
                inputNode.value = app.cells.at(app.index).raw;
            } else {
                app.index = app.cells.length;
                inputNode.value = '';
            }
            app.setPrompt(cell.prompt);
            saveState();
            if (cell.focus) {
                cell.focus.focus();
            }
        }

        /**
         * Process cursor up in input box
         */
        function cursorUp(event) {
            if (app.index === app.cells.length) {
                app.draft = inputNode.value;
            }
            app.index -= 1;
            if (app.index < 0) {
                app.index = app.cells.length;
                inputNode.value = app.draft;
            } else {
                if (event.altKey) {
                    const start = inputNode.selectionStart;
                    const end = inputNode.selectionEnd ?? start;
                    const reference = event.ctrlKey ? `${app.cells.at(app.index).value}` : `<${app.index - app.cells.length}>`;
                    inputNode.value = inputNode.value.slice(0, start) + reference + inputNode.value.slice(end);
                    inputNode.setSelectionRange(start, start + reference.length);
                } else {
                    inputNode.value = app.cells[app.index].raw;
                }
                if (app.cells.at(app.index).view.result) {
                    const node = app.cells.at(app.index).view.result;
                    node.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                }
            }
        }

        /**
         * Process cursor up in input box
         */
        function cursorDown(event) {
            if (app.index === app.cells.length) {
                app.draft = inputNode.value;
                app.index = -1;
            }
            app.index += 1;
            if (app.index === app.cells.length) {
                inputNode.value = app.draft;
            } else {
                if (event.altKey) {
                    const start = inputNode.selectionStart;
                    const end = inputNode.selectionEnd ?? start;
                    const reference = event.ctrlKey ? `${app.cells.at(app.index).value}` : `<${app.index - app.cells.length}>`;
                    inputNode.value = inputNode.value.slice(0, start) + reference + inputNode.value.slice(end);
                    inputNode.setSelectionRange(start, start + reference.length);
                } else {
                    inputNode.value = app.cells[app.index].raw;
                }
                if (app.cells.at(app.index).view.result) {
                    const node = app.cells.at(app.index).view.result;
                    node.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                }
            }
        }

        /**
         * Save the current state to local storage
         */
        function saveState() {
            const state = { app };
            localStorage.setItem('noia-state', JSON.stringify(state));
        }

        /**
         * Reload the state from local storage
         */
        function loadState() {
            const stateStr = localStorage.getItem('noia-state');
            if (stateStr) {
                const state = JSON.parse(stateStr);
                state.app = state.app ?? state.context;
                state.app.cells.filter((cell) => cell && cell.raw).forEach((storedCell) => {
                    app.history.push(storedCell.raw);
                    const cell = evaluate(storedCell.raw);
                    if (storedCell.content) {
                        cell.content = storedCell.content;
                    }
                    if (cell && cell !== Ignore) {
                        cell.timestamp = new Date(storedCell.timestamp);
                        if (cell.type === Status) {
                            app.setStatus(cell.value);
                        } else {
                            showResults(cell, app.cells.length);
                            app.cells.push(cell);
                        }
                    }
                });
                app.index = app.cells.length;
                const currentIndex = document.getElementById('current-index');
                currentIndex.innerHTML = app.cells.length;
                app.events.historyChange.forEach((cell) => cell.update());
            }
            inputNode.focus();
        }

        (function loadFileList() {
            const request = window.indexedDB.open('NoaiDatabase', 1);

            // Handle a failure
            request.onerror = (event) => {
                console.error(`Database error: ${event.target.error?.message}`);
            };

            // save the files
            request.onsuccess = (event) => {
                const db = event.target.result;

                if (db.objectStoreNames.contains('files')) {
                    const transaction = db.transaction(['files']);
                    const objectStore = transaction.objectStore('files');
                    const request = objectStore.getAll();
                    request.onerror = (event) => {
                        console.error(`Database error: ${event.target.error?.message}`);
                    };
                    request.onsuccess = async (event) => {
                        event.target.result.forEach((file) =>
                            named.files[file.name] = file.handle);
                    };
                }
            };

            request.onupgradeneeded = (event) => {
                // Save the IDBDatabase interface
                const db = event.target.result;

                // Create an objectStore for this database
                const objectStore = db.createObjectStore('files', { keyPath: 'name' });

                // Use transaction oncomplete to make sure the objectStore creation is
                // finished before adding data into it.
                objectStore.transaction.oncomplete = (event) => {
                    // Store values in the newly created objectStore.
                    const fileHandleStore = db
                        .transaction('files', 'readwrite')
                        .objectStore('files');
                    files.forEach((file) => {
                        fileHandleStore.add(file);
                    });
                };
            };
        })();

        /**
         * Check the permissions for the file to load
         */
        async function verifyPermission(fileHandle, readWrite) {
            const options = {};
            if (readWrite) {
                options.mode = 'readwrite';
            }
            // Check if permission was already granted. If so, return true.
            if ((await fileHandle.queryPermission(options)) === 'granted') {
                return true;
            }
            // Request permission. If the user grants permission, return true.
            if ((await fileHandle.requestPermission(options)) === 'granted') {
                return true;
            }
            // The user didn't grant permission, so return false.
            return false;
        }

        /**
         * Load a file from a handle in an indexeddb database
         */
        async function load(cell, filename, process) {
            if (named.files[filename]) {
                const handle = named.files[filename];
                if (verifyPermission(handle)) {
                    const file = await handle.getFile();
                    const contents = await file.text();
                    if (process) {
                        process(contents);
                    }
                } else {
                    console.log('Permission not granted for file :(');
                }
            }
        }

        /**
         * Save the value of a cell to a file
         */
        async function save(cell, filename) {
            if (named.files[filename]) {
                const handle = named.files[filename];
                if (verifyPermission(handle)) {
                    const file = await handle.getFile();
                    const contents = await file.text();
                    if (process) {
                        process(contents);
                    }
                } else {
                    console.log('Permission not granted for file :(');
                }
            }
        }


        /**
         * Save a list of file handles to a indexeddb database
         */
        function saveFileHandles(files) {
            // Open the database
            const request = window.indexedDB.open('NoaiDatabase', 1);

            // Handle a failure
            request.onerror = (event) => {
                console.error(`Database error: ${event.target.error?.message}`);
            };

            // save the files
            request.onsuccess = (event) => {
                const db = event.target.result;

                const transaction = db.transaction(['files'], 'readwrite');
                // Do something with request.result!
                // Do something when all the data is added to the database.
                transaction.oncomplete = (event) => {
                    console.log('All done!');
                };

                transaction.onerror = (event) => {
                    // Don't forget to handle errors!
                };

                const fileHandleStore = transaction.objectStore('files');
                files.forEach((file) => {
                    const request = fileHandleStore.put(file);
                    request.onsuccess = (event) => {
                        console.log(`stored handle for ${file.name}`);
                    };
                    request.onerror = (event) => {
                        console.log(`Database error: ${event.target.error?.message}`);
                    };
                });
            };

            request.onupgradeneeded = (event) => {
                // Save the IDBDatabase interface
                const db = event.target.result;

                // Create an objectStore for this database
                const objectStore = db.createObjectStore('files', { keyPath: 'name' });

                // Use transaction oncomplete to make sure the objectStore creation is
                // finished before adding data into it.
                objectStore.transaction.oncomplete = (event) => {
                    // Store values in the newly created objectStore.
                    const fileHandleStore = db
                        .transaction('files', 'readwrite')
                        .objectStore('files');
                    files.forEach((file) => {
                        fileHandleStore.add(file);
                    });
                };
            };
        }


        function dropHandler(event) {
            event.preventDefault();

            function loadFile(file) {
                const reader = new FileReader();
                const cell = new Cell(`dropped file ${file.name}`);
                reader.addEventListener('load', (event) => {
                    cell.value = reader.result;
                    cell.view.result.innerHTML = `<pre>${reader.result}</pre>`;
                    cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' })
                });
                reader.readAsText(file);

                showResults(cell, app.cells.length);
                //saveState();
            }

            if (event.dataTransfer.items) {
                [...event.dataTransfer.items].forEach((item, index) => {
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        loadFile(file);
                        item.getAsFileSystemHandle().then((handle) => {
                            saveFileHandles([{ name: file.name, handle }]);
                            named.files[file.name] = handle;
                        });
                    }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
            }
        }

        function dragOverHandler(event) {
            // Prevent default behavior (Prevent file from being opened)
            event.preventDefault();
        }

        /**
         * Proces a key press in the input box
         */
        function processKey(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                app.context.at(-1).process(event);
            }
            if (event.key === 'ArrowUp') {
                event.preventDefault();
                cursorUp(event);
            }
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                cursorDown(event);
            }
            if (event.target.value) {
                const list = document.getElementById('named-items');
                event.target.setAttribute('list', 'named-items');
            }
        }

        const results = document.getElementById('results');
        inputNode.addEventListener('dragover', dragOverHandler);
        inputNode.addEventListener('drop', dropHandler);
        results.addEventListener('drop', dragOverHandler);
        results.addEventListener('drop', dropHandler);

        app.setPrompt('Load previous state (Y/n)');
        app.context.push({
            process: (event) => {
                if (event.target.value.toLowerCase()[0] !== 'n') {
                    loadState()
                }
                event.target.value = '';
                app.context.pop();
            }
        });

        inputNode.addEventListener('keydown', processKey);

        results.addEventListener('click', (event) => {
            if (event.target === results) {
                inputNode.focus();
            }
        });
        inputNode.focus();

    </script>
</body>

</html>