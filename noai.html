<!DOCTYPE html>
<html>
<!--
TODO:
indicate change of state when input cell changes
cell from sequence
side widgets: notes
cell types?
background colour
markdown
better handling of file access when api not present
web midi

don't add named items to actions?
amending config files
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>js-notepad</title>
    <link href="styles/noia-workbench-1.3.css" rel="stylesheet" />
</head>

<body>
    <div id="header"></div>
    <div id="main">
        <div id="results"></div>
        <div id="input-area">
            <span id="current-index">0</span><span>&gt; </span>
            <datalist id="named-items"></datalist>
            <input id="command-entry" type="text" autocorrect="off" autocapitalize="none"><!-- list="named-items"> -->
        </div>
    </div>
    <div id="widgets"></div>
    <div id="footer"></div>
    <div id="status" class="fade"></div>
    <div id="placeholder"></div>
    <script type="module">
        const themes = ['vt-220', 'workbench-1.3', 'workbench-4.1'];


        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: false });

        /**
         * Utility functions
         */
        function sameDay(date1, date2) {
            return date1.getDate() === date2.getDate() &&
                date1.getMonth() === date2.getMonth() &&
                date1.getFullYear() === date2.getFullYear();
        }

        /**
         * Add an item to the list used for completions
         */
        function addNamedItem(name, type) {
            const list = document.getElementById('named-items');
            const item = document.createElement('option');
            item.innerText = name;
            list.appendChild(item);
        }

        /**
         * Add a date to the named items
         */
        function getDate(string) {
            if (string instanceof Date) {
                return new Date(string.getTime());
            }
            const [p1, p2, p3] = string.trim().split(/[-/_]/g).map((s) => parseInt(s));
            const [day, month, year] = (p1 > 1000) ? [p3, p2, p1] : [p1, p2, p3];
            return new Date(year < 2000 ? year + 2000 : year, month - 1, day);
        }

        /**
         *  Helper function to get list of items from a string
         */
        function getList_old(string, sep = " ", start = "<", end = ">") {
            const list = [];
            const quoted = (char) => {
                if (char === end) {
                    return init;
                }
                list.at(-1).push(char);
            };
            const unquoted = (char) => {
                if (char === sep) {
                    return init;
                }
                list.at(-1).push(char);
            }
            const init = (char) => {
                if (char === start) {
                    list.push(['']);
                    return quoted;
                } else if (char !== sep) {
                    list.push([char]);
                    return unquoted
                }
            }
            let action = init
            for (let i = 0; i < string.length; ++i) {
                action = action(string[i]) || action;
            }
            return list.map((item) => item.join(''));
        }

        /**
         *  Helper function to get list of items from a string
         */
        function getList(string, sep = ' ', start = '<', end = '>', esc = '\\') {
            const list = [];
            const invalid = [];
            const escaped = (char) => {
                list.at(-1).push(char);
                return escaped.next;
            };
            const quoted = (char) => {
                if (char === esc) {
                    escaped.next = quoted;
                    return escaped;
                }
                if (char === end) {
                    return init;
                }
                list.at(-1).push(char);
            };
            const unquoted = (char) => {
                if (char === esc) {
                    escaped.next = unquoted;
                    return escaped;
                }
                if (char === sep) {
                    if (list.at(-1))
                        return init;
                }
                list.at(-1).push(char);
            }
            const init = (char) => {
                if (char === esc) {
                    escaped.next = unquoted;
                    return escaped;
                }
                if (char === start) {
                    list.push(['']);
                    return quoted;
                } else if (char !== sep) {
                    list.push([char]);
                    return unquoted
                }
            }

            let action = init
            for (let i = 0; i < string.length; ++i) {
                action = action(string[i]) || action;
            }
            return list.map((item) => item.join(''));
        }

        /**
         *  Helper function to get list of cells from input string
         */
        function getCells(string) {
            if (string) {
                const list = getList(string);
                const cells = list.map((index) => app.namedCells[index] ?? app.cells.at(index));
                return cells.filter((cell) => cell);
            }
            return [app.cells.at(-1)];
        }


        /**
         *  Helper function to get list of cells from input string and set up users / uses relationships
         */
        function getReferences(string, cell) {
            const cells = getCells(string);
            cells.forEach((input) => {
                input.users.add(cell);
                cell.uses.add(input);
            });
            return cells;
        }


        /**
         * calendar functions
         */
        const calendar = {
            holidays: [],
            // Offset of time from UCT so that day number is consistent even if date includes time information
            offset: (new Date(1970, 0, 4, 23)).getTime(),
            dayNumber: (date) => Math.floor((date.getTime() - calendar.offset) / (24 * 60 * 60 * 1000)),
            setStart: (date) => {
                date.setHours(8);
                date.setMinutes(0);
                date.setSeconds(0);
                date.setMilliseconds(0);
                return date;
            },
            setFinish: (date) => {
                date.setHours(18);
                date.setMinutes(0);
                date.setSeconds(0);
                date.setMilliseconds(0);
                return date;
            },
            days(start, end) {
                start = getDate(start);
                end = getDate(end);
                return Math.abs(calendar.dayNumber(end) - calendar.dayNumber(start));
            },
            isWorkingDay(date) {
                const day = calendar.dayNumber(date);
                return ((day % 7) < 5 && !calendar.holidays.includes(day));
            },
            workingDays(start, end) {
                start = getDate(start);
                end = getDate(end);

                if (isNaN(start) || isNaN(end)) return;
                if (start > end) {
                    [end, start] = [start, end];
                }
                calendar.setStart(start);
                calendar.setFinish(end);
                let days = 0;
                const day = new Date(start.getTime());
                if (day.getHours() > 12) {
                    day.setDate(day.getDate() + 1);
                }
                while (!calendar.isWorkingDay(day)) {
                    day.setDate(day.getDate() + 1);
                }
                while (day < end) {
                    days += 1;
                    day.setDate(day.getDate() + 1);
                    while (!calendar.isWorkingDay(day)) {
                        day.setDate(day.getDate() + 1);
                    }
                }
                return days;
            },

            getTimeToGo(start, end) {
                const workingDays = calendar.workingDays(start, end);
                let timeToGo = `${workingDays} working days`
                if (workingDays > 5) {
                    const weeks = Math.floor(workingDays / 5);
                    timeToGo += ` (${weeks} weeks)`;
                }
                return timeToGo;
            },

            /**
             * Get the end date of an activity based on its start and duration, assumes monday to friday minus public holidays.
             * Start assumed to be start of day, end is COB, hence start and end will be same date for single day task.
             */
            getEndDate(start, duration) {
                const end = new Date(start.getTime());
                --duration;
                while (!calendar.isWorkingDay(end)) {
                    end.setDate(end.getDate() + 1);
                }
                while (duration > 0) {
                    --duration;
                    end.setDate(end.getDate() + 1);
                    while (!calendar.isWorkingDay(end)) {
                        end.setDate(end.getDate() + 1);
                    }
                }
                calendar.setFinish(end);
                return end;
            },

            /**
             * Update a date by the given number of working days
             */
            offsetDate(date, workingDays = 0) {
                if (isNaN(date) || isNaN(workingDays)) {
                    return date;
                }
                workingDays = Math.round(workingDays);
                const delta = Math.sign(workingDays);
                while (workingDays !== 0) {
                    date.setDate(date.getDate() + delta);
                    while (!calendar.isWorkingDay(date)) {
                        date.setDate(date.getDate() + delta);
                    }
                    workingDays -= delta;
                }
                return date;
            },

            /**
             * Get the start date of an activity based on its finish and duration, assumes monday to friday minus public holidays.
             * Start assumed to be start of day, end is COB, hence start and end will be same date for single day task.
             */
            getStartDate(finish, duration) {
                const start = new Date(finish.getTime());
                --duration;
                while ((start.getDay() === 0) || (start.getDay() === 6) || calendar.holidays.includes(calendar.dayNumber(start))) {
                    start.setDate(start.getDate() - 1);
                }
                while (duration > 0) {
                    --duration;
                    start.setDate(start.getDate() - 1);
                    while ((start.getDay() === 0) || (start.getDay() === 6) || calendar.holidays.includes(calendar.dayNumber(start))) {
                        start.setDate(start.getDate() - 1);
                    }
                }
                calendar.setStart(start);
                return start;
            },

            /**
             * Return the financial month end for a given date.
             */
            getMonthEnd(date) {
                const year = date.getFullYear();
                const monthEnd = new Date(date.getMonth() < 5 ? year - 1 : year, 6, 1, 23, 59, 59, 999);
                const sequence = [28, 28, 35];
                let next = 0;
                if (monthEnd.getDay() < 4) {
                    next = 28;
                } else {
                    next = 35;
                }
                let i = 0;
                while (monthEnd <= date) {
                    monthEnd.setDate(monthEnd.getDate() + (next || sequence[i]) - monthEnd.getDay());
                    next = 0;
                    if (monthEnd.getMonth() === 11) {
                        monthEnd.setDate(31);
                        if (monthEnd.getDay() > 3) {
                            next = 35
                        }
                    }
                    if (monthEnd.getMonth() === 0 && monthEnd.getDate() < 7) {
                        monthEnd.setDate(0);
                        if (monthEnd.getDay() > 3) {
                            next = 35
                        }
                    }
                    if (monthEnd.getMonth() === 5) {
                        monthEnd.setDate(31);
                    }
                    if (monthEnd.getMonth() === 0 && monthEnd.getDate() < 7) {
                        console.log('> ' + monthEnd.toLocaleDateString());
                        monthEnd.setDate(0);
                        console.log(monthEnd.toLocaleDateString());
                    }
                    i = (i + 1) % 3;
                }
                return monthEnd;
            }
        };


        /**
         * Custom Actions
         *
         */
        const actions = {
            /**
             * Toggle fullscreen mode
             */
            fullscreen(cell) {
                if (!navigator.userActivation.isActive) {
                    cell.value = 'fullscreen request ignored in script';
                    return;
                }
                if (document.body.webkitRequestFullscreen) {
                    if (document.body.webkitIsFullScreen) {
                        document.body.webkitCancelFullScreen();
                        cell.value = 'exit fullscreen';
                    } else {
                        document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                        cell.value = 'enter fullscreen';
                    }
                }
                if (document.body.requestFullscreen) {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                        cell.value = 'exit fullscreen';
                    } else {
                        document.body.requestFullscreen();
                        cell.value = 'enter fullscreen';
                    }
                }
                cell.type = Status;
            },

            /**
             * Clear the screen
             */
            cls(cell) {
                const results = document.getElementById('results');
                results.innerHTML = 'clear cells';
                cell.type = Status;
            },

            /**
             * Reload the page
             */
            reload(cell) {
                if (!app.loaded) {
                    cell.value = 'reload request ignored until app initialised';
                    return;
                }
                location.reload();
                cell.toJSON = () => undefined;
            },

            /**
             * Change the theme
             */
            theme(cell) {
                const themeName = cell.raw.replace(/^\s*theme\s+/, '').trim();
                document.documentElement.setAttribute('data-theme', themeName);
                cell.type = Status;
                cell.value = `theme set to ${themeName}`;
                if (!themes.includes(themeName)) {
                    cell.value += ' (unknown theme)!';
                }
                app.state.theme = themeName;
            },

            /**
             * List the themes
             */
            themes(cell) {
                const themeName = document.documentElement.getAttribute('data-theme');
                const themesNames = themes.map((name) => name === themeName ? name + ' *' : name);
                cell.type = Status;
                cell.value = themesNames.join('<br>');
                if (!themes.includes(themeName)) {
                    cell.value += ` ${themeName} unknown theme!`;
                }
            },


            /**
             * Show the command history
             */
            history(cell) {
                const toString = (cell, index) => `${index}: ${cell.raw}`
                cell.value = app.history.join('<br>');
                const cellMap = new Map();
                cell.update = (time) => {
                    cell.value = app.history.join('<br>');
                    cell.view.result.innerHTML = cell.value;
                }
                app.events.historyChange.add(cell);
            },

            /**
             * Show the list of cells
             */
            cells(cell) {
                const toString = (cell, index) => `${index}: ${cell.raw}${cell?.users?.size ? ' (' + cell.users.size + ')' : ''}`;
                cell.value = app.cells.filter((cell) => cell.view.result).map(toString).join('<br>');
                cell.update = (time) => {
                    cell.value = app.cells.filter((cell) => cell.view.result).map(toString).join('<br>');
                    cell.view.result.innerHTML = '';
                    cell.view.result.classList.add('table');
                    cell.view.result.style.gridTemplateColumns = `min-content min-content 1fr`;
                    app.cells.filter((cell) => cell.view.result).forEach((eachCell) => {
                        const indexNode = document.createElement('span');
                        indexNode.innerHTML = `${app.cells.indexOf(eachCell)}:`;
                        indexNode.classList.add('cells-list', 'cells-list-index');
                        cell.view.result.appendChild(indexNode);
                        indexNode.addEventListener('click', (event) => {
                            eachCell.view.result.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
                        });

                        const nameNode = document.createElement('span');
                        nameNode.innerHTML = `${eachCell.name ?? ''}`;
                        nameNode.classList.add('cells-list', 'cells-list-name');
                        cell.view.result.appendChild(nameNode);

                        const rawNode = document.createElement('span');
                        rawNode.innerHTML = `${eachCell.command}${eachCell?.users?.size ? ' (' + eachCell.users.size + ')' : ''}`;
                        rawNode.classList.add('cells-list', 'cells-list-raw');
                        cell.view.result.appendChild(rawNode);
                        rawNode.addEventListener('click', (event) => {
                            const start = inputNode.selectionStart;
                            const end = inputNode.selectionEnd;
                            inputNode.value = inputNode.value.slice(0, start) + eachCell.raw + inputNode.value.slice(end);
                            inputNode.selectionStart = start;
                            inputNode.selectionEnd = start + eachCell.raw.length;
                        });
                    });
                };
                app.events.historyChange.add(cell);
            },

            /**
             * perform a google search
             */
            google(cell) {
                const string = cell.raw.replace(/google\s+/, '');
                const pattern = string.replace(/\s+/g, '+');
                const url = `https://www.google.com/search?q=${pattern}`;
                window.open(url, string, 'pop');
                cell.value = `googling ${string}`;
                cell.type = Status;
            },

            /**
             * Download a resource from the net
             */
            wget(cell) {
                const url = cell.raw.replace(/wget\s+/, '').replace(/\s+/g, '%20');
                const name = url.split(/\//g).at(-1);
                const link = document.createElement("a");
                link.href = url;
                link.download = name;
                link.click();
                cell.value = `fetching ${url}`;
                cell.type = Status;
            },

            /**
             * Set a cell size to its content
             */
            fit(cell) {
                const string = cell.raw.replace(/\s*fit\s*/, '');

                const cells = getCells(string);
                const result = [];

                const fit = (cell) => {
                    const origin = cell.view.cell.getBoundingClientRect();

                    const size = {
                        width: 0, height: 0,
                    };
                    for (let child of cell.view.cell.childNodes) {
                        const box = child.getBoundingClientRect();
                        size.width = Math.max(size.width, child.scrollWidth);
                        size.height = Math.max(size.height, child.scrollHeight);
                    }
                    const name = cell.name || cell.index;
                    cell.view.cell.style.width = `${size.width}px`;
                    cell.view.cell.style.height = `${size.height}px`;
                    cell.view.cell.style.maxWidth = `100dvw`;
                    cell.view.cell.style.maxheight = `100dvh`;

                    result.push(`<${name}> now hidden`);
                };

                cells.forEach((cell) => {
                    fit(cell);
                    result.push(`<${name}> now hidden`);
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * Set the 'hide' state for cells
             */
            hide(cell) {
                const string = cell.raw.replace(/\s*hide\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    cell.setMode('hidden');
                    result.push(`<${cell.name || cell.index}> now hidden`);
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * Toggle the 'hide' state for a cell
             */
            unhide(cell) {
                const string = cell.raw.replace(/\s*unhide\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    cell.clearMode('hidden');
                    result.push(`<${cell.name || cell.index}> now unhidden`);
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * Set the 'collapse' state for cell(s)
             */
            collapse(cell) {
                const string = cell.raw.replace(/\s*collapse\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    if (cell.state === 'floating') {
                        cell.view.box = cell.view.cell.getBoundingClientRect();
                    }
                    cell.setMode('collapsed');
                    result.push(`<${cell.name || cell.index}> now collapsed`);
                    cell.view.cell.style.width = '';
                    cell.view.cell.style.height = '';
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * clear the 'collapse' state for cell(s)
             */
            expand(cell) {
                const string = cell.raw.replace(/\s*expand\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    cell.clearMode('collapsed');
                    const name = cell.name || cell.index;
                    result.push(`<${name}> now collapsed`);
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * Toggle the 'widget' state for a cell
             */
            widget(cell) {
                const string = cell.raw.replace(/\s*widget\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    const node = cell.view.result;
                    if (cell.view.cell.classList.contains('widget')) {
                        cell.lastState();
                        result.push(`<${app.cells.indexOf(cell)}> no longer a widget`);
                    } else {
                        cell.setState('widget');
                        result.push(`<${app.cells.indexOf(cell)}> now a widget`);
                    }
                });
                cell.value = result.join('<br>');
                cell.type = Status;
            },

            /**
             * display the cell in line with the other cells
             */
            normal(cell) {
                const string = cell.raw.replace(/\s*stick\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => cell.setState('normal'));
                cell.value = result.join('<br>');
                cell.type = Status;
                app.layoutChange();
            },

            /**
             * Toggle the 'sticky' state for a cell
             */
            stick(cell) {
                const string = cell.raw.replace(/\s*stick\s*/, '');

                const cells = getCells(string);
                const result = [];
                cells.forEach((cell) => {
                    if (cell.view.cell.classList.contains('sticky')) {
                        cell.lastState();
                        result.push(`<${app.cells.indexOf(cell)}> now unstuck`);
                    } else {
                        cell.setState('sticky');
                        result.push(`<${app.cells.indexOf(cell)}> now stuck`);
                    }
                });
                cell.value = result.join('<br>');
                cell.type = Status;
                app.layoutChange();
            },

            /**
             * Convert a cell to a window and set it's position
             */
            window(cell) {
                const string = cell.raw.replace(/\s*window\s*/, '');

                const args = getList(string);
                const { cells, values } = args.reduce((results, value) => {
                    const index = Number(value);
                    if (app.namedCells[value] !== undefined) {
                        results.cells.push(app.namedCells[value]);
                    } else if (!isNaN(index) && index > -app.cells.length && index < app.cells.length) {
                        results.cells.push(app.cells.at(index));
                    } else {
                        results.values.push(value);
                    }
                    return results;
                }, { cells: [], values: [] });

                const pos = values.map((val) => Number(val));
                const result = [];
                cells.forEach((cell) => {
                    if (cell.view.cell.classList.contains('floating')) {
                        cell.lastState();
                    } else {
                        cell.setState('floating');

                        if (!isNaN(pos[0])) {
                            cell.view.cell.style.left = `${pos[0]}px`;
                        }
                        if (!isNaN(pos[1])) {
                            cell.view.cell.style.top = `${pos[1]}px`;
                        }
                    }
                    result.push(`${cell.getName()} position fixed`);
                });
                cell.value = result.join('<br>');
                cell.type = Status;
                app.layoutChange();
            },

            /**
             * Set a background image
             */
            background(cell) {
                const string = cell.raw.replace(/\s*background\s*/, '');
                const url = string || 'https://taws.ch/Patterns/Boing.jpg';
                if (url === 'none') {
                    document.body.style.backgroundImage = `none`;
                } else {
                    document.body.style.backgroundImage = `url("${url}")`;
                }
                cell.type = Status;
                cell.value = `background set to ${url}`;
                app.state.background = url;
            },

            /**
             * Log the content of the specified cell(s)
             */
            log(cell) {
                cell.type = Status;
                if (!navigator.userActivation.isActive) {
                    cell.value = 'delete ignored when reloading state';
                    return;
                }
                if (!app.interactive) {
                    cell.value = 'delete ignored in non-interactive mode';
                    return;
                }

                const string = cell.raw.replace(/^\s*log\s*/, '');
                const cells = getCells(string);
                if (cells.length === 0) {
                    cell.value = `No cells logged!`;
                } else if (cells.length === 1) {
                    cell.value = `log cell ${app.cells.indexOf(cells[0])}`;
                } else {
                    cell.value = `log cells ${cells.map((cell) => app.cells.indexOf(cell)).join()}`;
                }
                app.cells = app.cells.filter((cell) => !cells.includes(cell));
                cells.forEach((cell) => console.log(cell.content));
            },

            /**
             * Delete a cell
             */
            delete(cell) {
                cell.type = Status;
                if (!navigator.userActivation.isActive) {
                    cell.value = 'delete ignored when reloading state';
                    return;
                }
                if (!app.interactive) {
                    cell.value = 'delete ignored in non-interactive mode';
                    return;
                }

                const string = cell.raw.replace(/^\s*delete\s*/, '');
                const len = app.cells.length;
                const cells = getCells(string);
                if (cells.length === 0) {
                    cell.value = `No cells deleted!`;
                } else if (cells.length === 1) {
                    cell.value = `deleted cell ${app.cells.indexOf(cells[0])}`;
                } else {
                    cell.value = `deleted cells ${cells.map((cell) => app.cells.indexOf(cell)).join()}`;
                }
                app.cells = app.cells.filter((cell) => !cells.includes(cell));
                cells.forEach((cell) => cell.remove());
            },

            /**
             * List the known commands
             */
            actions(cell) {
                cell.value = Object.keys(actions).map((action, index) => `${index}: ${action}`).join('<br>')
            },

            /**
             * List the known files
             */
            files(cell) {
                cell.value = Object.keys(named.files).map((file, index) => `${index}: ${file}`).join('<br>')
            },

            /**
             * Create a notes cell
             */
            notes_old(cell) {
                const string = cell.raw.replace(/^\s*(<[^>]+>:)?\s*/, '').replace(/^notes\s*/, '');
                const index = app.cells.length;

                const content = string ? getCells(string).map((cell) => cell.value).join('\n') : '';

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                }

                const resolve = (str) => {
                    return str.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            app.cells.at(getIndex(index)).value)
                        .replace(/<([^>]+)>/g, (match, name) =>
                            named.all[name] ?? match);
                }

                cell.view.result = document.createElement('pre');
                cell.view.result.classList.add('notes');
                cell.view.result.contentEditable = true;
                cell.content = content;
                cell.view.result.innerText = content || '<enter notes>';
                cell.view.result.addEventListener('blur', (event) => {
                    cell.content = cell.view.result.innerText;
                    cell.view.result.innerText = resolve(cell.content) || `<enter note>`;
                    cell.users.forEach((user) => user.update());
                    saveState();
                    inputNode.focus();
                });
                cell.view.result.addEventListener('focus', (event) => {
                    if (cell.content) {
                        cell.view.result.innerText = cell.content;
                    } else {
                        cell.view.result.innerText = '<enter note>';
                        cell.view.result.selectionStart = 0;
                        cell.view.result.selectionEnd = 12;
                    }
                });
                cell.view.result.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        cell.view.result.blur();
                    }
                });
                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: () => resolve(cell.content),
                    },
                    content: {
                        enumerable: true,
                        get: () => cell.view.result.innerText,
                        set: (value) => {
                            cell.view.result.innerText = value;
                            const users = Array.from(cell.users);
                            users.forEach((user) => user.update());
                        },
                    },
                });
                cell.focus = cell.view.result;
            },

            /**
             * Create a notes cell
             */
            html(cell) {
                const string = cell.raw.replace(/^html\s*/, '');
                const index = app.cells.length;

                const cells = getReferences(string, cell);

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                }

                const resolve = (str) => {
                    return str.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            `app.cells.at(${getIndex(index)}).value`)
                        .replace(/<([^>]+)>/g, (match, name) =>
                            named.all[name] ?? match);
                }
                cell.update = (time) => {
                    cell.content = cells.map((cell) => cell.value).join('\n');
                    cell.value = resolve(cell.content);
                    cell.view.result.innerHTML = cell.value;
                };
            },

            /**
             * Create a mermaid diagram cell
             */
            diagram(cell) {
                const string = cell.raw.replace(/^diagram\s*/, '');
                const index = app.mermaidCount++;

                const cells = getReferences(string, cell);

                cell.content = string || '<-1>';

                cell.view.result = document.createElement('div');
                cell.view.result.classList.add('mermaid-cell');

                const diagram = document.createElement('div');

                diagram.classList.add('mermaid');
                cell.view.result.appendChild(diagram);
                diagram.addEventListener('click', (event) => diagram.classList.toggle('focused'));

                cell.update = async (time) => {
                    const source = cells.map((input) => input.value).join('\n');
                    try {
                        const { svg } = await mermaid.render(`graph_${index}`, source);
                        diagram.innerHTML = svg;
                        cell.svg = diagram.firstElementChild;
                    } catch (error) {
                        diagram.innerHTML = error.message;

                    }
                    cell.users.forEach((user) => user.update());
                }

                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: () => diagram.innerHTML,
                    },
                });
                //cell.update();
            },

            /**
             * Create a js cell
             */
            js_old(cell) {
                const string = cell.raw.replace(/^js\s*/, '');
                const index = app.cells.length;

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                }

                cell.view.result = document.createElement('div');
                cell.view.result.classList.add('result');
                const node = document.createElement('textarea');
                node.placeholder = 'Enter code';
                node.rows = 20;
                node.value = string;
                node.classList.add('code-area');
                node.addEventListener('blur', (event) => {
                    evaluate();
                    cell.users.entries().filter((cell) => cell.update).forEach((cell) => cell.update);
                    saveState();
                    inputNode.focus();
                });
                node.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        node.blur();
                    }
                });
                cell.view.result.appendChild(node);
                const evaluate = () => {
                    const expr = node.value.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            `app.cells.at(${getIndex(index)}).value`);
                    try {
                        const args = string.split(/[\s+]/);
                        const func = new Function('app', ...args, `${expr}`);
                        const result = func(app);
                        app.setStatus(result);
                        return result;
                    } catch (error) {
                        app.setStatus(error.message);
                        return error.message;
                    }
                };
                Object.defineProperties(cell, {
                    value: {
                        enumerable: true,
                        get: evaluate,
                    },
                    content: {
                        enumerable: true,
                        get: () => node.value,
                        set: (value) => node.value = value,
                    },
                });
                cell.focus = node;
            },

            /**
             * Create a js cell
             */
            js(cell) {
                const string = cell.raw.replace(/^js\s*/, '');
                const index = app.cells.length;

                const cells = getReferences(string, cell);

                const getIndex = (str) => {
                    const i = parseInt(str);
                    if (isNaN(i)) {
                        return index - 1;
                    }
                    if (i < 0) {
                        return index + (i % index);
                    }
                    return i % index;
                };

                cell.update = (time) => {
                    cell.content = cells.map((cell) => cell.value).join('\n');
                    const expr = cell.content.replace(/^\\/, '')
                        .replace(/<(-?[0-9]*)>/g, (match, index) =>
                            `app.cells.at(${getIndex(index)}).value`);
                    try {
                        const func = new Function('app', `${expr}`);
                        cell.value = func(app);
                    } catch (error) {
                        cell.value = error.message;
                    }
                    app.setStatus(cell.value);
                    cell.view.result.innerText = cell.value;
                    cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'start' });
                };
            },


            /**
             * Reset command history
             */
            reset(cell) {
                cell.prompt = 'Reset all? (Y/n)';
                cell.action = (input) => {
                    app.action = null;
                };
            },

            /**
             * Add a date to the named items
             */
            date(cell) {
                const string = cell.raw.replace(/date\s*/, '');
                const parts = string.split(/(\s+)/g);
                const date = parts.pop();
                const name = parts.join('').trim();
                const [day, month, year] = date.split(/[-/_]/g).map((s) => parseInt(s));
                named.dates[name] = named.dates[name] || [];
                named.dates[name].push(new Date(year < 2000 ? year + 2000 : year, month - 1, day));
                addNamedItem(name);
                cell.value = named.dates[name];
                app.notifyListeners('dates', { action: 'add', value: { name: named.dates[name] } });
            },

            /**
             * List dates
             */
            dates(cell) {
                cell.value = Object.entries(named.dates)
                    .map(([name, date]) => `${name}: ${date.toDateString()}`)
                    .join('<br>');
            },


            /**
             * Add a site to the named items
             */
            site(cell) {
                const string = cell.raw.replace(/site\s*/, '');
                const [name, addr] = string.split(/\s*http/);
                const url = `http${addr}`;
                this[name] = (cell) => {
                    window.open(url, '_blank');
                    cell.value = `<a href="url">${name}</a>`;
                };
                named.sites[name] = url;
                addNamedItem(name);
                cell.type = Status;
                cell.value = `added shortcut ${name} -> ${url}`;
                saveState();
            },

            /**
             * List sites
             */
            sites(cell) {
                cell.value = Object.entries(named.sites)
                    .map(([name, item]) => `${name}: <a href="${item.url}">${item.url}</a>`)
                    .join('<br>');
            },

            /**
             * Add an abbreviation
             */
            abbr(cell) {
                const string = cell.raw.replace(/abbr\s*/, '');
                const parts = string.split(/(\s+)/);
                const name = parts.shift();
                const expansion = parts.join('').trim();
                named.abbreviations[name] = expansion;
                addNamedItem(name);
                cell.value = `${name} -> ${expansion}`;
            },

            /**
             * List abbreviations
             */
            abbreviations(cell) {
                cell.value = Object.entries(named.abbreviations)
                    .map(([name, expansion]) => `${name}: ${expansion}`)
                    .join('<br>');
            },

            /**
             * Load a file using a handle in the database
             */
            load(cell) {
                if (!navigator.userActivation.isActive) {
                    cell.value = 'load request ignored in script';
                    return;
                }

                const chooseFile = async () => {
                    if ('showOpenFilePicker' in self) {
                        const [fileHandle] = await window.showOpenFilePicker();
                        if (fileHandle) {
                            cell.view.result.innerHTML = `Loading...`;
                            const file = await fileHandle.getFile();
                            cell.content = file.name;
                            cell.value = await file.text();
                            cell.view.result.innerHTML = `<pre>${cell.value}</pre>`;
                            saveFileHandles([{ name: file.name, handle: fileHandle }]);
                        }
                    }
                };

                const file = cell.raw.replace(/^\s*load\s*/, '');
                if (file) {
                    load(cell, file, (contents) => cell.view.result.innerHTML = `<pre>${contents}</pre>`);
                } else {
                    cell.value = `Select File...`;
                    chooseFile();
                }
            },

            /**
             * Save the contents of the specified cells
             */
            save(cell) {
                const string = cell.raw.replace(/^\s*save\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]
                const cells = getReferences(string.replace(pattern, ''), cell);

                let fileHandle;
                cell.update = async () => {
                    if (fileHandle) {
                        const contents = cells.map((cell) => cell.value).join('\n');
                        // Create a FileSystemWritableFileStream to write to.
                        const writable = await fileHandle.createWritable();
                        // Write the contents of the file to the stream.
                        await writable.write(contents);
                        // Close the file and write the contents to disk.
                        await writable.close();
                    }
                }

                const pickfile = async () => {
                    fileHandle = await window.showSaveFilePicker(options);
                    const file = await fileHandle.getFile();
                    cell.contents = file.name;
                    cell.raw += ` as ${file.name}`;
                    saveFileHandles([{ name: file.name, handle: fileHandle }]);
                }

                if (filename && named.files[filename]) {
                    fileHandle = named.files[filename];
                } else {
                    const options = {
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                    };
                    pickfile();
                }
                cell.update();
            },

            /**
             * Save the session
             */
            'save session'(cell) {
                const string = cell.raw.replace(/^\s*save session\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]

                cell.update = async () => {
                    if (cell.fileHandle) {
                        const contents = JSON.stringify({ app, named });
                        // Create a FileSystemWritableFileStream to write to.
                        const writable = await cell.fileHandle.createWritable();
                        // Write the contents of the file to the stream.
                        await writable.write(contents);
                        // Close the file and write the contents to disk.
                        await writable.close();
                    }
                }

                const pickfile = async (options) => {
                    cell.fileHandle = await window.showSaveFilePicker(options);
                    const file = await cell.fileHandle.getFile();
                    cell.contents = file.name;
                    cell.raw += ` as ${file.name}`;
                    saveFileHandles([{ name: file.name, handle: cell.fileHandle }]);
                    cell.update();
                }

                if (cell.filename && named.files[filename]) {
                    cell.fileHandle = named.files[filename];
                    cell.update();
                } else {
                    const options = {
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.json'],
                                },
                            },
                        ],
                    };
                    pickfile(options);
                }
            },

            /**
             * Show a status bar
             */
            'status bar'(cell) {
                const string = cell.raw.replace(/^\s*status bar\s*/, '');

                let update;

                cell.type = Status;
                if (document.getElementById('status-bar')) {
                    document.getElementById('status-bar').remove();
                    update = false;
                    app.statusBar = false;
                } else {
                    const bar = document.createElement('div');
                    bar.id = 'status-bar';
                    document.getElementById('header').appendChild(bar);
                    update = true;
                    app.statusBar = true;
                }

                const node = document.getElementById('status-bar');
                const network = document.createElement('div');
                network.classList.add('status-bar-time');
                node.appendChild(network);

                const time = document.createElement('div');
                time.classList.add('status-bar-time');
                node.appendChild(time);

                const refresh = () => {
                    network.innerHTML = navigator.connection.type || '';
                    const now = new Date();
                    time.innerHTML = now.toLocaleTimeString();
                    if (update) {
                        requestAnimationFrame(refresh);
                    }
                }
                refresh();
            },


            /**
             * Save the session
             */
            'load session'(cell) {
                const string = cell.raw.replace(/^\s*load session\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]

                const update = async () => {
                    if (cell.filename && named.files[cell.filename]) {
                        const handle = named.files[cell.filename];
                        if (await verifyPermission(handle)) {
                            const file = await handle.getFile();
                            cell.contents = await file.text();
                            try {
                                const state = JSON.parse(cell.contents);
                                restoreState(state);
                            } catch (error) {
                                app.setStatus(error.message);
                            }
                        } else {
                            console.log('Permission not granted for file :(');
                        }
                    }
                }

                const chooseFile = async () => {
                    const [fileHandle] = await window.showOpenFilePicker();
                    if (fileHandle) {
                        cell.filename = fileHandle.name;
                        named.files[cell.filename] = fileHandle;
                        const file = await fileHandle.getFile();
                        cell.raw += ` ${cell.filename}`;
                        saveFileHandles([{ name: cell.filename, handle: fileHandle }]);
                        update();
                    }
                }

                if (cell.filename && named.files[cell.filename]) {
                    update();
                } else if ('showOpenFilePicker' in self) {
                    chooseFile();
                }
            },

            saveSvg(cell) {
                const string = cell.raw.replace(/^\s*saveSvg\s*/, '');
                const pattern = /\s+as (\S+)/;
                const filename = string.match(pattern)?.[1]
                const cells = getReferences(string.replace(pattern, ''), cell);

                cell.update = () => {
                    cells.filter((cell) => cell.svg).forEach((cell, index) =>
                        cells.length > 1 ? convertSVGtoImg(cell.svg, `${filename}_${index}.png`) : convertSVGtoImg(cell.svg, `${filename}.png`));
                };

                cell.update();
            },

            /**
             * Load user specified data file
             */
            loadData(cell) {
                if (!navigator.userActivation.isActive) {
                    cell.value = 'loadData request ignored in script';
                    return;
                }
                const file = cell.raw.replace(/^\s*loadData\s*/, '');

                const process = (contents) => {
                    cell.value = contents;
                    cell.view.result.innerHTML = `<pre>${cell.value}</pre>`;

                    let sectionName;
                    let current;
                    const section = /^[^\s]+[^:]*:\s*$/;
                    const data = {};
                    cell.value.split(/\r?\n/g).forEach((line) => {
                        if (section.test(line)) {
                            sectionName = line.replace(/:\s*$/, '');
                            data[sectionName] = named[sectionName] || {};
                        } else if (sectionName && line.trim() !== '') {
                            const [pre, ...values] = line.split(/:/);
                            const name = pre.trim();
                            const value = values.join(':').trim();
                            data[sectionName][name] = data[sectionName][name] || [];
                            data[sectionName][name].push(value);
                        }
                    });
                    if (data.abbreviations) {
                        Object.entries(data.abbreviations).forEach(([name, expansion]) => {
                            named.abbreviations[name] = {
                                eval(cell) {
                                    cell.value = expansion
                                },
                            };
                            addNamedItem(name);
                        });
                    }
                    if (data.dates) {
                        Object.entries(data.dates).forEach(([name, dates]) => {
                            named.dates[name] = {
                                eval(cell) {
                                    cell.value = getDate(dates[0])
                                },
                                value: getDate(dates[0]),
                            };
                            addNamedItem(name);
                        });
                    }
                    if (data.sites) {
                        Object.entries(data.sites).forEach(([name, urls]) => {
                            const url = urls[0];
                            named.sites[name] = {
                                eval(cell) {
                                    const windowReference = window.open(url, name, 'pop');
                                    named.sites[name] = url;
                                    if (windowReference) {
                                        windowReference.focus();
                                    }
                                    cell.type = Status;
                                    cell.value = `<a href="url">${name}</a>`;
                                },
                                url,
                            };
                            addNamedItem(name);
                        });
                    }
                    if (data.holidays) {
                        Object.entries(data.holidays).forEach(([date, name]) => {
                            calendar.holidays.push(calendar.dayNumber(getDate(date)));
                            if (name) {
                                named.holidays[name] = named.holidays[name] || {
                                    eval(cell) {
                                        cell.value = date[0];
                                    },
                                    dates: [],
                                }
                                named.holidays[name].dates.push(date);
                                addNamedItem(name);
                            }
                        });
                    }
                    app.notifyListeners('dates', { action: 'added', values: data.dates });
                    cell.users.forEach((user) => user.update());
                }

                const chooseFile = async () => {
                    const [fileHandle] = await window.showOpenFilePicker();
                    if (fileHandle) {
                        const file = await fileHandle.getFile();
                        cell.raw += ` ${file.name}`;
                        cell.content = file.name;
                        const contents = await file.text();
                        process(contents);
                        saveFileHandles([{ name: file.name, handle: fileHandle }]);
                        saveState();
                    }
                }

                if (file) {
                    load(cell, file, process);
                } else {
                    if ('showOpenFilePicker' in self) {
                        chooseFile();
                    }
                }
            },
        }

        const named = {
            dates: {},
            holidays: {},
            sites: {},
            abbreviations: {},
            files: {},
        }
        Object.defineProperties(named, {
            all: {
                get() {
                    return Object.values(this).reduce((all, value) => Object.assign(all, value), {});
                },
            }
        })

        Object.keys(actions).forEach(addNamedItem);

        const inputNode = document.getElementById('command-entry');

        const action = {};
        document.body.addEventListener('mousemove', (event) => {
            if (action.move) {
                action.move(event);
            }
        });
        document.body.addEventListener('mouseup', (event) => {
            if (action.move) {
                action.move = null;
                inputNode.focus();
            }
            document.body.classList.remove('noselect');
            saveState();
            for (const node of document.querySelectorAll('.dragging')) {
                node.classList.remove('dragging');
            }
        });

        document.body.addEventListener('focusin', () => {
            const cell = app.cells.find((cell) => cell.view?.cell?.contains(document.activeElement));
            app.setCurrentCell(cell);
        });

        document.body.addEventListener('focusout', () => {
            setTimeout(() => {
                if (document.activeElement === document.body) {
                    inputNode.focus();
                }
            }, 10);
        });


        class Cell {
            constructor(raw, content, expr, resolved, uses = []) {
                this.raw = raw;
                this.timestamp = new Date();
                this.expr = expr ?? raw;
                this.resolved = resolved ?? raw;
                this.content = content;
                this.value = content;
                this.uses = new Set(uses);
                this.users = new Set();
                this.view = {};
                this.modes = new Set();
            }
            get index() {
                return app.cells.indexOf(this);
            }
            getName() {
                const name = [];
                name.push(`${app.cells.indexOf(this)}:`);
                if (this.name) {
                    name.push(this.name);
                }
                name.push(this.raw);
                return name.join(' ');
            }
            getResultNode() {
                const node = document.createElement('div');
                node.classList.add('result');
                node.innerHTML = this.value ?? '';
                return node;
            }
            makeView() {
                this.view.cell = document.createElement('div');
                this.view.cell.addEventListener('click', (event) => app.setCurrentCell(this));
                this.view.cell.classList.add('cell');

                this.view.index = document.createElement('span');
                this.view.index.classList.add('index');
                this.view.cell.appendChild(this.view.index);
                this.view.index.addEventListener('click', (event) => {
                    const str = ` <${app.cells.indexOf(this)}>`;
                    const pos = inputNode.selectionStart;
                    inputNode.value = inputNode.value.slice(0, pos) + str + inputNode.value.slice(pos);
                    inputNode.focus();
                    inputNode.selectionStart = inputNode.selectionEnd = pos + str.length;
                });

                this.view.input = this.view.input || document.createElement('div');
                this.view.input.classList.add('input');
                this.view.cell.appendChild(this.view.input);

                this.view.container = document.createElement('div');
                this.view.container.classList.add('result-box');
                this.view.cell.appendChild(this.view.container);

                const references = {
                    x: [],
                    y: [],
                };
                const mousemove = (event) => {
                    event.preventDefault();
                    this.setState('floating');

                    action.node.classList.add('dragging');

                    const x = event.clientX - action.start.x + action.pos.x;
                    const y = event.clientY - action.start.y + action.pos.y;
                    if (!event.ctrlKey) {
                        const x2 = references.x.reduce((x, rx) =>
                            Math.abs(rx - x) < 10 ? rx : x, x);
                        const y2 = references.y.reduce((y, ry) =>
                            Math.abs(ry - y) < 10 ? ry : y, y);
                        action.node.style.left = `${x2}px`
                        action.node.style.top = `${y2}px`;
                    } else {
                        action.node.style.left = `${x}px`
                        action.node.style.top = `${y}px`;
                    }
                    app.layoutChange();
                };

                this.view.input.addEventListener('mousedown', (event) => {
                    references.x.length = 0;
                    references.y.length = 0;
                    for (const node of document.querySelectorAll('.floating .result-box')) {
                        if (node !== this.view.result.parentElement) {
                            const box = node.getBoundingClientRect();
                            references.x.push(box.x, box.x + box.width, box.x - this.view.result.clientWidth);
                            references.y.push(box.y, box.y + box.height, box.y - this.view.result.clientHeight);
                        }
                    }
                    if (this.view.cell.classList.contains('sticky') ||
                        this.view.cell.classList.contains('floating')) {
                        action.node = this.view.cell;
                        action.move = mousemove;
                        action.start = { x: event.clientX, y: event.clientY };
                        action.pos = action.node.getBoundingClientRect();
                        document.body.classList.add('noselect');
                        document.getElementById('results').appendChild(this.view.cell);
                    }
                });

                this.view.raw = this.view.raw || document.createElement('span');
                this.view.raw.classList.add('raw');
                this.view.raw.innerText = this.raw;
                this.view.input.appendChild(this.view.raw);
                this.view.raw.addEventListener('dblclick', (event) => {
                    if (event.ctrlKey) {
                        this.view.raw.contentEditable = true;
                        this.view.raw.focus();
                    } else {
                        if (this.state === 'hidden') {
                            this.setState('normal');
                        } else {
                            this.setState('hidden');
                        }
                        /*
                        this.view.result.classList.toggle('hidden');
                        this.view.input.classList.toggle('dim');
                        */
                    }
                });
                this.view.raw.addEventListener('blur', (event) => {
                    this.view.raw.contentEditable = false;
                    this.raw = this.view.raw.innerText;
                });

                if (this.raw !== this.resolved) {
                    const arrow = document.createElement('span');
                    arrow.innerHTML = ' &rarr; ';
                    this.view.input.appendChild(arrow);

                    this.view.resolved = this.view.resolved || document.createElement('span');
                    this.view.resolved.classList.add('resolved');
                    this.view.resolved.innerHTML = this.resolved;
                    this.view.input.appendChild(resolvedNode);
                }
                this.view.result = this.view.result || this.getResultNode();
                this.view.result.draggable = true;
                this.view.result.addEventListener('dragstart', (event) => {
                    event.dataTransfer.setData('text/plain', this.value);
                    const box = this.view.result.getBoundingClientRect();
                    const placeholder = document.getElementById('placeholder');
                    placeholder.style.width = `${box.width}px`;
                    placeholder.style.height = `${box.height}px`;
                    app.dragging = this.view.result;
                });
                this.view.result.addEventListener('dragover', (event) => {
                    if (event.dataTransfer.types.includes('Files')) {
                    } else {
                        const placeholder = document.getElementById('placeholder');
                        placeholder.classList.remove('hidden');
                        const parent = this.view.result.parentElement;
                        //app.dragging.replaceWith(placeholder);
                        const box = this.view.result.getBoundingClientRect();
                        if (event.clientY < box.y + box.height / 2) {
                            parent.insertBefore(app.dragging, this.view.result);
                        } else {
                            parent.insertBefore(app.dragging, this.view.result.nextSibling)
                        }
                    }
                });
                this.view.result.addEventListener('dragend', (event) => {
                    placeholder.classList.add('hidden');
                });
                /*
            this.view.result.addEventListener('dragover', (event) => {
                event.preventDefault();
            });
            */
                this.view.container.appendChild(this.view.result);
            }
            getSettings() {
                return undefined;
            }
            serialiseContent() {
                return this.content;
            }
            toJSON(key) {
                if (this.type === Status) {
                    return undefined;
                }
                const state = {};
                const view = {};
                if (this.view) {
                    const box = this.view.cell.getBoundingClientRect();

                    view.state = this.state;
                    if (this.state === 'floating') {
                        view.box = this.view.box || { x: box.x, y: box.y, width: box.width, height: box.height };
                    }
                    view.modes = Array.from(this.modes).filter((mode) => mode);
                }

                return {
                    raw: this.raw,
                    timestamp: this.timestamp.getTime(),
                    content: this.serialiseContent(),
                    view,
                    settings: this.getSettings(),
                }
            }
            changeState(state) {
                this.state = state;
                const states = ['normal', 'sticky', 'floating', 'widget', 'collapsed', 'hidden'];

                this.view.cell.style.top = '';
                this.view.cell.style.left = '';
                this.view.cell.style.bottom = '';

                if (state === 'sticky') {
                    const top = Math.max(0, ...Array.from(document.querySelectorAll('.sticky'))
                        .map((node) => {
                            const box = node.getBoundingClientRect();
                            return box.y + box.height;
                        })
                    );
                    this.view.cell.style.top = `${top}px`;
                    this.view.cell.style.left = 0;
                    this.view.cell.style.bottom = 0;
                } else if (this.lastState === 'sticky') {
                    const box = this.view.cell.getBoundingClientRect();
                    this.view.cell.classList.remove('sticky');
                    Array.from(document.querySelectorAll('.sticky'))
                        .filter((node) => node.getBoundingClientRect().y > box.y)
                        .forEach((node) => node.style.top = `${node.getBoundingClientRect().y - box.height}px`);
                }

                if ((state === 'floating' || state === 'widget') && !(this.lastState === 'floating' || this.lastState === 'widget')) {
                    this.view.placeholder = this.view.placeholder || document.createElement('div');
                    this.view.cell.replaceWith(this.view.placeholder);
                } else if (!(state === 'floating' || state === 'widget') && (this.lastState === 'floating' || this.state === 'widget')) {
                    this.view.placeholder.replaceWith(this.view.cell);
                }

                if (state === 'widget') {
                    document.getElementById('widgets').appendChild(this.view.cell);
                    this.view.cell.title = `${this.index}: ${this.raw}`;
                }

                if (state === 'floating') {
                    document.getElementById('results').appendChild(this.view.cell);
                    if (this.view.box) {
                        this.view.cell.style.top = `${this.view.box.top}px`;
                        this.view.cell.style.left = `${this.view.box.left}px`;
                        this.view.cell.style.width = `${this.view.box.width}px`;
                        this.view.cell.style.height = `${this.view.box.height}px`;
                    } else {
                        this.view.cell.style.top = '20%';
                        this.view.cell.style.left = '20%';
                    }
                } else if (this.lastState === 'floating') {
                    this.view.box = this.view.cell.getBoundingClientRect();
                }

                const classes = this.view.cell.classList;
                states.forEach((possibleState) => possibleState === state ? classes.add(state) : classes.remove(possibleState));

                if (state === 'normal') {
                    this.view.cell.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'start' });
                }
            }
            setState(state) {
                if (state !== this.state) {
                    this.lastState = this.state;
                    this.changeState(state);
                }
            }
            lastState() {
                const state = this.lastState || this.defaultState || 'normal';
                this.changeState(state);
            }
            setMode(mode) {
                this.modes.add(mode);
                this.view.cell.classList.add(mode);
            }
            clearMode(mode) {
                this.modes.delete(mode);
                this.view.cell.classList.remove(mode);
            }
            remove() {
                if (this.view.cell) {
                    this.view.cell.remove();
                }
                this.uses.forEach((input) => input.users.delete(this));
                this.users.forEach((user) => user.uses.delete(this));
            }
        }


        /**
         * Create and editable span.
         */
        function editableSpan(get, set) {
            const node = document.createElement('span');
            node.contentEditable = true;
            node.innerText = get();
            node.addEventListener('blur', (event) => set(node));
            let previous;
            node.addEventListener('focus', (event) => {
                node.innerText = get();
                previous = node.innerText;
            });
            node.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    set(node);
                }
                if (event.key === 'escape') {
                    node.innerText = previous;
                }
            });

            return node;
        }

        /**
         * Create and editable span.
         */
        function expander(getState, expand, collapse) {
            const node = document.createElement('span');
            node.classList.add('expander');

            const toggle = (event) => {
                if (getState() === 'expanded') {
                    node.innerHTML = '&#128449;';//'&#9654;';
                    collapse(event);
                } else if (getState() === 'collapsed') {
                    node.innerHTML = '&#128448;';//'&#9660;';
                    expand(event);
                } else {
                    node.innerHTML = '&#128462;';
                }
            };

            if (getState() === 'expanded') {
                node.innerHTML = '&#128449;';//'&#9660;';
            } else if (getState() === 'collapsed') {
                node.innerHTML = '&#128448;';//'&#9654;';
            } else {
                node.innerHTML = '&#128462;';
            }

            node.addEventListener('click', (event) => toggle(event));
            return node;
        }

        /**
         * Flatten a tree to a set of nodes
         */
        function flatten(node, getParts = (node) => node[meta].parts, expanded = new Set()) {
            if (expanded.has(node)) {
                console.log('tree contains circular relationship');
                return expanded;
            }
            expanded.add(node);
            if (Array.isArray(getParts(node))) {
                getParts(node).forEach((node) => flatten(node, getParts, expanded));
            }
            return expanded;
        }


        /**
         * Data for simple todos
         */
        class ToDo {
            constructor(detail, raised, done, title) {
                this.update(detail, raised, done, title);
                // Add to the global list of todos.
                app.addTyped(this);
                app.notifyListeners('todos', { action: 'new', todo: this });
            }
            update(detail, raised, done, title) {
                raised = detail.raised ?? raised;
                this.raised = raised ? new Date(raised) : new Date();

                done = detail.done ?? done;
                this.done = done ? new Date(done) : null;

                this.title = detail.title ?? title;
                this.detail = detail.detail ?? detail;
            }
            toString() {
                return this.detail;
            }
            complete(done) {
                this.done = done ? new Date(done) : new Date();
                app.notifyListeners('todos', { action: 'complete', todo: this });
            }
            toShortHTML() {
                if (this.done) {
                    return `<span class="dim"><s>${this.title || this.detail}</s></span>`;
                }
                return `<span>${this.title || this.detail}</span>`;
            }
        }


        const meta = Symbol('meta');

        /**
         * Convert a tree that uses symbol keys into a plain tree
         */
        function serialiseTree(all) {
            return all.map((source) => ({ parts: source[meta].parts.map((part) => all.indexOf(part)), data: source }));
        }

        /**
         * Convert a tree that uses symbol keys into a plain tree
         */
        function makeTree(all) {
            return all.map((source) => {
                source.data[meta] = {
                    parts: source.parts.map((part) => all[part].data),
                };
                source.data[meta].parts.forEach((part) => part[meta].parent = source.data);
                return source.data;
            }).filter((node) => !node.parent);
        }

        /**
         * Cell types applied to a cell after creation.
         */
        const cellTypes = {
            /**
             * Add a clock to the widget area
             */
            clock: {
                defaultState: 'widget',
                init() {
                },
                getResultNode() {
                    const canvas = document.createElement('canvas');
                    canvas.classList.add('clock');
                    this.context = canvas.getContext('2d');
                    return canvas;
                },
                update() {
                    this.value = new Date();

                    const width = this.context.width = this.view.result.clientWidth;
                    const height = this.context.height = this.view.result.clientHeight;
                    const radius = Math.min(width, height) / 2;

                    const dayStart = new Date();
                    dayStart.setHours(0);
                    dayStart.setMinutes(0);
                    dayStart.setSeconds(0);
                    dayStart.setMilliseconds(0);
                    const style = window.getComputedStyle(document.body);

                    const colour = style.getPropertyValue('--colour');
                    const dim = style.getPropertyValue('--dim');
                    this.value = new Date();
                    const time = (this.value.getTime() - dayStart.getTime()) / 1000;
                    this.context.clearRect(0, 0, width, height);
                    this.context.fillStyle = colour;
                    this.context.strokeStyle = colour;
                    this.context.beginPath();
                    for (let i = 0; i < 12; ++i) {
                        const x1 = width / 2 + radius * Math.sin(i * 2 * Math.PI / 12);
                        const y1 = height / 2 - radius * Math.cos(i * 2 * Math.PI / 12);
                        this.context.moveTo(x1, y1);
                        const x2 = width / 2 + (radius - 5) * Math.sin(i * 2 * Math.PI / 12);
                        const y2 = height / 2 - (radius - 5) * Math.cos(i * 2 * Math.PI / 12);
                        this.context.lineTo(x2, y2);
                    }
                    const x2 = width / 2 + 0.8 * radius * Math.sin(time * 2 * Math.PI / 3600);
                    const y2 = height / 2 - 0.8 * radius * Math.cos(time * 2 * Math.PI / 3600);
                    this.context.moveTo(width / 2, height / 2);
                    this.context.lineTo(x2, y2);
                    const x3 = width / 2 + 0.6 * radius * Math.sin(time * 2 * Math.PI / (12 * 3600));
                    const y3 = height / 2 - 0.6 * radius * Math.cos(time * 2 * Math.PI / (12 * 3600));
                    this.context.moveTo(width / 2, height / 2);
                    this.context.lineTo(x3, y3);
                    this.context.stroke();

                    this.context.fillStyle = dim;
                    this.context.strokeStyle = dim;
                    this.context.beginPath();

                    const seconds = Math.floor(time);
                    const x1 = width / 2 + 0.95 * radius * Math.sin(seconds * 2 * Math.PI / 60);
                    const y1 = height / 2 - 0.95 * radius * Math.cos(seconds * 2 * Math.PI / 60);
                    this.context.moveTo(width / 2, height / 2);
                    this.context.lineTo(x1, y1);
                    this.context.stroke();

                    requestAnimationFrame(() => this.update());
                }
            },

            calendar: {
                defaultState: 'widget',
                init() {
                    const parameters = this.raw.replace(/\s*newCalendar\s*/, '');
                    const pattern = /((?<day>[0-9]{1,2})[-\/\._])?(?<month>[0-9]{1,2})[-\/\._](?<year>[0-9]{1,4})[-\/\._]/;
                    const match = parameters.match(pattern);
                    const now = new Date();
                    if (match) {
                        const day = parseInt(match.groups.day) || 1;
                        const month = parseInt(match.groups.month) || 1;
                        const year = parseInt(match.groups.year) || now.getFullYear();
                        this.calendarDate = new Date(Year < 2000 ? year + 2000 : year, month - 1, day);
                    } else {
                        this.calendarDate = now;
                    }
                },
                getResultNode() {
                    this.value = new Date();

                    const calendarWidget = document.createElement('div');
                    calendarWidget.classList.add('calendar');

                    const previousMonth = document.createElement('span');
                    previousMonth.innerHTML = '&lt;';
                    previousMonth.classList.add('calendar-day');
                    calendarWidget.appendChild(previousMonth);
                    previousMonth.addEventListener('click', (event) => {
                        this.calendarDate.setMonth(this.calendarDate.getMonth() - 1);
                        update()
                    });

                    const monthName = document.createElement('span');
                    monthName.classList.add('calendar-month-name');
                    calendarWidget.appendChild(monthName);

                    const nextMonth = document.createElement('span');
                    nextMonth.innerHTML = '&gt;';
                    nextMonth.classList.add('calendar-day');
                    calendarWidget.appendChild(nextMonth);
                    nextMonth.addEventListener('click', (event) => {
                        this.calendarDate.setMonth(this.calendarDate.getMonth() + 1);
                        update()
                    });

                    'SMTWTFS'.split('').forEach((c) => {
                        const day = document.createElement('span');
                        day.classList.add('calendar-day');
                        day.innerHTML = c;
                        calendarWidget.appendChild(day);
                    });
                    const days = [];
                    for (let i = 0; i < 42; ++i) {
                        const day = document.createElement('span');
                        day.classList.add('calendar-day');
                        calendarWidget.appendChild(day);
                        days.push(day);
                    }

                    const update = () => {
                        const today = new Date();
                        monthName.innerHTML = this.calendarDate.toLocaleDateString('en-AU', { month: 'long' });
                        const month = this.calendarDate.getMonth();
                        const year = this.calendarDate.getFullYear();
                        const date = new Date(year, month, 1);
                        date.setDate(date.getDate() - date.getDay());
                        const end = new Date(year, month + 1, 0);
                        end.setDate(end.getDate() + 7 - end.getDay());
                        days.forEach((day) => {
                            if (sameDay(today, date)) {
                                day.classList.add('calendar-day-today');
                            } else {
                                day.classList.remove('calendar-day-today');
                            }
                            if (date.getMonth() === month) {
                                day.classList.remove('calendar-day-fade');
                            } else {
                                day.classList.add('calendar-day-fade');
                            }
                            if (date < end) {
                                day.innerHTML = ('' + date.getDate()).padStart(2, '0');
                            } else {
                                day.innerHTML = '';
                            }
                            date.setDate(date.getDate() + 1);
                        });
                    }
                    update();
                    return calendarWidget;
                }
            },
            /**
             * Notes cell for adding free text
             */
            notes: {
                setContent(content) {
                    this.content = content;
                },
                init() {
                    this.content = '';
                    const parameters = this.raw.replace(/^\s*<[^>]+>[:#=]\s*/).replace(/^notes\s*/, '');
                    const args = getList(parameters);
                    const { cells, values } = args.reduce((results, value) => {
                        const index = Number(value);
                        if (app.namedCells[value] !== undefined) {
                            results.cells.push(app.namedCells[value]);
                            //link(app.namedCells[value], this);
                        } else if (!isNaN(index) && index > -app.cells.length && index < app.cells.length) {
                            results.cells.push(app.cells.at(index));
                            //link(app.cells.at(index), this);
                        } else {
                            results.values.push(value);
                        }
                        return results;
                    }, { cells: [], values: [] });
                    this.content = cells.map((cells) => cells.value).join('\n');
                    this.placeholder = '<enter text>';

                    Object.defineProperties(this, {
                        html: {
                            enumerable: true,
                            get() {
                                if (!this.content || this.content === '') {
                                    return `<span class="dim">${this.placeholder}</span>`;
                                }
                                const index = app.cells.length;
                                const getIndex = (str) => {
                                    const i = parseInt(str);
                                    if (isNaN(i)) {
                                        return index - 1;
                                    }
                                    if (i < 0) {
                                        return index + (i % index);
                                    }
                                    return i % index;
                                }

                                const content = this.content ?? '';
                                const resolved = content.replace(/^\\/, '')
                                    .replace(/<(-?[0-9]*)>/g, (match, index) =>
                                        index === this.index ? match : app.cells.at(getIndex(index)).value)
                                    .replace(/<([^>]+)>/g, (match, name) =>
                                        named.all[name] ?? match);//.replace(/ |\t/g, (match) => ({' ':'&nbsp;', '\t': ''}[match]));
                                const lines = content.split(/\r?\n/g);

                                return lines.map((line) => `<div class="line">${line}</div>`).join('');
                            },
                        },
                        value: {
                            enumerable: true,
                            get() {
                                const index = app.cells.length;
                                const getIndex = (str) => {
                                    const i = parseInt(str);
                                    if (isNaN(i)) {
                                        return index - 1;
                                    }
                                    if (i < 0) {
                                        return index + (i % index);
                                    }
                                    return i % index;
                                }

                                return (this.content ?? '').replace(/^\\/, '')
                                    .replace(/<(-?[0-9]*)>/g, (match, index) =>
                                        index === this.index ? match : app.cells.at(getIndex(index)).value)
                                    .replace(/<([^>]+)>/g, (match, name) =>
                                        named.all[name] ?? match);//.replace(/ |\t/g, (match) => ({' ':'&nbsp;', '\t': ''}[match]));
                            }
                        }
                    });
                },
                getTextAreaResultNode() {
                    this.view.result = document.createElement('textarea');
                    this.view.result.classList.add('notes');
                    this.view.result.placeholder = '<enter notes>';
                    this.view.result.value = this.value || '';
                    this.view.result.addEventListener('blur', (event) => {
                        this.content = this.view.result.value;
                        this.view.result.value = this.value;
                        this.view.result.rows = Math.max(1, this.view.result.value.split(/\n/).length);

                        this.users.forEach((user) => user.update());
                        saveState();
                        inputNode.focus();
                    });
                    this.view.result.addEventListener('focus', (event) => {
                        this.view.result.value = this.content;
                    });
                    this.view.result.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            this.view.result.blur();
                        }
                    });
                    this.view.result.addEventListener('input', (event) => {
                        this.view.result.rows = Math.max(1, this.view.result.value.split(/\n/).length);
                        this.view.result.style.height = '';
                        this.view.result.style.width = 'stretch';
                        this.view.result.style.maxHeight = 'stretch';
                    });
                    this.focus = this.view.result;
                    this.view.result.rows = Math.max(1, this.view.result.value.split(/\n/).length);
                    return this.view.result;
                },
                getResultNode() {
                    this.view.result = document.createElement('div');
                    this.view.result.classList.add('notes');

                    this.view.result.contentEditable = true;
                    this.view.result.spellcheck = false;
                    this.view.result.autocorrect = "off";
                    this.view.result.autocapitalize = "off";
                    this.view.result.translate = "no";
                    this.view.result.class = "cm-content cm-lineWrapping";
                    this.view.result.style = "tab-size: 2;";
                    this.view.result.role = "textbox";
                    /*
                    this.view.result.ariaMultiline = "true";
                    this.view.result.ariaLabelledby = "codemirror-label focus-trap-help-panel";
                    this.view.result.ariaAutocomplete = "list";
                    */

                    this.view.result.innerHTML = this.html;
                    this.view.result.addEventListener('blur', (event) => {
                        this.content = this.view.result.innerText;
                        this.view.result.innerHTML = this.html;
                        this.users.forEach((user) => user.update());
                        saveState();
                        inputNode.focus();
                    });
                    this.view.result.addEventListener('focus', (event) => {
                        this.view.result.innerText = this.content || '';
                    });
                    this.view.result.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            this.view.result.blur();
                        }
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            document.getSelection().getRangeAt(0).insertNode(document.createElement('br'));
                        }
                        if (event.key === 'Tab') {
                            event.preventDefault();
                            event.stopPropagation();
                            const selection = document.getSelection();
                            if (selection.isCollapsed && selection.rangeCount) {
                                selection.getRangeAt(0).insertNode(document.createTextNode('    '));
                            }
                        }
                    });
                    this.view.result.addEventListener('input', (event) => { });
                    this.focus = this.view.result;
                    return this.view.result;
                },
            },
            text: {
                setContent(content) {
                    this.value = this.content = content;
                },
                init(string, cells, parameters) {
                    if (named.files[parameters[0]]) {
                        load(this, parameters[0], (content) => {
                            this.value = content;
                            this.update();
                        });
                    } else {
                        this.content = cells.map((cell) => cell.value).join('\n');
                    }
                },
                getResultNode() {
                    return document.createElement('pre');
                },
                update() {
                    this.view.result.innerHTML = this.value;
                }
            },
            replace: {
                setContent(content) {
                    if (this.localInput) {
                        this.content = content;
                    }
                },
                init() {
                    const parameters = this.raw.replace(/^\s*<[^>]+>[:#=]\s*/).replace(/^replace\s*/, '');
                    if (parameters) {
                        const link = (from, to) => {
                            from.users.add(to);
                            to.uses.add(from);
                        };
                        const args = getList(parameters);
                        const { cells, values } = args.reduce((results, value) => {
                            const index = Number(value);
                            if (app.namedCells[value] !== undefined) {
                                results.cells.push(app.namedCells[value]);
                                link(app.namedCells[value], this);
                            } else if (!isNaN(index) && index > -app.cells.length && index < app.cells.length) {
                                results.cells.push(app.cells.at(index));
                                link(app.cells.at(index), this);
                            } else {
                                results.values.push(value);
                            }
                            return results;
                        }, { cells: [], values: [] });
                        this.cells = cells;
                        this.pattern = values[0];
                        this.replacement = values[1];
                    } else {
                        this.localInput = true;
                        this.content = '';
                    }
                },
                getResultNode() {
                    const container = document.createElement('div');

                    if (this.localInput) {
                        this.sourceNode = document.createElement('textarea');
                        this.sourceNode.classList.add('source');
                        this.sourceNode.placeholder = 'Enter source text';
                        this.sourceNode.value = this.content;
                        container.appendChild(this.sourceNode);
                        this.sourceNode.addEventListener('input', (event) => {
                            this.content = this.sourceNode.value;
                            dynamicUpdate(event)
                        });
                        this.sourceNode.addEventListener('change', (event) => update(event));
                    }

                    const controlsNode = document.createElement('div');
                    controlsNode.classList.add('controls');
                    container.appendChild(controlsNode);

                    const dynamicUpdate = (event) => {
                        if (dynamicUpdateNode.checked) {
                            this.update();
                        }
                    }
                    const update = (event) => {
                        this.update();
                    }

                    controlsNode.append('Pattern:');
                    this.patternNode = document.createElement('input');
                    controlsNode.appendChild(this.patternNode);
                    this.patternNode.placeholder = 'Search String';
                    this.patternNode.value = this.pattern || '';
                    this.patternNode.addEventListener('input', (event) => dynamicUpdate(event));
                    this.patternNode.addEventListener('change', (event) => update(event));

                    controlsNode.append('Replacement:');
                    this.replacementNode = document.createElement('input');
                    controlsNode.appendChild(this.replacementNode);
                    this.replacementNode.placeholder = 'Replacement';
                    this.replacementNode.value = this.replacement || '';
                    this.replacementNode.addEventListener('input', (event) => dynamicUpdate(event));
                    this.replacementNode.addEventListener('change', (event) => update(event));

                    controlsNode.append('Live:');
                    const dynamicUpdateNode = document.createElement('input');
                    dynamicUpdateNode.type = 'checkbox';
                    dynamicUpdateNode.checked = this.live ?? true;
                    controlsNode.appendChild(dynamicUpdateNode);
                    dynamicUpdateNode.addEventListener('input', (event) => dynamicUpdate(event));

                    this.outputNode = document.createElement('pre');
                    controlsNode.classList.add('output');
                    container.appendChild(this.outputNode);
                    this.outputNode.addEventListener('dblclick', (event) => this.outputNode.classList.toggle('shrink'));

                    return container;
                },
                update() {
                    try {
                        if (!this.localInput) {
                            this.content = this.cells.map((cell) => cell.value).join('\n');
                        }
                        const pattern = new RegExp(this.patternNode.value, 'g');
                        const replacement = this.replacementNode.value;
                        this.value = this.content.replace(pattern, replacement);
                        this.outputNode.innerText = this.value;
                    } catch (error) {
                        app.setStatus(error.message);
                    }
                    saveState();
                },
                getSettings() {
                    return {
                        pattern: this.patternNode?.value,
                        replacement: this.replacementNode?.value,
                        live: this.dynamicUpdate?.checked,
                    };
                },
                setSettings(settings) {
                    this.pattern = settings.pattern;
                    this.replacement = settings.replacement;
                    this.live = settings.live;
                },
            },
            todo: {
                defaultState: 'widget',
                init() {
                    const string = this.raw.replace(/^\s*todo\s*/, '');
                    this.content = new ToDo(string);
                },
                setContent(content) {
                    this.content.update(content);
                },
                update() {
                    this.view.result.innerHTML = `<span class="raised">${this.content.raised.toDateString()}</span><br><span class="details">${this.content.detail}</span>`;
                    if (this.content.done) {
                        this.view.result.innerHTML += `<br><span class="done">${this.content.done.toDateString()}</span>`;
                    }
                    if (!this.checkbox) {
                        this.checkbox = document.createElement('input');
                        this.checkbox.type = 'checkbox';
                        this.checkbox.classList.add('top-right');
                        this.checkbox.checked = this.content.done;
                        this.checkbox.addEventListener('change', (event) => {
                            if (this.checkbox.checked) {
                                this.content.complete();
                            } else {
                                this.content.done = null;
                                app.notifyListeners('todos', { action: 'uncomplete', todo: this });
                            }
                            this.update();
                        });
                    }
                    this.view.result.appendChild(this.checkbox);
                    this.view.result.classList.add('todo');
                    if (this.checkbox.checked) {
                        this.view.result.classList.add('done');
                    } else {
                        this.view.result.classList.remove('done');
                    }
                }
            },
            todos: {
                defaultState: 'floating',
                init() {
                    const string = this.raw.replace(/^\s*todo\s*/, '');
                    this.content = string;
                    app.addListener('todos', this);
                },
                update() {
                    const todos = app.types.get(ToDo) || [];
                    this.view.result.innerHTML = '<ul>' + todos.map((todo) => `<li>${todo.toShortHTML()}</li>`).join('') + '</ul>';
                }
            },
            table: {
                setContent(content) {
                    this.content = content;
                    this.rows = this.content.map((row) => ({ size: 'minmax(1em, max-content)' }));
                    const cols = Math.max(0, ...this.content.map((row) => row.length));
                    this.cols = [];
                    for (let col = 0; col < cols; ++col) {
                        this.cols.push({ size: 'minmax(2em, max-content)' });
                    }
                    //  this.update(true);
                },
                tableFromString(string) {
                    const data = string.split(/\r?\n/g).map((row) => row.split(/\s*,\s*/g));
                    const cols = data.shift().map((value) => ({ name: value }));
                    const rows = data.map((row) => ({ name: row.shift() }));
                    return { data, cols, rows };
                },
                init() {
                    let table = {};
                    if (table instanceof String) {
                        table = this.tableFromString(table);
                    }
                    const nRows = table.rows?.length || table.data?.length || 1;
                    const nCols = table.cols?.length || Math.max(0, ...(table.data?.map((row) => row.length) || [])) || 1;

                    this.content = Array.isArray(table.data) ? table.data : (table.data ? [[table.data]] : []);
                    this.cols = [];
                    this.rows = [];
                    this.deleted = [];

                    for (let x = 0; x < nCols; ++x) {
                        const col = table.cols?.[x] || {};
                        this.cols.push({ name: col.name, size: col.size || 'max-content' });
                    }
                    for (let y = 0; y < nRows; ++y) {
                        const row = table.rows?.[y] || {};
                        this.rows.push({ name: row.name, size: row.size || 'max-content' });
                    }
                },
                getResultNode() {
                    const resultNode = document.createElement('div');
                    resultNode.classList.add('table');
                    const background = document.createElement('div');
                    background.classList.add('grid');
                    resultNode.appendChild(background);

                    const getCell = () => {
                        let cell = document.activeElement;
                        while (!cell.classList.contains('table-cell') && cell.parentElement) {
                            cell = cell.parentElement;
                        }
                        return cell;
                    }
                    resultNode.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            inputNode.focus();
                        }
                        const cell = getCell();
                        const col = parseInt(cell.dataset.col);
                        const row = parseInt(cell.dataset.row);
                        if (event.ctrlKey) {
                            if (event.key === 'Delete') {
                                if (isNaN(col) && !isNaN(row)) {
                                    const deleted = {};
                                    deleted.rows = this.rows.splice(row, 1);
                                    deleted.content = this.content.splice(row, 1);
                                    this.deleted.push(deleted);
                                    this.update(true);
                                    if (row <= this.rows.length) {
                                        this.view.result.querySelector(`.cell-0-${row}`).focus();
                                    } else if (this.rows.length > 1) {
                                        this.view.result.querySelector(`.cell-0-${row - 1}`).focus();
                                    } else {
                                        inputNode.focus();
                                    }
                                }
                                if (!isNaN(col) && isNaN(row)) {
                                    const deleted = {};
                                    deleted.cols = this.cols.splice(col, 1);
                                    deleted.content = this.content.map((row) => row.splice(col, 1));
                                    this.deleted.push(deleted);
                                    this.update(true);
                                    if (col <= this.cols.length) {
                                        this.view.result.querySelector(`.cell-${col}-0`).focus();
                                    } else if (this.cols.length > 1) {
                                        this.view.result.querySelector(`.cell-${col - 1}-0`).focus();
                                    } else {
                                        inputNode.focus();
                                    }
                                }
                                event.preventDefault();
                            }
                        }
                        if (event.altKey) {
                            event.preventDefault();
                            if (event.key === 'ArrowRight') {
                                const newCol = col ?? 0;
                                if (!isNaN(col) && !isNaN(row)) {
                                    this.content[row][col] = cell.innerText;
                                }
                                if (event.shiftKey) {
                                    this.cols.splice(newCol, 0, { size: 'max-content' });
                                    this.content.forEach((row) => row.splice(newCol, 0, ''));
                                    this.update(true);
                                }
                                if (isNaN(col)) {
                                    this.view.result.querySelector(`.cell-0-${row}`).focus();
                                } else if (isNaN(row)) {
                                    this.view.result.querySelector(`.table-column-${(col + 1) % this.cols.length}`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-${((isNaN(col) ? -1 : col) + 1) % this.cols.length}-${row}`).focus();
                                }
                                saveState();
                            }
                            if (event.key === 'ArrowLeft') {
                                if (!isNaN(col) && !isNaN(row)) {
                                    this.content[row][col] = cell.innerText;
                                    if (event.shiftKey) {
                                        this.cols.splice(col, 0, { size: 'max-content' });
                                        this.content.forEach((row) => row.splice(col, 0, ''));
                                        this.update(true);
                                        this.view.result.querySelector(`.cell-${col}-${row}`).focus();
                                    } else if (col === 0) {
                                        this.view.result.querySelector(`.table-row-${row}`).focus();
                                    } else {
                                        this.view.result.querySelector(`.cell-${col - 1}-${row}`).focus();
                                    }
                                    saveState();
                                } else if (isNaN(row)) {
                                    this.view.result.querySelector(`.table-column-${(col > 0 ? col : this.cols.length) - 1}`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-${this.cols.length - 1}-${row}`).focus();
                                }
                            }
                            if (event.key === 'ArrowUp') {
                                if (!isNaN(row) && !isNaN(col)) {
                                    this.content[row][col] = cell.innerText;
                                    if (event.shiftKey) {
                                        this.rows.splice(row, 0, { size: 'max-content' });
                                        this.content.splice(row, 0, []);
                                        this.update(true);
                                        this.view.result.querySelector(`.cell-${col}-${row}`).focus();
                                    } else if (row === 0) {
                                        this.view.result.querySelector(`.table-column-${col}`).focus();
                                    } else {
                                        this.view.result.querySelector(`.cell-${col}-${row - 1}`).focus();
                                    }
                                    saveState();
                                } else if (isNaN(col)) {
                                    this.view.result.querySelector(`.table-row-${(row > 0 ? row : this.content.length) - 1}`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-${col}-${this.content.length - 1}`).focus();
                                }
                            }
                            if (event.key === 'ArrowDown') {
                                const newRow = row ?? 0;
                                if (!isNaN(row) && !isNaN(col)) {
                                    this.content[row][col] = cell.innerText;
                                }
                                if (event.shiftKey) {
                                    this.rows.splice(row, 0, { size: 'max-content' });
                                    this.content.splice(row, 0, []);
                                    this.update(true);
                                }
                                if (isNaN(row)) {
                                    this.view.result.querySelector(`.cell-${col}-0`).focus();
                                } else if (isNaN(col)) {
                                    this.view.result.querySelector(`.table-row-${(row + 1) % this.content.length}`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-${col}-${((isNaN(row) ? -1 : row) + 1) % this.content.length}`).focus();
                                }
                                saveState();
                            }
                            event.preventDefault();
                        }
                    });
                    return resultNode;
                },
                update(clear) {
                    const makeTemplate = (definition) => `max-content ${definition.map((col) => col.size).join(' ')}`;
                    this.view.result.style.gridTemplateColumns = makeTemplate(this.cols);
                    this.view.result.style.gridTemplateRows = makeTemplate(this.rows);
                    if (!Array.isArray(this.content)) {
                        this.content = this.content ? [[this.content]] : [];
                    }
                    if (clear) {
                        for (const node of this.view.result.querySelectorAll('.table-cell')) {
                            node.remove();
                        }
                    }
                    const updateCell = (cell, x, y) => {
                        const cls = `cell-${x}-${y}`;
                        const node = this.view.result.querySelector(`.${cls}`) || editableSpan(
                            () => this.content[y][x] || '',
                            (node) => this.content[y][x] = node.innerText);

                        if (!node.classList.contains(cls)) {
                            node.style.gridColumn = x + 2; // Grid column is 1-based and allow column for row names
                            node.style.gridRow = y + 2; // Grid row is 1-based and allow row for column names
                            node.classList.add('table-cell', 'table-body-cell', cls);
                            node.dataset.col = x;
                            node.dataset.row = y;
                            this.view.result.appendChild(node);
                        }

                        node.innerText = this.content[y]?.[x] ?? '';
                        node.title = `cell[${this.rows?.[y].name || y}][${this.cols?.[x].name || x}]`;
                        node.classList.add('table-data');
                    }

                    const cols = [{ name: '' }, ...this.cols];
                    const rows = [{ name: '' }, ...this.rows];

                    const titleNode = this.view.result.querySelector(`.title-cell`) || document.createElement('span');
                    titleNode.title = `Table Name: ${this.name || Unnamed}`;
                    titleNode.innerText = this.name;
                    if (!titleNode.classList.contains('titleNode')) {
                        titleNode.style.gridColumn = 1;
                        titleNode.style.gridRow = 1;
                        titleNode.classList.add('table-cell', 'table-header', 'table-name');
                        this.view.result.appendChild(titleNode);
                    }

                    this.content.forEach((row, rowIndex) =>
                        row.forEach((cell, columnIndex) => updateCell(cell, columnIndex, rowIndex)));

                    this.cols.forEach((column, index) => {
                        const cls = `table-column-${index}`;
                        const node = this.view.result.querySelector(`.${cls}`) || editableSpan(
                            () => this.cols[index].name || '',
                            (node) => {
                                this.cols[index].name = node.innerText;
                                node.innerText = node.innerText || index;
                            });
                        node.title = `Column: ${column.name || index}`;
                        node.innerText = column.name || index;
                        if (!node.classList.contains('titleNode')) {
                            node.style.gridColumn = index + 2; // Grid column is 1-based and allow a column for row names
                            node.style.gridRow = 1;
                            node.dataset.col = index;
                            node.classList.add('table-cell', 'table-header', 'table-column-header', cls);
                            this.view.result.appendChild(node);
                        }
                    });
                    this.rows.forEach((row, index) => {
                        const cls = `table-row-${index}`;
                        const node = this.view.result.querySelector(`.${cls}`) || editableSpan(
                            () => this.rows[index].name || '',
                            (node) => {
                                if (index < this.rows.length) {
                                    this.rows[index].name = node.innerText;
                                    node.innerText = node.innerText || index;
                                }
                            });
                        node.title = `row: ${row.name || index}`;
                        node.innerText = row.name || index;
                        if (!node.classList.contains('titleNode')) {
                            node.style.gridRow = index + 2; // Grid row is 1-based and allow a row for column names
                            node.style.gridColumn = 1;
                            node.dataset.row = index;
                            node.classList.add('table-cell', 'table-header', 'table-row-header', cls);
                            this.view.result.appendChild(node);
                        }
                    });
                },
            },
            'working days': {
                init() {
                    app.addListener('dates', this);
                    this.content = { from: {}, to: {} };
                },
                getResultNode() {
                    const eventNames = Object.keys(named.dates);
                    eventNames.sort((a, b) => a.localeCompare(b));
                    const container = document.createElement('div');
                    container.append('From: ')
                    this.fromEvent = document.createElement('select');
                    this.fromEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                    this.fromEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                    container.appendChild(this.fromEvent);

                    this.from = document.createElement('input');
                    this.from.type = 'date';
                    container.appendChild(this.from);
                    this.from.addEventListener('change', (event) => {
                        this.content.from.date = this.from.value;
                        this.update();
                    });

                    this.fromEvent.addEventListener('change', (event) => {
                        this.content.from.event = this.fromEvent.value;
                        this.update();
                    });

                    container.append('To: ')
                    this.toEvent = document.createElement('select');
                    this.toEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                    this.toEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                    container.appendChild(this.toEvent);

                    this.to = document.createElement('input');
                    this.to.type = 'date';
                    container.appendChild(this.to);
                    this.to.addEventListener('change', (event) => {
                        this.content.to.date = this.to.value;
                        this.update();
                    });

                    this.toEvent.addEventListener('change', (event) => {
                        this.content.to.event = this.toEvent.value;
                        this.update();
                    });

                    this.days = document.createElement('div');
                    container.appendChild(this.days);

                    if (this.content) {
                        if (this.content.from?.event) {
                            this.fromEvent.value = this.content.from.event;
                        } else if (this.content.from?.date) {
                            this.from.value = this.content.from.date;
                        }
                        if (this.content.to?.event) {
                            this.toEvent.value = this.content.to.event;
                        } else if (this.content.to?.date) {
                            this.to.value = this.content.to.date;
                        }
                    }

                    return container;
                },
                update() {
                    const eventNames = Object.keys(named.dates);
                    eventNames.sort((a, b) => a.localeCompare(b));

                    this.fromEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                    this.fromEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                    this.fromEvent.value = this.content.from.event ?? 'Custom Date';

                    if (this.fromEvent.value === 'Custom Date') {
                        this.from.disabled = false;
                        if (this.content.from.date) {
                            this.from.value = this.content.from.date;
                        }
                    } else if (this.fromEvent.value === 'Today' || named.dates[this.toEvent.value]) {
                        this.from.disabled = true;
                        const date = this.fromEvent.value === 'Today' ? new Date() : named.dates[this.toEvent.value].value;
                        this.from.value = `${date.getFullYear()}-${(date.getMonth() + 1 + '').padStart(2, '0')}-${(date.getDate() + '').padStart(2, '0')}`;
                    }

                    this.toEvent.innerHTML = '<option>Custom Date</option><option>Today</option>';
                    this.toEvent.innerHTML += eventNames.map((event) => `<option>${event}</option>`);
                    this.toEvent.value = this.content.to.event ?? 'Custom Date';

                    if (this.toEvent.value === 'Custom Date') {
                        this.to.disabled = false;
                        if (this.content.to.date) {
                            this.to.value = this.content.to.date;
                        }
                    } else if (this.toEvent.value === 'Today' || named.dates[this.toEvent.value]) {
                        this.to.disabled = true;
                        const date = this.toEvent.value === 'Today' ? new Date() : named.dates[this.toEvent.value].value;
                        this.to.value = `${date.getFullYear()}-${(date.getMonth() + 1 + '').padStart(2, '0')}-${(date.getDate() + '').padStart(2, '0')}`;
                    }

                    if (this.from.value && this.to.value) {
                        this.days.innerHTML = calendar.workingDays(this.from.value, this.to.value);
                    }
                }
            },
            'tree table': {
                modelNode(node) {
                    return {
                        getState() {
                            if (node[meta].parts?.length) {
                                return this.state;
                            }
                        },
                        state: 'expanded',
                        expand(event) {
                            this.state = 'expanded';
                            if (event.ctrlKey && node[meta].parts) {
                                node[meta].parts.forEach((child) => model.get(child).collapse(event));
                            }
                        },
                        collapse(event) {
                            this.state = 'collapsed';
                            if (event.ctrlKey && node[meta].parts) {
                                node[meta].parts.forEach((child) => model.get(child).collapse(event));
                            }
                        },
                        nodes: [],
                    }
                },
                setData() {
                    this.keys = [];
                    this.all = this.content.flatMap((item) => Array.from(flatten(item)));
                    this.all.forEach((node) => this.keys.push(...Object.keys(node).filter((key) => !(this.keys.includes(key)))));
                    this.rows = this.all.map((row) => ({ size: 'minmax(1em, max-content)' }));
                    this.cols = this.keys.map((key) => ({ size: 'minmax(min-content, max-content)' }));
                    this.model = new Map();
                    const model = this.model;
                    this.all.forEach((node) => this.model.set(node, this.modelNode(node)));
                },
                setContent(content) {
                    this.content = this.deserialiseContent(content);
                    this.setData();
                },
                init(string, cells = [], values = []) {
                    if (app.loaded || cells.length) {
                        if (cells.length === 0) {
                            cells = [app.cells.at(-1)];
                        }
                        this.content = cells.flatMap((cell) => cell.value);
                        this.setData();
                    }
                    this.deleted = [];
                },
                getResultNode() {
                    const resultNode = document.createElement('div');
                    resultNode.classList.add('table');
                    const background = document.createElement('div');
                    background.classList.add('grid');
                    resultNode.appendChild(background);

                    const getCell = () => {
                        let cell = document.activeElement;
                        while (!(cell.classList.contains('tree-table-cell') || cell.classList.contains('tree-table-header')) && cell.parentElement) {
                            cell = cell.parentElement;
                        }
                        return cell;
                    }
                    resultNode.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            inputNode.focus();
                        }
                        const cell = getCell();
                        const col = parseInt(cell.dataset.col);
                        const row = parseInt(cell.dataset.row);
                        if (event.key === 'Tab' && col === 0 && row > 0) {
                            const node = this.all[row];
                            const parent = this.all.find((parent) => parent[meta].parts?.includes(node));
                            if (event.shiftKey) { // move item up in level
                                if (parent) {
                                    parent[meta].parts.splice(parent[meta].parts.indexOf(node), 1);
                                    const newParent = this.all.find((node) => node[meta].parts?.includes(parent));
                                    if (newParent) {
                                        const position = newParent[meta].parts.indexOf(parent);
                                        newParent[meta].parts.splice(position + 1, 0, node);
                                    } else {
                                        const position = this.content.indexOf(parent) + 1;
                                        this.content.splice(position, 0, node);
                                    }
                                }
                            } else {
                                const container = parent ? parent[meta].parts : this.content;
                                const position = container.indexOf(node);
                                const previous = container[position - 1];
                                if (previous) {
                                    container.splice(position, 1);
                                    previous[meta].parts.push(node)
                                }
                            }
                            this.update();
                            this.view.result.querySelector(`.cell-content-${col}-${row}`).focus();
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        if (event.ctrlKey) {
                            if (event.key === 'Delete') {
                                if (isNaN(row) && this.keys.length > 1) {
                                    cell.blur();
                                    const key = this.keys[col];
                                    const deleted = { key };
                                    this.keys.splice(col, 1);
                                    this.update(true);
                                    if (col < this.keys.length) {
                                        this.view.result.querySelector(`.tree-table-column-${col}`).focus();
                                    } else {
                                        this.view.result.querySelector(`.tree-table-column-${col - 1}`).focus();
                                    }
                                } else {
                                    const item = this.all[row];
                                    const parent = this.all.find((node) => node[meta].parts.includes(item));
                                    const position = (parent ? parent[meta].parts : this.content).indexOf(item);
                                    const deleted = { item, parent, position };
                                    this.deleted.push(deleted);
                                    this.all.splice(row, 1);
                                    this.rows.splice(row, 1);
                                    if (item?.[meta].parts.length) {
                                        (parent ? parent[meta].parts : this.content).splice(position, 1, ...item[meta].parts);
                                    } else {
                                        (parent ? parent[meta].parts : this.content).splice(position, 1);
                                    }
                                    this.model.delete(item);
                                    this.update();
                                    if (row < this.rows.length) {
                                        this.view.result.querySelector(`.cell-content-${col}-${row}`).focus();
                                    } else if (this.rows.length > 0) {
                                        this.view.result.querySelector(`.cell-content-${col}-${row - 1}`).focus();
                                    } else {
                                        this.view.result.querySelector(`.tree-table-column-${col}`).focus();
                                    }
                                }
                                event.preventDefault();
                            }
                        }
                        if (event.altKey) {
                            event.preventDefault();
                            if (event.key === 'ArrowRight') {
                                if (event.shiftKey) {
                                    this.keys.splice(col + 1, 0, null);
                                    this.update();
                                    this.view.result.querySelector(`.tree-table-column-${(col + 1) % this.keys.length}`).focus();
                                } else {
                                    if (isNaN(row)) {
                                        this.view.result.querySelector(`.tree-table-column-${(col + 1) % this.cols.length}`).focus();
                                    } else {
                                        this.view.result.querySelector(`.cell-content-${(col + 1) % this.cols.length}-${row}`).focus();
                                    }
                                }
                            }
                            if (event.key === 'ArrowLeft') {
                                if (event.shiftKey) {
                                    this.keys.splice(col + 1, 0, null);
                                    this.update();
                                    this.view.result.querySelector(`.tree-table-column-${col}`).focus();
                                } else {
                                    if (isNaN(row)) {
                                        this.view.result.querySelector(`.tree-table-column-${(col > 0 ? col : this.cols.length) - 1}`).focus();
                                    } else {
                                        this.view.result.querySelector(`.cell-content-${(col > 0 ? col : this.cols.length) - 1}-${row}`).focus();
                                    }
                                }
                            }
                            if (event.key === 'ArrowUp') {
                                if (event.shiftKey && !isNaN(row)) {
                                    // Add a new item before the current item
                                    const current = this.all[row];
                                    const newItem = {};
                                    this.model.set(newItem, this.modelNode(newItem));
                                    const parent = this.all.find((node) => node['childrent'].includes(current));
                                    if (parent) {
                                        const position = node['childrent'].indexOf(current);
                                        parent.splice(position, 0, newItem);
                                    } else {
                                        const postion = this.content.indexOf(current);
                                        this.content.splice(position, 0, newItem);
                                    }
                                    this.all.splice(row, 0, newItem);
                                    this.rows.splice(row, 0, { size: 'max-content' });

                                    this.update();
                                    this.view.result.querySelector(`.cell-content-${col}-${row}`).focus();

                                } else if (row > 0) {
                                    this.view.result.querySelector(`.cell-content-${col}-${row - 1}`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-content-${col}-${this.rows.length - 1}`).focus();
                                }
                            }
                            if (event.key === 'ArrowDown') {
                                if (event.shiftKey) {
                                    const newItem = {};
                                    this.model.set(newItem, this.modelNode(newItem));
                                    if (isNaN(row)) {
                                        // Add a new item as the first child
                                        this.content.unshift(newItem);
                                        this.all.unshift(newItem);
                                        this.rows.unshift({ size: 'max-content' });
                                    } else {
                                        // Add a new item as a child of the item at the current row
                                        const current = this.all[row];
                                        this.all.splice(row + 1, 0, newItem);
                                        this.rows.splice(row + 1, 0, { size: 'max-content' });
                                        current[meta].parts = current[meta].parts || [];
                                        current[meta].parts.unshift(newItem);
                                    }
                                    this.update();
                                }

                                if (isNaN(row)) {
                                    this.view.result.querySelector(`.cell-${col}-0`).focus();
                                } else {
                                    this.view.result.querySelector(`.cell-content-${col}-${(row + 1) % this.all.length}`).focus();
                                }
                            }
                            saveState();
                            event.preventDefault();
                        }
                    });
                    return resultNode;
                },
                clearUpdate() {
                    for (const node of this.view.result.querySelectorAll('.tree-table-cell')) {
                        node.remove();
                    }
                    update();
                },
                update() {
                    this.view.result.innerHTML = '';

                    const makeTemplate = (definition) => `${definition.map((col) => col.size).join(' ')}`;
                    this.view.result.style.gridTemplateColumns = makeTemplate(this.cols);
                    this.view.result.style.gridTemplateRows = makeTemplate(this.rows);

                    let row = 2;
                    const addNode = (node, level = 0) => {
                        this.keys.forEach((key, index) => {
                            const cell = document.createElement('div');
                            cell.classList.add('tree-table-cell', `cell-${index}-${row - 2}`);
                            cell.style.gridRow = row;
                            cell.style.gridCol = index + 1;
                            cell.dataset.row = this.all.indexOf(node);
                            cell.dataset.col = index;
                            if (index === 0) {
                                cell.innerHTML = '&nbsp;'.repeat(level * 2);
                                const meta = this.model.get(node);
                                const expand = expander(() => meta.getState(), (event) => { meta.expand(event); this.update(); }, (event) => { meta.collapse(event); this.update(); });
                                cell.appendChild(expand);
                                cell.appendChild(editableSpan(() => node[key] ?? '', (span) => node[key] = span.innerText));
                                cell.classList.add('tree-table-header');
                            } else {
                                cell.appendChild(editableSpan(() => node[key] ?? '', (span) => node[key] = span.innerText));
                            }
                            cell.lastElementChild.classList.add(`cell-content-${index}-${row - 2}`)
                            this.view.result.append(cell);
                        });
                        row += 1;
                        if (this.model.get(node).getState() === 'expanded') {
                            node[meta].parts?.forEach((child) => addNode(child, level + 1));
                        }
                    }

                    this.content.forEach((node) => addNode(node));
                    this.keys.forEach((key, index) => {
                        const cell = editableSpan(() => this.keys[index], (node) => this.keys[index] = node.innerText);
                        cell.classList.add('tree-table-header', `tree-table-column-${index}`);
                        cell.innerHTML = key || '<new key>';
                        cell.dataset.col = index;
                        cell.style.gridRow = 1;
                        cell.style.gridColumn = index + 1;
                        this.view.result.append(cell);
                    });
                },
                serialiseContent() {
                    const nodes = this.all.map((source) => ({
                        data: source,
                        parts: source[meta].parts?.map((part) => this.all.indexOf(part)),
                    }));
                    return nodes;
                },
                deserialiseContent(nodes) {
                    nodes.forEach((node) => node.data[meta] = {});

                    const all = nodes.map((source) => {
                        const node = source.data;
                        node[meta].parts = source.parts?.map((part) => nodes[part].data) || [];
                        node[meta].parts.forEach((part) => part[meta].parent = node);
                        return node;
                    });
                    const roots = all.filter((node) => node[meta].parent === undefined);
                    return roots;
                },
            },
            'make tree': {
                init(string, cells = [], parameters) {
                    if (cells.length === 0) {
                        cells = [app.cells.at(-1)];
                    }
                    this.input = cells.map((cell) => cell.value).join('');

                    //const lines = this.input.split(/\r?\n/g).map((line) => line.split(/\s*[,\t\|]\s*/g));
                    const lines = this.input.split(/\r?\n/g).filter((line) => line.trim() !== '').map((line) => line.split(/\t/g).map((item) => item.trim()));

                    //const lines = this.input.split(/\r?\n/g).filter((line) => line.trim() !== '').map((line) => line.split(/\s*[\t\|]\s*/g));
                    const headers = lines.shift();
                    const items = lines.map((line) => line.reduce((item, value, index) => {
                        item[headers[index]] = value;
                        return item;
                    }, { [meta]: {} }));

                    // Assume the first col contains id
                    const sorted = items.sort((a, b) => b[headers[0]].length - a[headers[0]].length);
                    sorted.forEach((item) => {
                        item[meta].parts = sorted.filter((other) => (other[meta].parent === undefined) && (other[headers[0]].length > item[headers[0]].length) && other[headers[0]].startsWith(item[headers[0]]));
                        item[meta].parts.forEach((part) => part[meta].parent = item);
                    });
                    this.value = sorted.filter((item) => item[meta].parent === undefined);
                },
                update() {
                    this.view.result.innerHTML = `<pre>${JSON.stringify(this.value, null, 2)}</pre>`;
                }
            },
            'current cell': {
                init() {
                    app.events.currentCellChange.add(this);
                },
                update() {
                    const lines = [];
                    lines.push(`${app.currentCell?.raw}`);
                    if (app.currentCell) {
                        for (const input of app.currentCell.uses) {
                            lines.push(`${input.index} ${input.name} --> ${app.currentCell.index} ${app.currentCell.name}`);
                        }
                        for (const output of app.currentCell.users) {
                            lines.push(`${app.currentCell.index} ${app.currentCell.name} --> ${output.index} ${output.name}`);
                        }
                    }
                    this.view.result.innerHTML = lines.join('<br>');
                }
            },
            windows: { // Display dynamic list of windows
                init() {
                    app.events.layoutChange.add(this);
                },
                getResultNode() {
                    const resultNode = document.createElement('div');
                    resultNode.classList.add('result', 'table');
                    resultNode.style.gridTemplateColumns = 'repeat(7, minmax(min-content, 1fr))';
                    return resultNode;
                },
                update() {
                    this.view.result.innerHTML = '';
                    const windows = app.cells.filter((cell) => cell.view?.cell?.classList.contains('floating'));
                    const makeSpan = (text) => {
                        const node = document.createElement('span');
                        node.innerText = text;
                        node.classList.add('table-cell');
                        return node;
                    }
                    windows.forEach((cell) => {
                        const box = cell.view.cell.getBoundingClientRect();
                        this.view.result.appendChild(makeSpan(`${app.cells.indexOf(cell)}:`));
                        this.view.result.appendChild(makeSpan(cell.name || ''));
                        this.view.result.appendChild(makeSpan(cell.command));
                        this.view.result.appendChild(makeSpan(box.x));
                        this.view.result.appendChild(makeSpan(box.y));
                        this.view.result.appendChild(makeSpan(box.width));
                        this.view.result.appendChild(makeSpan(box.height));
                    });
                },
            },
            messages: { // Display dynamic list of messages
                init() {
                    app.events.statusChange.add(this);
                },
                update() {
                    this.view.result.innerHTML = app.statusHistory.join('<br>');
                },
            }
        }


        function copyStylesInline(destinationNode, sourceNode) {
            var containerElements = ["svg", "g"];
            for (var cd = 0; cd < destinationNode.childNodes.length; cd++) {
                var child = destinationNode.childNodes[cd];
                if (containerElements.indexOf(child.tagName) != -1) {
                    copyStylesInline(child, sourceNode.childNodes[cd]);
                    continue;
                }
                var style = sourceNode.childNodes[cd].currentStyle || window.getComputedStyle(sourceNode.childNodes[cd]);
                if (style == "undefined" || style == null) continue;
                for (var st = 0; st < style.length; st++) {
                    child.style.setProperty(style[st], style.getPropertyValue(style[st]));
                }
            }
        }

        // https://stackoverflow.com/questions/3975499/convert-svg-to-image-jpeg-png-etc-in-the-browser
        const dataHeader = 'data:image/svg+xml;charset=utf-8';

        const loadImage = async url => {
            const img = document.createElement('img');
            img.src = url;
            return new Promise((resolve, reject) => {
                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        }

        const serializeAsXML = (e) => (new XMLSerializer()).serializeToString(e);

        const encodeAsUTF8 = (str) => `${dataHeader},${encodeURIComponent(str)}`;
        const encodeAsB64 = (str) => `${dataHeader};base64,${btoa(str)}`;

        /**
         * Extract SVG data and paste image to canvas to download
         */
        const convertSVGtoImg = async (svg, filename, format = 'png') => {
            const copy = svg.cloneNode(true);
            copyStylesInline(copy, svg);
            const svgData = encodeAsUTF8(serializeAsXML(copy));

            const img = await loadImage(svgData);

            const canvas = document.createElement('canvas');
            canvas.width = svg.clientWidth;
            canvas.height = svg.clientHeight;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgb(240, 248, 255)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.drawImage(img, 0, 0, svg.clientWidth, svg.clientHeight);

            const dataURL = await canvas.toDataURL(`image/${format}`, 1.0);
            triggerDownload(dataURL, filename);
        }

        /**
         * Create link and click it to trigger download
         */
        function triggerDownload(imgURI, fileName) {
            const event = new MouseEvent('click', {
                view: window,
                bubbles: false,
                cancelable: true
            });
            const link = document.createElement('a');
            link.setAttribute('download', fileName);
            link.setAttribute('href', imgURI);
            link.setAttribute('target', '_blank');
            link.dispatchEvent(event);
        }


        const app = {
            loaded: false,
            history: [],
            saveCommand(command) {
                this.history.push(command);
                this.historyIndex = this.history.length;
                this.historyChange();
            },
            cells: [],
            namedCells: {},
            managedTypes: [ToDo],
            types: new Map(),
            addTyped(item) {
                this.managedTypes.forEach((type) => {
                    if (item instanceof type) {
                        const list = this.types.get(type);
                        if (list) {
                            list.push(item);
                        } else {
                            this.types.set(type, [item]);
                        }
                    }
                });
            },
            index: 0,
            events: {
                historyChange: new Set(),
                layoutChange: new Set(),
                statusChange: new Set(),
                currentCellChange: new Set(),
            },
            historyChange() {
                this.events.historyChange.forEach((cell) => cell.update());
            },
            layoutChange() {
                for (const cell of this.events.layoutChange) {
                    cell.update();
                }
            },
            statusChange() {
                for (const cell of this.events.statusChange) {
                    cell.update();
                }
            },
            listeners: new Map(),
            addListener(event, listener) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).push(listener);
                } else {
                    this.listeners.set(event, [listener]);
                }
            },
            notifyListeners(event, detail) {
                const listeners = this.listeners.get(event) || [];
                listeners.forEach((listener) => listener.update(detail));
            },
            setCurrentCell(cell) {
                if (this.currentCell !== cell) {
                    this.currentCell = cell;
                    for (const cell of this.events.currentCellChange) {
                        cell.update();
                    }
                    for (const node of document.querySelectorAll('.source')) {
                        node.classList.remove('source');
                    }
                    for (const node of document.querySelectorAll('.sink')) {
                        node.classList.remove('sink');
                    }
                    if (cell) {
                        for (const input of cell.uses) {
                            input.view.cell.classList.add('source');
                        }
                        for (const output of cell.users) {
                            output.view.cell.classList.add('sink');
                        }
                        app.setStatus(`${cell.name || ''}: ${cell.raw}`);
                    }

                }
            },
            context: [{ process }],
            state: {},
            mermaidCount: 0,
            setPrompt(prompt) {
                const currentIndex = document.getElementById('current-index');
                if (prompt) {
                    currentIndex.innerHTML = prompt;
                } else {
                    currentIndex.innerHTML = this.cells.length;
                }
            },
            status: [],
            statusHistory: [],
            setStatus(text, timeout = 3) {
                this.statusHistory.push(text);
                this.status.push(text);

                const statusNode = document.getElementById('status');
                statusNode.innerHTML = this.status.join('<br>');
                statusNode.classList.remove('fade');
                /*
                if (app.timeout) {
                    clearTimeout(app.timeout);
                }*/
                const remove = () => {
                    const pos = this.status.indexOf(text);
                    this.status.splice(pos, 1);
                    if (this.status.length < 1) {
                        statusNode.classList.add('fade');
                    } else {
                        statusNode.innerHTML = this.status.join('<br>');
                    }
                }
                app.timeout = setTimeout(remove, timeout * 1000);
                this.statusChange();
            }
        };

        /**
         * Update dynamic cells of display
         */
        function update(time) {
            window.requestAnimationFrame(update);
        }
        //update();

        /**
         * Return the predefined functions passed to expressions
         */
        function getPredefined() {
            const predefined = {};
            Object.getOwnPropertyNames(Math).forEach((prop) => predefined[prop] = Math[prop]);
            Object.getOwnPropertyNames(calendar).forEach((prop) => predefined[prop] = calendar[prop]);
            return predefined;
        }

        const Status = Symbol('status');

        /**
         * Evaluate an input string
         * 
         * <name>[:#=] command parameters
         */
        function evaluate(raw) {
            const cell = new Cell(raw);
            const namePattern = /^\s*<([^>]+)>([:#=])\s*/;
            cell.name = raw.match(namePattern)?.[1];
            const command = {
                ':': 'notes',
                '#': 'table',
                '=': 'evaluate',
                undefined: raw.replace(namePattern, ''),
            }[raw.match(namePattern)?.[2]];
            cell.command = command;

            if (actions[command] !== undefined) {
                return actions[command](cell) ?? cell;
            } else {
                const commands = Object.getOwnPropertyNames(actions).sort((a, b) => b.length - a.length);
                const match = commands.find((match) => command.startsWith(match));
                if (match) {
                    return actions[match](cell) ?? cell;
                }
            }

            const cellTypeNames = Object.getOwnPropertyNames(cellTypes).sort((a, b) => b.length - a.length);
            const cellTypeMatch = cellTypeNames.find((match) => command.startsWith(match));
            if (cellTypeMatch) {
                Object.assign(cell, cellTypes[cellTypeMatch]);
                const pattern = new RegExp(`^\\s*${cellTypeMatch}\\s*`);
                const string = cell.raw.replace(pattern, '');

                const args = getList(string);
                const { cells, values } = args.reduce((results, value) => {
                    const index = Number(value);
                    if (app.namedCells[value] !== undefined) {
                        results.cells.push(app.namedCells[value]);
                    } else if (!isNaN(index) && index > -app.cells.length && index < app.cells.length) {
                        results.cells.push(app.cells.at(index));
                    } else {
                        results.values.push(value);
                    }
                    return results;
                }, { cells: [], values: [] });

                cell.init(string, cells, values);
                return cell;
            }
            if (named.all[command]) {
                named.all[command].eval(cell);
                return cell;
            }
            const getIndex = (str) => isNaN(parseInt(str)) ? -1 : parseInt(str) % app.cells.length;
            const link = (from, to) => {
                from.users.add(to);
                to.uses.add(from);
            };
            const expr = command.replace(/^\\/, '')
                .replace(/<(-?[^>]*)>/g, (match, name) => {
                    if (app.namedCells[name]?.value !== undefined) {
                        link(app.namedCells[name], cell);
                        return `app.namedCells['${name}''].value`;
                    } else if (named.all[name] !== undefined) {
                        return `named['${name}']`;
                    } else if (app.cells.at(getIndex(name)) !== undefined) {
                        link(app.cells.at(getIndex(name)), cell);
                        return `app.cells.at(${getIndex(name)}).value`;
                    }
                    return match;
                });
            const references = [];
            const resolved = command.replace(/^\\/, '').replace(/<(-?[0-9]*)>/g, (match, index) => {
                const referenced = app.cells.at(getIndex(index));
                referenced.users.add(cell);
                cell.uses.add(referenced);
                return `${referenced.value}`;
            });
            cell.update = () => {
                const predefined = getPredefined();
                const args = Object.keys(predefined);
                const parameters = Object.values(predefined);
                try {
                    if (app.action) {
                        const func = new Function('app', ...args, 'named', `return app.action(${expr})`);
                    }
                    const func = new Function('app', ...args, 'named', `return ${expr}`);

                    cell.value = func(app, ...parameters, named.all);
                } catch (error) {
                    cell.value = error.message;
                }
                if (cell.action) {
                    app.action === cell.action();
                }
            }
            cell.update();

            return cell;
        }

        /**
         * Add the results to the output
         */
        function showCell(cell, index) {
            const resultsNode = document.getElementById('results');

            cell.makeView();

            cell.view.index.innerHTML = `${index}: `;

            resultsNode.appendChild(cell.view.cell);
            if (cell.defaultState) {
                cell.setState(cell.defaultState);
            }
            cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'start' });
            app.show = () => cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'start' });
        }

        /**
         * Process the input
         */
        function process(event) {
            if (inputNode.value !== app.history.at(-1)) {
                app.saveCommand(inputNode.value);
            }
            const str = (app.cellIndex === app.cells.length && inputNode.value === '') ? app.cells.at(-1).raw : inputNode.value;
            app.interactive = true;
            const cell = evaluate(str);
            app.interactive = false;

            if (cell.type === Status) {
                app.setStatus(cell.value);
            } else {
                showCell(cell, app.cells.length);
            }
            app.namedCells[cell.name] = cell;
            app.cells.push(cell);

            app.events.historyChange.forEach((cell) => cell.update());

            if (event.ctrlKey && (app.historyIndex < (app.cells.length - 1))) {
                app.historyIndex += 1;
                inputNode.value = app.history.at(app.historyIndex).raw;
            } else {
                app.historyIndex = app.history.length;
                inputNode.value = '';
            }
            if (cell.update) {
                cell.update();
            }
            app.setPrompt(cell.prompt);
            saveState();
            if (cell.focus) {
                cell.focus.focus();
            }
            inputNode.removeAttribute('list');
        }


        /**
         * Previous command
         */
        function previousCommand(event) {
            if (app.historyIndex === app.history.length) {
                app.draft = inputNode.value;
            }
            app.historyIndex -= 1;
            if (app.historyIndex < 0) {
                app.historyIndex = app.history.length;
                inputNode.value = app.draft;
            }
            if (event.ctrlKey) {
                const command = app.history[app.historyIndex];
                const start = inputNode.selectionStart;
                const end = inputNode.selectionEnd ?? start;
                inputNode.value = inputNode.value.slice(0, start) + command + inputNode.value.slice(end);
                inputNode.setSelectionRange(start, start + command.length);
            } else {
                inputNode.value = app.history[app.historyIndex];
            }
        }

        /**
         * Previous cell
         */
        function previousCell(event) {
            if (app.cellIndex === app.cells.length) {
                app.draft = inputNode.value;
            }
            app.cellIndex -= 1;
            if (app.cellIndex < 0) {
                app.cellIndex = app.cells.length;
                inputNode.value = app.draft;
            } else {
                if (event.shiftKey) {
                    const start = inputNode.selectionStart;
                    const end = inputNode.selectionEnd ?? start;
                    const reference = event.ctrlKey ? `${app.cells.at(app.cellIndex).value}` : `<${app.cellIndex - app.cells.length}>`;
                    inputNode.value = inputNode.value.slice(0, start) + reference + inputNode.value.slice(end);
                    inputNode.setSelectionRange(start, start + reference.length);
                } else {
                    inputNode.value = app.cells[app.cellIndex].raw;
                }
                if (app.cells.at(app.cellIndex).view.result) {
                    const node = app.cells.at(app.cellIndex).view.result;
                    node.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
                }
            }
        }

        /**
         * Previous command
         */
        function nextCommand(event) {
            if (app.historyIndex === app.history.length) {
                app.draft = inputNode.value;
            }
            app.historyIndex = app.historyIndex += 1;
            if (event.ctrlKey) {
                app.historyIndex %= app.history.length;
                const command = app.history[app.historyIndex];
                const start = inputNode.selectionStart;
                const end = inputNode.selectionEnd ?? start;
                inputNode.value = inputNode.value.slice(0, start) + command + inputNode.value.slice(end);
                inputNode.setSelectionRange(start, start + command.length);
            } else {
                app.historyIndex %= (app.history.length + 1);
                if (app.historyIndex === app.history.length) {
                    inputNode.value = app.draft;
                } else {
                    inputNode.value = app.history[app.historyIndex];
                }
            }
        }


        /**
         * Cycle through cells
         */
        function nextCell(event) {
            if (app.cellIndex === app.cells.length) {
                app.draft = inputNode.value;
                app.cellIndex = -1;
            }
            app.cellIndex += 1;
            if (app.cellIndex === app.cells.length) {
                inputNode.value = app.draft;
            } else {
                if (event.shiftKey) {
                    const start = inputNode.selectionStart;
                    const end = inputNode.selectionEnd ?? start;
                    const reference = event.ctrlKey ? `${app.cells.at(app.cellIndex).value}` : `<${app.cellIndex - app.cells.length}>`;
                    inputNode.value = inputNode.value.slice(0, start) + reference + inputNode.value.slice(end);
                    inputNode.setSelectionRange(start, start + reference.length);
                } else {
                    inputNode.value = app.cells[app.cellIndex].raw;
                }
                if (app.cells.at(app.cellIndex).view.result) {
                    const node = app.cells.at(app.cellIndex).view.result;
                    node.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
                }
            }

        }

        /**
         * Process cursor up in input box
         */
        function cursorUp(event) {
            if (event.altKey) {
                previousCell(event);
            } else {
                previousCommand(event);
            }
        }

        /**
         * Process cursor up in input box
         */
        function cursorDown(event) {
            if (event.altKey) {
                nextCell(event);
            } else {
                nextCommand(event);
            }
        }

        /**
         * Save the current state to local storage
         */
        function saveState() {
            if (app.save) {
                const state = { app, named };
                const stateString = JSON.stringify(state);
                localStorage.setItem('noia-state', stateString);
            }
        }

        /**
         * Reload the state from local storage
         */
        function restoreState(state) {
            state.app = state.app ?? state.context;
            state.app.cells.filter((cell) => cell && cell.raw).forEach((storedCell) => {
                const cell = evaluate(storedCell.raw);
                if (storedCell.content) {
                    if (cell.setContent) {
                        cell.setContent(storedCell.content);
                    } else {
                        cell.content = storedCell.content;
                    }
                }
                if (storedCell.settings) {
                    cell.setSettings(storedCell.settings);
                }

                cell.timestamp = new Date(storedCell.timestamp);
                if (cell.type === Status) {
                    app.setStatus(cell.value);
                } else {
                    showCell(cell, app.cells.length);
                    app.cells.push(cell);
                    app.namedCells[cell.name] = cell;
                    if (storedCell.view) {
                        cell.setState(storedCell.view.state);
                        if (storedCell.view.box) {
                            cell.view.cell.style.left = `${storedCell.view.box.x}px`;
                            cell.view.cell.style.top = `${storedCell.view.box.y}px`;
                            cell.view.cell.style.width = `${Math.max(storedCell.view.box.width, 100)}px`;
                            cell.view.cell.style.height = `${Math.max(storedCell.view.box.height, 100)}px`;
                        }
                        storedCell.view.modes.forEach((mode) => cell.setMode(mode));
                    }
                }
                if (cell.update) {
                    cell.update();
                }
            });
            app.cellIndex = app.cells.length;
            const currentIndex = document.getElementById('current-index');
            currentIndex.innerHTML = app.cells.length;
            app.events.historyChange.forEach((cell) => cell.update());
            Object.assign(app.state, state.app.state);
            if (app.state.theme) {
                document.documentElement.setAttribute('data-theme', app.state.theme);
            }
            if (app.state.background) {
                document.body.style.backgroundImage = `url("${app.state.background}")`;
            }
            if (state.app.statusBar) {
                actions['status bar']({ raw: '' });
            }
            app.history.push(...state.app.history);
            app.historyIndex = app.history.length;
            app.historyChange();
        }

        /**
         * Reload the state from local storage
         */
        function loadState() {
            const stateStr = localStorage.getItem('noia-state');
            if (stateStr) {
                app.save = false;
                const state = JSON.parse(stateStr);
                restoreState(state);
                app.save = true;
            }
            inputNode.focus();
        }

        (function loadFileList() {
            const request = window.indexedDB.open('NoaiDatabase', 1);

            // Handle a failure
            request.onerror = (event) => {
                console.error(`Database error: ${event.target.error?.message}`);
            };

            // save the files
            request.onsuccess = (event) => {
                const db = event.target.result;

                if (db.objectStoreNames.contains('files')) {
                    const transaction = db.transaction(['files']);
                    const objectStore = transaction.objectStore('files');
                    const request = objectStore.getAll();
                    request.onerror = (event) => {
                        console.error(`Database error: ${event.target.error?.message}`);
                    };
                    request.onsuccess = async (event) => {
                        event.target.result.forEach((file) =>
                            named.files[file.name] = file.handle);
                    };
                }
            };

            request.onupgradeneeded = (event) => {
                // Save the IDBDatabase interface
                const db = event.target.result;

                // Create an objectStore for this database
                const objectStore = db.createObjectStore('files', { keyPath: 'name' });
            };
        })();

        /**
         * Check the permissions for the file to load
         */
        async function verifyPermission(fileHandle, readWrite) {
            const options = {};
            if (readWrite) {
                options.mode = 'readwrite';
            }
            // Check if permission was already granted. If so, return true.
            if ((await fileHandle.queryPermission(options)) === 'granted') {
                return true;
            }
            // Request permission. If the user grants permission, return true.
            if ((await fileHandle.requestPermission(options)) === 'granted') {
                return true;
            }
            // The user didn't grant permission, so return false.
            return false;
        }

        /**
         * Load a file from a handle in an indexeddb database
         */
        async function load(cell, filename, process) {
            if (named.files[filename]) {
                const handle = named.files[filename];
                if (await verifyPermission(handle)) {
                    const file = await handle.getFile();
                    const content = await file.text();
                    if (process) {
                        process(content);
                    } else {
                        cell.content = content;
                    }
                } else {
                    console.log('Permission not granted for file :(');
                }
            }
        }

        /**
         * Save the value of a cell to a file
         */
        async function save(cell, filename) {
            if (named.files[filename]) {
                const handle = named.files[filename];
                if (verifyPermission(handle, true)) {
                    const file = await handle.getFile();
                    if (process) {
                        process(contents);
                    }
                } else {
                    console.log('Permission not granted for file :(');
                }
            }
        }


        /**
         * Save a list of file handles to a indexeddb database
         */
        function saveFileHandles(files) {
            // Open the database
            const request = window.indexedDB.open('NoaiDatabase', 1);

            // Handle a failure
            request.onerror = (event) => {
                console.error(`Database error: ${event.target.error?.message}`);
            };

            // save the files
            request.onsuccess = (event) => {
                const db = event.target.result;

                const transaction = db.transaction(['files'], 'readwrite');
                // Do something with request.result!
                // Do something when all the data is added to the database.
                transaction.oncomplete = (event) => {
                    console.log('All done!');
                };

                transaction.onerror = (event) => {
                    // Don't forget to handle errors!
                };

                const fileHandleStore = transaction.objectStore('files');
                files.forEach((file) => {
                    named.files[file.name] = file.handle;
                    const request = fileHandleStore.put(file);
                    request.onsuccess = (event) => {
                        console.log(`stored handle for ${file.name}`);
                    };
                    request.onerror = (event) => {
                        console.log(`Database error: ${event.target.error?.message}`);
                    };
                });
            };

            request.onupgradeneeded = (event) => {
                // Save the IDBDatabase interface
                const db = event.target.result;

                // Create an objectStore for this database
                const objectStore = db.createObjectStore('files', { keyPath: 'name' });

                // Use transaction oncomplete to make sure the objectStore creation is
                // finished before adding data into it.
                objectStore.transaction.oncomplete = (event) => {
                    // Store values in the newly created objectStore.
                    const fileHandleStore = db
                        .transaction('files', 'readwrite')
                        .objectStore('files');
                    files.forEach((file) => {
                        fileHandleStore.add(file);
                    });
                };
            };
        }


        function dropHandler(event) {
            event.preventDefault();

            function loadFile(file) {
                const reader = new FileReader();
                const cell = new Cell(`text ${file.name}`);
                reader.addEventListener('load', (event) => {
                    cell.content = file.name;
                    cell.value = reader.result;
                    cell.view.result.innerHTML = `<pre>${reader.result}</pre>`;
                    cell.view.result.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'start' })
                });
                reader.readAsText(file);

                showCell(cell, app.cells.length);
                app.cells.push(cell);
                //saveState();
            }

            if (event.dataTransfer.items) {
                [...event.dataTransfer.items].forEach((item, index) => {
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        loadFile(file);
                        item.getAsFileSystemHandle().then((handle) => {
                            saveFileHandles([{ name: file.name, handle }]);
                        });
                    }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
            }
        }

        function dragOverHandler(event) {
            // Prevent default behavior (Prevent file from being opened)
            event.preventDefault();
        }

        /**
         * Process a key press in the input box
         */
        function processKey(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                app.context.at(-1).process(event);
            }
            if (event.key === 'ArrowUp') {
                event.preventDefault();
                cursorUp(event);
            }
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                cursorDown(event);
            }
            if (event.target.value) {
                const list = document.getElementById('named-items');
                event.target.setAttribute('list', 'named-items');
            }
        }

        const results = document.getElementById('results');
        inputNode.addEventListener('dragover', dragOverHandler);
        inputNode.addEventListener('drop', dropHandler);
        results.addEventListener('drop', dragOverHandler);
        results.addEventListener('drop', dropHandler);

        app.setPrompt('Load previous state (Y/n)');
        app.context.push({
            process: (event) => {
                if (event.target.value.toLowerCase()[0] !== 'n') {
                    loadState()
                }
                app.loaded = true;
                event.target.value = '';
                app.context.pop();
            }
        });

        inputNode.addEventListener('keydown', processKey);

        results.addEventListener('click', (event) => {
            if (event.target === results) {
                inputNode.focus();
            }
        });
        inputNode.focus();

    </script>
</body>

</html>
