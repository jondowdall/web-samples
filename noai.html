<!DOCTYPE html>
<html>
<!--
TODO:
Scroll to cell when added
alt + arrow to insert reference to cell
indicate change of state when input cell changes
save state
reload state at startup
drag files to add as cell
named cells
named actions
calendar functions
code cell
cell from sequence
side widgets: clock, calendar, todos, notes
view command history
cell types?
background colour / picture

-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>js-notepad</title>
    <link href="styles/noia-vt220.css" rel="stylesheet" />
</head>

<body>
    <div id="results"></div>
    <div id="widgets"></div>
    <div id="input-area">
        <span id="current-index">0</span><span>&gt; </span><input id="command-entry" type="text">
    </div>
    <script>

        /**
         * Custom Actions
         *
         */
        const actions = {
            /**
             * Toggle fullscreen mode
             */
            fullscreen(raw) {
                let result = '';
                if (!navigator.userActivation.isActive) {
                    return new Cell('fullscreen', 'full screen request ignored in script');
                }
                if (document.body.webkitRequestFullscreen) {
                    if (document.body.webkitIsFullScreen) {
                        document.body.webkitCancelFullScreen();
                        result = 'exit fullscreen';
                    } else {
                        document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                        result = 'enter fullscreen';
                    }
                }
                if (document.body.requestFullscreen) {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                        result = 'exit fullscreen';
                    } else {
                        document.body.requestFullscreen();
                        result = 'enter fullscreen';
                    }
                }
                return new Cell(raw, result);
            },

            /**
             * Clear the screen
             */
            cls(raw) {
                const results = document.getElementById('results');
                results.innerHTML = '';
                return ignore;
            },

            /**
             * Show the command history
             */
            history(raw) {
                const result = context.cells.map((cell, index) => `${index}: ${cell.raw}`).join('<br>')
                return new Cell(raw, result);
            },

            /**
             * Add a clock to the widget area
             */
            clock(raw) {
                if (this.clockWidget) {
                    this.clockWidget.node.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                    return this.clockWidget;
                }
                this.now = new Date();
                this.clockWidget = new Cell(raw, this.now);

                this.clockWidget.node = document.createElement('canvas');
                this.clockWidget.node.id = 'clock';
                document.getElementById('widgets').appendChild(this.clockWidget.node);

                const context = this.clockWidget.node.getContext('2d');
                const width = context.width = this.clockWidget.node.clientWidth;
                const height = context.height = this.clockWidget.node.clientHeight;
                const radius = Math.min(width, height) / 2;

                const update = (time) => {
                    this.now = new Date();
                    context.clearRect(0, 0, width, height);
                    context.fillStyle = 'lightgreen';
                    context.strokeStyle = 'lightgreen';
                    context.beginPath();
                    for (let i = 0; i < 12; ++i) {
                        const x1 = width / 2 + radius * Math.sin(i * 2 * Math.PI / 12);
                        const y1 = height / 2 - radius * Math.cos(i * 2 * Math.PI / 12);
                        context.moveTo(x1, y1);
                        const x2 = width / 2 + (radius - 2) * Math.sin(i * 2 * Math.PI / 12);
                        const y2 = height / 2 - (radius - 2) * Math.cos(i * 2 * Math.PI / 12);
                        context.lineTo(x2, y2);
                    }
                    const x1 = width / 2 + radius * Math.sin(this.now.getSeconds() * 2 * Math.PI / 60);
                    const y1 = height / 2 - radius * Math.cos(this.now.getSeconds() * 2 * Math.PI / 60);
                    context.moveTo(width / 2, height / 2);
                    context.lineTo(x1, y1);
                    const x2 = width / 2 + 0.8 * radius * Math.sin(this.now.getMinutes() * 2 * Math.PI / 60);
                    const y2 = height / 2 - 0.8 * radius * Math.cos(this.now.getMinutes() * 2 * Math.PI / 60);
                    context.moveTo(width / 2, height / 2);
                    context.lineTo(x2, y2);
                    const x3 = width / 2 + 0.6 * radius * Math.sin(this.now.getHours() * 2 * Math.PI / 12);
                    const y3 = height / 2 - 0.6 * radius * Math.cos(this.now.getHours() * 2 * Math.PI / 12);
                    context.moveTo(width / 2, height / 2);
                    context.lineTo(x3, y3);
                    context.stroke();
                    requestAnimationFrame(update);
                }
                update();
                return this.clockWidget;
            },

            calendar(raw) {
                if (this.calendarWidget) {
                    this.calendarWidget.node.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                    return this.calendarWidget;
                }
                this.calendarDate = new Date();
                this.calendarWidget = new Cell(raw, this.calendarDate);
                this.calendarWidget.node = document.createElement('div');
                this.calendarWidget.node.classList.add('calendar');
                document.getElementById('widgets').appendChild(this.calendarWidget.node);

                const previousMonth = document.createElement('span');
                this.calendarWidget.node.appendChild(previousMonth);
                previousMonth.addEventListener('click', (event) => {
                    this.calendarDate.setMonth(this.calendarDate.getMonth() - 1);
                    update()
                });

                const monthName = document.createElement('span');
                monthName.classList.add('calendar-month-name');
                this.calendarWidget.node.appendChild(monthName);

                const nextMonth = document.createElement('span');
                this.calendarWidget.node.appendChild(nextMonth);
                nextMonth.addEventListener('click', (event) => {
                    this.calendarDate.setMonth(this.calendarDate.getMonth() + 1);
                    update()
                });


                const update = () => {
                    monthName.innerHTML = this.calendarDate.toLocaleDateString('en-AU', {month: 'long'});

                    for (const node of this.calendarWidget.node.querySelectorAll('calendar-day')) {
                        node.remove();
                    }

                    const month = this.calendarDate.getMonth();
                    const year = this.calendarDate.getFullYear();
                    const date = new Date(year, month, 1);
                    date.setDate(date.getDate() - date.getDay());
                    while (date.getMonth() <= month || date.getDay() !== 0 ) {
                        const day = document.createElement('span');
                        day.innerHTML = ('' + date.getDate()).padStart(2, '0');
                        day.classList.add('calendar-day');
                        if (date.getMonth() !== month) {
                            day.classList.add('calendar-day-fade');
                        }
                        this.calendarWidget.node.appendChild(day);
                        date.setDate(date.getDate() + 1);
                    }
                }
                update();

                return this.calendarWidget;
            },

            /**
             * perform a google searcg
             */
            google(raw) {
                const string = raw.replace(/google\s+/, '').replace(/\s+/g, '+');
                const url = `https://www.google.com/search?q=${string}`;
                window.open(url, '_blank');
                return new Cell(raw, `<a href="${url}>google ${raw.replace(/google\s+/, '')}</a>`);
            }
        }



        const inputNode = document.getElementById('command-entry');

        class Cell {
            constructor(raw, result, expr, resolved, uses = []) {
                this.raw = raw;
                this.expr = expr ?? raw;
                this.resolved = resolved ?? raw;
                this.result = result;
                this.uses = [];
                this.users = [];
            }
            toJSON(key) {
                return {
                    raw: this.raw,
                    expr: this.expr,
                    resolved: this.resolved,
                    result: this.result,
                    uses: this.uses.map((cell) => context.cells.indexOf(cell)),
                    users: this.users.map((cell) => context.cells.indexOf(cell)),
                }
            }
        }

        const context = {
            args: {},
            cells: [],
            index: 0,
        };

        Object.getOwnPropertyNames(Math).forEach((prop) =>
            context.args[prop] = Math[prop]);


        const ignore = Symbol('ignore');

        /**
         * Process an input string
         */
        function execute(raw) {
            if (actions[raw] !== undefined) {
                return actions[raw](raw);
            } else if (actions[raw.split(' ')[0]]) {
                return actions[raw.split(' ')[0]](raw);
            }
            const getIndex = (str) => isNaN(parseInt(str)) ? -1 : parseInt(str) % context.cells.length;
            const expr = raw.replace(/^\\/, '').replace(/<(-?[0-9]*)>/g, (match, index) =>
                `context.cells.at(${getIndex(index)}).result`);
            const resolved = raw.replace(/^\\/, '').replace(/<(-?[0-9]*)>/g, (match, index) =>
                `${context.cells.at(getIndex(index)).result}`);
            let result;
            try {
                const func = new Function(...Object.keys(context.args), `return ${expr}`);
                result = func(...Object.values(context.args));
            } catch (error) {
                result = error.message;
            }

            return new Cell(raw, result, expr, resolved);
        }

        /**
         * Add the results to the output
         */
        function showResults(output, index) {
            const resultsNode = document.getElementById('results');

            const indexNode = document.createElement('span');
            indexNode.classList.add('index');
            indexNode.innerHTML = `${index}: `;
            resultsNode.appendChild(indexNode);

            const resultBg = document.createElement('div');
            resultBg.classList.add('result-background');
            indexNode.appendChild(resultBg);

            const itemNode = document.createElement('div');
            itemNode.classList.add('result-box');
            resultsNode.appendChild(itemNode);

            const inputNode = document.createElement('div');
            inputNode.classList.add('input');
            itemNode.appendChild(inputNode);

            const rawNode = document.createElement('span');
            rawNode.classList.add('raw');
            rawNode.innerHTML = output.raw;
            inputNode.appendChild(rawNode);


            if (output.raw !== output.resolved) {
                const arrow = document.createElement('span');
                arrow.innerHTML = ' &rarr; ';
                inputNode.appendChild(arrow);

                const resolvedNode = document.createElement('span');
                resolvedNode.classList.add('resolved');
                resolvedNode.innerHTML = output.resolved;
                inputNode.appendChild(resolvedNode);
            }

            const resultNode = document.createElement('div');
            resultNode.classList.add('result');
            resultNode.innerHTML = output.result;
            itemNode.appendChild(resultNode);
            resultNode.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
            output.node = resultNode;
        }

        /**
         * Process the input
         */
        function process(event) {
            const str = (context.index === context.cells.length && inputNode.value === '') ? context.cells.at(-1).raw : inputNode.value;
            const cell = execute(str);
            if (cell !== ignore) {
                showResults(cell, context.cells.length);
            }
            context.cells.push(cell);
            if (event.ctrlKey && (context.index < (context.cells.length - 1))) {
                context.index += 1;
                inputNode.value = context.cells.at(context.index).raw;
            } else {
                context.index = context.cells.length;
                inputNode.value = '';
            }
            const currentIndex = document.getElementById('current-index');
            currentIndex.innerHTML = context.cells.length;
            saveState();
        }

        /**
         * Process cursor up in input box
         */
        function cursorUp(event) {
            if (context.index === context.cells.length) {
                context.draft = inputNode.value;
            }
            context.index -= 1;
            if (context.index < 0) {
                context.index = context.cells.length;
                inputNode.value = context.draft;
            } else {
                if (event.altKey) {
                    const start = inputNode.selectionStart;
                    const end = inputNode.selectionEnd ?? start;
                    const reference = event.ctrlKey ? `${context.cells.at(context.index).result}` : `<${context.index - context.cells.length}>`;
                    inputNode.value = inputNode.value.slice(0, start) + reference + inputNode.value.slice(end);
                    inputNode.setSelectionRange(start, start + reference.length);
                } else {
                    inputNode.value = context.cells[context.index].raw;
                }
                if (context.cells.at(context.index).node) {
                    const node = context.cells.at(context.index).node;
                    node.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                }
            }
        }

        /**
         * Process cursor up in input box
         */
        function cursorDown(event) {
            if (context.index === context.cells.length) {
                context.draft = inputNode.value;
                context.index = -1;
            }
            context.index += 1;
            if (context.index === context.cells.lenght) {
                inputNode.value = context.draft;
            } else {
                inputNode.value = context.cells[context.index].raw;
            }
        }


        inputNode.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                process(event);
            }
            if (event.key === 'ArrowUp') {
                event.preventDefault();
                cursorUp(event);
            }
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                cursorDown(event);
            }
        });

        /**
         * Save the current state to local storage
         */
        function saveState() {
            const state = { context };
            localStorage.setItem('noia-state', JSON.stringify(state));
        }

        /**
         * Reload the state from local storage
         */
        function loadState() {
            const stateStr = localStorage.getItem('noia-state');
            if (stateStr) {
                const state = JSON.parse(stateStr);
                state.context.cells.filter((cell) => cell).forEach((cell) => {
                    const result = execute(cell.raw);
                    if (result && result !== ignore) {
                        showResults(result, context.cells.length);
                    }
                    context.cells.push(result);
                });
                context.index = context.cells.length;
                const currentIndex = document.getElementById('current-index');
                currentIndex.innerHTML = context.cells.length;
            }
        }

        loadState();
        inputNode.focus();

    </script>
</body>

</html>