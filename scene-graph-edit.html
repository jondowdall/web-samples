<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>webgl</title>
    <style>
        html {
            font-family: sans-serif;
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        input {
            width: 3em;
        }

        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            position: fixed;
            top: 0;
            right: 0;
            z-index: 10;
            background: rgb(10, 10, 10, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
        }

        .overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            z-index: 10;
            background: rgb(10, 10, 50, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
            transform: translate(-50%, -50%);
            pointer-events: none;
            white-space: nowrap;
        }

        .fixed {
            position: fixed;
        }

        .shape {
            font-style: italic;
        }

        .scene-node {
            font-weight: bold;
        }

        .number {
            width: 40vw;
        }

        .light-position {
            width: 30vw;
        }

        .tree-view {
            display: grid;
            grid-template-columns: 1rem 1rem max-content 1fr 1fr;
            grid-auto-rows: min-content;
            gap: 0;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: min-content 2fr 2fr 1fr;
            width: 100%;
            height: 100%;
            grid-gap: 2px;
        }

        #controls {
            grid-column: 1 / -1;
        }

        #edit {
            position: relative;
            grid-column: 1 / 2;
            display: grid;
            grid-template-rows: max-content 1fr;
            grid-template-columns: 1fr 1fr;
        }

        #input {
            font-size: 120%;
            width: 100%;
            height: 100%;
            overflow: auto;
            grid-column: 1 / -1;
        }

        #scene-container {
            grid-column: 2;
            position: relative;
            overflow: hidden;
        }

        #scene {
            width: 100%;
            height: 100%;
        }

        #top-view-container {
            grid-column: 1;
            grid-row: 3;
            position: relative;
            overflow: hidden;
        }

        #top-view {
            width: 100%;
            height: 100%;
        }

        .expanded-tree {
            overflow: auto;
        }

        .detail {
            grid-column: 1 / 3;
            overflow: auto;
        }

        .group {
            position: relative;
            border-left: 1px solid gray;
            border-top-left-radius: 0.5em;
            border-bottom-left-radius: 0.5em;

            border: 1px solid gray;
            border-radius: 0.5em;
            margin: 0 1px;

            transition: max-height 0.3s ease-in;
        }

        .expand {
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
            transition: max-height 0.3s ease-in;
            max-height: 1.2em;
            overflow: hidden;
        }

        .content {
            white-space: nowrap;
            max-height: 1.2em;
            transition: max-height 0.3s ease-in;
            overflow: hidden;
        }

        .range {
            font-style: italic;
            color: blue;
        }

        .control-node {
            font-style: italic;
            color: blue;
        }

        .range-expanded {
            font-style: italic;
            color: lightgray;
        }

        .collapse {
            max-height: 0;
            /*border: none;*/
        }

        .entry {
            padding-left: 1.1em;
        }

        .entry-content {
            padding-left: 1.1em;
        }

        .selected {
            background-color: yellow;
        }
    </style>
</head>

<body>
    <div id="overlay"></div>
    <div class="layout">
        <div id="controls">
            <input id="bases" class="number" type="range" min="1" max="20">
            <input id="components" class="number" type="range" min="0" max="100">
            <span id="total"></span>
            <input id="split" type="checkbox">
            <input id="move" type="checkbox">
            <input id="light-x" class="light-position" type="range" min="-100" max="100">
            <input id="light-y" class="light-position" type="range" min="-100" max="100">
            <input id="light-z" class="light-position" type="range" min="-100" max="100">
            <button id="next-node">Next</button>
        </div>

        <div id="transform" style="display:none;">
            <input class="a0" type="number" value="1">
            <input class="a1" type="number" value="0">
            <input class="a2" type="number" value="0">
            <input class="a3" type="number" value="0">
            <br>
            <input class="a4" type="number" value="0">
            <input class="a5" type="number" value="1">
            <input class="a6" type="number" value="0">
            <input class="a7" type="number" value="0">
            <br>
            <input class="a8" type="number" value="0">
            <input class="a9" type="number" value="0">
            <input class="a10" type="number" value="1">
            <input class="a11" type="number" value="0">
            <br>
            <input class="a12" type="number" value="0">
            <input class="a13" type="number" value="0">
            <input class="a14" type="number" value="0">
            <input class="a15" type="number" value="1">
        </div>
        <div id="edit">
            <button id="comment">Comment</button>
            <button id="uncomment">Uncomment</button>
            <textarea id="input" rows="20" cols="50">
                box
                @type=box;width=2;height=1;depth=1;position=1,1,0;
                box
                 @type=box;width=2;height=1.5;depth=2;position=1,1,0;
            </textarea>
        </div>
        <div id="scene-container"><canvas id="scene"></canvas></div>
        <div id="top-view-container"><canvas id="top-view"></canvas></div>
        <!--div class="tree"></div-->
        <div class="expanded-tree"></div>
        <div class="detail"></div>
    </div>

    <script>
        /**
         *
         */
        addEventListener('load', function (e) {
            main();
        });

        /**
         * Display the text in overlay div.
         */
        function report(text, sep) {
            if (sep) {
                document.getElementById('overlay').innerText += sep + text;
            } else {
                document.getElementById('overlay').innerText = text;
            }
        }

        /**
         * Converts an HSL color value to RGB. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
         * Assumes h, s, and l are contained in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         *
         * @param   {number}  h       The hue
         * @param   {number}  s       The saturation
         * @param   {number}  l       The lightness
         * @return  {Array}           The RGB representation
         */
        function hslToRgb(h, s, l) {
            var r, g, b;

            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                var hue2rgb = function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        /**
         * Extract group data from match data.
         */
        function setGroupData(node, match) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*\|\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(match.groups.list);
            if (!isNaN(count)) {
                node.group = [];
                for (let i = 1; i <= count; ++i) {
                    node.group.push(i);
                }
            } else {
                node.group = match.groups.list.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return item.trim();
                });
            }
            node.name = (match.groups.name || '').trim();
        }

        /**
         * convert string definition to structure
         */
        function getStructure(definition) {
            const lines = definition.split(/\r?\n/);
            const patterns = {
                group: /^\s*\[(?<list>[^\]]+)\]\s*(?<name>\S.*)/,
                template: /^\s*(?<content>\S.*)?\[(?<list>[^\]]+)\]\s*$/,
                conditional: /^\s*\?\[(?<expr>[^\]]+)\]\s*(?<content>.*)/,
                data: /^\s*\@(?<expr>([^=]+)(=\s*(.+))?(;([^=]+)(=\s*(.+))?)*)/,
                continuation: /^\s*\&(?<content>.+)/,
            };

            const structure = [];
            const stack = [];

            for (const line of lines) {
                if (/^\s*(#|$)/.test(line)) {
                    continue;
                }
                const content = line.trimStart();
                const level = line.length - content.length;
                while (stack.length && stack[0].level >= level) {
                    stack.shift();
                }

                const node = {
                    content, parent: stack[0], level, parts: [],
                };

                const groupNode = content.match(patterns.group);
                const templateNode = content.match(patterns.template);
                const conditionalNode = content.match(patterns.conditional);
                const dataNode = content.match(patterns.data);
                const continuation = content.match(patterns.continuation);

                if (continuation && stack.length) {
                    stack[0].content += '|' + continuation.groups.content;
                }

                if (groupNode) {
                    setGroupData(node, groupNode);
                    node.groupNode = true;
                }
                if (templateNode && !/\t\[[\]]+\]$/.test(content)) {
                    //node.template = Object.assign({}, node, { content: templateNode.groups.content });
                    setGroupData(node, templateNode);
                    node.content = templateNode.groups.content;
                    node.templateNode = true;
                    document.body.style.background = 'lightblue';
                }
                if (conditionalNode) {
                    node.conditionalNode = true;
                    const conditionPattern = /\s*(?<name>[^=]+)(=\s*(?<values>.+))?/;
                    const expr = conditionalNode.groups.expr.split(/;/g);
                    node.conditions = expr.map((item) => {
                        const conditionMatch = item.match(conditionPattern);
                        const condition = { name: conditionMatch.groups.name, };
                        if (conditionMatch.groups.values) {
                            condition.values = conditionMatch.groups.values.split(/,/g).map(numberOrString);
                        }
                        return condition;
                    });
                    if (conditionalNode.groups.content) {
                        const contentNode = {
                            content: conditionalNode.groups.content.trim(),
                            parent: node, level, parts: [],
                        };
                        node.parts.push(contentNode);
                    }
                    node.test = function (context) {
                        return this.conditions.every((condition) => {
                            if (condition.values) {
                                return condition.values.includes(context.parameters[condition.name]);
                            }
                            const names = condition.name.split(/\s*,\s*/g)
                            return names.some((name) => context.path.find((node) => node.name === name));
                        });
                    }
                }
                if (stack.length && dataNode) {
                    node.dataNode = true;
                    //document.body.style.background = 'lightblue';
                    const exprPattern = /(?<name>[^=]+)(=\s*(?<values>.+))?/;
                    const expr = dataNode.groups.expr.split(/;/g);
                    const getNum = (value) => {
                        const num = Number(value);
                        if (!isNaN(num)) {
                            return num;
                        }
                        return value.trim();
                    };
                    node.data = expr.filter((expr) => expr).reduce((data, item) => {
                        const exprMatch = item.match(exprPattern);
                        const name = exprMatch.groups.name.trim();
                        const values = exprMatch.groups.values;
                        if (values) {
                            if (values.includes(',')) {
                                data[name] = values.split(/,/g).map((value) =>
                                    getNum(value));
                            } else {
                                data[name] = getNum(values);
                            }
                        } else {
                            data[name] = true;
                        }
                        return data;
                    }, {});
                }

                if (stack.length) {
                    if (!continuation) {
                        stack[0].parts.push(node);
                    }
                } else {
                    structure.push(node);
                }
                stack.unshift(node);
            }
            return structure;
        }

        /**
         * Toggle the expansion of a node.
         */
        function toggleExpansion(node, recursive) {
            node.expanded = !node.expanded;

            const expand = (node) => {
                if (recursive) {
                    node.expanded = true;
                }
                node.nodes.forEach((node) => node.classList.remove('collapse'));
                if (node.expanded) {
                    node.parts.forEach((part) => expand(part));
                } else {
                    node.nodes[1].classList.add('collapse');
                }
            };

            const collapse = (node) => {
                if (recursive) {
                    node.expanded = false;
                }
                node.nodes.forEach((node) => node.classList.add('collapse'));
                node.parts.forEach((part) => collapse(part));
            };

            if (node.expanded) {
                node.parts.forEach((part) => expand(part));
                node.nodes[0].innerHTML = '&CircleMinus;';
                node.nodes[1].classList.remove('collapse');
            } else {
                node.parts.forEach((part) => collapse(part));
                node.nodes[0].innerHTML = '&CirclePlus;';
                node.nodes[1].classList.add('collapse');
            }
        }

        /**
         *
         */
        function numberOrString(input) {
            const num = Number(input);
            if (isNaN(num)) {
                return input.trim();
            }
            return num;
        }

        /**
         * Generate an new structure from the defintion
         */
        function defaultParser(node, context) {
            if (node.content) {
                const [name, ...data] = node.content.split(/\||\t|;/g);
                node.name = name.trim();
                node.values = [];
                node.data = data.reduce((data, item) => {
                    item = item.trim();
                    if (item.includes('=')) {
                        const [name, value] = item.split(/=/);
                        if (/^"[^"]+"$/.test(value)) {
                            data[name] = value;
                        } else if (value.includes(',')) {
                            data[name] = value.split(/,/g).map((val) => numberOrString(val));
                        } else {
                            data[name] = numberOrString(value);
                        }
                    } else {
                        node.values.push(numberOrString(item));
                    }
                    return data;
                }, {});
            }
        }



        /**
         * Generate an new structure from the defintion
         */
        function parseStructure(structure, parser = defaultParser) {
            const names = {};

            const evaluate = (string, context) => {
                const path = (sep, start = 0, end) =>
                    context.path.toReversed().slice(start, end).map((node) => node.name).join(sep || '');
                const pathUp = (sep, start = 0, end) =>
                    context.path.slice(start, end).map((node) => node.name).join(sep || '');

                const level = (val) =>
                    context.path[val < 0 ? Math.abs(val) : context.path.length - val].name || '';
                const names = [];
                const values = [];
                Object.keys(context.parameters).filter((key, value) => key).forEach((key) => {
                    names.push(key);
                    values.push(context.parameters[key]);
                });
                try {
                    const func = new Function('path', 'pathUp', 'level', ...names, `return ${string};`);
                    return func(path, pathUp, level, ...values);
                } catch (e) {
                    console.log(e);
                }
                return string;
            };

            const resolve = (string, context) => {
                string = string.replace(/\[\s*-?([0-9]+)\s*\]/, //'_path[$1]');
                    (m, p) => `${context.path[context.path.length - Number(p)] || ''}`);
                string = string.replace(/\[\s*\+\s*(?<sep>.+)?\s*\]/,
                    (m, sep) => `${context.path.join(sep || ' ')}`);
                string = string.replace(/\[\s*-\s*(?<sep>.+)?\s*\]/,
                    (m, sep) => `${context.path.toReversed().join(sep || ' ')}`);

                for (const [name, value] of Object.entries(context.parameters)) {
                    const pattern = new RegExp(`\\b${name}\\b`, 'g');
                    string = string.replace(pattern, value);
                }

                return `${string}`;
            };

            const root = [];

            const addNode = (source, parent, context = { resolved: true, parameters: {}, path: [], nesting: [] }) => {
                context = Object.assign({}, context);
                let node = { source, parts: [], content: source.content, data: {}, };
                const controlNode = source.groupNode || source.conditionalNode || source.templateNode;
                const parts = [...source.parts];

                if (!controlNode) {
                    node.content = node.content.replace(/<([^>]*)>/g, (match, label) => {
                        if (context.parameters[label]) {
                            return context.parameters[label];
                        }
                        const index = Number(label);
                        if (!isNaN(index) && context.nesting.length) {
                            return context.nesting[Math.abs(index) % context.nesting.length][0];
                        }
                        const keys = Object.keys(names).sort((a, b) => b.length - a.length);
                        const name = keys.find((key) => label.startsWith(key));
                        if (name) {
                            parts.unshift(...names[name].source.parts);
                            return names[name].content;
                        }
                        return match;
                    });
                    node.content = node.content.replace(/\{([^}]+)\}/g, (match, p1) => evaluate(p1, context));
                    node.content = node.content.replace(/:([^\t\|;:]+)/g, (all, item) => {
                        if (context.parameters[item]) {
                            return `:${context.parameters[item]}`;
                        }
                        const keys = Object.keys(names).sort((a, b) => b.length - a.length);
                        const name = keys.find((key) => item.startsWith(key));
                        if (name) {
                            parts.unshift(...names[name].source.parts);
                            return `:${names[name].content}`;
                        }
                        return all;
                    });
                }

                if (source.dataNode) {
                    Object.assign(context.path[0].data, source.data);
                }

                parser(node, context);

                if (!controlNode) {
                    const path = context.path.map((node) => node.name);
                    let l = 1;
                    while (names[`${node.name}, ${path.slice(0, l).join(', ')}`] && l < path.length) {
                        l += 1;
                    }
                    node.uniqueName = `${node.name}, ${path.slice(0, l).join(', ')}`
                }

                if (!controlNode) {
                    context.path.unshift(node);
                }

                const matched = (!source.conditionalNode) || source.test(context);

                if (source.templateNode) {
                    if (!/(<[^>]*>)|(\{[^\}]*\})/.test(node.content)) {
                        document.body.style.background = 'pink';
                        node.content = `${node.content} <>`;
                    }

                    node.parts = [...source.parts];
                    if (context.parameters[''] !== undefined) {
                        context.nesting.unshift([context.parameters[''], context.parameters['_n']])
                    }
                    source.group.forEach((item, index) => {
                        context.parameters[''] = item;
                        context.parameters[`_n`] = index;
                        /*
                        context.parameters[node.name] = item;
                        context.parameters[`${node.name}_n`] = index;
                        */
                        addNode(node, parent, context);
                    });
                    if (context.parameters[''] !== undefined) {
                        context.nesting.shift();
                    }
                }

                if (parts.length && matched && !source.referenceNode) {
                    if (source.groupNode) {
                        source.group.forEach((item, index) => {
                            context.parameters[source.name] = item;
                            context.parameters[`${source.name}_n`] = index;
                            parts.forEach((part) => addNode(part, parent, context));
                        });
                    } else {
                        parts.forEach((part) => addNode(part, node, context));
                    }
                }
                names[node.name] = names[node.name] || node;
                names[node.uniqueName] = node;
                if (!controlNode) {
                    context.path.shift();
                }
                if (!controlNode) {
                    if (parent) {
                        parent.parts.push(node);
                        node.parent = parent;
                    } else {
                        root.push(node);
                    }
                }
            };
            structure.forEach((node) => addNode(node));

            return root;
        }

        /**
         * Generate dom nodes for the given structure
         */
        function getView(structure, actions = {}) {
            const container = document.createElement('div');
            container.classList.add('tree-view');

            const nodes = [];

            const flatten = (node, level = 1) => {
                node.level = level;
                nodes.push(node);
                node.parts.forEach((part) => flatten(part, level + 1));
            };

            structure.forEach((part) => flatten(part));

            let depth = Math.max(...nodes.map((node) => node.level));

            let row = 0;
            const addNode = (node) => {
                row += 1;
                let text = node.name;
                node.expanded = true;
                node.row = row;
                node.nodes = [];
                const controlNode = node.source.groupNode || node.source.datNode || node.source.conditional;

                const group = document.createElement('div');
                container.appendChild(group);
                group.style.gridColumn = node.level;
                const expander = document.createElement('div');
                expander.classList.add('expand');
                node.nodes.push(expander);
                node.nodes.push(group);
                group.appendChild(expander);
                const content = document.createElement('div');
                content.classList.add('content');

                if (controlNode) {
                    content.classList.add('control-node');
                    if (node.unrolled) {
                        content.classList.add('range-expanded');
                    }
                    content.addEventListener('click', (event) => {
                        node.unrolled = !node.unrolled;
                        container.innerHTML = '';
                        row = 0;
                        structure.forEach((part) => addNode(part));
                    });
                }
                node.nodes.push(content);
                content.style.gridColumn = `${node.level + 1}/${depth + 2}`;
                container.appendChild(content);
                const data = Object.entries(node.data).map(([name, value]) => `${name} = ${value}`).join(', ');
                content.innerText = `${text}`;// (${data})`;
                content.title = `${node.uniqueName} ${data}`;
                if (node.shape) {
                    content.classList.add('shape');
                }
                if (node.sceneNode) {
                    content.classList.add('scene-node');
                }
                Object.entries(actions).forEach(([event, action]) =>
                    content.addEventListener(event, (event) => action(event, node)));

                if (node.parts.length) {
                    group.classList.add('group');
                    expander.innerHTML = '&CircleMinus;';
                    expander.addEventListener('click', (event) => toggleExpansion(node, event.ctrlKey));
                    expander.addEventListener('dblclick', (event) => toggleExpansion(node, true));

                    const startRow = row;
                    node.parts.forEach((part) => addNode(part));
                    group.style.gridRow = `${startRow}/${row + 1}`;
                    group.style.background = `hsl(${360 * Math.random()} 50% 50%)`;
                }
                return nodes;
            };

            const columns = `repeat(${depth}, 1em) max-content 1fr`;
            container.style.gridTemplateColumns = columns;

            structure.forEach((part) => addNode(part));
            return container;
        }

        /**
         * Generate scene graph for the given structure
         */
        function getGraph(structure, scene) {
            const buffers = {
                vertexBuffer: [],
                indices: [],
            };

            const types = {
                box: {
                    makeShape: (node) => new Box(scene.gl, buffers, node.data.width, node.data.height, node.data.depth),
                    hash: (node) => `box ${node.data.width} ${node.data.height} ${node.data.depth}`,
                },
                ball: {
                    makeShape: (node) => new Ball(scene.gl, buffers, node.data.width, node.data.height, node.data.depth, node.data.sides, node.data.strips),
                    hash: (node) => `ball ${node.data.width} ${node.data.height} ${node.data.depth} ${node.data.sides} ${node.data.strips}`,
                },
                cone: {
                    makeShape: (node) => new Frustrum(scene.gl, buffers, node.data.radius, 0, node.data.height, node.data.sides),
                    hash: (node) => `cone ${node.data.radius} ${node.data.height} ${node.data.sides}`,
                },
                cylinder: {
                    makeShape: (node) => new Cylinder(scene.gl, buffers, node.data.radius, node.data.height, node.data.sides),
                    hash: (node) => `cylinder ${node.data.radius} ${node.data.height} ${node.data.sides}`,
                },
                frustrum: {
                    makeShape: (node) => new Frustrum(scene.gl, buffers, node.data.baseRadius, node.data.topRadius, node.data.height, node.data.sides),
                    hash: (node) => `frustrum ${node.data.baseRadius} ${node.data.topRadius} ${node.data.height} ${node.data.sides}`,
                },
                diamond: {
                    makeShape: (node) => new Diamond(scene.gl, buffers, node.data.size),
                    hash: (node) => `diamond ${node.data.size}`,
                },
                tetrahedron: {
                    makeShape: (node) => new Tetrahedron(scene.gl, buffers, node.data.size),
                    hash: (node) => `tetrahedron ${node.data.size}`,
                },
            };
            scene.shapes = [];
            const shapes = {};

            const flatten = (node, level = 1) => {
                const type = node.data?.type ? node.data.type.toLowerCase() : null;
                if (type && types[type]) {
                    const hash = types[type].hash(node);
                    shapes[hash] = shapes[hash] || types[type].makeShape(node);
                    node.shape = shapes[hash];
                    scene.shapes.push(node.shape);
                }
                node.parts.forEach((part) => flatten(part, level + 1));
            };

            structure.forEach((part) => flatten(part));
            updateBuffers(scene.gl, scene.buffers, buffers);
            glErrors(scene.gl, context = 'Update Buffers');

            const stack = [];
            scene.graph = [];
            scene.nodes = [];

            const getParent = (node) => {
                let parent = node.parent;
                while (parent && !parent.sceneNode && parent.parent) {
                    parent = parent.parent;
                }
                return parent?.sceneNode;
            }

            const add = (node) => {
                if (node.data.position && node.data.position.length === 3) {
                    node.data.position = node.data.position.map((v) => isNaN(v) ? 0 : v);
                    const shader = Math.random() > 0.5 ? scene.shader3 : scene.shader4;
                    const transform = [];
                    if (node.data.rotation && node.data.rotation.length === 4) {
                        node.data.rotation = node.data.rotation.map((v) => isNaN(v) ? 0 : v);
                        const angle = Math.PI * node.data.rotation[0] / 180;
                        const axis = normalise([...node.data.rotation.slice(1)]);
                        const q = new Quaternion(
                            Math.cos(angle / 2),
                            Math.sin(angle / 2) * axis[0],
                            Math.sin(angle / 2) * axis[1],
                            Math.sin(angle / 2) * axis[2]);
                        q.setMatrix(transform);
                        transform[12] = node.data.position[0];
                        transform[13] = node.data.position[1];
                        transform[14] = node.data.position[2];
                    } else {
                        transform.push(
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            ...node.data.position, 1);
                    }
                    const parent = getParent(node);
                    const colour = [1, 0.9, 0.5, 1];
                    if (Array.isArray(node.data.colour)) {
                        node.data.colour.forEach((val, index) => colour[index] = val);
                    }
                    node.sceneNode = addNode(node.name, parent, transform, node.shape, shader, colour);
                    if (!parent) {
                        scene.graph.push(node.sceneNode);
                    }
                    node.sceneNode.sourceNode = node;
                    scene.nodes.unshift(node.sceneNode);
                    stack.unshift(node);
                }

                if (node.parts.length) {
                    node.parts.forEach((part) => add(part));
                }

                if (node.position) {
                    stack.shift();
                }
            };

            structure.forEach((part) => add(part));
        }

        /**
         *
         */
        function associateArray(node, arr, action) {
            let index = 0;
            const update = (index) => {
                return (event, value) => arr[index] = event.target.valueAsNumber;
            }

            for (const input of node.querySelectorAll('input')) {
                input.value = arr[index];
                input.addEventListener('input', update(index));
                index += 1;
            }
        }

        /**
         *
         */
        const scene = {
            shapes: [],
            points: [],
            lines: [],
            overlays: [],
        }


        // Vertex shader program
        /**
         *
         */
        const vsSource = `
            attribute vec4 aVertexPosition;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;

            varying vec4 v_position;

            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                v_position = gl_Position;
            }`;

        // Vertex shader
        /**
         *
         */
        const vsSource2 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
            }`;

        /**
         *
         */
        const fsSource = `
            precision mediump float;
            varying vec4 v_position;

            uniform vec4 uColour;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 color = v_position * 0.15 + 0.5;
                gl_FragColor = uColour;
            }`;

        /**
         *
         */
        const fsSource2 = `
            precision mediump float;
            varying vec4 v_position;

            uniform vec4 uColour;

            void main() {
                vec4 color = v_position * 0.5 + 0.5;
                gl_FragColor = color * uColour;
            }`;


        /**
         *
         */
        const fsSource3 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColor;
            uniform vec4 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient
                vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColor.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColor.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColor * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 color = ambient + diffuse + specular;

                // Output final color
                gl_FragColor = vec4(color, 1.0);
            }`;

        /**
         *
         */
        const fsSource4 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColor;
            uniform vec4 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColor.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColor * specularIntensity;

                float edge = clamp(1.0 - vNormal.z, 0.0, 1.0);
                vec3 ambient = edge * vec3(0.25, 0.25, 0.25) * uDiffuseColor.rgb;
                // Combine diffuse and specular contributions
                vec3 color = ambient + diffuse + specular;

                // Output final color
                gl_FragColor = vec4(color, 1.0);

            }`;

        /**
         *
         */
        const fsSource5 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColor;
            uniform vec4 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            float rand(float co) {
                return fract(sin(co*(91.3458)) * 47453.5453);
            }

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            float rand(vec3 co){
                return rand(co.xy+rand(co.z));
            }

            void main() {
                // ambient
                vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColor.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColor.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColor * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 color = ambient + diffuse + specular;

                // Output final color
                gl_FragColor = vec4(color, 1.0);
            }`;

        //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        /**
         *
         */
        function initialiseShaders(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getShaderLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        /**
         * creates a shader of the given type, uploads the source and
         * compiles it.
         */
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        /**
         *
         */
        function initBuffers(gl, data) {

            // Create a buffer for the square's positions.

            const vertexBuffer = gl.createBuffer();
            const indexBuffer = gl.createBuffer();

            // Select the .vertexBuffer as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);


            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(data.vertexBuffer),
                gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(data.indices),
                gl.STATIC_DRAW);

            return {
                vertexBuffer,
                indexBuffer
            };
        }

        /**
         *
         */
        function updateBuffers(gl, buffers, data) {
            // Select the .vertexBuffer as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertexBuffer);


            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(data.vertexBuffer),
                gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indexBuffer);

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(data.indices),
                gl.STATIC_DRAW);
        }

        /**
         *
         */
        function addClosedTriangleStrip(gl, indexBuffer, nQuads, start1, start2, step1 = 2, step2) {
            const offset = indexBuffer.length * 2;
            step2 = step2 || step1;
            start2 = start2 !== undefined ? start2 : start1 + 1;
            for (let i = 0; i < nQuads; ++i) {
                indexBuffer.push(start1 + i * step1);
                indexBuffer.push(start2 + i * step2);
            }
            indexBuffer.push(start1);
            indexBuffer.push(start2);
            const count = 2 + nQuads * 2
            return { mode: gl.TRIANGLE_STRIP, count, offset };
        }

        /**
         *
         */
        function addTriangles(gl, vertexBuffer, indexBuffer, points) {
            const offset = indexBuffer.length * 2;
            let index = vertexBuffer.length / 6;
            const nTriangles = Math.floor(points.length / 3);
            for (let i = 0; i < nTriangles; ++i) {
                const p0 = points[i * 3];
                const p1 = points[i * 3 + 1];
                const p2 = points[i * 3 + 2];
                const v1 = [p0[0] - p1[0], p0[1] - p1[1], p0[2] - p1[2]];
                const v2 = [p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];
                const n = [
                    v1[1] * v2[2] - v1[2] * v2[1],
                    v1[2] * v2[0] - v1[0] * v2[2],
                    v1[0] * v2[1] - v1[1] * v2[0]];
                const l = Math.hypot(n[0], n[1], n[2]);
                n[0] /= l;
                n[1] /= l;
                n[2] /= l;
                vertexBuffer.push(...p0, ...n);
                indexBuffer.push(index++);
                vertexBuffer.push(...p1, ...n);
                indexBuffer.push(index++);
                vertexBuffer.push(...p2, ...n);
                indexBuffer.push(index++);
            }

            return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
        }

        /**
         *
         */
        function addClosedTriangleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;

            if (true) {
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(centre);
                    indexBuffer.push(first + i * step);
                    indexBuffer.push(first + ((i + 1) % nTriangles) * step);
                }
                return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
            } else {
                indexBuffer.push(centre);
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(first + i * step);
                }
                indexBuffer.push(first);
                const count = 2 + nTriangles
                return { mode: gl.TRIANGLE_FAN, count, offset };
            }
        }

        /**
         *
         */
        function addOpenTraingleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;
            indexBuffer.push(centre);
            for (let i = 0; i <= nTriangles; ++i) {
                indexBuffer.push(first + i * step);
            }
            const count = 2 + nTriangles
            return { mode: gl.TRIANGLE_FAN, count, offset };
        }

        /**
         *
         */
        function addLineLoop(gl, indexBuffer, nSegments, first, step = 1) {
            const offset = indexBuffer.length * 2;
            for (let i = 0; i < nSegments; ++i) {
                indexBuffer.push(first + i * step);
            }
            indexBuffer.push(first);
            const count = 1 + nSegments
            return { mode: gl.LINE_STRIP, count, offset };
        }

        /**
         *
         */
        class Box {
            constructor(gl, data, w, h, d) {
                if (w === undefined) {
                    w = 0.5;
                } else {
                    w /= 2;
                }
                if (h === undefined) {
                    h = w;
                } else {
                    h /= 2;
                }
                if (d === undefined) {
                    d = h;
                } else {
                    d /= 2;
                }
                this.width = 2 * w;
                this.height = 2 * h;
                this.depth = 2 * d;
                const start = data.vertexBuffer.length / 6;
                data.vertexBuffer.push(
                    -w, -h, -d,
                    0, 0, -1,
                    -w, h, -d,
                    0, 0, -1,

                    w, -h, -d,
                    0, 0, -1,
                    w, h, -d,
                    0, 0, -1,

                    w, -h, -d,
                    1, 0, 0,
                    w, h, -d,
                    1, 0, 0,

                    w, -h, d,
                    1, 0, 0,
                    w, h, d,
                    1, 0, 0,

                    w, -h, d,
                    0, 0, 1,
                    w, h, d,
                    0, 0, 1,

                    -w, -h, d,
                    0, 0, 1,
                    -w, h, d,
                    0, 0, 1,

                    -w, -h, d,
                    -1, 0, 0,
                    -w, h, d,
                    -1, 0, 0,

                    -w, -h, -d,
                    -1, 0, 0,
                    -w, h, -d,
                    -1, 0, 0,

                    -w, -h, -d,
                    0, -1, 0,
                    w, -h, -d,
                    0, -1, 0,

                    w, -h, d,
                    0, -1, 0,
                    -w, -h, d,
                    0, -1, 0,

                    -w, h, -d,
                    0, 1, 0,
                    w, h, -d,
                    0, 1, 0,

                    w, h, d,
                    0, 1, 0,
                    -w, h, d,
                    0, 1, 0
                );

                const indexStart = data.indices.length;
                data.indices.push(...[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                    16, 17, 18, 18, 19, 16, 20, 21, 22, 22, 23, 20,
                    16, 17, 18, 19, 16, 20, 21, 22, 23, 20,
                    16, 20, 17, 21, 18, 22, 19, 23,
                ].map((i) => i + start));

                this.elements = [
                    { mode: gl.TRIANGLE_STRIP, count: 16, offset: indexStart * 2 },
                    { mode: gl.TRIANGLES, count: 12, offset: (16 + indexStart) * 2 },
                    { mode: gl.LINE_STRIP, count: 5, offset: (28 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 5, offset: (33 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINES, count: 8, offset: (indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const planes = [
                    { point: [this.width / 2, 0, 0], normal: [1, 0, 0] },
                    { point: [-this.width / 2, 0, 0], normal: [-1, 0, 0] },
                    { point: [0, this.height / 2, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height / 2, 0], normal: [0, -1, 0] },
                    { point: [0, 0, this.depth / 2], normal: [0, 0, 1] },
                    { point: [0, 0, -this.depth / 2], normal: [0, 0, -1] },
                ];
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const w = this.width / 2;
                const h = this.height / 2;
                const d = this.depth / 2;
                const points = [
                    [-w, -h, -d,],
                    [w, -h, -d,],
                    [w, -h, d,],
                    [-w, -h, d,],

                    [-w, h, -d,],
                    [w, h, -d,],
                    [w, h, d,],
                    [-w, h, d,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.lineTo(points[4][0], points[4][1]);

                context.moveTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.moveTo(points[2][0], points[2][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.moveTo(points[4][0], points[4][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.stroke();
            }
        }

        /**
         *
         */
        class Diamond {
            constructor(gl, data, size = 1) {
                this.size = size;
                const start = data.vertexBuffer.length / 6;
                const indexStart = data.indices.length;
                const points = [
                    [0, 1, 0,],
                    [1, 0, 0,],
                    [0, 0, 1,],

                    [0, 1, 0,],
                    [0, 0, 1,],
                    [-1, 0, 0,],

                    [0, 1, 0,],
                    [-1, 0, 0,],
                    [0, 0, -1,],

                    [0, 1, 0,],
                    [0, 0, -1,],
                    [1, 0, 0,],


                    [0, -1, 0,],
                    [1, 0, 0,],
                    [0, 0, 1,],

                    [0, -1, 0,],
                    [0, 0, 1,],
                    [-1, 0, 0,],

                    [0, -1, 0,],
                    [-1, 0, 0,],
                    [0, 0, -1,],

                    [0, -1, 0,],
                    [0, 0, -1,],
                    [1, 0, 0,],
                ].map((point) => point.map((v) => v * size));

                data.indices.push(...[
                    0, 1, 2, 0, 7, 8, 0,
                    12, 13, 14, 12, 17, 18, 12
                ].map((i) => i + start));

                this.elements = [
                    addTriangles(gl, data.vertexBuffer, data.indices, points),
                    { mode: gl.LINE_STRIP, count: 7, offset: (24 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 7, offset: (31 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ];

                const planes = [
                    planeFromPoints(points[0], points[2], points[1]),
                    planeFromPoints(points[0], points[3], points[2]),
                    planeFromPoints(points[0], points[4], points[3]),
                    planeFromPoints(points[0], points[1], points[4]),

                    planeFromPoints(points[5], points[1], points[2]),
                    planeFromPoints(points[5], points[2], points[3]),
                    planeFromPoints(points[5], points[3], points[4]),
                    planeFromPoints(points[5], points[4], points[1]),
                ];

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[0][0], points[0][1]);

                context.moveTo(points[5][0], points[5][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);

                context.stroke();
            }
        }

        /**
         *
         */
        class Ball {
            constructor(gl, data, width = 2, depth = 2, height = 2, sides = 12, strips = 12) {
                this.width = width / 2;
                this.depth = depth / 2;
                this.height = height / 2;
                this.sides = sides;
                this.strips = strips;
                const start = data.vertexBuffer.length / 6;
                const indexStart = data.indices.length;

                // Create the mesh for the ball
                data.vertexBuffer.push(0, height / 2, 0);
                data.vertexBuffer.push(0, 1, 0);
                data.vertexBuffer.push(0, -height / 2, 0);
                data.vertexBuffer.push(0, -1, 0);
                for (let j = 0; j < strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / strips);
                    for (let i = 0; i < sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / sides;
                        data.vertexBuffer.push(
                            this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians));
                        data.vertexBuffer.push(
                            radius * Math.sin(radians), ny, radius * Math.cos(radians));
                    }
                }

                const elements = [
                    addClosedTriangleFan(gl, data.indices, sides, start, start + 2),
                    addClosedTriangleFan(gl, data.indices, sides, start + 1, start + 2 + (strips - 2) * sides),
                ];

                for (let j = 0; j < strips - 2; ++j) {
                    elements.push(addClosedTriangleStrip(gl, data.indices, sides, start + 2 + j * sides, start + 2 + (j + 1) * sides, 1, 1));
                }

                this.elements = elements;
            }
            intersects(line) {

                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Frustrum {
            constructor(gl, data, baseRadius = 1, topRadius = 0.5, height = 2, sides = 12) {
                height /= 2;
                this.height = height;
                this.baseRadius = baseRadius;
                this.topRadius = topRadius;
                this.sides = sides;

                const start = data.vertexBuffer.length / 6;
                const indexStart = data.indices.length;

                const angle = Math.atan((baseRadius - topRadius) / 2 * height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                for (let i = 0; i < sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / sides;
                    const topRadians = (1 + i * 2) * Math.PI / sides;
                    data.vertexBuffer.push(
                        baseRadius * Math.sin(baseRadians), -height, baseRadius * Math.cos(baseRadians),
                        nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),
                        topRadius * Math.sin(topRadians), height, topRadius * Math.cos(topRadians),
                        nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians));
                }

                data.vertexBuffer.push(0, -height, 0);
                data.vertexBuffer.push(0, -1, 0);

                for (let i = 0; i < sides; ++i) {
                    const angle = i * 2 * Math.PI / sides;
                    data.vertexBuffer.push(
                        baseRadius * Math.sin(angle), -height, baseRadius * Math.cos(angle),
                        0, -1, 0);
                }

                const elements = [
                    addClosedTriangleStrip(gl, data.indices, sides, start),
                    addClosedTriangleFan(gl, data.indices, sides, start + 2 * sides, 1 + start + 2 * sides),
                ];

                if (topRadius > 0) {
                    data.vertexBuffer.push(0, height, 0);
                    data.vertexBuffer.push(0, 1, 0);

                    for (let i = 0; i < sides; ++i) {
                        const angle = (1 + i * 2) * Math.PI / sides;
                        data.vertexBuffer.push(
                            topRadius * Math.sin(angle), height, topRadius * Math.cos(angle),
                            0, 1, 0);
                    }
                    elements.push(addClosedTriangleFan(gl, data.indices, sides, 1 + start + 3 * sides, 2 + start + 3 * sides));
                }

                elements.push(
                    Object.assign(addLineLoop(gl, data.indices, sides, 1 + start + 2 * sides), { colour: [1, 1, 1, 1] }));

                if (topRadius > 0) {
                    elements.push(
                        Object.assign(addLineLoop(gl, data.indices, sides, 2 + start + 3 * sides), { colour: [1, 1, 1, 1] }));
                }

                if (sides < 7) {
                    elements.push({ mode: gl.LINE_STRIP, count: sides * 2, offset: indexStart * 2, colour: [1, 1, 1, 1] });
                }
                this.elements = elements;
            }
            intersects(line) {
                const angle = Math.atan((this.baseRadius - this.topRadius) / 2 * this.height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                const planes = [
                    { point: [0, this.height, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height, 0], normal: [0, -1, 0] },
                ];

                for (let i = 0; i < this.sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / this.sides;
                    const topRadians = (1 + i * 2) * Math.PI / this.sides;

                    planes.push({
                        point: [this.baseRadius * Math.sin(baseRadians), -this.height, this.baseRadius * Math.cos(baseRadians),],
                        normal: [nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),],
                    }, {
                        point: [this.topRadius * Math.sin(topRadians), this.height, this.topRadius * Math.cos(topRadians),],
                        normal: [nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),],
                    });
                }

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Cylinder extends (Frustrum) {
            constructor(gl, data, radius = 1, height = 2, sides = 12) {
                super(gl, data, radius, radius, height, sides);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Tetrahedron {
            constructor(gl, data, size = 1) {
                this.size = 1;
                const indexStart = data.indices.length;
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [-l * l, -0.5, -0.5 * l],
                    [0, 1, 0],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((point) => point.map((v) => v * size));

                data.indices.push(0, 1, 1, 2, 2, 0, 3, 0, 3, 1, 3, 2);

                this.elements = [
                    addTriangles(gl, data.vertexBuffer, data.indices, points),
                    { mode: gl.LINES, count: 12, offset: (12 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const l = Math.cos(30 * Math.PI / 180);
                const sides = [
                    [[0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l]],
                    [[0, 1, 0],
                    [-l * l, -0.5, -0.5 * l],
                    [0, -0.5, l],],
                    [[0, 1, 0],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l]],
                    [[l * l, -0.5, -0.5 * l],
                    [0, -0.5, l,],
                    [-l * l, -0.5, -0.5 * l]],
                ].map((point) => point.map((v) => scaled(v, this.size)));

                const planes = sides.map((side) => planeFromPoints(...side));
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((p) => transformed(scaled(p, this.size), transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[1][0], points[1][1]);

                context.moveTo(points[3][0], points[3][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.stroke();
            }
        }

        /**
         *
         */
        function addNode(name, parent, transform, shape, shader, colour = [1, 0, 1, 1]) {
            /*
            const axis = [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1],
            ][Math.floor(Math.random() * 3)];
            const angle = (Math.random() - 0.5) * Math.PI / 360;
            const q = new Quaternion(
                Math.cos(angle / 2),
                Math.sin(angle / 2) * axis[0],
                Math.sin(angle / 2) * axis[1],
                Math.sin(angle / 2) * axis[2]);

            const spin = q.getMatrix();
            transform[12] += 0.1 - 0.2 * Math.random();
            transform[13] += 0.1 - 0.2 * Math.random();
            transform[14] += 0.1 - 0.2 * Math.random();
            */
            const spin = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            const node = {
                name, parent, transform, shape, shader, colour, children: [], spin, shininess: 1 + 5 * Math.random(),
            };
            if (parent) {
                parent.children.push(node);
            }
            return node;
        }

        /**
         *
         */
        function drawNode(gl, origin, node, time) {
            node.world = matrixMultiply(node.transform, origin);
            const transform = matrixMultiply(node.world, scene.modelViewMatrix);

            gl.useProgram(node.shader.program);
            gl.uniformMatrix4fv(node.shader.modelViewMatrixLocation, false, transform);
            const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
            gl.uniformMatrix3fv(node.shader.normalMatrixLocation, false, normalMatrix);
            node.shader.setNodeData(gl, node);
            if (node.shape) {
                node.shape.elements.forEach((shape) => {
                    if (shape.colour) {
                        gl.uniform4fv(node.shader.colourLocation, shape.colour);
                    }
                    gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                });
            }
            node.children.forEach((child) => drawNode(gl, node.world, child, time));
        }

        /**
         *
         */
        function positionNode(origin, node) {
            node.world = matrixMultiply(node.transform, origin);
            node.children.forEach((child) => positionNode(node.world, child));
        }

        /**
         *
         */
        function drawNode2(gl, node, shader, time) {
            if (node.shader === shader) {
                const transform = matrixMultiply(node.world, scene.modelViewMatrix);
                gl.uniformMatrix4fv(node.shader.modelViewMatrixLocation, false, transform);
                const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
                gl.uniformMatrix3fv(node.shader.normalMatrixLocation, false, normalMatrix);
                node.shader.setNodeData(gl, node);
                node.shape.forEach((shape) => {
                    if (shape.colour) {
                        gl.uniform4fv(node.shader.colourLocation, shape.colour);
                    }
                    gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                });
            }

            node.children.forEach((child) => drawNode2(gl, child, shader));
        }

        /**
         *
         */
        function drawScene(gl, buffers, shapes, time) {
            gl.clearColor(0.0, 0.1, 0.1, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            glErrors(gl, 'drawScene');
            const ident = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            scene.graph.forEach((node) => drawNode(scene.gl, ident, node, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function drawScene2(gl, buffers, shapes, time) {
            gl.clearColor(0.0, 0.1, 0.1, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            glErrors(gl, 'drawScene');

            const origin = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            scene.graph.forEach((node) => positionNode(origin, node));

            gl.useProgram(scene.shader3.program);
            scene.graph.forEach((node) => drawNode2(scene.gl, node, scene.shader3, time));
            gl.useProgram(scene.shader4.program);
            scene.graph.forEach((node) => drawNode2(scene.gl, node, scene.shader4, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function glErrors(gl, context = '') {
            const err = gl.getError();
            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.log(context, errors[err]);
            }
        }

        /**
         *
         */
        function initialiseShader(gl, shader, buffers, projectionMatrix) {
            const numComponents = 3;  // pull out 2 values per iteration
            const type = gl.FLOAT;    // the data in the buffer is 32bit floats
            const normalize = false;  // don't normalize
            const stride = 4 * 3 * 2;         // how many bytes to get from one set of values to the next
            // 0 = use type and numComponents above
            const offset = 0;         // how many bytes inside the buffer to start from
            gl.useProgram(shader.program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertexBuffer);
            gl.vertexAttribPointer(
                shader.attribLocations.vertexPosition,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            gl.enableVertexAttribArray(shader.attribLocations.vertexPosition);

            if (shader.attribLocations.vertexNormal) {
                gl.vertexAttribPointer(
                    shader.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    4 * 3);
                gl.enableVertexAttribArray(shader.attribLocations.vertexNormal);
            }

            // Tell WebGL to use our program when drawi

            // Set the shader uniforms
            gl.uniformMatrix4fv(shader.projectionMatrixLocation, false, projectionMatrix);

            if (shader.lightPosition) {
                gl.uniform3fv(shader.lightPosition, shader.light.position);
            }
        }

        /**
         *
         */
        const times = [];
        let last = 0;

        /**
         *
         */
        const cameraMove = document.getElementById('move');

        /**
         *
         */
        class Camera {
            constructor(position = [0, 0, 1], target = [0, 0, 0], up = [0, 1, 0]) {
                this.position = position;
                this.target = target;
                this.up = up;
            }
            viewMatrix(eye, at, up) {
                const zaxis = normalise(subtract(this.target, this.position));
                const xaxis = normalise(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);

                negate(zaxis);

                return [
                    xaxis[0], yaxis[0], zaxis[0], 0,
                    xaxis[1], yaxis[1], zaxis[1], 0,
                    xaxis[2], yaxis[2], zaxis[2], 0,
                    -dot(xaxis, this.position), -dot(yaxis, this.position), -dot(zaxis, this.position), 1
                ];
            }
            forward(distance) {
                const zaxis = normalise(subtract(this.target, this.position));
                const movement = scaled(zaxis, distance);
                this.position = add(this.position, movement);
                this.target = add(this.target, movement);
            }
            rotateX(angle) {
                const zaxis = subtract(this.target, this.position);
                const xaxis = cross(zaxis, this.up);

                const offset = subtract(this.position, this.target);
                rotate(offset, xaxis, angle);
                rotate(this.up, xaxis, angle);

                this.position = add(this.target, offset);
            }
            rotateY(angle) {
                const offset = subtract(this.position, this.target);
                rotate(offset, this.up, angle);
                //rotate(this.up, [0, 1, 0], angle);

                this.position = add(this.target, offset);
            }
            pitch(angle) {
                const zaxis = subtract(this.target, this.position);
                const xaxis = cross(zaxis, this.up);

                rotate(zaxis, xaxis, angle);
                rotate(this.up, xaxis, angle);
                this.target = add(this.position, zaxis);
            }
            yaw(angle) {
                const zaxis = subtract(this.target, this.position);
                rotate(zaxis, this.up, angle);
                this.target = add(this.position, zaxis);
            }
            roll(angle) {
                const zaxis = subtract(this.target, this.position);
                rotate(this.up, zaxis, angle);
            }
            getLine(x, y, fieldOfView) {
                const aspect = scene.gl.canvas.clientWidth / scene.gl.canvas.clientHeight;
                const fov = fieldOfView * Math.PI / 180;
                const zaxis = normalise(subtract(this.target, this.position));
                const xaxis = normalise(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);
                const d = 1 / Math.tan(fov / 2);
                const direction = normalise(add(scaled(xaxis, x * aspect), scaled(yaxis, y), scaled(zaxis, d)));
                //const direction = normalise(subtract(point, this.position));
                return { point: this.position, direction };
            }
        }

        /**
         *
         */
        const camera = new Camera();
        camera.position = [0, 0, -20];
        camera.target = [0, 0, 0];
        camera.up = [0, 1, 0];

        /**
         * Management of a 2 view using a canvas
         */
        class View2d {
            constructor(scene, canvasId) {
                this.projection = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
                this.scene = scene;
                this.canvas = document.getElementById(canvasId);
                this.context = this.canvas.getContext('2d');
                const scale = Math.min(this.canvas.width, this.canvas.height) / 20;
                this.projection[8] = scale;
                this.projection[5] = scale;
                /*
                this.projection[1] = scale;
                this.projection[9] = scale;
                */

                this.projection[12] = this.canvas.width / 2;
                this.projection[13] = this.canvas.height / 2;
            }
            render() {
                if (!this.canvas) return;

                this.context.globalCompositeOperation = 'source-over';
                this.context.shadowBlur = 0;
                this.context.fillStyle = 'rgb(0,0,0)';
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                //context.globalCompositeOperation = 'lighter';

                this.context.lineWidth = 1;
                this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                //this.context.fillStyle = 'rgba(255, 240, 100, 0.2)';
                const renderNode = (node) => {
                    if (node.world && node.shape) {
                        if (node.colour) {
                            this.context.strokeStyle = `rgba(${node.colour[0] * 255}, ${node.colour[1] * 255}, ${node.colour[2] * 255}, ${node.colour[3]})`;
                        } else {
                            this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                        }
                        const transform = matrixMultiply(node.world, this.projection);
                        node.shape.draw2d(this.context, transform);
                    }
                    //node.children.forEach((part) => renderNode(part));
                }
                scene.nodes.forEach(node => renderNode(node));

                if (scene.ray) {
                    const start = transformed(scene.ray.point, this.projection);
                    const endPoint = add(scene.ray.point, scaled(scene.ray.direction, 500));
                    const end = transformed(endPoint, this.projection);

                    this.context.strokeStyle = 'rgb(255, 255, 255, 0.9)';
                    this.context.beginPath();
                    this.context.moveTo(start[0], start[1]);
                    this.context.lineTo(end[0], end[1]);
                    this.context.stroke();
                }
                if (scene.points) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    scene.points.forEach((point) => {
                        const centre = transformed(point, this.projection);
                        this.context.beginPath();
                        this.context.arc(centre[0], centre[1], 3, 0, Math.PI * 2);
                        this.context.stroke();
                    });
                }
                if (scene.lines) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    this.context.beginPath();
                    scene.lines.forEach((line) => {
                        const start = transformed(line.start, this.projection);
                        const end = transformed(line.end, this.projection);
                        this.context.moveTo(start[0], start[1]);
                        this.context.lineTo(end[0], end[1]);
                    });
                    this.context.stroke();
                }
            }
        }

        /**
         *
         */
        let topView;
        let sideView;

        /**
         *
         */
        function render(time = 0) {
            if (paused) {
                return;
            }

            if (last) {
                const delta = time - last;
                times.push(delta);
                if (times.length > 5) {
                    times.shift();
                    const total = times.reduce((sum, delta) => sum + delta);
                    const average = 5000 / total;
                }
            }
            last = time;

            // Set the drawing position to the "identity" point, which is
            // the center of the scene.
            /*
                        if (!cameraMove.checked && scene.nodes[scene.target]?.world && scene.nodes[scene.camera]?.world) {
                            camera.position = [...scene.nodes[scene.camera].world.slice(12, 16)];
                            camera.position[2] -= 10;
                            camera.target = [...scene.nodes[scene.target].world.slice(12, 16)];
            
                            scene.modelViewMatrix = camera.viewMatrix();
                        } else {
                            camera.position = [...scene.nodes[scene.camera].world.slice(12, 16)];
                            camera.position[2] -= 10;
                            camera.target = [...scene.nodes[scene.target].world.slice(12, 16)];
                            scene.modelViewMatrix = camera.viewMatrix();
                        }
            *
            camera.position = [0, 0, -20];
            camera.target = [0, 0, 0];
            camera.up = [0, 1, 0];
            */
            scene.modelViewMatrix = camera.viewMatrix();

            // Create a perspective matrix, a special matrix that is
            // used to simulate the distortion of perspective in a camera.
            // Our field of view is 45 degrees, with a width/height
            // ratio that matches the display size of the canvas
            const fieldOfView = 45;   // in degrees
            const aspect = scene.gl.canvas.clientWidth / scene.gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 1000.0;
            const projectionMatrix = mat4.create();

            // note: glmatrix.js always has the first argument
            // as the destination to receive the result.
            mat4.perspective(projectionMatrix,
                fieldOfView,
                aspect,
                zNear,
                zFar);
            scene.projectionMatrix = projectionMatrix;// matrixMultiply(projectionMatrix, scene.modelViewMatrix);
            initialiseShader(scene.gl, scene.shader, scene.buffers, projectionMatrix);
            initialiseShader(scene.gl, scene.shader2, scene.buffers, projectionMatrix);
            initialiseShader(scene.gl, scene.shader3, scene.buffers, projectionMatrix);
            initialiseShader(scene.gl, scene.shader4, scene.buffers, projectionMatrix);

            scene.nodes.forEach((node) =>
                node.transform = matrixMultiply(node.transform, node.spin));

            const split = document.getElementById('split');
            if (split.checked) {
                drawScene2(scene.gl, scene.buffers, scene.shapes, time);
            } else {
                drawScene(scene.gl, scene.buffers, scene.shapes, time);
            }
            glErrors(scene.gl);

            topView.render();

            if (scene.overlays) {
                scene.overlays.forEach((overlay) => overlay.updateOverlay(scene.projectionMatrix));
            }

            window.requestAnimationFrame(render);
        }

        /**
         *
         */
        function matrixMultiply(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
            ];
        }

        /**
         *
         */
        function get3x3(input) {
            return [
                input[0], input[1], input[2],
                input[4], input[5], input[6],
                input[8], input[9], input[10]];
        }

        /**
         *
         */
        function transpose3x3(input) {
            return [
                input[0], input[3], input[6],
                input[1], input[4], input[7],
                input[2], input[5], input[8]];
        }

        /**
         *
         */
        function invert3x3(input) {
            let a00 = input[0], a01 = input[1], a02 = input[2];
            let a10 = input[3], a11 = input[4], a12 = input[5];
            let a20 = input[6], a21 = input[7], a22 = input[8];

            let b01 = a22 * a11 - a12 * a21;
            let b11 = -a22 * a10 + a12 * a20;
            let b21 = a21 * a10 - a11 * a20;
            // Calculate the determinant
            let det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return null;
            }
            det = 1.0 / det;
            return [
                b01 * det,
                (-a22 * a01 + a02 * a21) * det,
                (a12 * a01 - a02 * a11) * det,
                b11 * det,
                (a22 * a00 - a02 * a20) * det,
                (-a12 * a00 + a02 * a10) * det,
                b21 * det,
                (-a21 * a00 + a01 * a20) * det,
                (a11 * a00 - a01 * a10) * det];
            return out;
        }

        /**
         *
         */
        function transpose(input) {
            return [
                input[0], input[4], input[8], input[12],
                input[1], input[5], input[9], input[13],
                input[2], input[6], input[10], input[14],
                input[3], input[7], input[11], input[15]];
        }

        /**
         *
         */
        function invert(input) {
            const x0 = input[0];
            const x1 = input[1];
            const x2 = input[2];
            const x3 = input[3];
            const x4 = input[4];
            const x5 = input[5];
            const x6 = input[6];
            const x7 = input[7];
            const x8 = input[8];
            const x9 = input[9];
            const x10 = input[10];
            const x11 = input[11];
            const x12 = input[12];
            const x13 = input[13];
            const x14 = input[14];
            const x15 = input[15];

            const a0 = x0 * x5 - x1 * x4;
            const a1 = x0 * x6 - x2 * x4;
            const a2 = x0 * x7 - x3 * x4;
            const a3 = x1 * x6 - x2 * x5;
            const a4 = x1 * x7 - x3 * x5;
            const a5 = x2 * x7 - x3 * x6;
            const b0 = x8 * x13 - x9 * x12;
            const b1 = x8 * x14 - x10 * x12;
            const b2 = x8 * x15 - x11 * x12;
            const b3 = x9 * x14 - x10 * x13;
            const b4 = x9 * x15 - x11 * x13;
            const b5 = x10 * x15 - x11 * x14;
            const invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

            return [
                (+x5 * b5 - x6 * b4 + x7 * b3) * invdet,
                (-x1 * b5 + x2 * b4 - x3 * b3) * invdet,
                (+x13 * a5 - x14 * a4 + x15 * a3) * invdet,
                (-x9 * a5 + x10 * a4 - x11 * a3) * invdet,
                (-x4 * b5 + x6 * b2 - x7 * b1) * invdet,
                (+x0 * b5 - x2 * b2 + x3 * b1) * invdet,
                (-x12 * a5 + x14 * a2 - x15 * a1) * invdet,
                (+x8 * a5 - x10 * a2 + x11 * a1) * invdet,
                (+x4 * b4 - x5 * b2 + x7 * b0) * invdet,
                (-x0 * b4 + x1 * b2 - x3 * b0) * invdet,
                (+x12 * a4 - x13 * a2 + x15 * a0) * invdet,
                (-x8 * a4 + x9 * a2 - x11 * a0) * invdet,
                (-x4 * b3 + x5 * b1 - x6 * b0) * invdet,
                (+x0 * b3 - x1 * b1 + x2 * b0) * invdet,
                (-x12 * a3 + x13 * a1 - x14 * a0) * invdet,
                (+x8 * a3 - x9 * a1 + x10 * a0) * invdet];
        }

        /**
         *
         */
        function normalise(v) {
            const hypot = Math.hypot(v[0], v[1], v[2]);
            return [v[0] / hypot, v[1] / hypot, v[2] / hypot];
        }

        /**
         *
         */
        function dot(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        /**
         *
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0]];
        }

        /**
         *
         */
        function negate(v) {
            v[0] = -v[0];
            v[1] = -v[1];
            v[2] = -v[2];
        }

        /**
         *
         */
        function add(...vectors) {
            return vectors.reduce((sum, v) => [sum[0] + v[0], sum[1] + v[1], sum[2] + v[2]], [0, 0, 0]);
            return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
        }

        /**
         *
         */
        function subtract(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        /**
         *
         */
        function scale(v, s) {
            v[0] *= s;
            v[1] *= s;
            v[2] *= s;
            return v;
        }

        /**
         *
         */
        function scaled(v, s) {
            return v.map((e) => e * s);
        }

        /**
         *
         */
        function rotate(v, axis, angle) {
            angle *= Math.PI / 180;
            axis = normalise(axis);

            const s = Math.cos(angle / 2);
            const u = scaled(axis, Math.sin(angle / 2));

            const p1 = scale(cross(v, u), 2 * s);
            const p2 = scaled(v, s * s - dot(u, u));
            const p3 = scaled(u, 2 * dot(v, u));

            [v[0], v[1], v[2]] = add(p1, add(p2, p3));

            return add(p1, add(p2, p3));
        }

        /**
         *
         */
        function matrixVectorMultiply(v, matrix) {
            const x = matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12];
            const y = matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13];
            const z = matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14];
            v[0] = x;
            v[1] = y;
            v[2] = z;
            return v
        }

        /**
         * point transform (apply translation)
         */
        function transformed(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
            ];
        }

        /**
          * point transform (apply translation)
          */
        function transform4(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
                matrix[3] * v[0] + matrix[7] * v[1] + matrix[11] * v[2] + matrix[15],
            ];
        }

        /**
         * Direction transform (ignore translation)
         */
        function transformDirection(v, matrix) {
            return normalise([
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2],
            ]);
        }


        /**
         * Return the plane defined by three points
         */
        function planeFromPoints(p0, p1, p2) {
            const v0 = subtract(p0, p1);
            const v1 = subtract(p0, p2);
            const normal = normalise(cross(v0, v1));
            return { point: p0, normal };
        }

        /**
         *
         */
        function lookAt(eye, at, up) {
            const zaxis = normalise(subtract(at, eye));
            const xaxis = normalise(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eye), -dot(yaxis, eye), -dot(zaxis, eye), 1
            ];
        }

        /**
         *
         */
        function makeShapes(scene) {
            const dataBuffers = {
                vertexBuffer: [],
                indices: [],
            };

            scene.shapes.push(new Diamond(scene.gl, dataBuffers));
            scene.shapes.push(new Tetrahedron(scene.gl, dataBuffers));

            const randInt = (min, max) => min + Math.floor((max - min) * Math.random());
            const rand = (min, max) => min + (max - min) * Math.random();
            for (let i = 0; i < 10; ++i) {
                scene.shapes.push(new Box(scene.gl, dataBuffers,
                    rand(0.5, 2), rand(0.5, 2), rand(0.5, 2)));

                scene.shapes.push(new Cylinder(scene.gl, dataBuffers,
                    rand(0.5, 2), rand(0.5, 2), randInt(3, 32)));

                scene.shapes.push(new Frustrum(scene.gl, dataBuffers,
                    rand(0.5, 2), rand(0.5, 2), rand(0.5, 2), randInt(3, 32)));

                scene.shapes.push(new Ball(scene.gl, dataBuffers,
                    rand(0.5, 2), rand(0.5, 2), rand(0.5, 2), randInt(3, 32), randInt(3, 32)));

            }
            scene.buffers = initBuffers(scene.gl, dataBuffers);
        }

        /**
         *
         */
        function makeGraph(scene, bases, components) {
            scene.graph = [];
            scene.nodes = [];
            for (let j = 0; j < bases * bases; ++j) {
                let direction = [0, 2, 0];
                const t = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 3 * (-bases / 2 + j % bases), 0, 3 * (-bases / 2 + Math.floor(j / bases)), 1];
                const colour = [...hslToRgb(Math.random(), 0.5 + Math.random() * 0.5, 0.2 + 0.6 * Math.random()).map(v => v / 255), 1];

                scene.nodes.unshift(addNode(`node ${j}`, null, t, scene.shapes[0], scene.shader3, colour));
                scene.graph.push(scene.nodes[0]);

                for (let i = 0; i < components; ++i) {
                    const shader = Math.random() > 0.5 ? scene.shader3 : scene.shader4;
                    let parent = scene.nodes[0];
                    const scale = 0.9 + 0.1 * Math.random();
                    if (((i / 1000) + Math.random()) > 0.9) {
                        direction = [
                            [0, 0, 0],
                            [0, 2, 0],
                            [0, 0, 2],
                            [-2, 0, 0],
                            [0, -2, 0],
                            [0, 0, -2],
                        ][Math.floor(6 * Math.random())];
                        parent = scene.nodes[Math.floor(Math.random() * scene.nodes.length)];
                    }
                    const transform = [
                        scale, 0, 0, 0,
                        0, scale, 0, 0,
                        0, 0, scale, 0,
                        ...direction, 1,
                    ];
                    const colour = [...hslToRgb(Math.random(), 0.5 + Math.random() * 0.5, 0.5).map(v => v / 255), 1];
                    const shape = scene.shapes[Math.floor(Math.random() * scene.shapes.length)];

                    scene.nodes.unshift(addNode(`node ${j}, ${i}`, parent, transform, shape, shader, colour));
                }
            }
            scene.target = Math.floor(scene.nodes.length * Math.random());
            scene.camera = Math.floor(scene.nodes.length * Math.random());
        }

        /**
         * Find the closest point on a line to a given point
         */
        function closestPoint(line, point) {
            // line = lp + d * ld
            // point = p
            // From line to point = p - (lp + d * ld)
            // Closest when (p - (lp + d * ld)).ld = 0
            // dot product is distributive hence
            // (p - (lp + d * ld)).ld = p.ld - lp.ld + d * (ld. ld)
            // d = (lp - p).ld / ld.ld
            const numerator = dot(subtract(line.point - point), line.direction);
            const divisor = dot(line.direction, line.direction);
            return numerator / divisor;
        }

        /**
         * Return the distance between two points
         */
        function distance(point1, point2) {
            return math.hypot(point1[0] - point2[0], point1[1] - point2[1], point1[2] - point2[2]);
        }

        /**
         * Add touch controls to the given node
         */
        function planeIntercept(line, plane) {
            // plane (p - p0).n = 0
            // line p = l + dt
            // (l + dt - p0).n = 0
            // (lx + dxt - p0x)nx + (ly + dyt - p0y)ny + (lz + dzt - p0z)nz = 0
            // t(dx.nx + dy.ny + dz.nz) = nx(p0x-lx) + ny(p0y-ly) + nz(p0z-lz)
            // t = (nx(p0x-lx) + ny(p0y-ly) +nz(p0z-lz)) / (dx.nx + dy.ny + dz.nz)

            const divisor = dot(line.direction, plane.normal);
            if (divisor !== 0) {
                const offset = subtract(plane.point, line.point);
                return dot(offset, plane.normal) / divisor;
            }
        }

        /**
         * Get the point from a line and distance along it
         */
        function getPoint(line, distance) {
            return add(line.point, scaled(line.direction, distance));
        }

        /**
         * Determine the intecep of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalise(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start) {
                return [start, end];
            }
        }

        /**
         * Process a 'click' event
         */
        function click(x, y) {
            const ray = camera.getLine(x, y, 45);
            scene.ray = ray;
            scene.points.length = 0;
            scene.lines.length = 0;
            const hits = scene.nodes.filter((node) => {
                if (node.shape) {
                    const inverse = invert(node.world);
                    const point = transformed(ray.point, inverse);
                    const direction = transformDirection(ray.direction, inverse);
                    const points = node.shape.intersects({ point, direction });

                    if (points) {
                        node.hit = points;
                        scene.points.push(getPoint(ray, points[0]), getPoint(ray, points[1]));
                        return true;
                    }
                    if (!event.shiftKey) {
                        node.hit = null;
                    }
                    node.sourceNode.nodes.forEach((node) => node.classList.remove('selected'));
                }
            });
            if (hits.length > 0) {
                hits.sort((a, b) => a.hit[0] - b.hit[0]);
                if (!event.altKey) {
                    hits.slice(1).forEach((node) => node.hit = null);
                    if (hits[0].overlay) {
                        removeOverlay(hits[0]);
                    } else {
                        scene.overlays.push(addOverlay(hits[0]));
                    }
                }
                hits.forEach((hit) => hit.sourceNode.nodes.forEach((node) => node.classList.add('selected')));

                if (event.ctrlKey) {
                    camera.target = hits[0].world.slice(12, 16);
                }
            }
        }

        /**
         * Add touch controls to the given node
         */
        function addControls(node) {
            const start = {};
            let action;
            node.addEventListener('touchstart', (event) => {
                event.preventDefault();
                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;
                action = 'click';
            });

            node.addEventListener('touchmove', (event) => {
                event.preventDefault();
                //if (cameraMove.checked) {
                action = 'drag';
                const deltaX = event.touches[0].clientX - start.x;
                const deltaY = event.touches[0].clientY - start.y;

                if (event.altKey) {
                    camera.yaw(deltaX / 10);
                    camera.pitch(deltaY / 10);
                } else {
                    camera.rotateY(deltaX);
                    camera.rotateX(deltaY);
                }

                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;
                //}
            });

            node.addEventListener('touchend', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;
                    click(x, y);
                }
            });

            node.addEventListener('mousedown', (event) => {
                event.preventDefault();
                start.x = event.clientX;
                start.y = event.clientY;
                action = 'click';
            });

            node.addEventListener('mousemove', (event) => {
                event.preventDefault();
                if (action) { // && cameraMove.checked) {
                    action = 'drag';
                    const deltaX = event.clientX - start.x;
                    const deltaY = event.clientY - start.y;

                    if (event.altKey) {
                        camera.yaw(deltaX / 10);
                        camera.pitch(deltaY / 10);
                    } else {
                        camera.rotateY(deltaX);
                        camera.rotateX(deltaY);
                    }
                    start.x = event.clientX;
                    start.y = event.clientY;
                }
            });

            node.addEventListener('mouseup', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    click(x, y);
                }
                action = null;
            });

            node.addEventListener('wheel', (event) => {
                const dist = event.deltaY / 10;
                camera.forward(dist);
            });
        }

        /**
         * Add an overlay for the specified node
         */
        function addOverlay(node) {
            const box = document.getElementById('scene').getBoundingClientRect();
            const container = document.createElement('div');
            container.classList.add('overlay', 'fixed');

            const updateOverlay = (projectionMatrix) => {
                const modelViewMatrix = matrixMultiply(node.world, scene.modelViewMatrix);

                const transform = matrixMultiply(modelViewMatrix, scene.projectionMatrix);
                const position = transform4([0, 0, 0], transform);
                const x = box.left + (position[0] / position[3] + 1) * box.width / 2;
                const y = box.bottom - (position[1] / position[3] + 1) * box.height / 2;

                container.style.left = `${x}px`;
                container.style.top = `${y}px`;
                container.innerHTML = `<span>${node.name}</span><br>Position: <span>${node.transform.slice(12, 15).map((p) => p.toFixed(2)).join(', ')}</span>`;
            }
            updateOverlay(scene.projectionMatrix);

            document.body.appendChild(container);
            node.overlay = { container, updateOverlay };
            return node.overlay;
        }

        /**
         * Add an overlay for the specified node
         */
        function removeOverlay(node) {
            if (node.overlay) {
                node.overlay.container.remove();
                const pos = scene.overlays.indexOf(node.overlay);
                if (pos > -1) {
                    scene.overlays.splice(pos, 1);
                }
                node.overlay = null;
            }
        }

        /**
         * Display element
         */
        function showEntry(name, value, stack = []) {
            if (Array.isArray(value)) {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (array[${value.length}])`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                for (let i = 0; i < value.length; ++i) {
                    if (stack.includes(value[i])) {
                        content.append(showEntry(name, '...'));
                    } else {
                        stack.push(value[i]);
                        //content.append(showEntry(name, value[i], stack));
                        stack.pop();
                    }
                }
                return container;
            } else if (value === undefined) {
                return `${name}: undefined`;
            } else if (value && typeof (value) === 'object') {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (object)`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content')
                Object.entries(value).forEach(([name, value]) => {
                    if (stack.includes(value)) {
                        content.append(showEntry(name, '...'));
                    } else {
                        stack.push(value);
                        //content.append(showEntry(name, value, stack));
                        stack.pop();
                    }
                });
                return container;
            }
            const container = document.createElement('div');
            container.innerText = `${name}: ${value}`;
            container.classList.add('entry');
            return container;
        }

        /**
         * Display the details for a deployed node.
         */
        function showDeployedNodeDetails(node) {
            const detailNode = document.querySelector('.detail');
            Object.entries(node).map(([key, value]) =>
                detailNode.append(showEntry(key, value)));
            return;

            const lines = Object.entries(node).map(([key, value]) =>
                `${key}: ${value}`);
            detailNode.innerHTML = lines.join('<br>');
        }

        /**
         *
         */
        let paused = false;

        /**
         *
         */
        function main() {
            const canvas = document.getElementById('scene');
            const view2 = document.getElementById('top-view');

            addControls(canvas);

            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            scene.gl = canvas.getContext('webgl');

            view2.width = view2.clientWidth;
            view2.height = view2.clientHeight;
            topView = new View2d(scene, 'top-view');
            topView.width = view2.clientWidth;
            topView.Height = view2.clientHeight;

            const shader = initialiseShaders(scene.gl, vsSource, fsSource);
            const shader2 = initialiseShaders(scene.gl, vsSource, fsSource2);
            const shader3 = initialiseShaders(scene.gl, vsSource2, fsSource3);
            const shader4 = initialiseShaders(scene.gl, vsSource2, fsSource4);

            scene.shader = {
                program: shader,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader, 'aVertexPosition'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader, 'uModelViewMatrix'),
                colourLocation: scene.gl.getUniformLocation(shader, 'uColour'),
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                },
            };

            scene.shader2 = {
                program: shader2,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader2, 'aVertexPosition'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader2, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader2, 'uModelViewMatrix'),
                colourLocation: scene.gl.getUniformLocation(shader2, 'uColour'),
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                },
            };

            scene.shader3 = {
                program: shader3,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader3, 'aPosition'),
                    vertexNormal: scene.gl.getAttribLocation(shader3, 'aNormal'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader3, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader3, 'uModelViewMatrix'),
                normalMatrixLocation: scene.gl.getUniformLocation(shader3, 'uNormalMatrix'),

                lightPosition: scene.gl.getUniformLocation(shader3, 'uLightPosition'),
                colourLocation: scene.gl.getUniformLocation(shader3, 'uDiffuseColor'),
                specularColour: scene.gl.getUniformLocation(shader3, 'uSpecularColor'),
                shininess: scene.gl.getUniformLocation(shader3, 'uShininess'),

                light: {
                    position: [2, 10, -5],
                },
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                    gl.uniform3fv(this.specularColour, [0.8, 0.9, 0.3]);
                    gl.uniform1f(this.shininess, node.shininess);
                },
            };
            scene.shader4 = {
                program: shader4,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader4, 'aPosition'),
                    vertexNormal: scene.gl.getAttribLocation(shader4, 'aNormal'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader4, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader4, 'uModelViewMatrix'),
                normalMatrixLocation: scene.gl.getUniformLocation(shader4, 'uNormalMatrix'),

                lightPosition: scene.gl.getUniformLocation(shader4, 'uLightPosition'),
                colourLocation: scene.gl.getUniformLocation(shader4, 'uDiffuseColor'),
                specularColour: scene.gl.getUniformLocation(shader4, 'uSpecularColor'),
                shininess: scene.gl.getUniformLocation(shader4, 'uShininess'),

                light: {
                    position: [2, 10, -5],
                },
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                    gl.uniform3fv(this.specularColour, [0.8, 0.9, 0.3]);
                    gl.uniform1f(this.shininess, node.shininess);
                },
            };

            // Set clear color to black, fully opaque
            scene.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            // Clear the color buffer with specified clear color
            scene.gl.clear(scene.gl.COLOR_BUFFER_BIT);

            let bases = 1;
            let components = 3;
            const basesControl = document.getElementById('bases');
            const componentsControl = document.getElementById('components');
            const totalControl = document.getElementById('total');
            totalControl.innerHTML = bases * bases * (components + 1);

            basesControl.value = bases;
            componentsControl.value = components;

            basesControl.addEventListener('change', (event) => {
                bases = basesControl.valueAsNumber;
                totalControl.innerHTML = bases * bases * (components + 1);
                makeGraph(scene, bases, components);
            });
            componentsControl.addEventListener('change', (event) => {
                components = componentsControl.valueAsNumber;
                totalControl.innerHTML = bases * bases * (components + 1);
                makeGraph(scene, bases, components);
            });

            const lightX = document.getElementById('light-x');
            const lightY = document.getElementById('light-y');
            const lightZ = document.getElementById('light-z');

            lightX.value = scene.shader3.light.position[0];
            lightY.value = scene.shader3.light.position[1];
            lightZ.value = scene.shader3.light.position[2];

            lightX.addEventListener('input', () => {
                scene.shader3.light.position[0] = lightX.value;
                scene.shader4.light.position[0] = lightX.value;
            });
            lightY.addEventListener('input', () => {
                scene.shader3.light.position[1] = lightY.value;
                scene.shader4.light.position[1] = lightY.value;
            });
            lightZ.addEventListener('input', () => {
                scene.shader3.light.position[2] = lightZ.value;
                scene.shader4.light.position[2] = lightZ.value;
            });

            const nextNode = document.getElementById('next-node');
            nextNode.addEventListener('click', () =>
                scene.target = (scene.target + 1) % scene.nodes.length);

            //const treeNode = document.querySelector('.tree');
            const expandedTreeNode = document.querySelector('.expanded-tree');

            const input = document.getElementById('input');

            const deployedNodeActions = {
                click: (event, node) => showDeployedNodeDetails(node),
            };

            input.addEventListener('input', (event) => {
                localStorage.setItem('structure', input.value);
                const structure = getStructure(input.value);
                const deployed = parseStructure(structure);
                expandedTreeNode.innerHTML = '';
                getGraph(deployed, scene);
                expandedTreeNode.appendChild(getView(deployed, deployedNodeActions));
                //treeNode.innerHTML = '';
                //treeNode.appendChild(getView(parseStructure(structure)));
            });

            const structure = getStructure(input.value);
            const fullStructure = parseStructure(structure);
            const definition = parseStructure(structure);

            //treeNode.appendChild(getView(definition));
            //expandedTreeNode.appendChild(getView(fullStructure));

            const comment = document.getElementById('comment');
            comment.addEventListener('click', (event) => {
                const text = input.value;
                input.value = '#' + text.replace(/\n(\s*)#?/g, '\n$1#');
            });

            const uncomment = document.getElementById('uncomment');
            uncomment.addEventListener('click', (event) => {
                const text = input.value;
                input.value = text.replace(/\n(\s*)#?/g, '\n$1')
                    .replace(/^\s*#/g, '');
            });

            makeShapes(scene);

            makeGraph(scene, bases, components);

            const content = localStorage.getItem('structure');
            if (content) {
                input.value = content;
                const structure = getStructure(content);
                const deployed = parseStructure(structure);
                expandedTreeNode.innerHTML = '';
                getGraph(deployed, scene);
                expandedTreeNode.appendChild(getView(deployed, deployedNodeActions));
                //treeNode.innerHTML = '';
                //treeNode.appendChild(getView(parseStructure(structure)));
            }

            render();
        }


        /**
         * Quaternion constructor
         *
         * @param {*} w
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Quaternion {
            constructor(w, x, y, z) {
                this.w = w === undefined ? 1 : w;
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
            }
            clone() {
                return new Quaternion(this.w, this.x, this.y, this.z);
            }
            static create(w, x, y, z) {
                var v;
                if (w instanceof Vector3d && x == undefined) {
                    return new Quaternion(0, w.x, w.y, w.z);
                } else if (w instanceof Vector3d) {
                    return Quaternion.createRotation(w, x);
                } else if (w && Array.isArray(w) && w.length === 4) {
                    return new Quaternion(w[0], w[1], w[2], w[3])
                } else if (w && w.w !== undefined) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else if (x instanceof Vector3d) {
                    return Quaternion.createRotation(x, w);
                } else if (w instanceof Quaternion) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else {
                    return new Quaternion(w === undefined ? 1 : w, x || 0, y || 0, z || 0);
                }
            }
            static createFromObject(obj) {
                return new Quaternion(obj.w, obj.x, obj.y, obj.z);
            }
            static createRotation(axis, angle) {
                const v = axis.normal();
                return new Quaternion(
                    Math.cos(angle / 2),
                    Math.sin(angle / 2) * v.x,
                    Math.sin(angle / 2) * v.y,
                    Math.sin(angle / 2) * v.z);
            }
            get length() {
                return Math.hypot(this.w, this.x, this.y, this.z);
            }

            get values() {
                return [this.w, this.x, this.y, this.z];

            }
            get inverse() {
                return this.conjugate();
            }
            get s() {
                return this.w;
            }
            get v() {
                return new Vector3d(this.x, this.y, this.z);
            }
            invert() {
                this.x *= -1;
                this.y *= -1;
                this.z *= -1;
                return this;
            }
            conjugate() {
                return new Quaternion(this.w, -this.x, -this.y, -this.z);
            }
            apply(v) {
                var vp = this.multiply(new Quaternion(0, v.x, v.y, v.z)).multiply(this.conjugate());
                return new Vector3d(vp.x, vp.y, vp.z);
                var u = new Vector3d(this.x, this.y, this.z);
                var s = this.w;
                var udotv = u.dotProduct(v);
                var udotu = u.dotProduct(u);
                var uxv = u.crossProduct(v);
                u.scale(2 * udotv);
                v.scale(s * s - udotu);
                uxv.scale(2 * s);
                return uxv.add(u).add(v);
            }
            rotate(other, angle) {
                if (angle !== undefined) {
                    other = Quaternion.createRotation(other, angle);
                }
                const s = this.s * other.s - this.v.dot(other.v);
                const v = other.v.scaled(this.s).add(this.v.scaled(other.s)).add(this.v.crossProduct(other.v));
                this.w = s;
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return;
            }
            scale(value) {
                this.w *= value;
                this.x *= value;
                this.y *= value;
                this.z *= value;
                return this;
            }
            scaled(value) {
                const result = this.clone();
                return result.scale(value);
            }
            multiply(other) {
                return new Quaternion(
                    this.w * other.w - this.x * other.x - this.y * other.y - this.z * other.z,// 1
                    this.w * other.x + this.x * other.w + this.y * other.z - this.z * other.y,// i
                    this.w * other.y - this.x * other.z + this.y * other.w + this.z * other.x,// j
                    this.w * other.z + this.x * other.y - this.y * other.x + this.z * other.w // k
                );
            }
            dot(other) {
                return this.w * other.w + this.x * other.x + this.y * other.y + this.z * other.z;
            }
            getMatrix() {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
                2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
                2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                    0, 0, 0, a * a + b * b + c * c + d * d];
            }
            setMatrix(matrix) {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                matrix[0] = a * a + b * b - c * c - d * d;
                matrix[1] = 2 * (b * c - a * d);
                matrix[2] = 2 * (b * d + a * c);
                matrix[3] = 0;
                matrix[4] = 2 * (b * c + a * d);
                matrix[5] = a * a - b * b + c * c - d * d;
                matrix[6] = 2 * (c * d - a * b);
                matrix[7] = 0;
                matrix[8] = 2 * (b * d - a * c);
                matrix[9] = 2 * (c * d + a * b);
                matrix[10] = a * a - b * b - c * c + d * d;
                matrix[11] = 0;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = 0;
                matrix[15] = a * a + b * b + c * c + d * d;
            }
        }


        /**
         * Vector3d constructor
         *
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Vector3d {
            constructor(x, y, z) {
                this.x = x || 0
                this.y = y || 0
                this.z = z || 0
            }
            static create(x, y, z) {
                if (x instanceof Vector3d) {
                    return x.clone();
                } else if (x && Array.isArray(x) && x.length === 3) {
                    return new Vector3d(x[0], x[1], x[2]);
                } else if (x && x.x !== undefined) {
                    return new Vector3d(x.x, x.y, x.z);
                }
                return new Vector3d(x, y, z);
            }
            clone() {
                return new Vector3d(this.x, this.y, this.z);
            }
            static createFromObject(obj) {
                return new Vector3d(obj.x, obj.y, obj.z);
            }
            get length() {
                return Math.hypot(this.x, this.y, this.z);
            }
            get array() {
                return [this.x, this.y, this.z, 0];
            }
            get array3() {
                return [this.x, this.y, this.z];
            }
            dotProduct(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            crossProduct(other) {
                return new Vector3d(this.y * other.z - this.z * other.y,
                    this.z * other.x - this.x * other.z,
                    this.x * other.y - this.y * other.x);
            }
            cross(other) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                this.x = y * other.z - z * other.y;
                this.y = z * other.x - x * other.z;
                this.z = x * other.y - y * other.x;
                return this;
            }
            normalise() {
                var n = this.length || 1;
                this.x /= n;
                this.y /= n;
                this.z /= n;
                return this;
            }
            normal() {
                var result = this.clone();
                return result.normalise()
            }
            scale(value) {
                this.x *= value
                this.y *= value
                this.z *= value
                return this
            }
            scaled(value) {
                var result = this.clone();
                return result.scale(value);
            }
            add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                return this;
            }
            subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                return this;
            }
            plus(other) {
                var result = this.clone();
                return result.add(other);
            }
            minus(other) {
                var result = this.clone();
                return result.subtract(other);
            }
            rotate(q, angle) {
                if (angle) {
                    q = Quaternion.createRotation(q, angle);
                }

                let s = q.w;
                let u = new Vector3d(q.x, q.y, q.z);
                let v = this.clone();

                this.cross(u).scale(2 * s)
                    .add(v.scaled(s * s - u.dot(u))).add(u.scaled(2 * v.dot(u)));
                return this;
            }
            transform(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];

                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            transform2(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];
                const w = matrix[3] * this.x + matrix[7] * this.y + matrix[11] * this.z + matrix[15];

                this.x = x / w;
                this.y = y / w;
                this.z = z / w;
                return this;
            }
            getProjection(rd) {
                if (rd === this.z) {
                    return { x: 0, y: 0 }
                } else {
                    return {
                        x: this.x / (1 + -this.z / rd),
                        y: -this.y / (1 + -this.z / rd)
                    }
                }
            }
        }

        /**
         *
         */
        const mat4 = {
            create: function () {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]
            },
            perspective: function (matrix, fieldOfView, aspect, zNear, zFar) {
                var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
                matrix[0] = f / aspect;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 0;
                matrix[4] = 0;
                matrix[5] = f;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = 0;
                matrix[9] = 0;
                matrix[10] = (zFar + zNear) / (zNear - zFar)
                matrix[11] = -1;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = (2 * zFar * zNear) / (zNear - zFar);
                matrix[15] = 1;
            },
            translate: function (input, output, change) {
                var m = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    change[0], change[1], change[2], 1
                ]
                this.multiply(input, m, output);
            },
            copy: function (input, output) {
                output[0] = input[0];
                output[1] = input[1];
                output[2] = input[2];
                output[3] = input[3];
                output[4] = input[4];
                output[5] = input[5];
                output[6] = input[6];
                output[7] = input[7];
                output[8] = input[8];
                output[9] = input[9];
                output[10] = input[10];
                output[11] = input[11];
                output[12] = input[12];
                output[13] = input[13];
                output[14] = input[14];
                output[15] = input[15];
            },
            rotate2d: function (input, output, angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                var m = [
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                ]
                var t = this.create();
                this.multiply(input, m, t);
                this.copy(t, output);
            },
            rotate: function (input, output, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                this.multiply(input, q.getMatrix(), output);
            },
            rotated: function (input, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                return matrixMultiply(input, q.getMatrix());
            },
            multiply: function (a, b, out) {
                var result = this.create();
                result[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
                result[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
                result[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
                result[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

                result[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
                result[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
                result[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
                result[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

                result[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
                result[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
                result[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
                result[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

                result[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
                result[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
                result[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
                result[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
                this.copy(result, out);
            },
            transpose: function (input, output) {
                var temp = this.create();
                this.copy(input, temp);
                output[1] = temp[4];
                output[2] = temp[8];
                output[3] = temp[12];
                output[4] = temp[2];
                output[6] = temp[9];
                output[7] = temp[13];
                output[8] = temp[2];
                output[9] = temp[6];
                output[11] = temp[14];
                output[12] = temp[3];
                output[13] = temp[7];
                output[14] = temp[11];
            },
            invert: function (input, output) {
                var x0 = input[0];
                var x1 = input[4];
                var x2 = input[8];
                var x3 = input[12];
                var x4 = input[1];
                var x5 = input[5];
                var x6 = input[9];
                var x7 = input[13];
                var x8 = input[2];
                var x9 = input[6];
                var x10 = input[10];
                var x11 = input[14];
                var x12 = input[3];
                var x13 = input[7];
                var x14 = input[11];
                var x15 = input[15];

                var a0 = x0 * x5 - x1 * x4;
                var a1 = x0 * x6 - x2 * x4;
                var a2 = x0 * x7 - x3 * x4;
                var a3 = x1 * x6 - x2 * x5;
                var a4 = x1 * x7 - x3 * x5;
                var a5 = x2 * x7 - x3 * x6;
                var b0 = x8 * x13 - x9 * x12;
                var b1 = x8 * x14 - x10 * x12;
                var b2 = x8 * x15 - x11 * x12;
                var b3 = x9 * x14 - x10 * x13;
                var b4 = x9 * x15 - x11 * x13;
                var b5 = x10 * x15 - x11 * x14;
                var invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

                output[0] = (+x5 * b5 - x6 * b4 + x7 * b3) * invdet;
                output[4] = (-x1 * b5 + x2 * b4 - x3 * b3) * invdet;
                output[8] = (+x13 * a5 - x14 * a4 + x15 * a3) * invdet;
                output[12] = (-x9 * a5 + x10 * a4 - x11 * a3) * invdet;
                output[1] = (-x4 * b5 + x6 * b2 - x7 * b1) * invdet;
                output[5] = (+x0 * b5 - x2 * b2 + x3 * b1) * invdet;
                output[9] = (-x12 * a5 + x14 * a2 - x15 * a1) * invdet;
                output[13] = (+x8 * a5 - x10 * a2 + x11 * a1) * invdet;
                output[2] = (+x4 * b4 - x5 * b2 + x7 * b0) * invdet;
                output[6] = (-x0 * b4 + x1 * b2 - x3 * b0) * invdet;
                output[10] = (+x12 * a4 - x13 * a2 + x15 * a0) * invdet;
                output[14] = (-x8 * a4 + x9 * a2 - x11 * a0) * invdet;
                output[3] = (-x4 * b3 + x5 * b1 - x6 * b0) * invdet;
                output[7] = (+x0 * b3 - x1 * b1 + x2 * b0) * invdet;
                output[11] = (-x12 * a3 + x13 * a1 - x14 * a0) * invdet;
                output[15] = (+x8 * a3 - x9 * a1 + x10 * a0) * invdet;

                return this;
            }
        }

        /**
         * Return the point of intersection of a line and plane, if line parallel to plane return undefined
         * @param {*} line 
         * @param {*} plane 
         */
        function linePlaneIntersection(line, plane) {
            var dv = plane.point.minus(line.point);
            var product = line.direction.dotProduct(plane.normal);
            if (product !== 0) {
                return line.direction.scaled(dv.dotProduct(plane.normal) / product).add(line.point);
            }
        }


        /**
         * Vector definition of a line
         */
        function Line(point, direction) {
            this.point = point.clone();
            this.direction = direction.clone();
        }

        /**
         *
         */
        Line.prototype = {
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t)
                return v.add(this.point)
            },
            intersection(other) {
                if (other instanceof Plane) {
                    return linePlaneIntersection(this, other)
                    return this.planeIntersection(other)
                } else {
                    return this.lineIntersection(other)
                }
            },
            planeIntersection(plane) {
                const v = this.direction.clone();
                const dv = plane.point.minus(this.point);
                const div = v.dot(plane.normal);
                if (div) {
                    var a = dv.dot(plane.normal) / div;
                    return v.scale(a).add(this.point);
                }
            },
            lineIntersection(line) {
                if ((this.direction.x * line.direction.y - this.direction.y * line.direction.x) !== 0) {
                    var s = (this.direction.x * (line.point.y - this.point.y) + this.direction.y * (line.point.x - this.point.x))
                        / (this.direction.x * line.direction.y - this.direction.y * line.direction.x)
                } else {
                    var s = (this.direction.z * (line.point.y - this.point.y) + this.direction.y * (line.point.z - this.point.z))
                        / (this.direction.z * line.direction.y - this.direction.y * line.direction.z)
                }
                return line.point.plus(this.direction.scaled(s));
            }
        }


        /**
         * Definition of a segment
         */
        class Segment {
            constructor(start, end) {
                this.start = start.clone();
                this.end = end.clone();
            }

            get direction() {
                return (this.end.minus(this.start)).normalise();
            }
            set direction(direction) {
                this.end = this.start.plus(direction);
            }
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t);
                return v.add(this.start);
            }
        }

        /**
         * Vector definition of a plane
         */
        function Plane(point, normal) {
            this.point = point.clone();
            this.normal = normal.clone();
            this.normal.normalise();
            this.bounds = [];
        }

        /**
         *
         */
        Plane.prototype = {
            intersection(other) {
                if (other instanceof Plane) {
                    return this.planeIntersection(other)
                } else {
                    return linePlaneIntersection(other, this)
                    return other.planeIntersection(this)
                }
            },
            planeIntersection(plane) {
                var d = this.normal.crossProduct(plane.normal)
                var v = d.crossProduct(this.normal)
                if (v.length === 0) {
                    return
                }
                var dv = plane.point.minus(this.point)
                var a = (dv.x * plane.normal.x + dv.y * plane.normal.y + dv.z * plane.normal.z) / (v.x * plane.normal.x + v.y * plane.normal.y + v.z * plane.normal.z)
                var p = v.scale(a).add(this.point)
                return new Line(p, d)
            },
            addBoundary(other) {
                this.bounds.push(other)
                other.bounds.push(this)
            },
            getBoundary() {
                var line = this.intersection(this.bounds[this.bounds.length - 1])
                var segments = []
                this.bounds.forEach(function (bound, index, all) {
                    var point = line.intersection(bound)
                    var segment = new Segment(point, point)
                    if (segments.length > 0) {
                        segments[segments.length - 1].end = point
                    }
                    segments.push(segment)
                    line = this.intersection(bound)
                }, this)
                segments[segments.length - 1].end = segments[0].start

                return segments
            }
        }

        /**
         *
         */
        class Triangle {
            constructor(p1, p2, p3) {
                this.p1 = Vector3d.create(p1);
                this.p2 = Vector3d.create(p2);
                this.p3 = Vector3d.create(p3);
            }
            get plane() {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                return new Plane(this.p1, n);
            }
            intersects(line) {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                const p = line.planeIntersection(new Plane(this.p1, n));
                if (p) {
                    const dt = (d1.x * d2.y - d2.x * d1.y);
                    if (dt !== 0 && d1.x !== 0) {
                        const t = (d1.x * (p.y - d1.y) + d1.y * (d1.x - p.x)) / dt;
                        const s = (p.x - t * d2.x - this.p1.x) / d1.x;
                        return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                    } else {
                        const dt = (d1.y * d2.z - d2.y * d1.z);
                        if (dt !== 0 && d1.y !== 0) {
                            const t = (d1.y * (p.z - d1.z) + d1.z * (d1.y - p.y)) / dt;
                            const s = (p.y - t * d2.y - this.p1.y) / d1.y;
                            return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                        } else {
                            const dt = (d1.z * d2.x - d2.z * d1.x);
                            if (dt !== 0 && d1.z !== 0) {
                                const t = (d1.z * (p.x - d1.x) + d1.x * (d1.z - p.z)) / dt;
                                const s = (p.z - t * d2.z - this.p1.z) / d1.z;
                                return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                            }
                        }
                    }
                }
                return false;
            }
        }
    </script>
</body>

</html>
