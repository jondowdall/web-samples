<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>Structure View</title>
    <style>
        html {
            font-family: sans-serif;
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            width: 100vw;
            height: 100dvh;
            padding: 0.25rem;
            overflow: hidden;
            background-color: lightgray;
        }

        #overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            position: fixed;
            bottom: 0;
            right: 0;
            z-index: 10;
            background: rgb(10, 10, 10, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
        }

        .overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            z-index: 10;
            background: rgb(10, 10, 50, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
            transform: translate(-50%, -50%);
            pointer-events: none;
            white-space: nowrap;
        }

        .fixed {
            position: fixed;
        }

        .shape {
            font-style: italic;
        }

        .scene-node {
            font-weight: bold;
        }

        .number {
            width: 40vw;
        }

        .existing-file {
            font-weight: bold;
        }

        .light-position {
            width: 100%;
        }

        .tree-view {
            display: grid;
            grid-template-columns: 1rem 1rem max-content 1fr 1fr;
            grid-auto-rows: min-content;
            gap: 0;
        }

        .branch-content {
            margin-left: 1em;
            transition:  max-height 0.3s ease-in;
        }

        .expander {
            display: inline-block;
            width: 1.1em;
            cursor: default;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr;
            /* 1fr min-content 1fr; */
            grid-template-rows: min-content 1fr min-content 1fr;
            width: 100%;
            height: 100%;
            grid-gap: 2px;
            background-color: lightgray;
        }

        .layout-row {
            display: grid;
            grid-template-columns: 1fr min-content 1fr;
            /* grid-template-rows: min-content 1fr min-content 1fr; */
            background-color: lightgray;
        }

        .vertical-bar {
            width: 4px;
            grid-column: 2;
            grid-row: 2 / -1;
            cursor: ew-resize;
            margin: 2px;
        }

        .horizontal-bar {
            height: 4px;
            grid-column: 1 / -1;
            grid-row: 3;
            cursor: ns-resize;
            margin: 2px;
        }

        .vertical-bar, .horizontal-bar {
            border: 1px outset white;
        }


        .controls {
            grid-column: 1 / -1;
            grid-row: 1;
        }

        .right {
            float: right;
        }

        #playback-contols {
            grid-column: 4 / 7;
        }

        #edit {
            position: relative;
            display: grid;
            grid-template-rows: max-content 1fr;
            grid-template-columns: 1fr 1fr 1fr 1fr;
        }

        .editor {
            display: flex;
            grid-column: 1 / -1;
        }

        .line-numbers {
            text-align: end;
            background: lightgray;
            resize: none;
            overflow: hidden;
            font-variant-numeric: tabular-nums;
        }

        .main {
            flex-grow: 1;
            resize: none;
        }

        #input {
            /*font-size: 100%;*/
            width: 100%;
            height: 100%;
            overflow: auto;
            grid-column: 1 / -1;
            flex-grow: 1;
            resize: none;
            /*white-space: nowrap;*/
        }

        #scene-container {
            position: relative;
            overflow: hidden;
        }

        #scene {
            width: 100%;
            height: 100%;
        }

        #top-view-container {
            position: relative;
            overflow: hidden;
        }

        #top-view {
            width: 100%;
            height: 100%;
        }

        .expanded-tree {
            overflow: auto;
        }

        .search-controls {
            display: flex;
        }

        .search {
            border-radius: 50px;
            flex-grow: 1;
            outline: none;
        }

        .detail {
            overflow: auto;
        }

        .vector-sliders {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
        }

        .group {
            position: relative;
            border-left: 1px solid gray;
            border-top-left-radius: 0.5em;
            border-bottom-left-radius: 0.5em;

            border: 1px solid gray;
            border-radius: 0.5em;
            margin: 0 1px;

            transition: max-height 0.3s ease-in;
        }

        .expand {
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
            transition: max-height 0.3s ease-in;
            max-height: 1.2em;
            overflow: hidden;
        }

        .shader-controls {
            display: flex;
        }

        .shader-name {
            flex-grow: 1;
        }

        .content {
            white-space: nowrap;
            max-height: 1.2em;
            transition: max-height 0.3s ease-in;
            overflow: hidden;
        }

        .range {
            font-style: italic;
            color: blue;
        }

        .control-node {
            font-style: italic;
            color: blue;
        }

        .range-expanded {
            font-style: italic;
            color: lightgray;
        }

        .collapse {
            max-height: 0;
            /*border: none;*/
        }

        .entry {
            padding-left: 1.1em;
        }

        .entry-content {
            padding-left: 1.1em;
        }

        .selected {
            background-color: yellow;
        }

        .media-button {
            padding: 0;
            margin: 0;
            background: none;
            border: none;
            font-size: 150%;
        }

        .focus {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            z-index: 5;
        }

        #external-names {
            grid-column: 1 / -1;
            grid-row: 4;
            overflow: auto;
            padding: 0.5rem;
        }

        .header {
            background-color: lightgray;
            font-weight: bold;
            position: sticky;
            padding: 0.25rem;
            text-align: center;
        }

        .cell {
            background-color: white;
            padding: 0.25rem;
            width: 100%;
        }

        .attributes,
        .uniforms {
            display: grid;
            grid-gap: 1px;
        }

        .attributes {
            grid-template-columns: repeat(3, 1fr);
        }

        .uniforms {
            grid-template-columns: repeat(4, 1fr);
        }

        .hidden {
            display: none !important;
        }

        .hide {
            max-height: 0;
            overflow: hidden;
        }

    </style>
</head>

<body>
    <div id="overlay"></div>
    <datalist id="shader-list"></datalist>
    <template id="editor-template">
        <div class="editor">
            <textarea class="line-numbers"></textarea>
            <textarea class="main" wrap="off"></textarea>
        </div>
    </template>
    <template id="shader-controls-template">
        <div class="shader-controls">
            <input class="shader-name" placeholder="Shader Name" list="shader-list">
            <button class="build-shader">Build</button>
        </div>
    </template>

    <div class="layout">
        <div class="controls">
            <datalist id="files"></datalist>
            <input id="filename" list="files" placeholder="Name" value="New Scene">
            <button id="save">&#x1F4BE;</button>
            <!--button id="load">&#x1F4C2;</button-->
            <select id="layout-selection">
                <option value="0">Scene</option>
                <Option value="1">Source</Option>
                <Option value="2">Tree</Option>
                <Option value="3">3d</Option>
                <Option value="4">Top</Option>
                <Option value="5">Details</Option>
                <Option value="6">Shader</Option>
            </select>
            <button id="fullscreen">fullscreen</button>
            <button id="start" class="media-button">&#x23ee;</button>
            <button id="rewind" class="media-button">&#x23ea;</button>
            <button id="play" class="media-button">&#x23ef;</button>
            <button id="forward" class="media-button">&#x23e9;</button>
            <button id="end" class="media-button">&#x23ed;</button>

            <label for="split">Split</label><input id="split" type="checkbox">
            <label for="move">Move</label><input id="move" type="checkbox">
            <button id="reset">Reset</button>
        </div>
        <div class="layout-row">
            <div id="edit">
                <button id="comment">Comment</button>
                <button id="uncomment">Uncomment</button>
                <button id="unindent">&larr;</button>
                <button id="indent">&rarr;</button>
                <div class="editor">
                    <textarea class="line-numbers"></textarea>
                    <textarea id="input" rows="20" cols="50" wrap="off"></textarea>
                </div>
            </div>
            <div class="vertical-bar" data-column="1"></div>
            <div id="scene-container">
                <div id="light-direction" class="vector-sliders">
                    <input id="light-x" class="light-position" type="range" min="-100" max="100">
                    <input id="light-y" class="light-position" type="range" min="-100" max="100">
                    <input id="light-z" class="light-position" type="range" min="-100" max="100">
                </div>
                <canvas id="scene"></canvas>
            </div>
        </div>
        <!--div id="top-view-container"><canvas id="top-view"></canvas></div-->
        <!--div class="tree"></div-->
        <div class="horizontal-bar" data-row="2"></div>
        <div class="layout-row">

            <div class="expanded-tree"></div>
            <div class="vertical-bar" data-column="1"></div>

            <div class="detail"></div>
        </div>
        <div id="external-names" class="hidden">
            <h2>Name Mapping</h2>
            <div class="attributes">
                <span class="header">Attribute</span>
                <span class="header" title="Offset in bytes into vertex data">Offset</span>
                <span class="header">Type</span>
            </div>
            <br>
            <div class="uniforms">
                <span class="header">Uniform</span>
                <span class="header">Name</span>
                <span class="header">Type</span>
                <span class="header">Default</span>
            </div>
        </div>

    </div>

    <script>
        /**
         *
         */
        addEventListener('load', function (e) {
            main();
        });

        /**
         * Display the text in overlay div.
         */
        function report(text, sep) {
            if (sep) {
                document.getElementById('overlay').innerText += sep + text;
            } else {
                document.getElementById('overlay').innerText = text;
            }
        }

        /**
         * Converts an HSL colour value to RGB. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSL_colour_space.
         * Assumes h, s, and l are contained in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         *
         * @param   {number}  h       The hue
         * @param   {number}  s       The saturation
         * @param   {number}  l       The lightness
         * @return  {Array}           The RGB representation
         */
        function hslToRgb(h, s, l) {
            var r, g, b;

            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                var hue2rgb = function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        /**
         * Utility function to support downloading generated content.
         */
        function download(text, name='') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }

        /**
         * Editor component
         */
        class Editor {
            constructor(parent) {
                const template = document.getElementById('editor-template');
                this.container = template.content.firstElementChild.cloneNode(true);
                this.lineNumbers = this.container.querySelector('.line-numbers');
                this.main = this.container.querySelector('.main');

                this.main.addEventListener('scroll', (event) =>
                    this.lineNumbers.scrollTop = this.main.scrollTop);

                this.main.addEventListener('input', (event) => this.updateLineNumbers());

                if (parent) {
                    parent.appendChild(this.container);
                }
            }
            updateLineNumbers() {
                const count = this.main.value.split(/\n/g).length;
                this.lineNumbers.value = '';
                const numbers = Array(count).fill(0).map((e, i) => i + 1);
                this.lineNumbers.value = numbers.join('\r\n');
                this.lineNumbers.cols = 1 + (count + '').length;
            }
            get value() {
                return this.main.value;
            }
            set value(text) {
                this.main.value = text;
                this.updateLineNumbers();
            }
        }

        /**
         * Extract group data from match data.
         */
        function setGroupData(node) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*\|\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(node.list);
            if (!isNaN(count)) {
                node.group = [];
                for (let i = 1; i <= count; ++i) {
                    node.group.push(i);
                }
            } else {
                node.group = node.list.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return item.trim();
                });
            }
            node.name = (node.name || '').trim();
        }

        /*
         * Symbols used to provide attributes of the nodes that are independent of user attributes.
         */
        const symbols = {
            source: Symbol('source'),
            content: Symbol('content'),
            container: Symbol('container'),
            value: Symbol('value'),
            values: Symbol('values'),
            links: Symbol('links'),
        }


        /**
         * Classes of the nodes in the template structure.
         */
        class MetaNode {
            constructor(value, level, lineNumber) {
                this.value = value;
                this.level = level;
                this.lineNumber = lineNumber;
                this.content = [];
            }
            makeNode(context) {
                const node = {
                    [symbols.source]: this,
                    [symbols.container]: context.container[0],
                    [symbols.links]: {},
                    [symbols.values]: [],
                }
                context.container.unshift(node);
                node[symbols.content] = this.content.flatMap((node) => node.expand(context));
                context.container.shift();
                context.parse(node, this.value);
                context.parsers.forEach((parser) => parser.apply(node, context));
                context.named.push(node);
                return node;
            }
        }

        class ContinuationNode extends MetaNode {
            static match(value) {
                const pattern = /^\s*\&(?<value>.+)$/;
                return pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\s*\&(?<value>.+)$/;
                const match = value.match(pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                context.parse(context.container, this.value);
                return this.content.flatMap((node) => node.expand(context));
            }
        }

        class DataNode extends MetaNode {
            static pattern = /^\s*\*(?<value>.+)$/;
            static match(value) {
                return DataNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(DataNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                // Generate a temporary node
                if (context.defaultValue.length > 0) {
                    this.value = `${this.value};${context.defaultValue.join(' ')}`;
                }
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const node = super.makeNode(context);
                if (node.name) {
                    context.names[node.name] = context.names[node.name] || [];
                    context.names[node.name].unshift(node);
                }
                context.container.unshift(this);
                node[symbols.content] = this.content.flatMap((node) => node.expand(context));
                context.container.shift();

                if (node.name) {
                    context.names[node.name].shift();
                }
                // If the name is found add the data otherwise return the node
                if (context.named[node.name]) {
                    const ref = context.named[node.name];
                    Object.assign(ref, node, ref);
                    ref[symbols.content].push(...node.content);
                    return [];
                }
                return node;
            }
        }

        class DefaultNode extends MetaNode {
            static pattern = /^\s*\!(?<value>.+)$/;
            static match(value) {
                return DefaultNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(DefaultNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.defaultValue.push(this.value);
                const content = this.content.flatMap((node) => node.expand(context));
                context.defaultValue.pop();
                return content;
            }            
        }
        
        class GroupNode extends MetaNode {
            static match(content) {
                const pattern = /^\s*\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\s*\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
                const match = value.match(pattern);
                this.list = match.groups.list;
                this.name = match.groups.name || '';
            }
            expand(context) {
                // Process the elements of the value based on the context
                context.modifiers.forEach((modifier) => {
                    this.list = modifier.apply(this.list);
                    this.name = modifier.apply(this.name);
                });
                setGroupData(this);
                const content = this.group.flatMap((item, index) => {
                    context.values[this.name] = item;
                    context.values[`${this.name}_n`] = index;
                    return this.content.flatMap((node) => node.expand(context));
                });
                return content;
            }
        }

        class TemplateNode extends MetaNode {
            static match(content) {
                const pattern = /^\s*(?<value>\S.*)\[(?<list>[^\]]+)\]\s*$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\s*(?<value>\S.*)\[(?<list>[^\]]+)\]\s*$/;
                const match = value.match(pattern);

                this.value = match.groups.value;
                this.list = match.groups.list;
            }
            expand(context) {
                // Process the elements of the value based on the context
                if (context.defaultValue.length > 0) {
                    this.value = `${this.value};${context.defaultValue.join(' ')}`;
                }
                context.modifiers.forEach((modifier) => {
                    this.list = modifier.apply(this.list);
                    this.value = modifier.apply(this.value);
                });

                setGroupData(this);
                const content = this.group.flatMap((item, index) => {
                    context.values[this.name] = item;
                    context.values[`${this.name}_n`] = index;
                    const node = super.makeNode(context);
                    if (node.name) {
                        context.names[node.name] = context.names[node.name] || [];
                        context.names[node.name].unshift(node);
                    }
                    context.container.unshift(this);
                    node[symbols.content] = this.content.flatMap((node) => node.expand(context));
                    context.container.shift();

                    if (node.name) {
                        context.names[node.name].shift();
                    }
                    return node;
                });
                return content;
            }
        }

        class ReferenceNode extends MetaNode {
            static pattern = /^\s*<(?<parameter>[^=]+)=(?<value>[^>]+)>$/;
            static match(content) {
                return ReferenceNode.pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ReferenceNode.pattern);

                this.parameter = match.groups.parameter;
                this.value = match.groups.value;
            }
            expand(context) {
                // Process the elements of the value based on the context
                context.modifiers.forEach((modifier) => {
                    this.parameter = modifier.apply(this.parameter);
                    this.value = modifier.apply(this.value);
                });

                const refNode = context.find((node) => node[parameters] === value);
                if (refNode) {
                    return refNode.source.expand(context);

                }
                context.warnings.push(`Unresolved refernce ${parameter} = ${value} on line: $(this.lineNumber}`);

                const node = super.makeNode(context);
                if (node.name) {
                    context.names[node.name] = context.names[node.name] || [];
                    context.names[node.name].unshift(node);
                }
                context.container.unshift(this);
                node[symbols.content] = this.content.flatMap((node) => node.expand(context));
                context.container.shift();

                if (node.name) {
                    context.names[node.name].shift();
                }
                return node;

            }
        }

        class ConditionalNode extends MetaNode {
            static match(content) {
                const pattern = /^\s*\?\[(?<expr>[^\]]+)\]\s*(?<content>.*)/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\s*\?\[(?<expr>[^\]]+)\]\s*(?<value>.*)/;
                const match = value.match(pattern);

                this.value = match.groups.value;
                this.expr = match.groups.expr;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.expr = modifier.apply(this.expr);
                    this.value = modifier.apply(this.value);
                });

                const expr = `return ${context.resolve(this.expr)}`;
                try {
                    const names = Object.keys(context.values).map((name) => name ? name : '_');
                    const values = Object.values(context.values);
                    const func = new Function(...names, expr);
                    if (func(...values)) {
                        return this.content.flatMap((node) => node.expand(context));
                    }
                } catch (e) {
                    console.log(`Invalid expression on line ${this.lineNumber} (${expr})`);
                }
                // Return an empty list on test failure or exception;
                return [];
            }
        }

        class PatternNode extends MetaNode {
            static pattern = /^\s*\/(?<pattern>[^\/]+)\/(?<flags>[ig])?\s*=>\s*(?<replacement>.+)$/;
            static match(content) {
                return this.pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const match = value.match(PatternNode.pattern);

                this.pattern = match.groups.pattern;
                this.flags = match.groups.flags;
                this.replacement = match.groups.replacement.trim();
            }
            expand(context) {
                try {
                    this.expr = new RegExp(this.pattern, this.flags);
                    this.apply = (value) => value.replace(this.expr, this.replacement);
                } catch (e) {
                    console.log(`Invalid Regular expression on line ${lineNumber}`);
                    this.apply = (value) => value;
                }
                context.modifiers.unshift(this);
                const content = this.content.flatMap((node) => node.expand(context));
                context.modifiers.shift();
                return content;
            }
        }

        class FormatNode extends MetaNode {
            static match(content) {
                const pattern = /^\s*\$(?<format>(<[^>]+>[^<]+)*(<[^>]+>))\s*;?\s*$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const pattern = /^\s*\$(?<format>(<[^>]+>[^<]+)*(<[^>]+>))\s*;?\s*$/;
                const match = value.match(pattern);
            }
            apply(value) {

            }
            expand(context) {
                const content = this.content.flatMap((node) => node.expand(context));
                return content;
            }
        }

        class TableNode extends MetaNode {
            static pattern = /^\s*\|(?<headings>[^\t;\|]+([\t;\|][^\t;\|]+)*)\|?$/;
            static match(value) {
                return TableNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const match = value.match(TableNode.pattern);
                this.headings = match.groups.headings.split(/[\t;\|]/g);
            }
            apply(node, context) {
                this.headings.forEach((heading, index) => {
                    if (node[symbols.values][index]) {
                        if (heading.endsWith('*')) {
                            node.name = node[symbols.values][index];
                            heading = heading.replace(/\*\s*$/, '');
                        }
                        node[heading] = node[symbols.values][index];
                    }
                });
            }
            expand(context) {
                context.parsers.unshift(this);
                const content = this.content.flatMap((node) => node.expand(context));
                context.parsers.shift(this);
                return content;
            }
        }

        class PlainNode extends MetaNode {
            static match(content) {
                const pattern = /^.*$/;   // Match anything not already matched
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
            }
            expand(context) {
                if (context.defaultValue.length > 0) {
                    this.value = `${this.value};${context.defaultValue.join(' ')}`;
                }
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const node = super.makeNode(context);
                if (node.name) {
                    context.names[node.name] = context.names[node.name] || [];
                    context.names[node.name].unshift(node);
                }
                context.container.unshift(this);
                node[symbols.content] = this.content.flatMap((node) => node.expand(context));
                context.container.shift();

                if (node.name) {
                    context.names[node.name].shift();
                }
                return node;
            }
        }

        /**
         * convert string definition to structure
         */
        function getStructure(definition) {
            const lines = definition.split(/\r?\n/);
            const nodeTypes = [
                ContinuationNode,
                DefaultNode,
                DataNode,
                ConditionalNode,
                GroupNode,
                TemplateNode,
                ReferenceNode,
                PatternNode,
                FormatNode,
                TableNode,
                PlainNode];

            const structure = [];
            const stack = [];
            const names = {};

            // The structure is determined by indentation, level, or 'path' style.
            // When using indentation a tab is equivelent to 4 spaces.
            // Level is indicated by > at the start of a line followed by integer
            // at start of line.
            // Path is indicated by optional whitespace followed by a '.'
            // separated path, including a leading and trailling '.'.

            let lineNumber = 0;
            for (const line of lines) {
                ++lineNumber;
                if (/^\s*(#|$)/.test(line)) {
                    continue;
                }

                // Level can be determined by indentaion or numerically
                // Convert a leading integer into that number of spaces
                let level = 0;
                let levelCount = '';
                let offset = 0;
                let i = 0;
                const lineStructure = /^(?<indent>\s*[\^-]?\s*([0-9]+\s+)?)(?<value>.*)$/
                const match = line.match(lineStructure);
                const indent = match.groups.indent || ''; //line.replace(/(\s*([0-9]+\s+)?)(.*)/, '$1');
                for (let i = 0; i < indent.length; ++i) {
                    const c = indent[i];
                    if (/[0-9]/.test(c)) {
                        levelCount += c;
                    } else if (c === '^' && stack.length) {
                        offset = stack[0].level;
                    } else if (c === '-') {
                        offset = 0;
                    } else if (c === '\t') {
                        level += 4 - (level % 4);
                    } else {
                        level += 1;
                    }
                }
                level += offset;
                if (levelCount) {
                    level += parseInt(levelCount);
                }

                while (stack.length && stack[0].level >= level) {
                    stack.shift();
                }

                const value = match.groups.value; //line.replace(/^(\s*)(?<level>[0-9]+)?\s*/, '');

                // Determine node type based on content
                const type = nodeTypes.find((type) => type.match(value));
                if (type) {
                    const metaNode = new type(value, level, lineNumber);
                    if (stack[0]) {
                        stack[0].content.push(metaNode);
                    } else {
                        structure.push(metaNode)
                    }
                    stack.unshift(metaNode);
                } else {
                    console.log(`Unrecognised node type on line: ${lineNumber}`);
                }
            }
            return structure;
        }

        /**
         * Expand the structure
         */
        function expand(structure, parser) {
            const context = {
                values: {},
                stack: [],
                names: {},
                named: {},
                container: [],
                modifiers: [],
                parsers: [],
                defaultValue: [],
                resolve(value) {
                    if (value) {
                        // Convert any variables in the string to the values in the context.
                        value = value.replace(/<([^>]*)>/g, (match, name) =>
                            this.values[name] || `<name>`);
                        value = value.replace(/\{([^:]+)(:0+)?\}/g, (match, expr, format) => {
                            let result = match;
                            const names = Object.keys(context.values).map((name) => name ? name : '_');
                            const values = Object.values(context.values);
                            try {
                                result = new Function(...names, `return ${expr}`)(...values);
                            } catch (e) {
                                console.log(`Info: expression ${expr} unresolved`);
                            }
                            if (format) {
                                result = (result + '').pad(format.length - 1, format[1]);
                            }
                            return result;
                        });
                        return value;
                    }
                },
                parse(node, value) {
                    const resolved = this.resolve(value);
                    return parser(node, this.resolve(value));
                },
            };

            const expanded = structure.flatMap((node) => node.expand(context));
            return expanded;
        }

        /**
         * Node in a tree View
         */
        class TreeViewNode {
            constructor(item, tree, container) {
                this.item = item;
                this.container = container;
                this.tree = tree;
                this.node = document.createElement('div');
                this.expander = document.createElement('span');
                this.node.append(this.expander);
                this.expander.classList.add('expander');
                this.labelNode = document.createElement('span');
                this.labelNode.innerText = this.label;
                const title = this.title;
                if (title) {
                    this.labelNode.title = title;
                }
                this.node.append(this.labelNode);
                this.contentNode = document.createElement('div');
                this.node.append(this.contentNode);
                this.contentNode.classList.add('branch-content');
                this.contentNode.classList.remove('hide');
                this.expanded = false;

                this.expander.addEventListener('click', (event) => this.toggle(event.ctrlKey));
                this.expander.innerHTML = this.indicator;
            }
            expand(recursive) {
                const content = this.content;
                this.contentNode.innerHTML = '';
                this.contentNode.classList.remove('hide');
                this.nodes = content.map((item) => {
                    const node = this.content.find((existing) => existing.item === item) ||
                        new TreeViewNode(item, this.tree, this);
                    this.contentNode.append(node.node);
                    if (recursive) {
                        node.expand(recursive);
                    }
                });
                this.expanded = true;
                this.expander.innerHTML = this.indicator;
            }
            collapse(recursive) {
                this.contentNode.classList.add('hide');
                if (recursive) {
                    this.content.forEach((item) => node.collapse(recursive));
                }
                this.expanded = false;
                this.expander.innerHTML = this.indicator;
            }
            toggle(recursive) {
                if (this.expanded) {
                    this.collapse(recursive);
                } else {
                    this.expand(recursive);
                }
            }
            get indicator() {
                if (this.content.length > 0) {
                    return this.expanded ? '&#9661' : '&#9655'; 
                }
                return '';
            }
            get label() {
                if (this.tree.config.getLabel) {
                    return this.tree.config.getLabel(this);
                }
                return this.item.name;
            }
            get title() {
                if (this.tree.config.getTitle) {
                    return this.tree.config.getTitle(this);
                }
            }
            get content() {
                if (this.tree.config.getContent) {
                    return this.tree.config.getContent(this.item);
                }
                return this.item.content || [];
            }
        }

        /**
         * Class for managing tree views
         */
        class TreeView {
            constructor(config = {}, content = []) {
                this.node = document.createElement('div');
                this.searchControl = document.createElement('div');
                this.node.append(this.searchControl);
                this.searchControl.classList.add('search-controls');
                this.searchText = document.createElement('input');
                this.searchControl.append(this.searchText);
                this.searchText.classList.add('search')
                this.caseSensitive = document.createElement('input');
                this.searchControl.append(this.caseSensitive);
                this.caseSensitive.type = 'checkbox';
                this.main = document.createElement('div');
                this.node.append(this.main);

                this.config = config;

                this.setContent(content);

                this.searchText.addEventListener('input', (event) =>
                    this.incrementalSearch());
                this.searchText.addEventListener('change', (event) =>
                    this.search());
                this.searchStack = [];
                this.path = [];
            }
            setContent(content) {
                this.main.innerHTML = '';
                this.content = content;
                this.nodes = this.content.map((item) => {
                    const node = new TreeViewNode(item, this);
                    this.main.append(node.node);
                    return node;
                });
            }
            test(node, pattern) {
                if (this.config.test) {
                    return this.config.test(node, pattern);
                }
                return pattern.test(node.label);
            }
            expand() {
                let nodes = this.nodes;
                this.path.forEach((item) => {
                    const node = nodes.find((node) => node.item === item);
                    node.expand();
                    nodes = node.content;
                });
            }
            resetSearch() {
                this.searchStack.length = 0;
                this.path = [];
                this.first = true;
            }
            search() {
                if (this.searchText.value) {
                    const flags = this.caseSensitive.checked ? '' : 'i';
                    const pattern = new RegExp(this.searchText.value, flags);

                    const content = this.config.content || ((item) => item.content);
                    this.items = [];
                    const stack = [];
                    while (stack.length) {
                        const item = stack.shift();
                        if (item) {
                            if (this.test(item, pattern)) {
                                this.path.push(item);
                                break;
                            }
                            this.path.push(item);
                            this.items.push(item, null);
                            this.stack.unshift(...content(item));
                        } else {
                            this.path.pop();
                        }
                    }
                    if (this.path) {
                        this.expand();
                    }
                }
            }
            incrementalSearch() {

            }
        }

        /**
         * Toggle the expansion of a node.
         */
        function toggleExpansion(node, recursive) {
            node.expanded = !node.expanded;

            const expand = (node) => {
                if (recursive) {
                    node.expanded = true;
                }
                node.nodes.forEach((node) => node.classList.remove('collapse'));
                if (node.expanded) {
                    node[symbols.content].forEach((part) => expand(part));
                } else {
                    node.nodes[1].classList.add('collapse');
                }
            };

            const collapse = (node) => {
                if (recursive) {
                    node.expanded = false;
                }
                node.nodes.forEach((node) => node.classList.add('collapse'));
                node[symbols.content].forEach((part) => collapse(part));
            };

            if (node.expanded) {
                node[symbols.content].forEach((part) => expand(part));
                node.nodes[0].innerHTML = '&CircleMinus;';
                node.nodes[1].classList.remove('collapse');
            } else {
                node[symbols.content].forEach((part) => collapse(part));
                node.nodes[0].innerHTML = '&CirclePlus;';
                node.nodes[1].classList.add('collapse');
            }
        }

        /**
         *
         */
        function numberOrString(input) {
            const num = Number(input);
            if (isNaN(num)) {
                return input.trim();
            }
            return num;
        }

        /**
         * Convert a string to a value or list of values
         */
        function getValue(str) {
            const list = str.split(/\s*,\s*/);
            if (list.length > 1) {
                return list.map((i) => numberOrString(i));
            }
            return numberOrString(str);
        }

        /**
         * Generate an new structure from the definition
         */
        function defaultParser(node, value) {
            node[symbols.values] = [];
            if (value) {
                const [...data] = value.split(/[\|\t;]/g);
                node.name = data[0].trim();
                data.forEach((item) => {
                    item = item.trim();
                    if (item.includes('=')) {
                        const [name, value] = item.split(/=/);
                        if (/^"[^"]+"$/.test(value)) {
                            node[name] = value;
                        } else if (value.includes(',')) {
                            node[name] = value.split(/,/g).map((val) => numberOrString(val));
                        } else {
                            node[name] = numberOrString(value);
                        }
                    } else {
                        if (/^"[^"]+"$/.test(item)) {
                            node[symbols.values].push(item);
                        } else if (item.includes(',')) {
                            node[symbols.values].push(item.split(/,/g).map((val) => numberOrString(val)));
                        } else {
                            node[symbols.values].push(numberOrString(item));
                        }
                    }
                });
            }
        }

        /**
         * Generate an new structure from the definition
         */
        function parseStructure(structure, parser = defaultParser) {
            const names = {};

            const evaluate = (string, context) => {
                const path = (sep, start = 0, end) =>
                    context.path.toReversed().slice(start, end).map((node) => node.name).join(sep || '');
                const pathUp = (sep, start = 0, end) =>
                    context.path.slice(start, end).map((node) => node.name).join(sep || '');

                const level = (val) =>
                    context.path[val < 0 ? Math.abs(val) : context.path.length - val].name || '';
                const names = [];
                const values = [];
                Object.keys(context.parameters).filter((key, value) => key).forEach((key) => {
                    names.push(key);
                    values.push(context.parameters[key]);
                });
                try {
                    const func = new Function('path', 'pathUp', 'level', ...names, `return ${string};`);
                    return func(path, pathUp, level, ...values);
                } catch (e) {
                    console.log(e);
                }
                return string;
            };

            const resolve = (string, context) => {
                string = string.replace(/\[\s*-?([0-9]+)\s*\]/, //'_path[$1]');
                    (m, p) => `${context.path[context.path.length - Number(p)] || ''}`);
                string = string.replace(/\[\s*\+\s*(?<sep>.+)?\s*\]/,
                    (m, sep) => `${context.path.join(sep || ' ')}`);
                string = string.replace(/\[\s*-\s*(?<sep>.+)?\s*\]/,
                    (m, sep) => `${context.path.toReversed().join(sep || ' ')}`);

                for (const [name, value] of Object.entries(context.parameters)) {
                    const pattern = new RegExp(`\\b${name}\\b`, 'g');
                    string = string.replace(pattern, value);
                }

                return `${string}`;
            };

            const root = [];

            const patternStack = [];

            const formatStack = [];
            const addNode = (source, parent, context = { resolved: true, parameters: {}, path: [], nesting: [] }) => {
                context = Object.assign({}, context);
                let node = { source, parts: [], content: source.content, data: {}, };
                const controlNode = source.patternNode || source.groupNode || source.conditionalNode || source.templateNode || source.formatNode;
                const parts = [...source[symbols.content]];

                if (source.patternNode) {
                    try {
                        patternStack.push({
                            match: new RegExp(source.pattern, source.flags),
                            replacement: source.replacement || '',
                        });
                    } catch (e) {
                        console.log(e);
                    }
                }

                if (source.formatNode) {
                    formatStack.unshift(source);
                }

                if (!controlNode) {
                    patternStack.forEach((pattern) =>
                        node.content = node.content.replace(pattern.match, pattern.replacement));
                    node.content = node.content.replace(/<([^>]*)>/g, (match, label) => {
                        if (context.parameters[label]) {
                            return context.parameters[label];
                        }
                        const index = Number(label);
                        if (!isNaN(index) && context.nesting.length) {
                            return context.nesting[Math.abs(index) % context.nesting.length][0];
                        }
                        const keys = Object.keys(names).sort((a, b) => b.length - a.length);
                        const name = keys.find((key) => label.startsWith(key));
                        if (name) {
                            parts.unshift(...names[name][symbols.source][symbols.content]);
                            return names[name].content;
                        }
                        return match;
                    });
                    node.content = node.content.replace(/\{([^}]+)\}/g, (match, p1) => evaluate(p1, context));
                    node.content = node.content.replace(/:([^\t\|;:]+)/g, (all, item) => {
                        if (context.parameters[item]) {
                            return `:${context.parameters[item]}`;
                        }
                        const keys = Object.keys(names).sort((a, b) => b.length - a.length);
                        const name = keys.find((key) => item.startsWith(key));
                        if (name) {
                            parts.unshift(...names[name][symbols.source][symbols.content]);
                            return `:${names[name].content}`;
                        }
                        return all;
                    });
                }

                parser(node, context);
                if (formatStack.length) {
                    const match = node.content.match(formatStack[0].pattern);
                    if (match) {
                        var index = 0;
                        const data = Object.entries(match.groups).reduce((obj, [name, value]) => {
                            obj[name] = getValue(value);
                            return obj;
                        }, {});
                        node = Object.assign(data, node);
                    }
                }

                if (!controlNode) {
                    const path = context.path.map((node) => node.name);
                    let l = 1;
                    while (names[`${node.name}, ${path.slice(0, l).join(', ')}`] && l < path.length) {
                        l += 1;
                    }
                    node.uniqueName = `${node.name}, ${path.slice(0, l).join(', ')}`
                }

                if (!controlNode) {
                    context.path.unshift(node);
                }

                const matched = (!source.conditionalNode) || source.test(context);

                if (source.templateNode) {
                    if (!/(<[^>]*>)|(\{[^\}]*\})/.test(node.content)) {
                        //document.body.style.background = 'pink';
                        node.content = `${node.content} <>`;
                    }

                    node[symbols.content] = [...source[symbols.content]];
                    if (context.parameters[''] !== undefined) {
                        context.nesting.unshift([context.parameters[''], context.parameters['_n']])
                    }
                    node.lineNumber = source.lineNumber;
                    source.group.forEach((item, index) => {
                        context.parameters[''] = item;
                        context.parameters[`_n`] = index;
                        /*
                        context.parameters[node.name] = item;
                        context.parameters[`${node.name}_n`] = index;
                        */
                        addNode(node, parent, context);
                    });
                    if (context.parameters[''] !== undefined) {
                        context.nesting.shift();
                    }
                }

                if (parts.length && matched && !source.referenceNode) {
                    if (source.groupNode) {
                        source.group.forEach((item, index) => {
                            context.parameters[source.name] = item;
                            context.parameters[`${source.name}_n`] = index;
                            parts.forEach((part) => addNode(part, parent, context));
                        });
                    } else if (source.patternNode || source.formatNode) {
                        parts.forEach((part) => addNode(part, parent, context));
                    } else {
                        parts.forEach((part) => addNode(part, node, context));
                    }
                }
                names[node.name] = names[node.name] || node;
                names[node.uniqueName] = node;
                if (!controlNode) {
                    context.path.shift();
                }
                if (!controlNode) {
                    if (parent) {
                        parent[symbols.content].push(node);
                        node.parent = parent;
                    } else {
                        root.push(node);
                    }
                }
                if (source.patternNode) {
                    patternStack.pop();
                }
                if (source.formatNode) {
                    formatStack.shift();
                }

            };
            structure.forEach((node) => addNode(node));

            return root;
        }

        var tree = {
            roots: [],
            nodes: [],
        };

        /**
         * Generate dom nodes for the given structure
         */
        function getView(structure, actions = {}) {
            const container = document.createElement('div');
            container.classList.add('tree-view');

            const nodes = [];

            const flatten = (node, level = 1) => {
                node.level = level;
                nodes.push(node);
                node[symbols.content].forEach((part) => flatten(part, level + 1));
            };

            structure.forEach((part) => flatten(part));
            tree.roots = structure;

            let depth = Math.max(...nodes.map((node) => node.level));

            let row = 0;
            const addNode = (node) => {
                row += 1;
                let text = node.name;
                node.expanded = true;
                node.row = row;
                node.nodes = [];
                const controlNode = node[symbols.source].groupNode || node[symbols.source].datNode || node[symbols.source].conditional;

                const group = document.createElement('div');
                container.appendChild(group);
                group.style.gridColumn = node.level;
                const expander = document.createElement('div');
                expander.classList.add('expand');
                node.nodes.push(expander);
                node.nodes.push(group);
                group.appendChild(expander);
                const content = document.createElement('div');
                content.classList.add('content');

                if (controlNode) {
                    content.classList.add('control-node');
                    if (node.unrolled) {
                        content.classList.add('range-expanded');
                    }
                    content.addEventListener('click', (event) => {
                        node.unrolled = !node.unrolled;
                        container.innerHTML = '';
                        row = 0;
                        structure.forEach((part) => addNode(part));
                    });
                }
                node.nodes.push(content);
                content.style.gridColumn = `${node.level + 1}/${depth + 2}`;
                container.appendChild(content);
                const data = Object.entries(node).map(([name, value]) => `${name} = ${value}`).join(', ');
                content.innerText = `${text}`;// (${data})`;
                content.title = `${node.uniqueName} ${data}`;
                if (node.shape) {
                    content.classList.add('shape');
                }
                if (node.sceneNode) {
                    content.classList.add('scene-node');
                }
                Object.entries(actions).forEach(([event, action]) =>
                    content.addEventListener(event, (event) => action(event, node)));

                if (node[symbols.content].length) {
                    group.classList.add('group');
                    expander.innerHTML = '&CircleMinus;';
                    expander.addEventListener('click', (event) => toggleExpansion(node, event.ctrlKey));
                    expander.addEventListener('dblclick', (event) => toggleExpansion(node, true));

                    const startRow = row;
                    node[symbols.content].forEach((part) => addNode(part));
                    group.style.gridRow = `${startRow}/${row + 1}`;
                    group.style.background = `hsl(${360 * Math.random()} 50% 50%)`;
                }
                return nodes;
            };

            const columns = `repeat(${depth}, 1em) max-content 1fr`;
            container.style.gridTemplateColumns = columns;

            structure.forEach((part) => addNode(part));
            return container;
        }

        const namedNodes = {};

        class Transition {
            constructor(node) {
                this.node = node.sceneNode;
            }
            start() { }
            finish() { }
        }

        class Translate extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
                }
                const p = d * d * (3 - 2 * d);
                const v = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    ...v, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
            }
        }

        class Rotate extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
                if (this.value.length < 4) {
                    const start = this.value.length;
                    this.value.length = 4;
                    this.value.fill(0, start);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        getRotationMatrix(this.value[0], this.value.slice(1)));
                }
                const p = d * d * (3 - 2 * d);
                const angle = this.value[0] * p;
                this.node.movement = matrixMultiply(this.node.movement,
                    getRotationMatrix(angle, this.value.slice(1)));
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    getRotationMatrix(this.value[0], this.value.slice(1)));
            }
        }

        class Scale extends Transition {
            constructor(node, value) {
                super();
                if (Array.isArray(value)) {
                    this.value = value;
                } else {
                    this.value = Array(3).fill(value);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement, [
                        this.value[0], 0, 0, 0,
                        0, this.value[1], 0, 0,
                        0, 0, this.value[2], 0,
                        0, 0, 0, 1,
                    ]);
                }
                const p = d * d * (3 - 2 * d);
                const s = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    s[0], 0, 0, 0,
                    0, s[1], 0, 0,
                    0, 0, s[2], 0,
                    0, 0, 0, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform, [
                    this.value[0], 0, 0, 0,
                    0, this.value[1], 0, 0,
                    0, 0, this.value[2], 0,
                    0, 0, 0, 1,
                ]);
            }
        }

        class ColourChange extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            start() {
                this.intialColour = this.node.colour;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const v = this.value.forEach((v, i) =>
                    this.intialColour[i] + (v - this.intialColour[i]) * p);
                this.node.colour = v;
            }
        }

        class Fade extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            start() {
                this.initialAlpha = this.node.colour[3];
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const f = this.initialAlpha + (this.value - this.initialAlpha) * p;
                this.node.colour[3] = f;
            }
        }

        const nodeTransitions = {
            Translate, Rotate, Scale, ColourChange, Fade,
        };

        /**
         * Generate scene graph for the given structure
         */
        function getGraph(structure, scene) {
            scene.data = {
                vertex: [],
                indices: [],
            };
            let links = 0;

            const types = {
                Box, Ball, Frustrum, Cylinder, Cone, Diamond, Tetrahedron, Torus, Prism, Link,
            }
            scene.shapes = [];
            const shapes = {};

            const stack = [];
            scene.graph = [];
            scene.nodes = [];

            const getParent = (node) => {
                let parent = node.parent;
                while (parent && !parent.sceneNode && parent.parent) {
                    parent = parent.parent;
                }
                return parent?.sceneNode;
            }

            function getEvents(node, sceneNode) {
                const eventPattern = /^@(?<trigger>[^,]+)\s*,\s*(?<transition>[^=]+)/
                const triggerPattern = /^(?<time>[^\/]+)\/(?<duration>[^\/]+)/
                return Object.entries(node).map(([item, value]) => {
                    const event = item.match(eventPattern);
                    if (event) {
                        const transition = nodeTransitions[event.groups.transition];
                        const triggerWithDuration = event.groups.trigger.match(triggerPattern);
                        let startTime;
                        let endTime;
                        if (triggerWithDuration) {
                            endTime = numberOrString(triggerWithDuration.groups.time);
                            const duration = numberOrString(triggerWithDuration.groups.duration);
                            startTime = endTime - duration;
                        } else {
                            endTime = numberOrString(event.groups.trigger)
                            startTime = endTime - 1;
                        }
                        if (transition) {
                            return {
                                node: sceneNode,
                                startTime,
                                endTime,
                                transition: new transition(node, value),
                            };
                        }
                    }
                }).filter((i) => i);
            }

            const add = (node) => {
                let index = 0;
                let positionalName = null;
                if (node[symbols.values][index] && (typeof node[symbols.values][index] === 'string' || node[symbols.values][index] instanceof String)) {
                    //positionalName = node[symbols.values][index].slice(0, 1).toUpperCase() + node[symbols.values][index].slice(1).toLowerCase();
                    if (positionalName in types) {
                        ++index;
                    }
                }
                let position;
                position = node.position;

                const shapeName = positionalName || (node?.shape ? node.shape.toLowerCase() : 'Box');
                const typeName = shapeName.slice(0, 1).toUpperCase() + shapeName.slice(1).toLowerCase();
                report(typeName);

                let shape;
                if (typeName && types[typeName]) {
                    const hash = types[typeName].hash(node);
                    shapes[hash] = shapes[hash] || types[typeName].make(scene.gl, scene.data, node, index, namedNodes);
                    shape = shapes[hash];
                    scene.shapes.push(shape);
                }

                if (node.name === "Camera" && !node.type) {
                    if (node.lookAt && node.lookAt.length === 3) {
                        camera.target = node.lookAt;
                    }
                    if (node.position && node.position.length === 3) {
                        camera.position = node.position;
                    }
                    if (node.up && node.up.length === 3) {
                        camera.up = node.up;
                    }
                } else if (node.name === 'Background') {
                    if (node.colour) {
                        background.colour = node.colour;
                    }
                } else if (position && position.length === 3) {
                    position = position.map((v) => isNaN(v) ? 0 : v);
                    const shader = scene.shaders[node.shader] || scene.shaders.shader4;
                    const transform = [];
                    if (node.rotation && node.rotation.length === 4) {
                        node.rotation = node.rotation.map((v) => isNaN(v) ? 0 : v);
                        const angle = Math.PI * node.rotation[0] / 180;
                        const axis = normalise([...node.rotation.slice(1)]);
                        const q = new Quaternion(
                            Math.cos(angle / 2),
                            Math.sin(angle / 2) * axis[0],
                            Math.sin(angle / 2) * axis[1],
                            Math.sin(angle / 2) * axis[2]);
                        q.setMatrix(transform);
                        transform[12] = position[0];
                        transform[13] = position[1];
                        transform[14] = position[2];
                    } else {
                        transform.push(
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            ...position, 1);
                    }
                    const parent = getParent(node);
                    let colour = node.colour;
                    let ancestor = parent;
                    while (ancestor && !colour) {
                        colour = ancestor.colour;
                        ancestor = ancestor.parent;
                    }

                    if (Array.isArray(colour)) {
                        colour = [1, 0.9, 0.5, 1].map((v, i) => colour[i] != undefined ? colour[i] : v);
                    } else {
                        colour = [1, 0.9, 0.5, 1];
                    }
                    if (Array.isArray(node.specularColour) && node.specularColour.length === 3) {

                    }

                    node.sceneNode = addNode(node, node.name, parent, transform, shape, shader, colour, node.specular || 4, node.specularColour);
                    namedNodes[node.name] = node.sceneNode;
                    if (!parent) {
                        scene.graph.push(node.sceneNode);
                    }
                    node.sceneNode.sourceNode = node;
                    scene.nodes.unshift(node.sceneNode);
                    const events = getEvents(node, node.sceneNode);
                    scene.events.push(...events);
                    stack.unshift(node);
                }

                if (node[symbols.content].length) {
                    node[symbols.content].forEach((part) => add(part));
                }

                if (node.position) {
                    stack.shift();
                }
            };

            structure.forEach((part) => add(part));
            scene.events.sort((a, b) => (a.startTime) - (b.startTime));

            updateBuffers(scene);
            glErrors(scene.gl, context = 'Update Buffers');
        }

        /**
         *
         */
        function associateArray(node, arr, action) {
            let index = 0;
            const update = (index) => {
                return (event, value) => arr[index] = event.target.valueAsNumber;
            }

            for (const input of node.querySelectorAll('input')) {
                input.value = arr[index];
                input.addEventListener('input', update(index));
                index += 1;
            }
        }

        /**
         *
         */
        const scene = {
            shapes: [],
            points: [],
            lines: [],
            graph: [],
            nodes: [],
            overlays: [],
            events: [],
            activeEvents: [],
            light: [{ position: [0, 0, 0] }],
        }

        // Vertex shader program
        /**
         *
         */
        const vsSource = `
            attribute vec4 aVertexPosition;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;

            varying vec4 vPosition;

            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vPosition = gl_Position;
            }`;

        /**
         * Vertex shader
         */
        const vsSource2 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
            }`;

        /**
         * Vertex shader
         */
        const vsSource3 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;
            varying highp vec2 vTextureCoord;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
                vTextureCoord = aTextureCoord;
            }`;

        /**
         *
         */
        const fsSource = `
            precision mediump float;
            varying vec4 vPosition;

            uniform vec4 uColour;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 colour = vPosition * 0.15 + 0.5;
                gl_FragColor = uColour;
            }`;

        /**
         *
         */
        const fsSource2 = `
            precision mediump float;
            varying vec4 vPosition;

            uniform vec4 uColour;

            void main() {
                vec4 colour = vPosition * 0.5 + 0.5;
                gl_FragColor = colour * uColour;
            }`;


        /**
         *
         */
        const fsSource3 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient
                vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, uDiffuseColour.a);
            }`;

        /**
         *
         */
        const fsSource4 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                float edge = clamp(1.0 - vNormal.z, 0.0, 1.0);
                vec3 ambient = edge * vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;
                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, uDiffuseColour.a);

            }`;

        /**
         *
         */
        const fsSource5 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            float rand(float co) {
                return fract(sin(co*(91.3458)) * 47453.5453);
            }

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            float rand(vec3 co){
                return rand(co.xy+rand(co.z));
            }

            void main() {
                // ambient
                vec3 ambient = vec3(0.25) * uAmbientColour.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, 1.0);
            }`;

        /**
         *
         */
        const fsSource6 = `
            precision mediump float;
            varying vec3 vPosition;
            varying highp vec2 vTextureCoord;

            uniform vec4 uDiffuseColour;
            uniform sampler2D uSampler;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 colour = vec4(vPosition * 0.15 + 0.5, 1);
                gl_FragColor = uDiffuseColour   ;
                gl_FragColor = texture2D(uSampler, vTextureCoord);
            }`;



        //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        /**
         *
         */
        function initialiseShaders(gl, vsSource, fsSource) {
            //document.body.style.background = 'purple';

            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            //document.body.style.background = 'green';

            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            //document.body.style.background = 'cyan';

            const shaderProgram = gl.createProgram();
            //document.body.style.background = 'blue';

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        /**
         * creates a shader of the given type, uploads the source and
         * compiles it.
         */
        function loadShader(gl, type, source) {
            //document.body.style.background = 'red';

            const shader = gl.createShader(type);
            //document.body.style.background = 'green';
            report('1844');
            report(shader);

            // Send the source to the shader object
            gl.shaderSource(shader, source);
            report('hello');

            //document.body.style.background = 'yellow';

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        /**
         *
         */
        function updateBuffers(scene) {
            const gl = scene.gl;
            const buffers = scene.buffers;
            const data = scene.data;

            // Select the vertex buffer as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);

            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertex), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data.indices), gl.STATIC_DRAW);
        }

        /**
         * Create the indexes for a strip of quads formed from pairs of triangles.
         */
        function addClosedTriangleStrip(gl, indexBuffer, nQuads, start1, start2, step1 = 2, step2) {
            const offset = indexBuffer.length * 2;
            step2 = step2 || step1;
            start2 = start2 !== undefined ? start2 : start1 + 1;
            for (let i = 0; i < nQuads; ++i) {
                indexBuffer.push(start1 + i * step1);
                indexBuffer.push(start2 + i * step2);
            }
            indexBuffer.push(start1);
            indexBuffer.push(start2);
            const count = 2 + nQuads * 2
            return { mode: gl.TRIANGLE_STRIP, count, offset };
        }

        /**
         *
         */
        function addTriangles(gl, vertex, indexBuffer, points) {
            const offset = indexBuffer.length * 2;
            let index = vertex.length / 8;
            const nTriangles = Math.floor(points.length / 3);
            for (let i = 0; i < nTriangles; ++i) {
                const p0 = points[i * 3].slice(0, 3);
                const p1 = points[i * 3 + 1].slice(0, 3);
                const p2 = points[i * 3 + 2].slice(0, 3);
                const v1 = subtract(p0, p1);//[p0[0] - p1[0], p0[1] - p1[1], p0[2] - p1[2]];
                const v2 = subtract(p1, p2);//[p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];
                const n = normalise((v1, v2));
                vertex.push(...p0.slice(0, 3), ...n, ...points[i * 3].slice(3));
                indexBuffer.push(index++);
                vertex.push(...p1.slice(0, 3), ...n, ...points[i * 3 + 1].slice(3));
                indexBuffer.push(index++);
                vertex.push(...p2.slice(0, 3), ...n, ...points[i * 3 + 2].slice(3));
                indexBuffer.push(index++);
            }

            return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
        }

        /**
         *
         */
        function addClosedTriangleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;

            if (true) {
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(centre);
                    indexBuffer.push(first + i * step);
                    indexBuffer.push(first + ((i + 1) % nTriangles) * step);
                }
                return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
            } else {
                indexBuffer.push(centre);
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(first + i * step);
                }
                indexBuffer.push(first);
                const count = 2 + nTriangles
                return { mode: gl.TRIANGLE_FAN, count, offset };
            }
        }

        /**
         *
         */
        function addOpenTraingleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;
            indexBuffer.push(centre);
            for (let i = 0; i <= nTriangles; ++i) {
                indexBuffer.push(first + i * step);
            }
            const count = 2 + nTriangles
            return { mode: gl.TRIANGLE_FAN, count, offset };
        }

        /**
         *
         */
        function addLineLoop(gl, indexBuffer, nSegments, first, step = 1) {
            const offset = indexBuffer.length * 2;
            for (let i = 0; i < nSegments; ++i) {
                indexBuffer.push(first + i * step);
            }
            indexBuffer.push(first);
            const count = 1 + nSegments
            return { mode: gl.LINE_STRIP, count, offset };
        }


        /**
         * Initialize a texture and load an image.
         * When the image finished loading copy it into the texture.
         */
        function loadTexture(gl, url) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Because images have to be downloaded over the internet
            // they might take a moment until they are ready.
            // Until then put a single pixel in the texture so we can
            // use it immediately. When the image has finished downloading
            // we'll update the texture with the contents of the image.
            const level = 0;
            const internalFormat = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
            gl.texImage2D(
                gl.TEXTURE_2D,
                level,
                internalFormat,
                width,
                height,
                border,
                srcFormat,
                srcType,
                pixel,
            );

            const image = new Image();
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    level,
                    internalFormat,
                    srcFormat,
                    srcType,
                    image,
                );

                // WebGL1 has different requirements for power of 2 images
                // vs. non power of 2 images so check if the image is a
                // power of 2 in both dimensions.
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    // Yes, it's a power of 2. Generate mips.
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    // No, it's not a power of 2. Turn off mips and set
                    // wrapping to clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
            };
            image.src = url;

            return texture;
        }

        function isPowerOf2(value) {
            return (value & (value - 1)) === 0;
        }

        const textures = [];

        /**
         * Add a texture to teh library
         */
        function getTexture(url, scene) {
            const current = textures.find((texture) => texture.url === url);
            if (!current) {
                textures.push({ url, texture: loadTexture(scene.gl, url) });
            }
            return current;
        }

        /**
         * 
         */
        function bindTextures(gl) {
            textures.forEach((texture, index) => {
                // Tell WebGL we want to affect texture unit 0
                gl.activeTexture(gl.TEXTURE0 + index);

                // Bind the texture to texture unit 0
                gl.bindTexture(gl.TEXTURE_2D, texture.texture);

                // Tell the shader we bound the texture to texture unit 0
                //gl.uniform1i(programInfo.uniformLocations.uSampler, index);
            });
        }


        class shape {
            constructor(data) { }
            updateBuffers(gl) { }
            draw3d(gl) {
                this.elements.forEach((shape) => {
                    if (this.colour) {
                        gl.uniform4fv(node.shader.colour, shape.colour);
                    }
                    gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                });
            }
        }

        /**
         *
         */
        class Box extends shape {
            static make(gl, data, node, index) {
                const size = node.size || [1, 1, 1];
                const width = node.width || size[0] || 1;
                const height = node.height || size[1] || size[0] || 1;
                const depth = node.depth || size[2] || size[0] || 1;
                const mapping = node.mapping;
                return new Box(gl, data, width, height, depth, mapping);
            }
            static hash(node) {
                return `box ${node.width} ${node.height} ${node.depth}`;
            }
            constructor(gl, data, width = 1, height = 1, depth = 1, mapping) {
                super();
                this.width = width;
                this.height = height;
                this.depth = depth;
                const w = width / 2;
                const h = height / 2;
                const d = depth / 2;
                const start = data.vertex.length / 8;

                const addFace = (p1, p2, p3, p4, normal, mapping) => {
                    if (mapping !== undefined) {
                        const u1 = (mapping % 4) / 4;
                        const v1 = Math.floor(mapping / 4) / 3;
                        const u2 = ((mapping % 4) + 1) / 4;
                        const v2 = (Math.floor(mapping / 4) + 1) / 3;
                        data.vertex.push(...p1, ...normal, u1, v1);
                        data.vertex.push(...p2, ...normal, u1, v2);
                        data.vertex.push(...p3, ...normal, u2, v1);
                        data.vertex.push(...p4, ...normal, u2, v2);
                    } else {
                        data.vertex.push(...p1, ...normal, 0, 0);
                        data.vertex.push(...p2, ...normal, 0, 1);
                        data.vertex.push(...p3, ...normal, 1, 0);
                        data.vertex.push(...p4, ...normal, 1, 1);
                    }
                };
                const points = [
                    [-w, -h, -d],
                    [-w, h, -d],

                    [w, -h, -d],
                    [w, h, -d],

                    [w, -h, d],
                    [w, h, d],

                    [-w, -h, d],
                    [-w, h, d],
                ];
                mapping = mapping || Array(6);
                addFace(points[0], points[1], points[2], points[3], [0, 0, 1], mapping[0]);
                addFace(points[2], points[3], points[4], points[5], [1, 0, 0], mapping[1]);
                addFace(points[4], points[5], points[6], points[7], [0, 0, -1], mapping[2]);
                addFace(points[6], points[7], points[0], points[1], [-1, 0, 0], mapping[3]);
                addFace(points[0], points[2], points[4], points[6], [0, -1, 0], mapping[4]);
                addFace(points[1], points[3], points[5], points[7], [0, 1, 0], mapping[5]);

                const indexStart = data.indices.length;
                data.indices.push(...[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                    16, 17, 18, 18, 19, 16, 20, 21, 22, 22, 23, 20,
                    16, 17, 18, 19, 16, 20, 21, 22, 23, 20,
                    16, 20, 17, 21, 18, 22, 19, 23,
                ].map((i) => i + start));

                this.elements = [
                    { mode: gl.TRIANGLE_STRIP, count: 16, offset: indexStart * 2 },
                    { mode: gl.TRIANGLES, count: 12, offset: (16 + indexStart) * 2 },
                    { mode: gl.LINE_STRIP, count: 5, offset: (28 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 5, offset: (33 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINES, count: 8, offset: (indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const planes = [
                    { point: [this.width / 2, 0, 0], normal: [1, 0, 0] },
                    { point: [-this.width / 2, 0, 0], normal: [-1, 0, 0] },
                    { point: [0, this.height / 2, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height / 2, 0], normal: [0, -1, 0] },
                    { point: [0, 0, this.depth / 2], normal: [0, 0, 1] },
                    { point: [0, 0, -this.depth / 2], normal: [0, 0, -1] },
                ];
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const w = this.width / 2;
                const h = this.height / 2;
                const d = this.depth / 2;
                const points = [
                    [-w, -h, -d,],
                    [w, -h, -d,],
                    [w, -h, d,],
                    [-w, -h, d,],

                    [-w, h, -d,],
                    [w, h, -d,],
                    [w, h, d,],
                    [-w, h, d,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.lineTo(points[4][0], points[4][1]);

                context.moveTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.moveTo(points[2][0], points[2][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.moveTo(points[4][0], points[4][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.stroke();
            }
        }

        /**
         *
         */
        class Diamond extends shape {
            static make(gl, data, node, index) {
                return new Diamond(scene.gl, data, node.size);
            }
            static hash(node) {
                return `diamond ${node.size}`;
            }
            constructor(gl, data, size = 1) {
                super();
                this.size = size;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;
                const points = [
                    [0, 1, 0, 0.125, 0],
                    [1, 0, 0, 0, 0.5],
                    [0, 0, 1, 0.25, 0.5],

                    [0, 1, 0, 0.375, 0],
                    [0, 0, 1, 0.25, 0.5],
                    [-1, 0, 0, 0.5, 0.5],

                    [0, 1, 0, 0.625, 0],
                    [-1, 0, 0, 0.5, 0.5],
                    [0, 0, -1, 0.75, 0.5],

                    [0, 1, 0, 0.875, 0],
                    [0, 0, -1, 0.75, 0.5],
                    [1, 0, 0, 1, 0.5],


                    [0, -1, 0, 0.125, 1],
                    [1, 0, 0, 0, 0.5],
                    [0, 0, 1, 0.25, 0.5],

                    [0, -1, 0, 0.375, 1],
                    [0, 0, 1, 0.25, 0.5],
                    [-1, 0, 0, 0.5, 0.5],

                    [0, -1, 0, 0.625, 1],
                    [-1, 0, 0, 0.5, 0.5],
                    [0, 0, -1, 0.75, 0.5],

                    [0, -1, 0, 0.875, 1],
                    [0, 0, -1, 0.75, 0.5],
                    [1, 0, 0, 1, 0.5],
                ].map((point) => point.map((v, i) => i < 3 ? v * size : v));

                data.indices.push(...[
                    0, 1, 2, 0, 7, 8, 0,
                    12, 13, 14, 12, 17, 18, 12
                ].map((i) => i + start));

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINE_STRIP, count: 7, offset: (24 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 7, offset: (31 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ];

                const planes = [
                    planeFromPoints(points[0], points[2], points[1]),
                    planeFromPoints(points[0], points[3], points[2]),
                    planeFromPoints(points[0], points[4], points[3]),
                    planeFromPoints(points[0], points[1], points[4]),

                    planeFromPoints(points[5], points[1], points[2]),
                    planeFromPoints(points[5], points[2], points[3]),
                    planeFromPoints(points[5], points[3], points[4]),
                    planeFromPoints(points[5], points[4], points[1]),
                ];

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[0][0], points[0][1]);

                context.moveTo(points[5][0], points[5][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);

                context.stroke();
            }
        }

        /**
         *
         */
        class Ball extends shape {
            static make(gl, data, node, index) {
                const values = node.parameters || [];
                const size = node.size || values[index++] || 2;
                const width = node.width || size[0] || values[index++] || 2;
                const depth = node.depth || size[1] || values[index++] || 2;
                const height = node.height || size[2] || values[index++] || 2;
                const sides = node.sides || values[index++] || 12;
                const strips = node.strips || values[index++] || 12;
                const mode = node.mode || values[index++] || 'solid';

                return new Ball(scene.gl, data, width, depth, height, sides, strips);
            }
            static hash(node) {
                return `ball ${node.size} ${node.height} ${node.depth} ${node.sides} ${node.strips}`;
            }
            constructor(gl, data, width = 2, depth = 0, height = 0, sides = 12, strips = 12) {
                super();
                depth = depth || width
                height = height || width

                this.width = width / 2;
                this.depth = depth / 2;
                this.height = height / 2;
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                // Create the mesh for the ball
                data.vertex.push(0, height / 2, 0);
                data.vertex.push(0, 1, 0);
                data.vertex.push(0.5, 0);
                data.vertex.push(0, -height / 2, 0);
                data.vertex.push(0, -1, 0);
                data.vertex.push(0.5, 1);
                for (let j = 0; j < strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / strips);
                    for (let i = 0; i < sides; ++i) {
                        const radians = (i * 2) * Math.PI / sides;
                        data.vertex.push(
                            this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians));
                        data.vertex.push(
                            radius * Math.sin(radians), ny, radius * Math.cos(radians));
                        data.vertex.push(i / (sides - 1), j / (strips - 1));
                    }
                }

                const elements = [
                    addClosedTriangleFan(gl, data.indices, sides, start, start + 2),
                    addClosedTriangleFan(gl, data.indices, sides, start + 1, start + 2 + (strips - 2) * sides),
                ];

                for (let j = 0; j < strips - 2; ++j) {
                    elements.push(addClosedTriangleStrip(gl, data.indices, sides, start + 2 + j * sides, start + 2 + (j + 1) * sides, 1, 1));
                }

                this.elements = elements;
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Torus extends shape {
            static make(gl, data, node, index) {
                const values = node.parameters || [];
                const size = node.size || values[index++] || 2;
                const thickness = node.thickness || values[index++] || 1;
                const sides = node.sides || values[index++] || 12;
                const strips = node.strips || values[index++] || 12;
                const start = node.start || values[index++] || 0;
                const mode = node.mode || values[index++] || 'solid';

                return new Torus(scene.gl, data, size, thickness, sides, strips, start, mode);
            }
            static hash(node) {
                return `torus ${node.size} ${node.thickness} ${node.sides} ${node.strips}`;
            }
            constructor(gl, data, mainRadius = 2, minorRadius = 1, sides = 12, strips = 12, startAngle = 0, mode = 'solid') {
                super();
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 8;
                startAngle = startAngle * Math.PI / 180;

                // Create the mesh for the torus
                for (let j = 0; j < sides; ++j) {
                    const dx = Math.cos(2 * j * Math.PI / sides);
                    const dz = Math.sin(2 * j * Math.PI / sides);

                    for (let i = 0; i < strips; ++i) {
                        const angle = startAngle + 2 * i * Math.PI / strips;
                        const x = dx * (mainRadius + minorRadius * Math.sin(angle));
                        const y = minorRadius * Math.cos(angle);
                        const z = dz * (mainRadius + minorRadius * Math.sin(angle));
                        data.vertex.push(x, y, z);
                        data.vertex.push(dx * Math.sin(angle), y, dz * Math.sin(angle));
                        data.vertex.push(j / (sides - 1), i / (strips - 1));
                    }
                }

                this.elements = [];
                if (mode !== 'wireframe') {
                    for (let j = 0; j < sides; ++j) {
                        const start1 = start + j * strips;
                        const start2 = start + ((j + 1) % sides) * strips;
                        this.elements.push(addClosedTriangleStrip(gl, data.indices, strips, start1, start2, 1, 1));
                    }
                }

                if (mode === 'lined' || mode === 'wireframe') {
                    for (let i = 0; i < sides; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, strips, start + i * strips, 1));
                    }
                    for (let i = 0; i < strips; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, sides, start + i, strips));
                    }
                }
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Frustrum extends shape {
            static make(gl, data, node, index) {
                return new Frustrum(scene.gl, data, node.radius, 0, node.height, node.sides);
            }
            static hash(node) {
                return `frustrum ${node.baseRadius} ${node.topRadius} ${node.height} ${node.sides}`;
            }
            constructor(gl, data, baseRadius = 1, topRadius = 0.5, height = 2, sides = 12) {
                super();
                height /= 2;
                this.height = height;
                this.baseRadius = baseRadius;
                this.topRadius = topRadius;
                this.sides = sides;

                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                const angle = Math.atan((baseRadius - topRadius) / 2 * height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                for (let i = 0; i < sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / sides;
                    const topRadians = (1 + i * 2) * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(baseRadians), -height, baseRadius * Math.cos(baseRadians),
                        nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),
                        i / (sides - 1), 0.25,
                        topRadius * Math.sin(topRadians), height, topRadius * Math.cos(topRadians),
                        nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),
                        i / (sides - 1), 0.75);
                }

                data.vertex.push(0, -height, 0);
                data.vertex.push(0, -1, 0);
                data.vertex.push(0.5, 0);

                for (let i = 0; i < sides; ++i) {
                    const angle = i * 2 * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(angle), -height, baseRadius * Math.cos(angle),
                        0, -1, 0,
                        i / (sides - 1), 0.25);
                }

                const elements = [
                    addClosedTriangleStrip(gl, data.indices, sides, start),
                    addClosedTriangleFan(gl, data.indices, sides, start + 2 * sides, 1 + start + 2 * sides),
                ];

                if (topRadius > 0) {
                    data.vertex.push(0, height, 0);
                    data.vertex.push(0, 1, 0);
                    data.vertex.push(0.5, 1);

                    for (let i = 0; i < sides; ++i) {
                        const angle = (1 + i * 2) * Math.PI / sides;
                        data.vertex.push(
                            topRadius * Math.sin(angle), height, topRadius * Math.cos(angle),
                            0, 1, 0,
                            i / (sides - 1), 0.75);
                    }
                    elements.push(addClosedTriangleFan(gl, data.indices, sides, 1 + start + 3 * sides, 2 + start + 3 * sides));
                }

                elements.push(
                    Object.assign(addLineLoop(gl, data.indices, sides, 1 + start + 2 * sides), { colour: [1, 1, 1, 1] }));

                if (topRadius > 0) {
                    elements.push(
                        Object.assign(addLineLoop(gl, data.indices, sides, 2 + start + 3 * sides), { colour: [1, 1, 1, 1] }));
                }

                if (sides < 7) {
                    elements.push({ mode: gl.LINE_STRIP, count: sides * 2, offset: indexStart * 2, colour: [1, 1, 1, 1] });
                }
                this.elements = elements;
            }
            intersects(line) {
                const angle = Math.atan((this.baseRadius - this.topRadius) / 2 * this.height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                const planes = [
                    { point: [0, this.height, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height, 0], normal: [0, -1, 0] },
                ];

                for (let i = 0; i < this.sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / this.sides;
                    const topRadians = (1 + i * 2) * Math.PI / this.sides;

                    planes.push({
                        point: [this.baseRadius * Math.sin(baseRadians), -this.height, this.baseRadius * Math.cos(baseRadians),],
                        normal: [nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),],
                    }, {
                        point: [this.topRadius * Math.sin(topRadians), this.height, this.topRadius * Math.cos(topRadians),],
                        normal: [nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),],
                    });
                }

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Cylinder extends (Frustrum) {
            static make(gl, data, node) {
                var index = 0;
                const values = node[symbols.values] || [];
                const radius = node.radius || values[index++];
                const height = node.height || values[index++];
                const sides = node.sides || values[index++];
                return new Cylinder(scene.gl, data, node.radius, node.height, node.sides);
            }
            static hash(node) {
                return `cylinder ${node.radius} ${node.height} ${node.sides}`;
            }
            constructor(gl, data, radius = 1, height = 2, sides = 12) {
                super(gl, data, radius, radius, height, sides);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Cone extends (Frustrum) {
            static make(gl, data, node) {
                return new Cone(scene.gl, data, node.radius, node.height, node.sides);
            }
            static hash(node) {
                return `cone ${node.radius} ${node.height} ${node.sides}`;
            }
            constructor(gl, data, radius = 1, height = 2, sides = 12) {
                super(gl, data, radius, 0, height, sides);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Tetrahedron extends shape {
            static make(gl, data, node, index) {
                return new Tetrahedron(scene.gl, data, node.size);
            }
            static hash(node) {
                return `tetrahedron ${node.size}`;
            }
            constructor(gl, data, size = 1) {
                super();
                const start = data.vertex.length / 8;
                this.size = 1;
                const indexStart = data.indices.length;
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0, 0.25, 0],
                    [0, -0.5, l, 0, 0.5],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],

                    [0, 1, 0, 0.5, 0],
                    [0, -0.5, l, 2 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 1 / 3, 0.5],

                    [0, 1, 0, 0.25, 0],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 2 / 3, 0.5],

                    [0, -0.5, l, 0, 0.5],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 1 / 6, 1],
                ].map((point) => point.map((v, i) => i < 3 ? v * size : v));

                const indices = [0, 1, 1, 2, 2, 0, 3, 0, 3, 1, 3, 2].map((i) => i + start);
                data.indices.push(...indices);

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINES, count: 12, offset: (12 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const l = Math.cos(30 * Math.PI / 180);
                const sides = [
                    [[0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l]],
                    [[0, 1, 0],
                    [-l * l, -0.5, -0.5 * l],
                    [0, -0.5, l],],
                    [[0, 1, 0],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l]],
                    [[l * l, -0.5, -0.5 * l],
                    [0, -0.5, l,],
                    [-l * l, -0.5, -0.5 * l]],
                ].map((point) => point.map((v) => scaled(v, this.size)));

                const planes = sides.map((side) => planeFromPoints(...side));
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((p) => transformed(scaled(p, this.size), transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[1][0], points[1][1]);

                context.moveTo(points[3][0], points[3][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.stroke();
            }
        }

        /**
          *
          */
        class Prism extends shape {
            static make(gl, data, node, index) {
                const points = [];
                if (Array.isArray(node.points)) {
                    for (let i = 0; i < node.points.length; i += 2) {
                        points.push([node.points[i], node.points[i + 1] || 0]);
                    }
                    return new Prism(gl, data, points, node.height, node.smooth);
                }
                return new Prism(gl, data, undefined, node.height, node.smooth);
            }
            static hash(node) {
                const points = Array.isArray(node.points) ? node.points : [];
                return `Prism ${points.join(',')} ${node.height} ${node.smooth}`;
            }
            constructor(gl, data, points = [[0, 0], [0, 1], [0, -1]], height = 1, smooth) {
                super();
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;
                this.height = height;
                this.points = points.flatMap((point) =>
                    [[point[0], -height / 2, point[1]], [point[0], height / 2, point[1]]]);

                const addFace = (p1, p2, p3, p4, mapping) => {
                    const v1 = subtract(p2, p1);
                    const v2 = subtract(p3, p1);
                    const normal = normalise(cross(v1, v2));
                    if (mapping !== undefined) {
                        const u1 = (mapping % 4) / 4;
                        const v1 = Math.floor(mapping / 4) / 3;
                        const u2 = ((mapping % 4) + 1) / 4;
                        const v2 = (Math.floor(mapping / 4) + 1) / 3;
                        data.vertex.push(...p1, ...normal, u1, v1);
                        data.vertex.push(...p2, ...normal, u1, v2);
                        data.vertex.push(...p3, ...normal, u2, v1);
                        data.vertex.push(...p4, ...normal, u2, v2);
                    } else {
                        data.vertex.push(...p1, ...normal, 0, 0);
                        data.vertex.push(...p2, ...normal, 0, 1);
                        data.vertex.push(...p3, ...normal, 1, 0);
                        data.vertex.push(...p4, ...normal, 1, 1);
                    }
                };

                for (let i = 0; i < points.length; ++i) {
                    const j = (i + 1) % points.length;
                    addFace(this.points[i * 2], this.points[i * 2 + 1], this.points[j * 2], this.points[j * 2 + 1])
                    data.indices.push(start + i * 4, start + 1 + i * 4, start + 2 + i * 4, start + 3 + i * 4);
                }

                this.elements = [
                    { mode: gl.TRIANGLE_STRIP, count: points.length * 4, offset: indexStart * 2 },
                ];

                const offset = data.indices.length * 2;
                const baseIndex = data.vertex.length / 8;
                data.vertex.push(...points.flatMap((point) => [point[0], -height / 2, point[1], 0, -1, 0, 0, 0]));
                const topIndex = data.vertex.length / 8;
                data.vertex.push(...points.flatMap((point) => [point[0], height / 2, point[1], 0, 1, 0, 0, 0]));

                const d = [];
                for (let j = 0; j < points.length; ++j) {
                    const i = (j + points.length - 1) % points.length;
                    const k = (j + 1) % points.length;

                    const v1 = [points[j][0] - points[i][0], points[j][1] - points[i][1]];
                    const v2 = [points[k][0] - points[j][0], points[k][1] - points[j][1]];

                    d.push(v1[0] * v2[1] - v1[1] * v2[0]);
                }
                const sign = d.reduce((sum, d) => sum + d, 0);
                let count = 0;
                if (d.some((d) => (d * sign) < 0)) {
                    points.forEach((point, index) => {
                        if ((d[index] * sign) < 0) {
                            let next = (index + 1) % points.length;
                            while (next !== index && ((d[next] * sign) > 0)) {
                                const third = (next + 1) % points.length;
                                data.indices.push(baseIndex + index, baseIndex + next, baseIndex + third);
                                data.indices.push(topIndex + index, topIndex + next, topIndex + third);
                                count += 6;
                                next = third;
                            }
                        }
                    });
                } else if (points.length > 2) {
                    for (let i = 1; i < points.length; ++i) {
                        const next = (i + 1) % points.length;
                        data.indices.push(baseIndex, baseIndex + i, baseIndex + next);
                        data.indices.push(topIndex, topIndex + i, topIndex + next);
                    }
                    count = (points.length - 2) * 6;
                }
                if (count > 0) {
                    this.elements.push({ mode: gl.TRIANGLES, count, offset });
                }
            }
            get3dPoints() {
                return [
                    ...points.map((point) => [point[0], -this.height / 2, point[1]]),
                    ...points.map((point) => [point[0], this.height / 2, point[1]]),
                ];
            }
            getSides() {
                const points = this.getPoints();
                const nPoints = this.points.length;
                const faces = this.points.map((point, i) => [
                    points[i], points[(i + 1) % nPoints],
                    points[nPoints + (i + 1) % nPoints], points[i + nPoints],
                ]);
            }
            intersects(line) {
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((p) => transformed(scaled(p, this.size), transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[1][0], points[1][1]);

                context.moveTo(points[3][0], points[3][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.stroke();
            }
        }


        /**
         * Find the first node that matches the name or undefined if no match found
         */
        function findNode(name) {
            return namedNodes[name];
        }



        /**
         * Connection between two nodes
         */
        class Link {
            static make(gl, buffers, node, index, namedNodes) {
                const from = node.from;
                const to = node.to;
                const values = node.points;
                // Ensure points list is valid
                if (Array.isArray(values)) {
                    values.length = 3 * Math.floor(values.length / 3);
                    const points = [];
                    for (let i = 0; i < values.length; i += 3) {
                        points.push([
                            isNaN(values[i]) ? 0 : values[i],
                            isNaN(values[i + 1]) ? 0 : values[i + 1],
                            isNaN(values[i + 2]) ? 0 : values[i + 2],
                        ]);
                    }
                    return new Link(gl, buffers, from, to, points);
                } else {
                    return new Link(gl, buffers, from, to);
                }
            }
            static hash(node) {
                return `link ${++links}`;
            }
            constructor(gl, data, from, to, points = []) {
                this.from = from;
                this.to = to;
                this.points = [[0, 0, 0], ...points, [0, 0, 0]];

                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;
                this.pointIndex = data.vertex.length;
                this.pointIndex2 = data.vertex.length + 8 + points.length * 8;

                data.vertex.push(...this.points.flatMap((point) => [...point, 0, 0, -1, 0, 0]));
                const indices = Array(this.points.length).fill(1).map((e, i) => i + start);

                data.indices.push(...indices);

                this.elements = [
                    { mode: gl.LINE_STRIP, count: this.points.length, offset: 2 * indexStart, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
            }
            updateBuffers(scene, node) {
                this.fromNode = this.fromNode || findNode(this.from) || node.parent;
                this.toNode = this.toNode || findNode(this.to) || node.parent;
                let inverse = identityMatrix();
                if (node.parent) {
                    inverse = invert(node.parent.world);
                }

                if (this.fromNode?.world && this.toNode?.world) {
                    // Update points based on object positions

                    const from = this.fromNode === node.parent ? [0, 0, 0] : transformed(transformed([0, 0, 0], this.fromNode.world), inverse);
                    const to = this.toNode === node.parent ? [0, 0, 0] : transformed(transformed([0, 0, 0], this.toNode.world), inverse);
                    scene.data.vertex[this.pointIndex] = from[0];
                    scene.data.vertex[this.pointIndex + 1] = from[1];
                    scene.data.vertex[this.pointIndex + 2] = from[2];

                    scene.data.vertex[this.pointIndex2] = to[0];
                    scene.data.vertex[this.pointIndex2 + 1] = to[1];
                    scene.data.vertex[this.pointIndex2 + 2] = to[2];
                }
            }
            draw3d(gl) {
                if (this.fromNode && this.toNode) {
                    this.elements.forEach((shape) => {
                        if (this.colour) {
                            gl.uniform4fv(node.shader.colour, shape.colour);
                        }
                        gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                    });
                }
            }
            draw2d(context, transform) {
                if (this.fromNode && this.toNode) {
                    const points2d = this.points.map((point) => transform4(point, transform));

                    context.beginPath();
                    points2d.forEach((point) => context.lineTo(point[0], point[1]));
                    context.stroke();
                }
            }
        }

        /**
         * Function to update node data prior to rendering
         */
        function update(scene, origin, time) {
            this.world = matrixMultiply(this.transform, origin);
            if (this.shape) {
                this.shape.updateBuffers(scene, this);
            }
            this.children.forEach((child) => child.update(scene, this.world, time));
        }

        /**
         *
         */
        function addNode(source, name, parent, transform, shape, shader, colour = [1, 0, 1, 1], shininess, specularColour) {

            shininess = shininess || 1 + 5 * Math.random();

            const node = Object.assign(Object.create({ update }), {
                name, parent, transform, movement: identityMatrix(),
                shape, shader, colour, shininess, specularColour, children: [],
            });
            if (source.texture) {
                node.texture = getTexture(source.texture, scene);
            }

            if (parent) {
                parent.children.push(node);
            }
            return node;
        }

        /**
         *
         */
        function drawNode(gl, origin, node, time) {
            node.world = matrixMultiply(matrixMultiply(node.transform, node.movement), origin);
            const transform = matrixMultiply(node.world, scene.modelViewMatrix);

            gl.useProgram(node.shader.program);
            gl.uniformMatrix4fv(node.shader.modelViewMatrix, false, transform);
            const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
            gl.uniformMatrix3fv(node.shader.normalMatrix, false, normalMatrix);
            node.shader.setNodeData(gl, node);
            if (node.shape) {
                node.shape.draw3d(gl);
            }
            node.children.forEach((child) => drawNode(gl, node.world, child, time));
            node.movement = identityMatrix();
        }

        /**
         *
         */
        function positionNode(origin, node) {
            node.world = matrixMultiply(node.transform, origin);
            node.children.forEach((child) => positionNode(node.world, child));
        }

        /**
         *
         */
        function drawNode2(gl, node, shader, time) {
            if (node.shader === shader) {
                node.world = matrixMultiply(matrixMultiply(node.transform, node.movement), origin);
                const transform = matrixMultiply(node.world, scene.modelViewMatrix);
                gl.uniformMatrix4fv(node.shader.modelViewMatrix, false, transform);
                const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
                gl.uniformMatrix3fv(node.shader.normalMatrix, false, normalMatrix);
                node.shader.setNodeData(gl, node);
                if (node.shape) {
                    node.shape.draw3d(gl);
                }
            }
            node.children.forEach((child) => drawNode2(gl, child, shader));
            node.movement = identityMatrix();
        }

        /**
         *
         */
        function drawScene(gl, buffers, shapes, time) {
            const clearColour = [0, 0, 0].map((e, i) => background.colour[i] || e);
            scene.gl.clearColor(...clearColour, 1.0);

            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            glErrors(gl, 'drawScene');
            glErrors(gl, 'drawScene===');
            scene.graph.forEach((node) => drawNode(scene.gl, identityMatrix(), node, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function drawScene2(gl, buffers, shapes, time) {
            const clearColour = [0, 0, 0].map((e, i) => background.colour[i] || e);
            scene.gl.clearColor(...clearColour, 1.0);

            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            glErrors(gl, 'drawScene');

            const origin = identityMatrix();
            scene.graph.forEach((node) => positionNode(origin, node));

            gl.useProgram(scene.shaders.shader3.program);
            scene.graph.forEach((node) => drawNode2(scene.gl, node, scene.shaders.shader3, time));
            gl.useProgram(scene.shaders.shader4.program);
            scene.graph.forEach((node) => drawNode2(scene.gl, node, scene.shaders.shader4, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function glErrors(gl, context = '') {
            const err = gl.getError();
            report('hello');

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.log(context, errors[err]);
                report(errors[err]);
            }
        }

        /**
         *
         */
        function initialiseShader(scene, shader, projectionMatrix) {
            const numComponents = 3;
            const type = scene.gl.FLOAT;    // the data in the buffer is 32bit floats
            const normalize = false;  // don't normalize
            const stride = 4 * (3 + 3 + 2);         // how many bytes to get from one set of values to the next
            // 0 = use type and numComponents above
            const offset = 0;         // how many bytes inside the buffer to start from
            scene.gl.useProgram(shader.program);
            scene.gl.bindBuffer(scene.gl.ARRAY_BUFFER, scene.buffers.vertex);

            scene.gl.vertexAttribPointer(
                shader.attribLocations.vertexPosition,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            scene.gl.enableVertexAttribArray(shader.attribLocations.vertexPosition);

            if (shader.attribLocations.vertexNormal) {
                scene.gl.vertexAttribPointer(
                    shader.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    true,  // normalise normals
                    stride,
                    4 * 3);
                scene.gl.enableVertexAttribArray(shader.attribLocations.vertexNormal);
            }

            if (shader.attribLocations.vertexTexture) {
                scene.gl.vertexAttribPointer(
                    shader.attribLocations.vertexTexture,
                    2,     // numcomponents
                    type,
                    normalize,
                    stride,
                    4 * (3 + 3));
                scene.gl.enableVertexAttribArray(shader.attribLocations.vertexTexture);
            }

            shader.setSceneData(scene);
        }

        /**
         *
         */
        const times = [];
        let last = 0;

        /**
         *
         */
        const rotationControl = document.getElementById('move');


        /**
         * Update the Camera position
         */
        function updateCamera(string) {
            const input = document.getElementById('input');
            let text = input.value.replace(/^\s*Camera.*/, string);
            input.value = text;
        }


        /**
         *
         */
        class Camera {
            constructor(position = [0, 0, 1], target = [0, 0, 0], up = [0, 1, 0]) {
                this.initial = { position, target, up };
                this.reset();
            }
            reset() {
                this.position = [...this.initial.position];
                this.target = [...this.initial.target];
                this.up = [...this.initial.up];
            }
            getString() {
                const str = (vector, fixed = 3) => vector.map((element) => element.toFixed(fixed));
                return `Camera;lookAt=${str(camera.target)};position=${str(camera.position)};up=${str(camera.up)}`;
            }
            zAxis() {
                return normalise(subtract(this.target, this.position));
            }
            xAxis() {
                return xaxis = normalise(cross(this.zAxis(), this.up));
            }
            yAxis() {
                const zAxis = normalise(subtract(this.target, this.position));
                const xAxis = normalise(cross(zAxis, this.up));
                return cross(xAxis, zAxis);
            }
            axes() {
                const zAxis = normalise(subtract(this.target, this.position));
                const xAxis = normalise(cross(zAxis, this.up));
                const yAxis = cross(xAxis, zAxis);

                return { xAxis, yAxis, zAxis };
            }
            viewMatrix(eye, at, up) {
                const zaxis = normalise(subtract(this.target, this.position));
                const xaxis = normalise(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);

                negate(zaxis);

                return [
                    xaxis[0], yaxis[0], zaxis[0], 0,
                    xaxis[1], yaxis[1], zaxis[1], 0,
                    xaxis[2], yaxis[2], zaxis[2], 0,
                    -dot(xaxis, this.position), -dot(yaxis, this.position), -dot(zaxis, this.position), 1
                ];
            }
            zoom(distance) {
                const direction = subtract(this.target, this.position);
                const movement = scaled(direction, distance);
                this.position = add(this.position, movement);
                updateCamera(this.getString);
            }
            forward(distance) {
                const zaxis = normalise(subtract(this.target, this.position));
                const movement = scaled(zaxis, distance);
                this.position = add(this.position, movement);
                this.target = add(this.target, movement);
                updateCamera(this.getString);
            }
            rotateX(angle) {
                const zaxis = subtract(this.target, this.position);
                const xaxis = cross(zaxis, this.up);

                const offset = subtract(this.position, this.target);
                rotate(offset, xaxis, angle);
                rotate(this.up, xaxis, angle);

                this.position = add(this.target, offset);
                updateCamera(this.getString);
            }
            rotateY(angle) {
                const offset = subtract(this.position, this.target);
                rotate(offset, this.up, angle);

                this.position = add(this.target, offset);
                updateCamera(this.getString);
            }
            pitch(angle) {
                const zaxis = subtract(this.target, this.position);
                const xaxis = cross(zaxis, this.up);

                rotate(zaxis, xaxis, angle);
                rotate(this.up, xaxis, angle);
                this.target = add(this.position, zaxis);
                updateCamera(this.getString);
            }
            yaw(angle) {
                const zaxis = subtract(this.target, this.position);
                rotate(zaxis, this.up, angle);
                this.target = add(this.position, zaxis);
                updateCamera(this.getString);
            }
            roll(angle) {
                const zaxis = subtract(this.target, this.position);
                rotate(this.up, zaxis, angle);
                updateCamera(this.getString);
            }
            getLine(x, y, fieldOfView) {
                const aspect = scene.gl.canvas.clientWidth / scene.gl.canvas.clientHeight;
                const fov = fieldOfView * Math.PI / 180;
                const zaxis = normalise(subtract(this.target, this.position));
                const xaxis = normalise(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);
                const d = 1 / Math.tan(fov / 2);
                const direction = normalise(add(scaled(xaxis, x * aspect), scaled(yaxis, y), scaled(zaxis, d)));
                return { point: this.position, direction };
            }
        }

        /**
         *
         */
        const camera = new Camera([0, 0, 20], [0, 0, 0], [0, 1, 0]);
        const background = { colour: [0, 0, 0] };

        /**
         * Management of a 2 view using a canvas
         */
        class View2d {
            constructor(scene, canvasId) {
                this.projection = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
                this.scene = scene;
                this.canvas = document.getElementById(canvasId);
                this.context = this.canvas.getContext('2d');
                const scale = Math.min(this.canvas.width, this.canvas.height) / 20;
                this.projection[8] = scale;
                this.projection[5] = scale;
                /*
                this.projection[1] = scale;
                this.projection[9] = scale;
                */

                this.projection[12] = this.canvas.width / 2;
                this.projection[13] = this.canvas.height / 2;
            }
            render() {
                if (!this.canvas) return;

                this.context.globalCompositeOperation = 'source-over';
                this.context.shadowBlur = 0;
                this.context.fillStyle = 'rgb(0,0,0)';
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                //context.globalCompositeOperation = 'lighter';

                this.context.lineWidth = 1;
                this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                const renderNode = (node) => {
                    if (node.world && node.shape) {
                        if (node.colour) {
                            this.context.strokeStyle = `rgba(${node.colour[0] * 255}, ${node.colour[1] * 255}, ${node.colour[2] * 255}, ${node.colour[3]})`;
                        } else {
                            this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                        }
                        const transform = matrixMultiply(node.world, this.projection);
                        node.shape.draw2d(this.context, transform);
                    }
                }
                scene.nodes.forEach(node => renderNode(node));

                if (scene.ray) {
                    const start = transformed(scene.ray.point, this.projection);
                    const endPoint = add(scene.ray.point, scaled(scene.ray.direction, 500));
                    const end = transformed(endPoint, this.projection);

                    this.context.strokeStyle = 'rgb(255, 255, 255, 0.9)';
                    this.context.beginPath();
                    this.context.moveTo(start[0], start[1]);
                    this.context.lineTo(end[0], end[1]);
                    this.context.stroke();
                }
                if (scene.points) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    scene.points.forEach((point) => {
                        const centre = transformed(point, this.projection);
                        this.context.beginPath();
                        this.context.arc(centre[0], centre[1], 3, 0, Math.PI * 2);
                        this.context.stroke();
                    });
                }
                if (scene.lines) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    this.context.beginPath();
                    scene.lines.forEach((line) => {
                        const start = transformed(line.start, this.projection);
                        const end = transformed(line.end, this.projection);
                        this.context.moveTo(start[0], start[1]);
                        this.context.lineTo(end[0], end[1]);
                    });
                    this.context.stroke();
                }
            }
        }

        /**
         *
         */
        let topView;
        let sideView;
        const cameraMove = {};

        /**
         * Start moving camera
         */
        function moveCamera(target, position, up, duration = 1) {
            cameraMove.action = 'start';
            cameraMove.target = target || camera.target;
            cameraMove.position = position || camera.position;
            cameraMove.up = up || camera.up;
            cameraMove.duration = duration;
        }

        /**
         *
         */
        function processActiveEvents(time) {
            //report(`${scene.activeEvents.length} ${time.toFixed(2)}`);
            scene.activeEvents.filter((event) => event.endTime <= time).forEach((event) => event.transition.finish());
            scene.activeEvents = scene.activeEvents.filter((event) => event.endTime > time);
            scene.activeEvents.forEach((event) => {
                const d = (time - event.startTime) / (event.endTime - event.startTime);
                event.transition.progress(d);
            });
        }

        /**
         * Resize the canvas based on the node size
         */
        function updateCanvasSize(scene) {
            return;
            // Lookup the size the browser is displaying the canvas in CSS pixels.
            const width = scene.gl.canvas.clientWidth;
            const height = scene.gl.canvas.clientHeight;

            // Check if the canvas is not the same size.
            const resize = scene.gl.canvas.width !== width || scene.gl.canvas.height !== height;

            if (resize) {
                // Make the canvas the same size
                scene.gl.canvas.width = width;
                scene.gl.canvas.height = height;

                scene.gl.viewport(0, 0, width, height);
            }

            return resize;
        }

        /**
         *
         */
        function render(time = 0) {
            if (paused) {
                return;
            }

            const stateAction = {
                start: () => {
                    state.time = 0;
                    state.nextEvent = 0;
                },
                rewind: () => { },
                play: () => {
                    if (state.mode === 'playing') {
                        state.rate = 1;
                        state.mode = 'paused';
                    } else {
                        state.mode = 'playing';
                    }
                },
                forward: () => { },
                end: () => { },
            }[state.action];
            if (stateAction) {
                stateAction();
            }

            state.action = null;

            if (last) {
                const delta = time - last;
                times.push(delta);
                if (times.length > 5) {
                    times.shift();
                    const total = times.reduce((sum, delta) => sum + delta);
                    const average = 5000 / total;
                }
                if (state.mode === 'playing') {
                    state.time += delta / 1000;
                    while (scene.events[state.nextEvent] && state.time > scene.events[state.nextEvent].startTime) {
                        const event = scene.events[state.nextEvent];
                        event.transition.start();
                        scene.activeEvents.push(event);
                        ++state.nextEvent;
                    }
                }
            }
            processActiveEvents(state.time);
            last = time;
            if (cameraMove.action === 'start') {
                cameraStart = {
                    target: camera.target,
                    position: camera.position,
                    up: camera.up,
                    time: time,
                }
                cameraMove.action = 'move';
            }
            if (cameraMove.action === 'move') {
                const d = (time - cameraStart.time) / (1000 * (cameraMove.duration || 1));
                const s = d * d * (3 - 2 * d);
                camera.target = add(cameraStart.target, scale(subtract(cameraMove.target, cameraStart.target), s));
                camera.position = add(cameraStart.position, scale(subtract(cameraMove.position, cameraStart.position), s));
                camera.up = add(cameraStart.up, scale(subtract(cameraMove.up, cameraStart.up), s));
                if (d > 1) {
                    cameraMove.action = null;
                }
            }

            updateCanvasSize(scene);
            scene.modelViewMatrix = camera.viewMatrix();

            // Create a perspective matrix, a special matrix that is
            // used to simulate the distortion of perspective in a camera.
            // Our field of view is 45 degrees, with a width/height
            // ratio that matches the display size of the canvas
            const fieldOfView = 45;   // in degrees
            const aspect = scene.gl.canvas.clientWidth / scene.gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 1000.0;
            const projectionMatrix = perspective(fieldOfView, aspect, zNear, zFar);
            scene.projectionMatrix = projectionMatrix;// matrixMultiply(projectionMatrix, scene.modelViewMatrix);

            scene.graph.forEach((node) => node.update(scene, identityMatrix(), node, time));

            updateBuffers(scene);

            Object.values(scene.shaders).forEach((shader) =>
                initialiseShader(scene, shader, projectionMatrix));

            bindTextures(scene.gl);

            const split = document.getElementById('split');
            scene.gl.enable(scene.gl.BLEND)
            scene.gl.blendFunc(scene.gl.SRC_ALPHA, scene.gl.ONE_MINUS_SRC_ALPHA);
            if (split.checked) {
                drawScene2(scene.gl, scene.buffers, scene.shapes, time);
            } else {
                drawScene(scene.gl, scene.buffers, scene.shapes, time);
            }
            glErrors(scene.gl);

            //topView.render();

            if (scene.overlays) {
                scene.overlays.forEach((overlay) => overlay.updateOverlay(scene.projectionMatrix));
            }

            window.requestAnimationFrame(render);
        }

        /**
         *
         */
        function matrixMultiply(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
            ];
        }

        /**
         *
         */
        function get3x3(input) {
            return [
                input[0], input[1], input[2],
                input[4], input[5], input[6],
                input[8], input[9], input[10]];
        }

        /**
         *
         */
        function transpose3x3(input) {
            return [
                input[0], input[3], input[6],
                input[1], input[4], input[7],
                input[2], input[5], input[8]];
        }

        /**
         *
         */
        function invert3x3(input) {
            let a00 = input[0], a01 = input[1], a02 = input[2];
            let a10 = input[3], a11 = input[4], a12 = input[5];
            let a20 = input[6], a21 = input[7], a22 = input[8];

            let b01 = a22 * a11 - a12 * a21;
            let b11 = -a22 * a10 + a12 * a20;
            let b21 = a21 * a10 - a11 * a20;
            // Calculate the determinant
            let det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return null;
            }
            det = 1.0 / det;
            return [
                b01 * det,
                (-a22 * a01 + a02 * a21) * det,
                (a12 * a01 - a02 * a11) * det,
                b11 * det,
                (a22 * a00 - a02 * a20) * det,
                (-a12 * a00 + a02 * a10) * det,
                b21 * det,
                (-a21 * a00 + a01 * a20) * det,
                (a11 * a00 - a01 * a10) * det];
        }

        /**
         *
         */
        function transpose(input) {
            return [
                input[0], input[4], input[8], input[12],
                input[1], input[5], input[9], input[13],
                input[2], input[6], input[10], input[14],
                input[3], input[7], input[11], input[15]];
        }

        /**
         *
         */
        function invert(input) {
            const x0 = input[0];
            const x1 = input[1];
            const x2 = input[2];
            const x3 = input[3];
            const x4 = input[4];
            const x5 = input[5];
            const x6 = input[6];
            const x7 = input[7];
            const x8 = input[8];
            const x9 = input[9];
            const x10 = input[10];
            const x11 = input[11];
            const x12 = input[12];
            const x13 = input[13];
            const x14 = input[14];
            const x15 = input[15];

            const a0 = x0 * x5 - x1 * x4;
            const a1 = x0 * x6 - x2 * x4;
            const a2 = x0 * x7 - x3 * x4;
            const a3 = x1 * x6 - x2 * x5;
            const a4 = x1 * x7 - x3 * x5;
            const a5 = x2 * x7 - x3 * x6;
            const b0 = x8 * x13 - x9 * x12;
            const b1 = x8 * x14 - x10 * x12;
            const b2 = x8 * x15 - x11 * x12;
            const b3 = x9 * x14 - x10 * x13;
            const b4 = x9 * x15 - x11 * x13;
            const b5 = x10 * x15 - x11 * x14;
            const invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

            return [
                (+x5 * b5 - x6 * b4 + x7 * b3) * invdet,
                (-x1 * b5 + x2 * b4 - x3 * b3) * invdet,
                (+x13 * a5 - x14 * a4 + x15 * a3) * invdet,
                (-x9 * a5 + x10 * a4 - x11 * a3) * invdet,
                (-x4 * b5 + x6 * b2 - x7 * b1) * invdet,
                (+x0 * b5 - x2 * b2 + x3 * b1) * invdet,
                (-x12 * a5 + x14 * a2 - x15 * a1) * invdet,
                (+x8 * a5 - x10 * a2 + x11 * a1) * invdet,
                (+x4 * b4 - x5 * b2 + x7 * b0) * invdet,
                (-x0 * b4 + x1 * b2 - x3 * b0) * invdet,
                (+x12 * a4 - x13 * a2 + x15 * a0) * invdet,
                (-x8 * a4 + x9 * a2 - x11 * a0) * invdet,
                (-x4 * b3 + x5 * b1 - x6 * b0) * invdet,
                (+x0 * b3 - x1 * b1 + x2 * b0) * invdet,
                (-x12 * a3 + x13 * a1 - x14 * a0) * invdet,
                (+x8 * a3 - x9 * a1 + x10 * a0) * invdet];
        }

        /**
         *
         */
        function normalise(v) {
            const hypot = Math.hypot(v[0], v[1], v[2]);
            return [v[0] / hypot, v[1] / hypot, v[2] / hypot];
        }

        /**
         *
         */
        function dot(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        /**
         *
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0]];
        }

        /**
         *
         */
        function negate(v) {
            v[0] = -v[0];
            v[1] = -v[1];
            v[2] = -v[2];
        }

        /**
         *
         */
        function add(...vectors) {
            return vectors.reduce((sum, v) => [sum[0] + v[0], sum[1] + v[1], sum[2] + v[2]], [0, 0, 0]);
        }

        /**
         *
         */
        function subtract(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        /**
         *
         */
        function scale(v, s) {
            v[0] *= s;
            v[1] *= s;
            v[2] *= s;
            return v;
        }

        /**
         *
         */
        function scaled(v, s) {
            return v.map((e) => e * s);
        }

        /**
         *
         */
        function rotate(v, axis, angle) {
            angle *= Math.PI / 180;
            axis = normalise(axis);

            const s = Math.cos(angle / 2);
            const u = scaled(axis, Math.sin(angle / 2));

            const p1 = scale(cross(v, u), 2 * s);
            const p2 = scaled(v, s * s - dot(u, u));
            const p3 = scaled(u, 2 * dot(v, u));

            [v[0], v[1], v[2]] = add(p1, add(p2, p3));

            return add(p1, add(p2, p3));
        }

        /**
         *
         */
        function matrixVectorMultiply(v, matrix) {
            const x = matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12];
            const y = matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13];
            const z = matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14];
            v[0] = x;
            v[1] = y;
            v[2] = z;
            return v
        }

        /**
         * point transform (apply translation)
         */
        function transformed(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
            ];
        }

        /**
          * point transform (apply translation)
          */
        function transform4(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
                matrix[3] * v[0] + matrix[7] * v[1] + matrix[11] * v[2] + matrix[15],
            ];
        }

        /**
         * Direction transform (ignore translation)
         */
        function transformDirection(v, matrix) {
            return normalise([
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2],
            ]);
        }


        /**
         * Return the plane defined by three points
         */
        function planeFromPoints(p0, p1, p2) {
            const v0 = subtract(p0, p1);
            const v1 = subtract(p0, p2);
            const normal = normalise(cross(v0, v1));
            return { point: p0, normal };
        }

        /**
         * Return an identity matrix
         */
        function identityMatrix() {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }

        /**
         *
         */
        function lookAt(eye, at, up) {
            const zaxis = normalise(subtract(at, eye));
            const xaxis = normalise(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eye), -dot(yaxis, eye), -dot(zaxis, eye), 1
            ];
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zFar + zNear) / (zNear - zFar), -1,
                0, 0, (2 * zFar * zNear) / (zNear - zFar), 1,
            ];
        }


        /**
         * Find the closest point on a line to a given point
         */
        function closestPoint(line, point) {
            // line = lp + d * ld
            // point = p
            // From line to point = p - (lp + d * ld)
            // Closest when (p - (lp + d * ld)).ld = 0
            // dot product is distributive hence
            // (p - (lp + d * ld)).ld = p.ld - lp.ld + d * (ld. ld)
            // d = (lp - p).ld / ld.ld
            const numerator = dot(subtract(line.point - point), line.direction);
            const divisor = dot(line.direction, line.direction);
            return numerator / divisor;
        }

        /**
         * Return the distance between two points
         */
        function distance(point1, point2) {
            return math.hypot(point1[0] - point2[0], point1[1] - point2[1], point1[2] - point2[2]);
        }

        /**
         * Add touch controls to the given node
         */
        function planeIntercept(line, plane) {
            // plane (p - p0).n = 0
            // line p = l + dt
            // (l + dt - p0).n = 0
            // (lx + dxt - p0x)nx + (ly + dyt - p0y)ny + (lz + dzt - p0z)nz = 0
            // t(dx.nx + dy.ny + dz.nz) = nx(p0x-lx) + ny(p0y-ly) + nz(p0z-lz)
            // t = (nx(p0x-lx) + ny(p0y-ly) +nz(p0z-lz)) / (dx.nx + dy.ny + dz.nz)

            const divisor = dot(line.direction, plane.normal);
            if (divisor !== 0) {
                const offset = subtract(plane.point, line.point);
                return dot(offset, plane.normal) / divisor;
            }
        }

        /**
         * Get the point from a line and distance along it
         */
        function getPoint(line, distance) {
            return add(line.point, scaled(line.direction, distance));
        }

        /**
         * Determine the intecep of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalise(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start) {
                return [start, end];
            }
        }

        /**
         * Return the nodes at the screen coordinate 
         */
        function pickNodes(x, y) {
            const ray = camera.getLine(x, y, 45);
            scene.ray = ray;
            scene.points.length = 0;
            scene.lines.length = 0;
            const hits = scene.nodes.filter((node) => {
                if (node.shape) {
                    const inverse = invert(node.world);
                    const point = transformed(ray.point, inverse);
                    const direction = transformDirection(ray.direction, inverse);
                    const points = node.shape.intersects({ point, direction });

                    if (points) {
                        node.hit = points;
                        node.hitPoint = getPoint(ray, points[0]);
                        scene.points.push(getPoint(ray, points[0]), getPoint(ray, points[1]));
                        return true;
                    }
                    if (!event.shiftKey) {
                        node.hit = null;
                    }
                    node.sourceNode.nodes.forEach((node) => node.classList.remove('selected'));
                }
            });
            return hits;
        }

        /**
         * Process a 'click' event
         */
        function click(x, y) {
            const hits = pickNodes(x, y);
            if (hits.length > 0) {
                hits.sort((a, b) => a.hit[0] - b.hit[0]);
                if (!event.altKey) {
                    hits.slice(1).forEach((node) => node.hit = null);
                }
                hits.forEach((hit) => hit.sourceNode.nodes.forEach((node) => node.classList.add('selected')));

                if (event.ctrlKey) {
                    camera.target = hits[0].world.slice(12, 16);
                    if (hits[0].overlay) {
                        removeOverlay(hits[0]);
                    } else {
                        scene.overlays.push(addOverlay(hits[0]));
                    }
                }
                const target = transformed([0, 0, 0], hits[0].world);
                moveCamera(target);
            }
        }

        /**
         * Move a node in screen space
         */
        function dragTo(node, x, y) {

            // Get the movement plane
            const normal = camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const ray = camera.getLine(x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));

            const worldOffset = subtract(point, node.hitPoint);

            camera.target = subtract(camera.target, worldOffset);
            camera.position = subtract(camera.position, worldOffset);
        }

        /**
         * Move a node in screen space
         */
        function dragNodeTo(node, x, y) {

            // Get the movement plane
            const normal = camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const ray = camera.getLine(x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));


            // Get the origin transform for this node
            const transform = node.parent ? node.parent.world : identityMatrix();
            const inverse = invert(transform);

            const worldOffset = subtract(point, node.hitPoint);
            const offset = [
                inverse[0] * worldOffset[0] + inverse[4] * worldOffset[1] + inverse[8] * worldOffset[2],
                inverse[1] * worldOffset[0] + inverse[5] * worldOffset[1] + inverse[9] * worldOffset[2],
                inverse[2] * worldOffset[0] + inverse[6] * worldOffset[1] + inverse[10] * worldOffset[2],
            ];

            const translate = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...offset, 1];
            node.transform = matrixMultiply(node.transform, translate);
            node.hitPoint = point;
        }

        /**
         * Move a node in screen space
         */
        function rotateNode(node, x, y) {
            const inverse = invert(node.world);

            const zAxis = normalise(subtract(camera.target, camera.position));
            const xAxis = normalise(cross(zAxis, camera.up));
            const yAxis = normalise(cross(zAxis, xAxis));

            const rotateX = getRotationMatrix(-y, transformDirection(xAxis, inverse));
            const rotateY = getRotationMatrix(x, transformDirection(yAxis, inverse));

            node.transform = matrixMultiply(rotateX, node.transform);
            node.transform = matrixMultiply(rotateY, node.transform);
        }

        /**
         * Add a comment marker to the start of each line of the selected text
         */
        function comment(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                lines[firstLine + index] = `# ${line}`;
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start + 2;
            input.selectionEnd = end + (lastLine - firstLine) * 2;
        }

        /**
         * Remove comment from the selected text
         */
        function uncomment(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                lines[firstLine + index] = line.replace(/^(\s*)# ?/, '$1');
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start - 4;
            input.selectionEnd = Math.max(start - 4, end - (lastLine - firstLine) * 4);
        }

        /**
         * Indent the selected text
         */
        function indent(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                lines[firstLine + index] = `    ${line}`;
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start + 4;
            input.selectionEnd = end + (lastLine - firstLine) * 4;
        }

        /**
         * Remove indent from the selected text
         */
        function unindent(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                if (line.charAt(0) === '\t') {
                    lines[firstLine + index] = line.slice(1);
                } else {
                    lines[firstLine + index] = line.replace(/^ {1,4}/, '');
                }
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start - 4;
            input.selectionEnd = Math.max(start - 4, end - (lastLine - firstLine) * 4);
        }

        /**
         * Add touch controls to the given node
         */
        function addControls(node) {
            const start = {};
            let action;
            node.addEventListener('touchstart', (event) => {
                event.preventDefault();

                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;

                if (event.touches.length === 1) {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    const hits = pickNodes(x, y);
                    if (hits.length > 0) {
                        hits.sort((a, b) => a.hit[0] - b.hit[0]);
                        start.hit = hits[0];
                    } else {
                        start.hit = null;
                    }
                    action = 'click';
                } else if (event.touches.length === 2) {
                    start.second = {
                        x: event.touches[1].clientX,
                        y: event.touches[1].clientY,
                    };
                    action = 'pinch';
                }
                report(action);
            });

            node.addEventListener('touchstart', (event) => {
                event.preventDefault();

                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;

                if (event.touches.length === 1) {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    const hits = pickNodes(x, y);
                    if (hits.length > 0) {
                        hits.sort((a, b) => a.hit[0] - b.hit[0]);
                        start.hit = hits[0];
                    } else {
                        start.hit = null;
                    }
                    action = 'click';
                } else if (event.touches.length === 2) {
                    start.second = {
                        x: event.touches[1].clientX,
                        y: event.touches[1].clientY,
                    };
                    action = 'pinch';
                }
                report(action);
            });

            node.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (action === 'pinch') {
                    const initial = Math.hypot(start.x - start.second.x, start.y - start.second.y);
                    const current = Math.hypot(event.touches[0].clientX - event.touches[1].clientX, event.touches[0].clientY - event.touches[1].clientY);

                    const offset = subtract(camera.position, camera.target);
                    const scale = current / initial;
                    camera.position = add(camera.target, scaled(offset, scale));

                    start.second.x = event.touches[1].clientX;
                    start.second.y = event.touches[1].clientY;
                } else if (action) {
                    action = 'drag';
                    const deltaX = event.touches[0].clientX - start.x;
                    const deltaY = event.touches[0].clientY - start.y;

                    if (start.hit) {
                        if (rotationControl.checked) {
                            rotateNode(start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.touches[0].clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.touches[0].clientY) / box.height) + 1;

                            dragTo(start.hit, x, y);
                        }
                    } else {
                        if (event.altKey) {
                            camera.yaw(deltaX / 10);
                            camera.pitch(deltaY / 10);
                        } else {
                            camera.rotateY(deltaX);
                            camera.rotateX(deltaY);
                        }
                    }
                }

                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;
            });

            node.addEventListener('touchend', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;
                    click(x, y);
                } else if (action === 'pinch') {
                    action = null;
                }
                node.classList.toggle('focus');
            });

            node.addEventListener('mousedown', (event) => {
                event.preventDefault();
                start.x = event.clientX;
                start.y = event.clientY;

                const box = node.getBoundingClientRect();

                const x = 2 * ((start.x - box.left) / box.width) - 1;
                const y = 2 * ((box.top - start.y) / box.height) + 1;

                const hits = pickNodes(x, y);
                if (hits.length > 0) {
                    hits.sort((a, b) => a.hit[0] - b.hit[0]);
                    start.hit = hits[0];
                } else {
                    start.hit = null;
                }
                action = 'click';
            });

            node.addEventListener('mousemove', (event) => {
                event.preventDefault();
                if (action) {
                    action = 'drag';
                    const deltaX = event.clientX - start.x;
                    const deltaY = event.clientY - start.y;

                    if (start.hit) {
                        if (rotationControl.checked || event.buttons & 4) {
                            rotateNode(start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.clientY) / box.height) + 1;

                            if (event.ctrlKey) {
                                dragNodeTo(start.hit, x, y);
                            } else {
                                dragTo(start.hit, x, y);
                            }
                        }
                    } else {
                        if (event.altKey) {
                            camera.yaw(deltaX / 10);
                            camera.pitch(deltaY / 10);
                        } else {
                            camera.rotateY(deltaX);
                            camera.rotateX(deltaY);
                        }
                    }
                    start.x = event.clientX;
                    start.y = event.clientY;
                }
            });

            node.addEventListener('mouseup', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    click(x, y);
                }
                action = null;
            });

            node.addEventListener('wheel', (event) => {
                const dist = event.deltaY / 1000;
                camera.zoom(dist);
                report(dist);
            });

            const input = document.getElementById('input');
            input.addEventListener('keydown', (event) => {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    if (event.shiftKey) {
                        unindent(input);
                    } else {
                        indent(input);
                    }
                }
            });

            document.getElementById('start').addEventListener('click', (event) => state.action = 'start');
            document.getElementById('rewind').addEventListener('click', (event) => state.action = 'rewind');
            document.getElementById('play').addEventListener('click', (event) => state.action = 'play');
            document.getElementById('forward').addEventListener('click', (event) => state.action = 'forward');
            document.getElementById('end').addEventListener('click', (event) => state.action = 'end');
        }


        /**
         * Add touch controls to the given node
         */
        function addLayoutControls() {
            let action = null;
            const start = {};
            let before = null;
            let after = null;

            const horizontalDrag = (event, x, y) => {
                event.preventDefault();
                const delta = x - start.x;
                start.sizes[start.index - 1] += delta;
                start.sizes[start.index + 1] -= delta;
                start.container.style.gridTemplateColumns = start.sizes.map((size) => `${size}px`).join(' ');

                start.x = x;
            }

            const startHorizontalDrag = (vbar, x) => {
                start.x = x;
                start.container = vbar.parentElement;
                start.index = parseInt(vbar.dataset.column);
                const content = Array.from(vbar.parentElement.children);
                start.sizes = content.map((element) => element.clientWidth);
                action = horizontalDrag;
            }

            const verticalBars = document.querySelectorAll('.vertical-bar');
            for (const vbar of verticalBars) {
                vbar.addEventListener('mousedown', (event) => {
                    startHorizontalDrag(vbar, event.clientX);
                });
                vbar.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (event.touches.length === 0) {
                        startHorizontalDrag(vbar, event.touches[0].clientX);
                    }
                });
            }

            const verticalDrag = (event, x, y) => {
                event.preventDefault();
                const delta = y - start.y;
                start.sizes[start.index - 1] += delta;
                start.sizes[start.index + 1] -= delta;
                start.container.style.gridTemplateRows = start.sizes.map((size) => `${size}px`).join(' ');
                start.y = y;
            }

            const startVerticalDrag = (hbar, y) => {
                start.y = y;
                start.container = hbar.parentElement;
                start.index = parseInt(hbar.dataset.row);
                const content = Array.from(hbar.parentElement.children);
                start.sizes = content.map((element) => element.clientHeight);
                action = verticalDrag;
            }

            const horizontalBars = document.querySelectorAll('.horizontal-bar');

            for (const hbar of horizontalBars) {
                hbar.addEventListener('mousedown', (event) => {
                    startVerticalDrag(hbar, event.clientY);
                });
                hbar.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (event.touches.length === 0) {
                        startVerticalDrag(hbar, event.touches[0].clientY);
                    }
                });
            }
            document.body.addEventListener('mousemove', (event) => {
                if (action) {
                    action(event, event.clientX, event.clientY);
                }
            });

            document.body.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (action && event.touches.length === 1) {
                    action(event, event.touches[0].clientX, event.touches[0].clientY);
                }
            });

            document.body.addEventListener('mouseenter', (event) => {
                action = null
            });

            document.body.addEventListener('mouseup', (event) => {
                action = null;
            });

            document.body.addEventListener('touchend', (event) => {
                //event.preventDefault();
                action = null;
            });
        }




        /**
         * Add an overlay for the specified node
         */
        function addOverlay(node) {
            const box = document.getElementById('scene').getBoundingClientRect();
            const container = document.createElement('div');
            container.classList.add('overlay', 'fixed');

            const updateOverlay = (projectionMatrix) => {
                const modelViewMatrix = matrixMultiply(node.world, scene.modelViewMatrix);

                const transform = matrixMultiply(modelViewMatrix, scene.projectionMatrix);
                const position = transform4([0, 0, 0], transform);
                const x = box.left + (position[0] / position[3] + 1) * box.width / 2;
                const y = box.bottom - (position[1] / position[3] + 1) * box.height / 2;

                container.style.left = `${x}px`;
                container.style.top = `${y}px`;
                container.innerHTML = `<span>${node.name}</span><br>Position: <span>${node.transform.slice(12, 15).map((p) => p.toFixed(2)).join(', ')}</span>`;
            }
            updateOverlay(scene.projectionMatrix);

            document.body.appendChild(container);
            node.overlay = { container, updateOverlay };
            return node.overlay;
        }

        /**
         * Add an overlay for the specified node
         */
        function removeOverlay(node) {
            if (node.overlay) {
                node.overlay.container.remove();
                const pos = scene.overlays.indexOf(node.overlay);
                if (pos > -1) {
                    scene.overlays.splice(pos, 1);
                }
                node.overlay = null;
            }
        }

        /**
         * Display element
         */
        function showEntry(name, value) {
            if (Array.isArray(value)) {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (array[${value.length}])`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                container.addEventListener('toggle', (event) => {
                    if (container.open) {
                        content.innerHTML = '';
                        value.forEach((element, i) =>
                            content.append(showEntry(`${i}`, element)));
                    }
                });
                /*
                for (let i = 0; i < value.length; ++i) {
                    if (stack.includes(value[i])) {
                        content.append(showEntry(name, '...'));
                    } else {
                        stack.push(value[i]);
                        content.append(showEntry(`${i}`, value[i], stack));
                        stack.pop();
                    }
                }
                */
                return container;
            } else if (value === undefined) {
                return `${name}: undefined`;
            } else if (value === null) {
                return `${name}: null`;
            } else if (value && typeof (value) === 'object') {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (object)`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                container.addEventListener('toggle', (event) => {
                    if (container.open) {
                        content.innerHTML = '';
                        Object.entries(value).forEach(([key, value]) =>
                            content.append(showEntry(`${key}`, value)));
                    }
                });
                /*
                Object.entries(value).forEach(([key, element]) => {
                    if (stack.includes(element)) {
                        content.append(showEntry(key, '...'));
                    } else {
                        stack.push(element);
                        content.append(showEntry(key, element, stack));
                        stack.pop();
                    }
                });
                */
                return container;
            }
            const container = document.createElement('div');
            container.innerText = `${name}: ${value}`;
            container.classList.add('entry');
            return container;
        }

        /**
         * Display the details for a deployed node.
         */
        function showDeployedNodeDetails(node) {
            scene.nodes.forEach((node) => node.hit = null);
            for (const node of document.querySelectorAll('.selected')) {
                node.classList.remove('selected');
            }
            if (node.sceneNode) {
                node.sceneNode.hit = true;
            }
            node.nodes.forEach((node) => node.classList.add('selected'));
            const detailNode = document.querySelector('.detail');
            detailNode.innerHTML = '';
            Object.entries(node).map(([key, value]) =>
                detailNode.append(showEntry(key, value, [value])));

            // Show the source node.
            input = document.getElementById('input');
            const lines = input.value.split(/\r?\n/);
            const position = input.scrollHeight * (node[symbols.source].lineNumber - 1) / lines.length;
            input.focus();
            input.scrollTo(0, position);
            const start = lines.slice(0, node[symbols.source].lineNumber - 1).reduce((total, line) => total + line.length + 1, 0);
            input.selectionStart = start;
            input.selectionEnd = start + lines[node[symbols.source].lineNumber - 1].length;
        }

        /**
         *
         */
        let paused = false;
        let state = { time: 0, rate: 1, mode: 'paused', nextEvent: 0 };

        /**
         * Update the line numbers for a textarea element
         */
        function updateLineNumbers(main, lineNumbers) {
            const count = main.value.split(/\n/g).length;
            lineNumbers.value = '';
            const numbers = Array(count).fill(0).map((e, i) => i + 1);
            lineNumbers.value = numbers.join('\r\n');
            lineNumbers.cols = 1 + (count + '').length;
        }

        const actions = {};


        /**
         * Add drag control to an element
         */
        function addElementDrag(node) {
            const start = {};

            const moveNode = (eventX, eventY) => {
                const dx = eventX - start.mouseX;
                const dy = eventY - start.mouseY;
                const x = start.elementX + dx;
                const y = start.elementY + dy;
                node.style.position = 'absolute';
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.style.right = 'auto';
            }
            const mouseMove = (event) => {
                moveNode(event.clientX, event.clientY);
            }
            const touchMove = (event) => {
                moveNode(event.touches[0].clientX, event.touches[0].clientY);
            }

            node.addEventListener('mousedown', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.clientX;
                start.mouseY = event.clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.mouseMove = mouseMove;
                actions.mouseUp = (event) => actions.mouseMove = null;
            });


            node.addEventListener('touchstart', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.touches[0].clientX;
                start.mouseY = event.touches[0].clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.touchMove = touchMove;
                actions.touchEnd = (event) => actions.touchMove = null;
            });
        }

        /**
         * Update the layout based on the selection
         */
        function updateLayout(event) {
            const selectedLayout = parseInt(event.target.value);
            const layout = document.querySelector('.layout');

            const sourceView = document.getElementById('edit');
            const treeView = document.querySelector('.expanded-tree');
            const topView = document.getElementById('top-view-container');
            const dynamicView = document.getElementById('scene-container');
            const detailView = document.querySelector('.detail');

            const reset = (node) => {
                node.style.zIndex = null;
                node.style.gridColumn = null;
                node.style.gridRow = null;
                node.style.display = null;
                shaderView.hide();
            }

            const resetAll = () => {
                layout.style.gridTemplateColumns = null;
                layout.style.gridTemplateRows = null;
                reset(sourceView);
                reset(treeView);
                reset(topView);
                reset(dynamicView);
                reset(detailView);
            }

            const gridLayout = () => {
                resetAll();
            }

            const setView = (view) => {
                resetAll();
                if (view === shaderView) {
                    sourceView.style.display = 'none';
                    treeView.style.display = 'none';
                    topView.style.display = 'none';
                    dynamicView.style.display = 'none';
                    detailView.style.display = 'none';
                    layout.style.gridTemplateRows = 'min-content 1fr 1fr';
                    view.show();
                } else if (view) {
                    sourceView.style.display = 'none';
                    treeView.style.display = 'none';
                    topView.style.display = 'none';
                    dynamicView.style.display = 'none';
                    detailView.style.display = 'none';
                    layout.style.gridTemplateColumns = '1fr';
                    layout.style.gridTemplateRows = 'min-content 1fr';
                    view.style.gridColumn = '1 / -1';
                    view.style.gridRow = '2 / -1';
                    view.zIndex = 5;
                    view.style.display = null;
                }
            }

            const views = [null, sourceView, treeView, dynamicView, topView, detailView, shaderView];
            setView(views[selectedLayout]);
        }

        /**
         * Create a shader view
         */
        function createShaderView() {
            let shader;
            const layout = document.querySelector('.layout');

            const template = document.getElementById('shader-controls-template');
            const controls = template.content.firstElementChild.cloneNode(true);
            layout.appendChild(controls);
            controls.style.gridColumn = '1 / -1';
            controls.style.gridRow = '2';

            const vertexEditor = new Editor(layout);
            const fragmentEditor = new Editor(layout);

            const nameSelection = controls.querySelector('.shader-name');
            nameSelection.addEventListener('change', (event) => {
                const name = nameSelection.value;
                if (scene.shaders[name]) {
                    shader = scene.shaders[name];
                    update(scene.shaders[name]);
                }
            });
            nameSelection.value = 'shader4';

            const buildButton = controls.querySelector('.build-shader');
            const externalNames = document.getElementById('external-names');

            const attributes = [];
            const uniforms = [];

            vertexEditor.main.addEventListener('input', (event) => shader.vertex = vertexEditor.value);
            fragmentEditor.main.addEventListener('input', (event) => shader.fragment = fragmentEditor.value);

            const getNames = (shader) => {
                const attrTable = externalNames.querySelector('.attributes');
                const attributePattern = /^\s*attribute\s+(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;

                const uniformTable = externalNames.querySelector('.uniforms');
                const uniformPattern = /^\s*uniform\s+(highp\s+)?(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;
                const lines = shader.definition.vertex.split('\n');
                lines.push(...shader.definition.fragment.split('\n'));

                setters = {
                    mat4: (location, value) => scene.gl.uniformMatrix4fv(location, false, value),
                    mat3: (location, value) => scene.gl.uniformMatrix3fv(location, false, value),
                    vec3: (location, value) => scene.gl.uniform3fv(location, value),
                    vec4: (location, value) => scene.gl.uniform4fv(location, value),
                    float: (location, value) => scene.gl.uniform1f(location, value),
                    sampler2D: (location, value) => scene.gl.uniform1i(location, value),
                };

                lines.forEach((line) => {
                    const attrMatch = line.match(attributePattern);
                    const uniformMatch = line.match(uniformPattern);

                    if (attrMatch) {
                        const definition = shader.definition.attributes.find((def) => def.attribute === attrMatch.groups.name);
                        const attribute = {
                            attribute: attrMatch.groups.name,
                            name: definition ? definition.name : '',
                            type: attrMatch.groups.type,
                        };
                        const name = document.createElement('span');
                        attrTable.appendChild(name);
                        name.innerHTML = attrMatch.groups.name;
                        name.classList.add('cell');
                        const input = document.createElement('input');
                        attrTable.appendChild(input);
                        input.classList.add('cell');
                        input.value = attribute.name;
                        input.addEventListener('change', (event) => attribute.name = input.value);
                        const type = document.createElement('span');
                        attrTable.appendChild(type);
                        type.innerHTML = attrMatch.groups.type;
                        type.classList.add('cell');
                        attributes.push(attribute);
                    }
                    if (uniformMatch) {
                        const definition = shader.definition.uniforms.find((def) => def.uniform === uniformMatch.groups.name);
                        const uniform = {
                            uniform: uniformMatch.groups.name,
                            name: definition ? definition.name : '',
                            type: uniformMatch.groups.type,
                            set: setters[uniformMatch.groups.type],
                        };

                        const name = document.createElement('span');
                        uniformTable.appendChild(name);
                        name.innerHTML = uniformMatch.groups.name;
                        name.classList.add('cell');
                        const input = document.createElement('input');
                        uniformTable.appendChild(input);
                        input.classList.add('cell');
                        input.value = uniform.name;
                        input.addEventListener('change', (event) => uniform.name = input.value);
                        const type = document.createElement('span');
                        uniformTable.appendChild(type);
                        type.innerHTML = uniformMatch.groups.type;
                        type.classList.add('cell');
                        const defaultValue = document.createElement('input');
                        uniformTable.appendChild(defaultValue)
                        defaultValue.classList.add('cell');
                        uniforms.push(uniform);
                    }
                });
            }

            const update = (shader) => {
                attributes.length = 0;
                uniforms.length = 0;
                vertexEditor.value = shader.vertex || shader.definition.vertex;
                fragmentEditor.value = shader.fragment || shader.definition.fragment;
                for (let cell of externalNames.querySelectorAll('.cell')) {
                    cell.remove();
                }

                getNames(shader);
            }

            const show = () => {
                const shaderList = document.getElementById('shader-list');
                shaderList.innerHTML = '';
                Object.keys(scene.shaders).forEach((shaderName) => {
                    const node = document.createElement('option');
                    shaderList.appendChild(node);
                    node.innerHTML = shaderName;
                });
                layout.style.gridTemplateRows = 'min-content min-content 1fr 1fr';
                shader = shader || scene.shaders.shader4;
                update(shader);
                vertexEditor.container.style.display = 'flex';
                fragmentEditor.container.style.display = 'flex';
                vertexEditor.container.style.gridColumn = 1;
                vertexEditor.container.style.gridRow = 3;
                fragmentEditor.container.style.gridColumn = 2;
                fragmentEditor.container.style.gridrow = 3;
                buildButton.style.display = 'inline-block';
                externalNames.classList.remove('hidden');
            };

            const hide = () => {
                vertexEditor.container.style.display = 'none';
                fragmentEditor.container.style.display = 'none';
                buildButton.style.display = 'none';
                externalNames.classList.add('hidden');
            };

            const build = () => {
                const definition = {
                    name: nameSelection.value,
                    vertex: vertexEditor.value,
                    fragment: fragmentEditor.value,
                    attributes, uniforms,
                };
                scene.shaders[definition.name] = makeShader(definition);
                const shaders = Object.values(scene.shaders);
                localStorage.setItem('shaders', JSON.stringify(shaders, null, 2));

                const input = document.getElementById('input');
                const structure = getStructure(input.value);
                const expanded = expand(structure, defaultParser);
                getGraph(expanded, scene);
            }

            buildButton.addEventListener('click', (event) => build());

            hide();

            return { show, hide, vertexEditor, fragmentEditor };
        }

        //const shaderView = createShaderView();

        /**
         * Build a shader from a definition.
         */
        function makeShader(definition) {
            const removeIndent = (text) => {
                const lines = text.split(/\n/);
                const indent = Math.min(...lines.filter((line) => line.length).map((line) => line.length - line.trimStart().length));
                return lines.map((line) => line.slice(indent)).join('\n');
            };

            definition.vertex = removeIndent(definition.vertex);
            definition.fragment = removeIndent(definition.fragment);

            const shader = {
                attribLocations: {},
                definition,
                toJSON() {
                    return this.definition
                },
            };
            //document.body.style.background = 'orange';

            shader.program = initialiseShaders(scene.gl, definition.vertex, definition.fragment);
            //document.body.style.background = 'blue';
            if (shader.program) {
                definition.attributes.forEach((attribute) =>
                    shader.attribLocations[attribute.name] = scene.gl.getAttribLocation(shader.program, attribute.attribute));
                definition.uniforms.forEach((uniform) =>
                    shader[uniform.name] = scene.gl.getUniformLocation(shader.program, uniform.uniform));
            }

            const setters = {
                mat4: (location, value) => scene.gl.uniformMatrix4fv(location, false, value),
                mat3: (location, value) => scene.gl.uniformMatrix3fv(location, false, value),
                vec3: (location, value) => scene.gl.uniform3fv(location, value),
                vec4: (location, value) => scene.gl.uniform4fv(location, value),
                float: (location, value) => scene.gl.uniform1f(location, value),
                sampler2D: (location, value) => scene.gl.uniform1i(location, value),
            };

            // Extract the declaration of uniforms from the source
            const uniformPattern = /^\s*uniform\s+(highp\s+)?(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;
            const full = (definition.vertex + definition.fragment).split(';');
            const uniforms = full.map((line) => line.match(uniformPattern))
                .flatMap((match) => match ? match.groups : [])
                .reduce((obj, uniform) => { obj[uniform.name] = uniform.type; return obj }, {});

            // Generate 'setters' for each uniform
            definition.uniforms.forEach((uniform) => uniform.set = uniform.set || setters[uniforms[uniform.uniform]]);
            definition.uniforms = definition.uniforms.filter((uniform) => uniform.set);

            Object.keys(uniforms).forEach((name) => {
                if (!definition.uniforms.find((match) => match.uniform === name)) {
                    console.log(`Warning ${name} not mapped for ${definition.name} shader`);
                }

            });

            shader.setSceneData = (scene) => {
                definition.uniforms.forEach((uniform) => {
                    if (scene[uniform.name]) {
                        uniform.set(shader[uniform.name], scene[uniform.name]);
                    }
                });
            }
            shader.setNodeData = (gl, node) => {
                definition.uniforms.forEach((uniform) => {
                    if (node[uniform.name]) {
                        uniform.set(shader[uniform.name], node[uniform.name]);
                    }
                });
                if (node.hit) {
                    gl.uniform4fv(shader.colour, [1, 0, 0, 1]);
                }
            }
            shader.setElementData = (element) => {
                definition.uniforms.forEach((uniform) => {
                    if (element[uniform.name]) {
                        uniform.set(shader[uniform.name], element[uniform.name]);
                    }
                });
            }

            return shader;
        }

        /**
         * Toggle fullscreen mode
         */
        function toggleFullscreen() {
            if (document.body.webkitRequestFullscreen) {
                if (document.body.webkitIsFullScreed) {
                    document.body.webkitCancelFullScreen();
                } else {
                    document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                }
            }
            if (document.body.requestFullscreen) {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.body.requestFullscreen();
                }
            }
        }

        /**
         * Save the content of the editor
         */
        function save() {
            const text = document.getElementById('input').value;
            const name = document.getElementById('filename').value;
            
            download(text, name);
            /*
            if (!config.files.includes(name)) {
                config.files.push(name);
            }
            localStorage.setItem(name, input.value);
            config.current = name;
            localStorage.setItem('scene-config', JSON.stringify(config));
            */
        }

        /**
         * Load a selected file
         */
        async function load() {
            const input = document.getElementById('input');
            const name = 'test-scene.txt.download';//document.getElementById('filename').value;
            
            const response = await fetch(`${name}`);
            const content = await response.text();
            input.value = content;
            if (content) {
                const expandedTreeNode = document.querySelector('.expanded-tree');
                const sceneNodeActions = {
                    click: (event, node) => showDeployedNodeDetails(node),
                };

                const structure = getStructure(content);
                const expanded = expand(structure, defaultParser);
                expandedTreeNode.innerHTML = '';
                getGraph(expanded, scene);
                expandedTreeNode.appendChild(getView(expanded, sceneNodeActions));
                const lines = document.querySelector('.line-numbers');
                updateLineNumbers(input, lines);
/*
                if (!config.files.includes(name)) {
                    config.files.push(name);
                }
                */
                config.current = name;
                localStorage.setItem('scene-config', JSON.stringify(config));
                document.getElementById('filename').classList.add('existing-file');
            }
                /*
            let file;
            try {
                file = localStorage.getItem(name);
            } catch (e) {

            }
            if (file) {
                const expandedTreeNode = document.querySelector('.expanded-tree');
                const sceneNodeActions = {
                    click: (event, node) => showDeployedNodeDetails(node),
                };

                input.value = file;
                const structure = getStructure(input.value);
                const expanded = expand(structure, defaultParser);
                expandedTreeNode.innerHTML = '';
                getGraph(expanded, scene);
                expandedTreeNode.appendChild(getView(expanded, sceneNodeActions));
                const lines = document.querySelector('.line-numbers');
                updateLineNumbers(input, lines);

                if (!config.files.includes(name)) {
                    config.files.push(name);
                }
                config.current = name;
                localStorage.setItem('scene-config', JSON.stringify(config));
                document.getElementById('filename').classList.add('existing-file');
            }
            */
        }

        let config = {
            files: [],
            current: 'New Scene',
        };

        /**
         *
         */
        function main() {
            addLayoutControls();
            const canvas = document.getElementById('scene');
                const view2 = document.getElementById('top-view');

                const tree = new TreeView({
                    getContent: (node) => node[symbols.content],
                    getTitle: (node) => Object.entries(node.item).map(([key, value]) => `${key}: ${value}`).join('\n'),
                });
                document.querySelector('.detail').append(tree.node);

                document.body.addEventListener('mousemove', (event) => {
                    if (actions.mouseMove) {
                        actions.mouseMove(event);
                    }
                });
                document.body.addEventListener('mouseup', (event) => {
                    if (actions.mouseUp) {
                        actions.mouseUp(event);
                    }
                });

                document.body.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    if (actions.touchMove) {
                        actions.touchMove(event);
                    }
                });
                document.body.addEventListener('touchend', (event) => {
                    if (actions.touchEnd) {
                        actions.touchEnd(event);
                    }
                });
                addElementDrag(document.getElementById('overlay'));

                addControls(canvas);

                const layoutSelection = document.getElementById('layout-selection');
                layoutSelection.addEventListener('change', updateLayout);

                const saveButton = document.getElementById('save');
                saveButton.addEventListener('click', save);
                /*
                            const load = document.getElementById('load');
                            load.addEventListener('click', load);
                */
                const filename = document.getElementById('filename');
                filename.addEventListener('input', (event) => {
                    save.disabled = !filename.value;
                    if (config.files.includes(filename.value)) {
                        filename.classList.add('existing-file');
                    } else {
                        filename.classList.remove('existing-file');
                    }
                });
                filename.addEventListener('change', load);
                const fullscreen = document.getElementById('fullscreen');
                fullscreen.addEventListener('click', toggleFullscreen);

                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                scene.gl = canvas.getContext('webgl');
                /*
                            view2.width = view2.clientWidth;
                            view2.height = view2.clientHeight;
                
                            topView = new View2d(scene, 'top-view');
                            topView.width = view2.clientWidth;
                            topView.Height = view2.clientHeight;
                */
                let savedShaders;
                try {
                    savedShaders = localStorage.getItem('shaders');
                } catch (e) { }

                const shaders = savedShaders ? JSON.parse(savedShaders) : [
                    {
                        name: 'shader1',
                        vertex: vsSource, fragment: fsSource,
                        attributes: [
                            { name: 'vertexPosition', attribute: 'aVertexPosition' },
                        ],
                        uniforms: [
                            { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'colour', uniform: 'uColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                        ],
                    },
                    {
                        name: 'shader2',
                        vertex: vsSource, fragment: fsSource2,
                        attributes: [
                            { name: 'vertexPosition', attribute: 'aVertexPosition' },
                        ],
                        uniforms: [
                            { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'colour', uniform: 'uColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                        ],
                    },
                    {
                        name: 'shader3',
                        vertex: vsSource2, fragment: fsSource3,
                        attributes: [
                            { name: 'vertexPosition', attribute: 'aPosition' },
                            { name: 'vertexNormal', attribute: 'aNormal' },
                        ],
                        uniforms: [
                            { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'normalMatrix', uniform: 'uNormalMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix3fv(location, false, value) },

                            { name: 'lightPosition', uniform: 'uLightPosition', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                            { name: 'ambient', uniform: 'uAmbientColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                            { name: 'colour', uniform: 'uDiffuseColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                            { name: 'specularColour', uniform: 'uSpecularColour', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                            { name: 'shininess', uniform: 'uShininess', }, //, set: (location, value) => scene.gl.uniform1f(location, value) },
                        ],
                    },
                    {
                        name: 'shader4',
                        vertex: vsSource2, fragment: fsSource4,
                        attributes: [
                            { name: 'vertexPosition', attribute: 'aPosition' },
                            { name: 'vertexNormal', attribute: 'aNormal' },
                        ],
                        uniforms: [
                            { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                            { name: 'normalMatrix', uniform: 'uNormalMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix3fv(location, false, value) },

                            { name: 'lightPosition', uniform: 'uLightPosition', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                            { name: 'ambient', uniform: 'uAmbientColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                            { name: 'colour', uniform: 'uDiffuseColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                            { name: 'specularColour', uniform: 'uSpecularColour', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                            { name: 'shininess', uniform: 'uShininess', }, //, set: (location, value) => scene.gl.uniform1f(location, value) },
                        ],
                    },
                    {
                        name: 'textured',
                        vertex: vsSource3, fragment: fsSource6,
                        attributes: [
                            { name: 'vertexPosition', attribute: 'aPosition' },
                            { name: 'vertexNormal', attribute: 'aNormal' },
                            { name: 'vertexTexture', attribute: 'aTextureCoord' },
                        ],
                        uniforms: [
                            { name: 'projectionMatrix', uniform: 'uProjectionMatrix', type: 'mat4' },
                            { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', type: 'mat4' },
                            { name: 'normalMatrix', uniform: 'uNormalMatrix', type: 'mat3' },

                            { name: 'lightPosition', uniform: 'uLightPosition', type: 'vec3' },
                            { name: 'colour', uniform: 'uDiffuseColour', type: 'vec4' },
                            { name: 'specularColour', uniform: 'uSpecularColour', type: 'vec3' },
                            { name: 'shininess', uniform: 'uShininess', type: 'float' },
                            { name: 'texture', uniform: 'uSampler', type: 'sampler2D' },
                        ],
                    },
                ];

                //document.body.style.background = 'pink';
                scene.shaders = shaders.reduce((shaders, definition) => {
                    shaders[definition.name] = makeShader(definition);
                    return shaders;
                }, {});
                //document.body.style.background = 'pink';

                // Set clear colour to black, fully opaque
                const clearColour = [0, 0, 0].map((e, i) => background.colour[i] || e);
                scene.gl.clearColor(...clearColour, 1.0);
                // Clear the colour buffer with specified clear colour
                scene.gl.clear(scene.gl.COLOR_BUFFER_BIT);

                const lightX = document.getElementById('light-x');
                const lightY = document.getElementById('light-y');
                const lightZ = document.getElementById('light-z');

                lightX.value = scene.light[0].position[0];
                lightY.value = scene.light[0].position[1];
                lightZ.value = scene.light[0].position[2];
                scene.lightPosition = scene.light[0].position;

                lightX.addEventListener('input', () => {
                    scene.light[0].position[0] = lightX.value;
                });
                lightY.addEventListener('input', () => {
                    scene.light[0].position[1] = lightY.value;
                });
                lightZ.addEventListener('input', () => {
                    scene.light[0].position[2] = lightZ.value;
                });

                const reset = document.getElementById('reset');
                reset.addEventListener('click', () => camera.reset());

                const expandedTreeNode = document.querySelector('.expanded-tree');

                const input = document.getElementById('input');

                const sceneNodeActions = {
                    click: (event, node) => showDeployedNodeDetails(node),
                };

                input.addEventListener('input', (event) => {
                    try {
                        //localStorage.setItem('structure', input.value);
                        const structure = getStructure(input.value);
                        const expanded = expand(structure, defaultParser);


                        tree.setContent(expanded);


                        expandedTreeNode.innerHTML = '';
                        getGraph(expanded, scene);
                        expandedTreeNode.appendChild(getView(expanded, sceneNodeActions));
                        const lines = document.querySelector('.line-numbers');
                        updateLineNumbers(input, lines);
                    } catch (e) {
                        const err = Object.entries(e).map(([key, value]) => `${key}: ${value}`);
                        err.forEach((err) =>
                            console.log(err));
                    }
                });

                const structure = getStructure(input.value);
                const expanded = expand(structure, defaultParser);

                document.getElementById('comment').addEventListener('click',
                    (event) => {
                        comment(input);
                        input.focus();
                    });
                document.getElementById('uncomment').addEventListener('click',
                    (event) => {
                        uncomment(input);
                        input.focus();
                    });
                document.getElementById('indent').addEventListener('click',
                    (event) => {
                        indent(input);
                        input.focus();
                    });
                document.getElementById('unindent').addEventListener('click',
                    (event) => {
                        unindent(input);
                        input.focus();
                    });

                scene.buffers = {
                    vertex: scene.gl.createBuffer(),
                    indices: scene.gl.createBuffer(),
                }

                let configStr;
                try {
                    configStr = localStorage.getItem('scene-config');
                } catch (e) {

                }

                if (configStr) {
                    config = JSON.parse(configStr);
                    config.files.forEach((name) => {
                        const option = document.createElement('option');
                        option.innerText = name;
                        document.getElementById('files').append(option);
                    });
                }
                document.getElementById('filename').value = config.current;

                load();

                /*
                const content = localStorage.getItem(config.current);
                if (content) {
                    input.value = content;
                    const structure = getStructure(content);
                    const expanded = expand(structure, defaultParser);
                    expandedTreeNode.innerHTML = '';
                    getGraph(expanded, scene);
                    expandedTreeNode.appendChild(getView(expanded, sceneNodeActions));
                    //treeNode.innerHTML = '';
                }
                */
                updateLineNumbers(input, document.querySelector('.line-numbers'));
                input.addEventListener('scroll', (event) =>
                    document.querySelector('.line-numbers').scrollTop = input.scrollTop);

                render();
        }

        /**
         * Return a matrix representing a rotation
         */
        function getRotationMatrix(angle, axis) {
            angle *= Math.PI / 180;
            axis = normalise(axis);

            const a = Math.cos(angle / 2);
            const b = Math.sin(angle / 2) * axis[0];
            const c = Math.sin(angle / 2) * axis[1];
            const d = Math.sin(angle / 2) * axis[2];

            return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
            2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
            2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                0, 0, 0, a * a + b * b + c * c + d * d];
        }

        /**
         * Quaternion constructor
         *
         * @param {*} w
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Quaternion {
            constructor(w, x, y, z) {
                this.w = w === undefined ? 1 : w;
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
            }
            clone() {
                return new Quaternion(this.w, this.x, this.y, this.z);
            }
            static create(w, x, y, z) {
                var v;
                if (w instanceof Vector3d && x == undefined) {
                    return new Quaternion(0, w.x, w.y, w.z);
                } else if (w instanceof Vector3d) {
                    return Quaternion.createRotation(w, x);
                } else if (w && Array.isArray(w) && w.length === 4) {
                    return new Quaternion(w[0], w[1], w[2], w[3])
                } else if (w && w.w !== undefined) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else if (x instanceof Vector3d) {
                    return Quaternion.createRotation(x, w);
                } else if (w instanceof Quaternion) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else {
                    return new Quaternion(w === undefined ? 1 : w, x || 0, y || 0, z || 0);
                }
            }
            static createFromObject(obj) {
                return new Quaternion(obj.w, obj.x, obj.y, obj.z);
            }
            static createRotation(axis, angle) {
                const v = axis.normal();
                return new Quaternion(
                    Math.cos(angle / 2),
                    Math.sin(angle / 2) * v.x,
                    Math.sin(angle / 2) * v.y,
                    Math.sin(angle / 2) * v.z);
            }
            get length() {
                return Math.hypot(this.w, this.x, this.y, this.z);
            }

            get values() {
                return [this.w, this.x, this.y, this.z];

            }
            get inverse() {
                return this.conjugate();
            }
            get s() {
                return this.w;
            }
            get v() {
                return new Vector3d(this.x, this.y, this.z);
            }
            invert() {
                this.x *= -1;
                this.y *= -1;
                this.z *= -1;
                return this;
            }
            conjugate() {
                return new Quaternion(this.w, -this.x, -this.y, -this.z);
            }
            apply(v) {
                var vp = this.multiply(new Quaternion(0, v.x, v.y, v.z)).multiply(this.conjugate());
                return new Vector3d(vp.x, vp.y, vp.z);
            }
            rotate(other, angle) {
                if (angle !== undefined) {
                    other = Quaternion.createRotation(other, angle);
                }
                const s = this.s * other.s - this.v.dot(other.v);
                const v = other.v.scaled(this.s).add(this.v.scaled(other.s)).add(this.v.crossProduct(other.v));
                this.w = s;
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return;
            }
            scale(value) {
                this.w *= value;
                this.x *= value;
                this.y *= value;
                this.z *= value;
                return this;
            }
            scaled(value) {
                const result = this.clone();
                return result.scale(value);
            }
            multiply(other) {
                return new Quaternion(
                    this.w * other.w - this.x * other.x - this.y * other.y - this.z * other.z,// 1
                    this.w * other.x + this.x * other.w + this.y * other.z - this.z * other.y,// i
                    this.w * other.y - this.x * other.z + this.y * other.w + this.z * other.x,// j
                    this.w * other.z + this.x * other.y - this.y * other.x + this.z * other.w // k
                );
            }
            dot(other) {
                return this.w * other.w + this.x * other.x + this.y * other.y + this.z * other.z;
            }
            getMatrix() {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
                2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
                2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                    0, 0, 0, a * a + b * b + c * c + d * d];
            }
            setMatrix(matrix) {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                matrix[0] = a * a + b * b - c * c - d * d;
                matrix[1] = 2 * (b * c - a * d);
                matrix[2] = 2 * (b * d + a * c);
                matrix[3] = 0;
                matrix[4] = 2 * (b * c + a * d);
                matrix[5] = a * a - b * b + c * c - d * d;
                matrix[6] = 2 * (c * d - a * b);
                matrix[7] = 0;
                matrix[8] = 2 * (b * d - a * c);
                matrix[9] = 2 * (c * d + a * b);
                matrix[10] = a * a - b * b - c * c + d * d;
                matrix[11] = 0;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = 0;
                matrix[15] = a * a + b * b + c * c + d * d;
            }
        }


        /**
         * Vector3d constructor
         *
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Vector3d {
            constructor(x, y, z) {
                this.x = x || 0
                this.y = y || 0
                this.z = z || 0
            }
            static create(x, y, z) {
                if (x instanceof Vector3d) {
                    return x.clone();
                } else if (x && Array.isArray(x) && x.length === 3) {
                    return new Vector3d(x[0], x[1], x[2]);
                } else if (x && x.x !== undefined) {
                    return new Vector3d(x.x, x.y, x.z);
                }
                return new Vector3d(x, y, z);
            }
            clone() {
                return new Vector3d(this.x, this.y, this.z);
            }
            static createFromObject(obj) {
                return new Vector3d(obj.x, obj.y, obj.z);
            }
            get length() {
                return Math.hypot(this.x, this.y, this.z);
            }
            get array() {
                return [this.x, this.y, this.z, 0];
            }
            get array3() {
                return [this.x, this.y, this.z];
            }
            dotProduct(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            crossProduct(other) {
                return new Vector3d(this.y * other.z - this.z * other.y,
                    this.z * other.x - this.x * other.z,
                    this.x * other.y - this.y * other.x);
            }
            cross(other) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                this.x = y * other.z - z * other.y;
                this.y = z * other.x - x * other.z;
                this.z = x * other.y - y * other.x;
                return this;
            }
            normalise() {
                var n = this.length || 1;
                this.x /= n;
                this.y /= n;
                this.z /= n;
                return this;
            }
            normal() {
                var result = this.clone();
                return result.normalise()
            }
            scale(value) {
                this.x *= value
                this.y *= value
                this.z *= value
                return this
            }
            scaled(value) {
                var result = this.clone();
                return result.scale(value);
            }
            add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                return this;
            }
            subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                return this;
            }
            plus(other) {
                var result = this.clone();
                return result.add(other);
            }
            minus(other) {
                var result = this.clone();
                return result.subtract(other);
            }
            rotate(q, angle) {
                if (angle) {
                    q = Quaternion.createRotation(q, angle);
                }

                let s = q.w;
                let u = new Vector3d(q.x, q.y, q.z);
                let v = this.clone();

                this.cross(u).scale(2 * s)
                    .add(v.scaled(s * s - u.dot(u))).add(u.scaled(2 * v.dot(u)));
                return this;
            }
            transform(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];

                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            transform2(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];
                const w = matrix[3] * this.x + matrix[7] * this.y + matrix[11] * this.z + matrix[15];

                this.x = x / w;
                this.y = y / w;
                this.z = z / w;
                return this;
            }
            getProjection(rd) {
                if (rd === this.z) {
                    return { x: 0, y: 0 }
                } else {
                    return {
                        x: this.x / (1 + -this.z / rd),
                        y: -this.y / (1 + -this.z / rd)
                    }
                }
            }
        }

        /**
         *
         */
        const mat4 = {
            create: function () {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]
            },
            perspective: function (matrix, fieldOfView, aspect, zNear, zFar) {
                var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
                matrix[0] = f / aspect;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 0;
                matrix[4] = 0;
                matrix[5] = f;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = 0;
                matrix[9] = 0;
                matrix[10] = (zFar + zNear) / (zNear - zFar)
                matrix[11] = -1;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = (2 * zFar * zNear) / (zNear - zFar);
                matrix[15] = 1;
            },
            translate: function (input, output, change) {
                var m = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    change[0], change[1], change[2], 1
                ]
                this.multiply(input, m, output);
            },
            copy: function (input, output) {
                output[0] = input[0];
                output[1] = input[1];
                output[2] = input[2];
                output[3] = input[3];
                output[4] = input[4];
                output[5] = input[5];
                output[6] = input[6];
                output[7] = input[7];
                output[8] = input[8];
                output[9] = input[9];
                output[10] = input[10];
                output[11] = input[11];
                output[12] = input[12];
                output[13] = input[13];
                output[14] = input[14];
                output[15] = input[15];
            },
            rotate2d: function (input, output, angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                var m = [
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                ]
                var t = this.create();
                this.multiply(input, m, t);
                this.copy(t, output);
            },
            rotate: function (input, output, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                this.multiply(input, q.getMatrix(), output);
            },
            rotated: function (input, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                return matrixMultiply(input, q.getMatrix());
            },
            multiply: function (a, b, out) {
                var result = this.create();
                result[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
                result[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
                result[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
                result[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

                result[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
                result[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
                result[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
                result[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

                result[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
                result[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
                result[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
                result[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

                result[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
                result[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
                result[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
                result[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
                this.copy(result, out);
            },
            transpose: function (input, output) {
                var temp = this.create();
                this.copy(input, temp);
                output[1] = temp[4];
                output[2] = temp[8];
                output[3] = temp[12];
                output[4] = temp[2];
                output[6] = temp[9];
                output[7] = temp[13];
                output[8] = temp[2];
                output[9] = temp[6];
                output[11] = temp[14];
                output[12] = temp[3];
                output[13] = temp[7];
                output[14] = temp[11];
            },
            invert: function (input, output) {
                var x0 = input[0];
                var x1 = input[4];
                var x2 = input[8];
                var x3 = input[12];
                var x4 = input[1];
                var x5 = input[5];
                var x6 = input[9];
                var x7 = input[13];
                var x8 = input[2];
                var x9 = input[6];
                var x10 = input[10];
                var x11 = input[14];
                var x12 = input[3];
                var x13 = input[7];
                var x14 = input[11];
                var x15 = input[15];

                var a0 = x0 * x5 - x1 * x4;
                var a1 = x0 * x6 - x2 * x4;
                var a2 = x0 * x7 - x3 * x4;
                var a3 = x1 * x6 - x2 * x5;
                var a4 = x1 * x7 - x3 * x5;
                var a5 = x2 * x7 - x3 * x6;
                var b0 = x8 * x13 - x9 * x12;
                var b1 = x8 * x14 - x10 * x12;
                var b2 = x8 * x15 - x11 * x12;
                var b3 = x9 * x14 - x10 * x13;
                var b4 = x9 * x15 - x11 * x13;
                var b5 = x10 * x15 - x11 * x14;
                var invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

                output[0] = (+x5 * b5 - x6 * b4 + x7 * b3) * invdet;
                output[4] = (-x1 * b5 + x2 * b4 - x3 * b3) * invdet;
                output[8] = (+x13 * a5 - x14 * a4 + x15 * a3) * invdet;
                output[12] = (-x9 * a5 + x10 * a4 - x11 * a3) * invdet;
                output[1] = (-x4 * b5 + x6 * b2 - x7 * b1) * invdet;
                output[5] = (+x0 * b5 - x2 * b2 + x3 * b1) * invdet;
                output[9] = (-x12 * a5 + x14 * a2 - x15 * a1) * invdet;
                output[13] = (+x8 * a5 - x10 * a2 + x11 * a1) * invdet;
                output[2] = (+x4 * b4 - x5 * b2 + x7 * b0) * invdet;
                output[6] = (-x0 * b4 + x1 * b2 - x3 * b0) * invdet;
                output[10] = (+x12 * a4 - x13 * a2 + x15 * a0) * invdet;
                output[14] = (-x8 * a4 + x9 * a2 - x11 * a0) * invdet;
                output[3] = (-x4 * b3 + x5 * b1 - x6 * b0) * invdet;
                output[7] = (+x0 * b3 - x1 * b1 + x2 * b0) * invdet;
                output[11] = (-x12 * a3 + x13 * a1 - x14 * a0) * invdet;
                output[15] = (+x8 * a3 - x9 * a1 + x10 * a0) * invdet;

                return this;
            }
        }

        /**
         * Return the point of intersection of a line and plane, if line parallel to plane return undefined
         * @param {*} line 
         * @param {*} plane 
         */
        function linePlaneIntersection(line, plane) {
            var dv = plane.point.minus(line.point);
            var product = line.direction.dotProduct(plane.normal);
            if (product !== 0) {
                return line.direction.scaled(dv.dotProduct(plane.normal) / product).add(line.point);
            }
        }


        /**
         * Vector definition of a line
         */
        function Line(point, direction) {
            this.point = point.clone();
            this.direction = direction.clone();
        }

        /**
         *
         */
        Line.prototype = {
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t)
                return v.add(this.point)
            },
            intersection(other) {
                if (other instanceof Plane) {
                    return linePlaneIntersection(this, other)
                } else {
                    return this.lineIntersection(other)
                }
            },
            planeIntersection(plane) {
                const v = this.direction.clone();
                const dv = plane.point.minus(this.point);
                const div = v.dot(plane.normal);
                if (div) {
                    var a = dv.dot(plane.normal) / div;
                    return v.scale(a).add(this.point);
                }
            },
            lineIntersection(line) {
                if ((this.direction.x * line.direction.y - this.direction.y * line.direction.x) !== 0) {
                    var s = (this.direction.x * (line.point.y - this.point.y) + this.direction.y * (line.point.x - this.point.x))
                        / (this.direction.x * line.direction.y - this.direction.y * line.direction.x)
                } else {
                    var s = (this.direction.z * (line.point.y - this.point.y) + this.direction.y * (line.point.z - this.point.z))
                        / (this.direction.z * line.direction.y - this.direction.y * line.direction.z)
                }
                return line.point.plus(this.direction.scaled(s));
            }
        }


        /**
         * Definition of a segment
         */
        class Segment {
            constructor(start, end) {
                this.start = start.clone();
                this.end = end.clone();
            }

            get direction() {
                return (this.end.minus(this.start)).normalise();
            }
            set direction(direction) {
                this.end = this.start.plus(direction);
            }
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t);
                return v.add(this.start);
            }
        }

        /**
         * Vector definition of a plane
         */
        function Plane(point, normal) {
            this.point = point.clone();
            this.normal = normal.clone();
            this.normal.normalise();
            this.bounds = [];
        }

        /**
         *
         */
        Plane.prototype = {
            intersection(other) {
                if (other instanceof Plane) {
                    return this.planeIntersection(other)
                } else {
                    return linePlaneIntersection(other, this)
                }
            },
            planeIntersection(plane) {
                var d = this.normal.crossProduct(plane.normal)
                var v = d.crossProduct(this.normal)
                if (v.length === 0) {
                    return
                }
                var dv = plane.point.minus(this.point)
                var a = (dv.x * plane.normal.x + dv.y * plane.normal.y + dv.z * plane.normal.z) / (v.x * plane.normal.x + v.y * plane.normal.y + v.z * plane.normal.z)
                var p = v.scale(a).add(this.point)
                return new Line(p, d)
            },
            addBoundary(other) {
                this.bounds.push(other)
                other.bounds.push(this)
            },
            getBoundary() {
                var line = this.intersection(this.bounds[this.bounds.length - 1])
                var segments = []
                this.bounds.forEach(function (bound, index, all) {
                    var point = line.intersection(bound)
                    var segment = new Segment(point, point)
                    if (segments.length > 0) {
                        segments[segments.length - 1].end = point
                    }
                    segments.push(segment)
                    line = this.intersection(bound)
                }, this)
                segments[segments.length - 1].end = segments[0].start

                return segments
            }
        }

        /**
         *
         */
        class Triangle {
            constructor(p1, p2, p3) {
                this.p1 = Vector3d.create(p1);
                this.p2 = Vector3d.create(p2);
                this.p3 = Vector3d.create(p3);
            }
            get plane() {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                return new Plane(this.p1, n);
            }
            intersects(line) {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                const p = line.planeIntersection(new Plane(this.p1, n));
                if (p) {
                    const dt = (d1.x * d2.y - d2.x * d1.y);
                    if (dt !== 0 && d1.x !== 0) {
                        const t = (d1.x * (p.y - d1.y) + d1.y * (d1.x - p.x)) / dt;
                        const s = (p.x - t * d2.x - this.p1.x) / d1.x;
                        return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                    } else {
                        const dt = (d1.y * d2.z - d2.y * d1.z);
                        if (dt !== 0 && d1.y !== 0) {
                            const t = (d1.y * (p.z - d1.z) + d1.z * (d1.y - p.y)) / dt;
                            const s = (p.y - t * d2.y - this.p1.y) / d1.y;
                            return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                        } else {
                            const dt = (d1.z * d2.x - d2.z * d1.x);
                            if (dt !== 0 && d1.z !== 0) {
                                const t = (d1.z * (p.x - d1.x) + d1.x * (d1.z - p.z)) / dt;
                                const s = (p.z - t * d2.z - this.p1.z) / d1.z;
                                return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                            }
                        }
                    }
                }
                return false;
            }
        }
    </script>
</body>
</html>
