<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>Structure View</title>
    <style>
        html {
            font-family: sans-serif;
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        input {
            width: 3em;
        }

        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            padding: 0.25rem;
            overflow: hidden;
            background-color: lightslategray;
        }

        #overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            position: fixed;
            top: 0;
            right: 0;
            z-index: 10;
            background: rgb(10, 10, 10, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
        }

        .overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            z-index: 10;
            background: rgb(10, 10, 50, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
            transform: translate(-50%, -50%);
            pointer-events: none;
            white-space: nowrap;
        }

        .fixed {
            position: fixed;
        }

        .shape {
                font-style: italic;
        }

        .scene-node {
            font-weight: bold;
        }

        .number {
            width: 40vw;
        }

        .light-position {
            width: 100%;
        }

        .tree-view {
            display: grid;
            grid-template-columns: 1rem 1rem max-content 1fr 1fr;
            grid-auto-rows: min-content;
            gap: 0;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: min-content 2fr 2fr 1fr;
            width: 100%;
            height: 100%;
            grid-gap: 2px;
            background-color: lightslategray;
        }

        #controls {
            grid-column: 1 / -1;
        }

        .controls {
            grid-column: 1 / -1;
        }

        .right {
            float: right;
        }

        #playback-contols {
            grid-column: 4 / 7;
        }

        #edit {
            position: relative;
            grid-column: 1 / 2;
            display: grid;
            grid-template-rows: max-content 1fr;
            grid-template-columns: 1fr 1fr 1fr 1fr;
        }

        .editor {
            display: flex;
            grid-column: 1 / -1;
        }

        .line-numbers {
            text-align: end;
            background: lightgray;
            resize: none;
            overflow: hidden;
        }

        .main {
            flex-grow: 1;
            resize: none;
        }

        #input {
            /*font-size: 100%;*/
            width: 100%;
            height: 100%;
            overflow: auto;
            grid-column: 1 / -1;
            flex-grow: 1;
            resize: none;
            /*white-space: nowrap;*/
        }

        #scene-container {
            grid-column: 2 / 3;
            grid-row: 2;
            position: relative;
            overflow: hidden;
        }

        #scene {
            width: 100%;
            height: 100%;
        }

        #top-view-container {
            grid-column: 1 / 2;
            grid-row: 2;
            position: relative;
            overflow: hidden;
        }

        #top-view {
            width: 100%;
            height: 100%;
        }

        .expanded-tree {
            grid-column: 2 / 3;
            overflow: auto;
        }

        .detail {
            grid-column: 1 / -1;
            overflow: auto;
        }

        .vector-sliders {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
        }

        .group {
            position: relative;
            border-left: 1px solid gray;
            border-top-left-radius: 0.5em;
            border-bottom-left-radius: 0.5em;

            border: 1px solid gray;
            border-radius: 0.5em;
            margin: 0 1px;

            transition: max-height 0.3s ease-in;
        }

        .expand {
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
            transition: max-height 0.3s ease-in;
            max-height: 1.2em;
            overflow: hidden;
        }

        .content {
            white-space: nowrap;
            max-height: 1.2em;
            transition: max-height 0.3s ease-in;
            overflow: hidden;
        }

        .range {
            font-style: italic;
            color: blue;
        }

        .control-node {
            font-style: italic;
            color: blue;
        }

        .range-expanded {
            font-style: italic;
            color: lightgray;
        }

        .collapse {
            max-height: 0;
            /*border: none;*/
        }

        .entry {
            padding-left: 1.1em;
        }

        .entry-content {
            padding-left: 1.1em;
        }

        .selected {
            background-color: yellow;
        }

        .media-button {
            padding: 0;
            margin: 0;
            background: none;
            border: none;
            font-size: 150%;
        }

        .focus {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            z-index: 5;
        }
    </style>
</head>

<body>
    <div id="overlay"></div>
    <div class="layout">
        <div class="controls">
            <select id="layout-selection">
                <option value="0">Grid</option>
                <Option value="1">Source</Option>
                <Option value="2">Tree</Option>
                <Option value="3">3d</Option>
                <Option value="4">Top</Option>
                <Option value="5">Details</Option>
                <Option value="6">Shader</Option>
            </select>
            <button id="fullscreen">fullscreen</button>
            <button id="start" class="media-button">&#x23ee;</button>
            <button id="rewind" class="media-button">&#x23ea;</button>
            <button id="play" class="media-button">&#x23ef;</button>
            <button id="forward" class="media-button">&#x23e9;</button>
            <button id="end" class="media-button">&#x23ed;</button>

            <label for="split">Split</label><input id="split" type="checkbox">
            <label for="move">Move</label><input id="move" type="checkbox">
            <button id="reset">Reset</button>
        </div>

        <div id="transform" style="display:none;">
            <input class="a0" type="number" value="1">
            <input class="a1" type="number" value="0">
            <input class="a2" type="number" value="0">
            <input class="a3" type="number" value="0">
            <br>
            <input class="a4" type="number" value="0">
            <input class="a5" type="number" value="1">
            <input class="a6" type="number" value="0">
            <input class="a7" type="number" value="0">
            <br>
            <input class="a8" type="number" value="0">
            <input class="a9" type="number" value="0">
            <input class="a10" type="number" value="1">
            <input class="a11" type="number" value="0">
            <br>
            <input class="a12" type="number" value="0">
            <input class="a13" type="number" value="0">
            <input class="a14" type="number" value="0">
            <input class="a15" type="number" value="1">
        </div>
        <div id="edit">
            <button id="comment">Comment</button>
            <button id="uncomment">Uncomment</button>
            <button id="indent">&rarr;</button>
            <button id="outdent">&larr;</button>
            <div class="editor">
                <textarea class="line-numbers"></textarea>
                <textarea id="input" rows="20" cols="50" wrap="off">
box;shape=box;width=2;height=1;depth=1;
box;shape=box;width=2;height=1.5;depth=2;position=1,1,0;
            </textarea>
            </div>
        </div>
        <template id="editor-template">
            <div class="editor">
                <textarea class="line-numbers"></textarea>
                <textarea class="main" wrap="off"></textarea>
            </div>
        </template>
        <div id="scene-container">
            <div id="light-direction" class="vector-sliders">
                <input id="light-x" class="light-position" type="range" min="-100" max="100">
                <input id="light-y" class="light-position" type="range" min="-100" max="100">
                <input id="light-z" class="light-position" type="range" min="-100" max="100">
            </div>
            <canvas id="scene"></canvas>
        </div>
        <div id="top-view-container"><canvas id="top-view"></canvas></div>
        <!--div class="tree"></div-->
        <div class="expanded-tree"></div>
        <div class="detail"></div>
    </div>

    <script>
        /**
         *
         */
        addEventListener('load', function (e) {
            main();
        });

        /**
         * Display the text in overlay div.
         */
        function report(text, sep) {
            if (sep) {
                document.getElementById('overlay').innerText += sep + text;
            } else {
                document.getElementById('overlay').innerText = text;
            }
        }

        /**
         * Converts an HSL color value to RGB. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
         * Assumes h, s, and l are contained in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         *
         * @param   {number}  h       The hue
         * @param   {number}  s       The saturation
         * @param   {number}  l       The lightness
         * @return  {Array}           The RGB representation
         */
        function hslToRgb(h, s, l) {
            var r, g, b;

            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                var hue2rgb = function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        /**
         * Editor component
         */
        class Editor {
            constructor(parent) {
                const template = document.getElementById('editor-template');
                this.container = template.content.firstElementChild.cloneNode(true);
                this.lineNumbers = this.container.querySelector('.line-numbers');
                this.main = this.container.querySelector('.main');

                this.main.addEventListener('scroll', (event) =>
                    this.lineNumbers.scrollTop = input.scrollTop);

                this.main.addEventListener('input', (event) => this.updateLineNumbers());

                if (parent) {
                    parent.appendChild(this.container);
                }
            }
            updateLineNumbers() {
                const count = this.main.value.split(/\n/g).length;
                this.lineNumbers.value = '';
                const numbers = Array(count).fill(0).map((e, i) => i + 1);
                this.lineNumbers.value = numbers.join('\r\n');
                this.lineNumbers.cols = 1 + (count + '').length;
            }
            get value() {
                return this.main.value;
            }
            set value(text) {
                this.main.value = text;
                this.updateLineNumbers();
            }
        }

        /**
         * Extract group data from match data.
         */
        function setGroupData(node, match) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*\|\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(match.groups.list);
            if (!isNaN(count)) {
                node.group = [];
                for (let i = 1; i <= count; ++i) {
                    node.group.push(i);
                }
            } else {
                node.group = match.groups.list.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return item.trim();
                });
            }
            node.name = (match.groups.name || '').trim();
        }

        /**
         * convert string definition to structure
         */
        function getStructure(definition) {
            const lines = definition.split(/\r?\n/);
            const patterns = {
                pattern: /^\s*`(?<pattern>[^`]+)`(?<flags>[ig])?\s*=>\s*`(?<replacement>[^`]+)`\s*$/,
                group: /^\s*\[(?<list>[^\]]+)\]\s*(?<name>\S.*)/,
                template: /^\s*(?<content>\S.*)?\[(?<list>[^\]]+)\]\s*$/,
                conditional: /^\s*\?\[(?<expr>[^\]]+)\]\s*(?<content>.*)/,
                event: /^\s*\@(?<type>([^=]+)(=\s*(.+))?(;([^=]+)(=\s*(.+))?)*)/,
                continuation: /^\s*\&(?<content>.+)/,
                format: /^\s*\$(?<format>(<[^>]+>[^<]+)*(<[^>]+>))\s*$/,
                id: /^\s*<id>(?<pattern>.+)/i,
                idSeparator: /^\s*<separator>(?<separator>.+)/i,
            };

            const structure = [];
            const stack = [];
            const names = {};

            // The structure is determined by indentation, level, or 'path' style.
            // When using indentation a tab is equivelent to 4 spaces.
            // Level is indicated by > at the start of a line followed by integer
            // at start of line.
            // Path is indicated by optional whitespace followed by a '.'
            // separated path, including a leading and trailling '.'.

            let idPattern;
            let idSeparator = '/';
            let lineNumber = 0;
            for (const line of lines) {
                ++lineNumber;
                if (/^\s*(#|$)/.test(line)) {
                    continue;
                }

                // Get the leading whitespace
                const indent = line.replace(/^(\s*)>(?<level>[0-9]+)/, (match, leading, level) =>
                    `${leading}${Array(parseInt(level)).fill(' ').join('')}`).replace(/\S.*/, '');
                const level = indent.split('').map((c, i) => c === '\t' ? 'xxxx'.slice(i % 4) : 'x').join('').length;

                const content = line.replace(/^(\s*)>(?<level>[0-9]+)/, '').trimStart();
                while (stack.length && stack[0].level >= level) {
                    stack.shift();
                }

                const separatorDefinition = line.match(patterns.idSeparator);
                if (separatorDefinition) {
                    idSeparator = separatorDefinition.groups.separator;
                    continue;
                }

                const idDefinition = line.match(patterns.id);
                if (idDefinition) {
                    if (idDefinition.groups.pattern.includes('(?<id>')) {
                        idPattern = new RegExp(idDefinition.groups.pattern);
                    } else {
                        try {
                            idPattern = new RegExp(`(?<id>${idDefinition.groups.pattern})`);
                        } catch (e) {
                            console.log(e);
                        }
                    }
                    continue;
                }

                const node = {
                    content, parent: stack[0], level, parts: [], lineNumber,
                };

                if (idPattern) {
                    const namePattern = line.match(idPattern);
                    if (namePattern) {
                        const id = namePattern.groups.id;
                        const path = id.split(idSeparator);
                        const name = path.pop();
                        const parentName = path.join(idSeparator);
                        if (names[parentName]) {
                            node.parent = names[parentName];
                            //report(parentName);
                        }
                        names[namePattern.groups.id] = node;
                    }
                }

                const groupNode = content.match(patterns.group);
                const templateNode = content.match(patterns.template);
                const conditionalNode = content.match(patterns.conditional);
                const eventNode = content.match(patterns.event);
                const continuation = content.match(patterns.continuation);
                const patternNode = content.match(patterns.pattern);
                const formatNode = content.match(patterns.format);

                if (continuation && stack.length) {
                    stack[0].content += '|' + continuation.groups.content;
                }

                if (groupNode) {
                    setGroupData(node, groupNode);
                    node.groupNode = true;
                }
                if (templateNode && !/\t\[[\]]+\]$/.test(content)) {
                    //node.template = Object.assign({}, node, { content: templateNode.groups.content });
                    setGroupData(node, templateNode);
                    node.content = templateNode.groups.content;
                    node.templateNode = true;
                    //document.body.style.background = 'lightblue';
                }
                if (conditionalNode) {
                    node.conditionalNode = true;
                    const conditionPattern = /\s*(?<name>[^=]+)(=\s*(?<values>.+))?/;
                    const expr = conditionalNode.groups.expr.split(/;/g);
                    node.conditions = expr.map((item) => {
                        const conditionMatch = item.match(conditionPattern);
                        const condition = { name: conditionMatch.groups.name, };
                        if (conditionMatch.groups.values) {
                            condition.values = conditionMatch.groups.values.split(/,/g).map(numberOrString);
                        }
                        return condition;
                    });
                    if (conditionalNode.groups.content) {
                        const contentNode = {
                            content: conditionalNode.groups.content.trim(),
                            parent: node, level, parts: [],
                        };
                        node.parts.push(contentNode);
                    }
                    node.test = function (context) {
                        return this.conditions.every((condition) => {
                            if (condition.values) {
                                return condition.values.includes(context.parameters[condition.name]);
                            }
                            const names = condition.name.split(/\s*,\s*/g)
                            return names.some((name) => context.path.find((node) => node.name === name));
                        });
                    }
                }
                if (stack.length && eventNode) {
                }
                if (patternNode) {
                    node.patternNode = true;
                    node.pattern = patternNode.groups.pattern;
                    node.flags = patternNode.groups.flags;
                    node.replacement = patternNode.groups.replacement;
                }

                if (formatNode) {
                    node.formatNode = true;
                    // Construct a test for a match to the format.
                    const parts = formatNode.groups.format.split(/[<>]/).slice(1);
                    const pattern = parts.map((item, index) => index % 2 ? item : `(?<${item}>.*)`).join('');
                    node.pattern = new RegExp(pattern);
                }

                if (!continuation) {
                    if (node.parent) {
                        node.parent.parts.push(node);
                    } else {
                        structure.push(node);
                    }
                    stack.unshift(node);
                }
            }
            return structure;
        }

        /**
         * Toggle the expansion of a node.
         */
        function toggleExpansion(node, recursive) {
            node.expanded = !node.expanded;

            const expand = (node) => {
                if (recursive) {
                    node.expanded = true;
                }
                node.nodes.forEach((node) => node.classList.remove('collapse'));
                if (node.expanded) {
                    node.parts.forEach((part) => expand(part));
                } else {
                    node.nodes[1].classList.add('collapse');
                }
            };

            const collapse = (node) => {
                if (recursive) {
                    node.expanded = false;
                }
                node.nodes.forEach((node) => node.classList.add('collapse'));
                node.parts.forEach((part) => collapse(part));
            };

            if (node.expanded) {
                node.parts.forEach((part) => expand(part));
                node.nodes[0].innerHTML = '&CircleMinus;';
                node.nodes[1].classList.remove('collapse');
            } else {
                node.parts.forEach((part) => collapse(part));
                node.nodes[0].innerHTML = '&CirclePlus;';
                node.nodes[1].classList.add('collapse');
            }
        }

        /**
         *
         */
        function numberOrString(input) {
            const num = Number(input);
            if (isNaN(num)) {
                return input.trim();
            }
            return num;
        }

        /**
         * Convert a string to a value or list of values
         */
        function getValue(str) {
            const list = str.split(/\s*,\s*/);
            if (list.length > 1) {
                return list.map((i) => numberOrString(i));
            }
            return numberOrString(str);
        }

        /**
         * Generate an new structure from the defintion
         */
        function defaultParser(node, context) {
            if (node.content) {
                const [name, ...data] = node.content.split(/[\|\t;]/g);
                node.name = name.trim();
                node.values = [];
                node.data = data.reduce((data, item) => {
                    item = item.trim();
                    if (item.includes('=')) {
                        const [name, value] = item.split(/=/);
                        if (/^"[^"]+"$/.test(value)) {
                            data[name] = value;
                        } else if (value.includes(',')) {
                            data[name] = value.split(/,/g).map((val) => numberOrString(val));
                        } else {
                            data[name] = numberOrString(value);
                        }
                    } else {
                        if (/^"[^"]+"$/.test(item)) {
                            node.values.push(item);
                        } else if (item.includes(',')) {
                            node.values.push(item.split(/,/g).map((val) => numberOrString(val)));
                        } else {
                            node.values.push(numberOrString(item));
                        }
                    }
                    return data;
                }, {});
            }
        }

        /**
         * Generate an new structure from the defintion
         */
        function parseStructure(structure, parser = defaultParser) {
            const names = {};

            const evaluate = (string, context) => {
                const path = (sep, start = 0, end) =>
                    context.path.toReversed().slice(start, end).map((node) => node.name).join(sep || '');
                const pathUp = (sep, start = 0, end) =>
                    context.path.slice(start, end).map((node) => node.name).join(sep || '');

                const level = (val) =>
                    context.path[val < 0 ? Math.abs(val) : context.path.length - val].name || '';
                const names = [];
                const values = [];
                Object.keys(context.parameters).filter((key, value) => key).forEach((key) => {
                    names.push(key);
                    values.push(context.parameters[key]);
                });
                try {
                    const func = new Function('path', 'pathUp', 'level', ...names, `return ${string};`);
                    return func(path, pathUp, level, ...values);
                } catch (e) {
                    console.log(e);
                }
                return string;
            };

            const resolve = (string, context) => {
                string = string.replace(/\[\s*-?([0-9]+)\s*\]/, //'_path[$1]');
                    (m, p) => `${context.path[context.path.length - Number(p)] || ''}`);
                string = string.replace(/\[\s*\+\s*(?<sep>.+)?\s*\]/,
                    (m, sep) => `${context.path.join(sep || ' ')}`);
                string = string.replace(/\[\s*-\s*(?<sep>.+)?\s*\]/,
                    (m, sep) => `${context.path.toReversed().join(sep || ' ')}`);

                for (const [name, value] of Object.entries(context.parameters)) {
                    const pattern = new RegExp(`\\b${name}\\b`, 'g');
                    string = string.replace(pattern, value);
                }

                return `${string}`;
            };

            const root = [];

            const patternStack = [];

            const formatStack = [];
            const addNode = (source, parent, context = { resolved: true, parameters: {}, path: [], nesting: [] }) => {
                context = Object.assign({}, context);
                let node = { source, parts: [], content: source.content, data: {}, };
                const controlNode = source.patternNode || source.groupNode || source.conditionalNode || source.templateNode || source.formatNode;
                const parts = [...source.parts];

                if (source.patternNode) {
                    try {
                        patternStack.push({
                            match: new RegExp(source.pattern, source.flags),
                            replacement: source.replacement || '',
                        });
                    } catch (e) {
                        console.log(e);
                    }
                }

                if (source.formatNode) {
                    formatStack.unshift(source);
                }

                if (!controlNode) {
                    patternStack.forEach((pattern) =>
                        node.content = node.content.replace(pattern.match, pattern.replacement));
                    node.content = node.content.replace(/<([^>]*)>/g, (match, label) => {
                        if (context.parameters[label]) {
                            return context.parameters[label];
                        }
                        const index = Number(label);
                        if (!isNaN(index) && context.nesting.length) {
                            return context.nesting[Math.abs(index) % context.nesting.length][0];
                        }
                        const keys = Object.keys(names).sort((a, b) => b.length - a.length);
                        const name = keys.find((key) => label.startsWith(key));
                        if (name) {
                            parts.unshift(...names[name].source.parts);
                            return names[name].content;
                        }
                        return match;
                    });
                    node.content = node.content.replace(/\{([^}]+)\}/g, (match, p1) => evaluate(p1, context));
                    node.content = node.content.replace(/:([^\t\|;:]+)/g, (all, item) => {
                        if (context.parameters[item]) {
                            return `:${context.parameters[item]}`;
                        }
                        const keys = Object.keys(names).sort((a, b) => b.length - a.length);
                        const name = keys.find((key) => item.startsWith(key));
                        if (name) {
                            parts.unshift(...names[name].source.parts);
                            return `:${names[name].content}`;
                        }
                        return all;
                    });
                }

                parser(node, context);
                if (formatStack.length) {
                    const match = node.content.match(formatStack[0].pattern);
                    if (match) {
                        var index = 0;
                        const data = Object.entries(match.groups).reduce((obj, [name, value]) => {
                            obj[name] = getValue(value);
                            return obj;
                        }, {});
                        node.data = Object.assign(data, node.data);
                    }
                }


                if (!controlNode) {
                    const path = context.path.map((node) => node.name);
                    let l = 1;
                    while (names[`${node.name}, ${path.slice(0, l).join(', ')}`] && l < path.length) {
                        l += 1;
                    }
                    node.uniqueName = `${node.name}, ${path.slice(0, l).join(', ')}`
                }

                if (!controlNode) {
                    context.path.unshift(node);
                }

                const matched = (!source.conditionalNode) || source.test(context);

                if (source.templateNode) {
                    if (!/(<[^>]*>)|(\{[^\}]*\})/.test(node.content)) {
                        document.body.style.background = 'pink';
                        node.content = `${node.content} <>`;
                    }

                    node.parts = [...source.parts];
                    if (context.parameters[''] !== undefined) {
                        context.nesting.unshift([context.parameters[''], context.parameters['_n']])
                    }
                    node.lineNumber = source.lineNumber;
                    source.group.forEach((item, index) => {
                        context.parameters[''] = item;
                        context.parameters[`_n`] = index;
                        /*
                        context.parameters[node.name] = item;
                        context.parameters[`${node.name}_n`] = index;
                        */
                        addNode(node, parent, context);
                    });
                    if (context.parameters[''] !== undefined) {
                        context.nesting.shift();
                    }
                }

                if (parts.length && matched && !source.referenceNode) {
                    if (source.groupNode) {
                        source.group.forEach((item, index) => {
                            context.parameters[source.name] = item;
                            context.parameters[`${source.name}_n`] = index;
                            parts.forEach((part) => addNode(part, parent, context));
                        });
                    } else if (source.patternNode || source.formatNode) {
                        parts.forEach((part) => addNode(part, parent, context));
                    } else {
                        parts.forEach((part) => addNode(part, node, context));
                    }
                }
                names[node.name] = names[node.name] || node;
                names[node.uniqueName] = node;
                if (!controlNode) {
                    context.path.shift();
                }
                if (!controlNode) {
                    if (parent) {
                        parent.parts.push(node);
                        node.parent = parent;
                    } else {
                        root.push(node);
                    }
                }
                if (source.patternNode) {
                    patternStack.pop();
                }
                if (source.formatNode) {
                    formatStack.shift();
                }

            };
            structure.forEach((node) => addNode(node));

            return root;
        }

        var tree = {
            roots: [],
            nodes: [],
        };
        /**
         * Generate dom nodes for the given structure
         */
        function getView(structure, actions = {}) {
            const container = document.createElement('div');
            container.classList.add('tree-view');

            const nodes = [];

            tree.nodes.length = 0;
            const flatten = (node, level = 1) => {
                node.level = level;
                tree.nodes.push(node);
                nodes.push(node);
                node.parts.forEach((part) => flatten(part, level + 1));
            };

            structure.forEach((part) => flatten(part));
            tree.roots = structure;

            let depth = Math.max(...nodes.map((node) => node.level));

            let row = 0;
            const addNode = (node) => {
                row += 1;
                let text = node.name;
                node.expanded = true;
                node.row = row;
                node.nodes = [];
                const controlNode = node.source.groupNode || node.source.datNode || node.source.conditional;

                const group = document.createElement('div');
                container.appendChild(group);
                group.style.gridColumn = node.level;
                const expander = document.createElement('div');
                expander.classList.add('expand');
                node.nodes.push(expander);
                node.nodes.push(group);
                group.appendChild(expander);
                const content = document.createElement('div');
                content.classList.add('content');

                if (controlNode) {
                    content.classList.add('control-node');
                    if (node.unrolled) {
                        content.classList.add('range-expanded');
                    }
                    content.addEventListener('click', (event) => {
                        node.unrolled = !node.unrolled;
                        container.innerHTML = '';
                        row = 0;
                        structure.forEach((part) => addNode(part));
                    });
                }
                node.nodes.push(content);
                content.style.gridColumn = `${node.level + 1}/${depth + 2}`;
                container.appendChild(content);
                const data = Object.entries(node.data).map(([name, value]) => `${name} = ${value}`).join(', ');
                content.innerText = `${text}`;// (${data})`;
                content.title = `${node.uniqueName} ${data}`;
                if (node.shape) {
                    content.classList.add('shape');
                }
                if (node.sceneNode) {
                    content.classList.add('scene-node');
                }
                Object.entries(actions).forEach(([event, action]) =>
                    content.addEventListener(event, (event) => action(event, node)));

                if (node.parts.length) {
                    group.classList.add('group');
                    expander.innerHTML = '&CircleMinus;';
                    expander.addEventListener('click', (event) => toggleExpansion(node, event.ctrlKey));
                    expander.addEventListener('dblclick', (event) => toggleExpansion(node, true));

                    const startRow = row;
                    node.parts.forEach((part) => addNode(part));
                    group.style.gridRow = `${startRow}/${row + 1}`;
                    group.style.background = `hsl(${360 * Math.random()} 50% 50%)`;
                }
                return nodes;
            };

            const columns = `repeat(${depth}, 1em) max-content 1fr`;
            container.style.gridTemplateColumns = columns;

            structure.forEach((part) => addNode(part));
            return container;
        }

        const namedNodes = {};

        class Transition {
            constructor(node) {
                this.node = node.sceneNode;
            }
            start() { }
            finish() { }
        }

        class Translate extends (Transition) {
            constructor(node, value) {
                super(node);
                this.value = value;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
                }
                const p = d * d * (3 - 2 * d);
                const v = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    ...v, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
            }
        }

        class Rotate extends (Transition) {
            constructor(node, value) {
                super(node);
                this.value = value;
                if (this.value.length < 4) {
                    const start = this.value.length;
                    this.value.length = 4;
                    this.value.fill(0, start);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        getRotationMatrix(this.value[0], this.value.slice(1)));
                }
                const p = d * d * (3 - 2 * d);
                const angle = this.value[0] * p;
                this.node.movement = matrixMultiply(this.node.movement,
                    getRotationMatrix(angle, this.value.slice(1)));
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    getRotationMatrix(this.value[0], this.value.slice(1)));
            }
        }

        class Scale extends (Transition) {
            constructor(node, value) {
                super(node);
                if (Array.isArray(value)) {
                    this.value = value;
                } else {
                    this.value = Array(3).fill(value);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement, [
                        this.value[0], 0, 0, 0,
                        0, this.value[1], 0, 0,
                        0, 0, this.value[2], 0,
                        0, 0, 0, 1,
                    ]);
                }
                const p = d * d * (3 - 2 * d);
                const s = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    s[0], 0, 0, 0,
                    0, s[1], 0, 0,
                    0, 0, s[2], 0,
                    0, 0, 0, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform, [
                    this.value[0], 0, 0, 0,
                    0, this.value[1], 0, 0,
                    0, 0, this.value[2], 0,
                    0, 0, 0, 1,
                ]);
            }
        }

        class ColourChange extends (Transition) {
            constructor(node, value) {
                super(node);
                this.value = value;
            }
            start() {
                this.intialColour = this.node.colour;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const v = this.value.forEach((v, i) =>
                    this.intialColour[i] + (v - this.intialColour[i]) * p);
                this.node.colour = v;
            }
        }

        class Fade extends (Transition) {
            constructor(node, value) {
                super(node);
                this.value = value;
            }
            start() {
                this.initialAlpha = this.node.colour[3];
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const f = this.initialAlpha + (this.value - this.initialAlpha) * p;
                this.node.colour[3] = f;
            }
        }

        const nodeTransitions = {
            Translate, Rotate, Scale, ColourChange, Fade,
        };

        /**
         * Generate scene graph for the given structure
         */
        function getGraph(structure, scene) {
            const buffers = {
                vertex: [],
                indices: [],
            };
            scene.data = buffers;
            let links = 0;

            const types = {
                Box, Ball, Frustrum, Cylinder, Cone, Diamond, Tetrahedron, Torus, Prism, Link,
            }
            scene.shapes = [];
            const shapes = {};

            const stack = [];
            scene.graph = [];
            scene.nodes = [];

            const getParent = (node) => {
                let parent = node.parent;
                while (parent && !parent.sceneNode && parent.parent) {
                    parent = parent.parent;
                }
                return parent?.sceneNode;
            }

            function getEvents(node, sceneNode) {
                const eventPattern = /^@(?<trigger>[^,]+)\s*,\s*(?<transition>[^=]+)/
                const triggerPattern = /^(?<time>[^\/]+)\/(?<duration>[^\/]+)/
                return Object.entries(node.data).map(([item, value]) => {
                    const event = item.match(eventPattern);
                    if (event) {
                        const transition = nodeTransitions[event.groups.transition];
                        const triggerWithDuration = event.groups.trigger.match(triggerPattern);
                        let startTime;
                        let endTime;
                        if (triggerWithDuration) {
                            endTime = numberOrString(triggerWithDuration.groups.time);
                            const duration = numberOrString(triggerWithDuration.groups.duration);
                            startTime = endTime - duration;
                        } else {
                            endTime = numberOrString(event.groups.trigger)
                            startTime = endTime - 1;
                        }
                        if (transition) {
                            return {
                                node: sceneNode,
                                startTime,
                                endTime,
                                transition: new transition(node, value),
                            };
                        }
                    }
                }).filter((i) => i);
            }

            const add = (node) => {
                let index = 0;
                let positionalName = null;
                if (node.values[index]) {
                    positionalName = node.values[index].slice(0, 1).toUpperCase() + node.values[index].slice(1).toLowerCase();
                    if (positionalName in types) {
                        ++index;
                    }
                }
                let position;
                if (node.values[index] && Array.isArray(node.values[index]) && node.values[index].length === 3) {
                    position = node.values[index];
                    ++index;
                } else {
                    position = node.data.position;
                }
                const shapeName = positionalName || (node.data?.shape ? node.data.shape.toLowerCase() : 'Ball');
                const typeName = shapeName.slice(0, 1).toUpperCase() + shapeName.slice(1).toLowerCase();
                report(typeName);

                if (typeName && types[typeName]) {
                    const hash = types[typeName].hash(node);
                    shapes[hash] = shapes[hash] || types[typeName].make(scene.gl, buffers, node, index, namedNodes);
                    node.shape = shapes[hash];
                    scene.shapes.push(node.shape);
                }
                //node.data.position = node.data.position || [0, 0, 0];

                if (node.name === "Camera" && !node.data.type) {
                    if (node.data.lookAt && node.data.lookAt.length === 3) {
                        camera.target = node.data.lookAt;
                    }
                    if (node.data.position && node.data.position.length === 3) {
                        camera.position = node.data.position;
                    }
                    if (node.data.up && node.data.up.length === 3) {
                        camera.up = node.data.up;
                    }
                } else if (node.name === 'Background') {
                    if (node.data.colour) {
                        background.colour = node.data.colour;
                    }
                } else if (position && position.length === 3) {
                    position = position.map((v) => isNaN(v) ? 0 : v);
                    const shader = Math.random() > 1 ? scene.shader3 : scene.shader4;
                    const transform = [];
                    if (node.data.rotation && node.data.rotation.length === 4) {
                        node.data.rotation = node.data.rotation.map((v) => isNaN(v) ? 0 : v);
                        const angle = Math.PI * node.data.rotation[0] / 180;
                        const axis = normalise([...node.data.rotation.slice(1)]);
                        const q = new Quaternion(
                            Math.cos(angle / 2),
                            Math.sin(angle / 2) * axis[0],
                            Math.sin(angle / 2) * axis[1],
                            Math.sin(angle / 2) * axis[2]);
                        q.setMatrix(transform);
                        transform[12] = position[0];
                        transform[13] = position[1];
                        transform[14] = position[2];
                    } else {
                        transform.push(
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            ...position, 1);
                    }
                    const parent = getParent(node);
                    let colour = node.data.colour;
                    let ancestor = parent;
                    while (ancestor && !colour) {
                        colour = ancestor.colour;
                        ancestor = ancestor.parent;
                    }

                    if (Array.isArray(colour)) {
                        colour = [1, 0.9, 0.5, 1].map((v, i) => colour[i] != undefined ? colour[i] : v);
                    } else {
                        colour = [1, 0.9, 0.5, 1];
                    }
                    if (Array.isArray(node.data.specularColour) && node.data.specularColour.length === 3) {

                    }

                    node.sceneNode = addNode(node.name, parent, transform, node.shape, shader, colour, node.data.specular || 4, node.data.specularColour);
                    namedNodes[node.name] = node.sceneNode;
                    if (!parent) {
                        scene.graph.push(node.sceneNode);
                    }
                    node.sceneNode.sourceNode = node;
                    scene.nodes.unshift(node.sceneNode);
                    const events = getEvents(node, node.sceneNode);
                    scene.events.push(...events);
                    stack.unshift(node);
                }

                if (node.parts.length) {
                    node.parts.forEach((part) => add(part));
                }

                if (node.position) {
                    stack.shift();
                }
            };

            structure.forEach((part) => add(part));
            scene.events.sort((a, b) => (a.startTime) - (b.startTime));

            updateBuffers(scene.gl, scene.buffers, buffers);
            glErrors(scene.gl, context = 'Update Buffers');
        }

        /**
         *
         */
        function associateArray(node, arr, action) {
            let index = 0;
            const update = (index) => {
                return (event, value) => arr[index] = event.target.valueAsNumber;
            }

            for (const input of node.querySelectorAll('input')) {
                input.value = arr[index];
                input.addEventListener('input', update(index));
                index += 1;
            }
        }

        /**
         *
         */
        const scene = {
            shapes: [],
            points: [],
            lines: [],
            overlays: [],
            events: [],
            activeEvents: [],
        }


        // Vertex shader program
        /**
         *
         */
        const vsSource = `
            attribute vec4 aVertexPosition;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;

            varying vec4 v_position;

            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                v_position = gl_Position;
            }`;

        // Vertex shader
        /**
         *
         */
        const vsSource2 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
            }`;

        /**
         *
         */
        const fsSource = `
            precision mediump float;
            varying vec4 v_position;

            uniform vec4 uColour;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 color = v_position * 0.15 + 0.5;
                gl_FragColor = uColour;
            }`;

        /**
         *
         */
        const fsSource2 = `
            precision mediump float;
            varying vec4 v_position;

            uniform vec4 uColour;

            void main() {
                vec4 color = v_position * 0.5 + 0.5;
                gl_FragColor = color * uColour;
            }`;


        /**
         *
         */
        const fsSource3 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColor;
            uniform vec4 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient
                vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColor.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColor.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColor * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 color = ambient + diffuse + specular;

                // Output final color
                gl_FragColor = vec4(color, uDiffuseColor.a);
            }`;

        /**
         *
         */
        const fsSource4 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColor;
            uniform vec4 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColor.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColor * specularIntensity;

                float edge = clamp(1.0 - vNormal.z, 0.0, 1.0);
                vec3 ambient = edge * vec3(0.25, 0.25, 0.25) * uDiffuseColor.rgb;
                // Combine diffuse and specular contributions
                vec3 color = ambient + diffuse + specular;

                // Output final color
                gl_FragColor = vec4(color, uDiffuseColor.a);

            }`;

        /**
         *
         */
        const fsSource5 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColor;
            uniform vec4 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            float rand(float co) {
                return fract(sin(co*(91.3458)) * 47453.5453);
            }

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            float rand(vec3 co){
                return rand(co.xy+rand(co.z));
            }

            void main() {
                // ambient
                vec3 ambient = vec3(0.25) * uAmbientColor.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColor.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColor * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 color = ambient + diffuse + specular;

                // Output final color
                gl_FragColor = vec4(color, 1.0);
            }`;

        //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        /**
         *
         */
        function initialiseShaders(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getShaderLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        /**
         * creates a shader of the given type, uploads the source and
         * compiles it.
         */
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        /**
         *
         */
        function initBuffers(scene, data) {

            // Create a buffer for the square's positions.

            //const vertex = gl.createBuffer();
            scene.buffers = {
                vertex: scene.gl.createBuffer(),
                index: scene.gl.createBuffer(),
            };

            // Select the .vertex as the one to apply buffer
            // operations to from here out.
            scene.gl.bindBuffer(scene.gl.ARRAY_BUFFER, scene.buffers.vertex);

            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            scene.gl.bufferData(scene.gl.ARRAY_BUFFER,
                new Float32Array(data.vertex),
                scene.gl.STATIC_DRAW);

            scene.gl.bindBuffer(scene.gl.ELEMENT_ARRAY_BUFFER, scene.buffers.indices);

            scene.gl.bufferData(scene.gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(data.indices),
                scene.gl.STATIC_DRAW);
        }

        /**
         *
         */
        function updateBuffers(gl, buffers, data) {
            // Select the .vertex as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);


            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(data.vertex),
                gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(data.indices),
                gl.STATIC_DRAW);
        }

        /**
         * Create the indexes for a strip of quads formed from pairs of triangles.
         */
        function addClosedTriangleStrip(gl, indexBuffer, nQuads, start1, start2, step1 = 2, step2) {
            const offset = indexBuffer.length * 2;
            step2 = step2 || step1;
            start2 = start2 !== undefined ? start2 : start1 + 1;
            for (let i = 0; i < nQuads; ++i) {
                indexBuffer.push(start1 + i * step1);
                indexBuffer.push(start2 + i * step2);
            }
            indexBuffer.push(start1);
            indexBuffer.push(start2);
            const count = 2 + nQuads * 2
            return { mode: gl.TRIANGLE_STRIP, count, offset };
        }

        /**
         *
         */
        function addTriangles(gl, vertex, indexBuffer, points) {
            const offset = indexBuffer.length * 2;
            let index = vertex.length / 6;
            const nTriangles = Math.floor(points.length / 3);
            for (let i = 0; i < nTriangles; ++i) {
                const p0 = points[i * 3];
                const p1 = points[i * 3 + 1];
                const p2 = points[i * 3 + 2];
                const v1 = [p0[0] - p1[0], p0[1] - p1[1], p0[2] - p1[2]];
                const v2 = [p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];
                const n = [
                    v1[1] * v2[2] - v1[2] * v2[1],
                    v1[2] * v2[0] - v1[0] * v2[2],
                    v1[0] * v2[1] - v1[1] * v2[0]];
                const l = Math.hypot(n[0], n[1], n[2]);
                n[0] /= l;
                n[1] /= l;
                n[2] /= l;
                vertex.push(...p0, ...n);
                indexBuffer.push(index++);
                vertex.push(...p1, ...n);
                indexBuffer.push(index++);
                vertex.push(...p2, ...n);
                indexBuffer.push(index++);
            }

            return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
        }

        /**
         *
         */
        function addClosedTriangleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;

            if (true) {
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(centre);
                    indexBuffer.push(first + i * step);
                    indexBuffer.push(first + ((i + 1) % nTriangles) * step);
                }
                return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
            } else {
                indexBuffer.push(centre);
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(first + i * step);
                }
                indexBuffer.push(first);
                const count = 2 + nTriangles
                return { mode: gl.TRIANGLE_FAN, count, offset };
            }
        }

        /**
         *
         */
        function addOpenTraingleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;
            indexBuffer.push(centre);
            for (let i = 0; i <= nTriangles; ++i) {
                indexBuffer.push(first + i * step);
            }
            const count = 2 + nTriangles
            return { mode: gl.TRIANGLE_FAN, count, offset };
        }

        /**
         *
         */
        function addLineLoop(gl, indexBuffer, nSegments, first, step = 1) {
            const offset = indexBuffer.length * 2;
            for (let i = 0; i < nSegments; ++i) {
                indexBuffer.push(first + i * step);
            }
            indexBuffer.push(first);
            const count = 1 + nSegments
            return { mode: gl.LINE_STRIP, count, offset };
        }


        class shape {
            updateBuffers(gl) {

            }
            draw3d(gl) {
                this.elements.forEach((shape) => {
                    if (this.colour) {
                        gl.uniform4fv(node.shader.colourLocation, shape.colour);
                    }
                    gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                });
            }
        }

        /**
         *
         */
        class Box extends (shape) {
            static make(gl, data, node, index) {
                const size = node.data.size || [1, 1, 1];
                const width = node.data.width || size[0] || 1;
                const height = node.data.height || size[1] || size[0] || 1;
                const depth = node.data.depth || size[2] || size[0] || 1;
                return new Box(gl, data, width, height, depth);
            }
            static hash(node) {
                return `box ${node.data.width} ${node.data.height} ${node.data.depth}`;
            }
            constructor(gl, data, w, h, d) {
                super();
                if (w === undefined) {
                    w = 0.5;
                } else {
                    w /= 2;
                }
                if (h === undefined) {
                    h = w;
                } else {
                    h /= 2;
                }
                if (d === undefined) {
                    d = h;
                } else {
                    d /= 2;
                }
                this.width = 2 * w;
                this.height = 2 * h;
                this.depth = 2 * d;
                const start = data.vertex.length / 6;
                data.vertex.push(
                    -w, -h, -d,
                    0, 0, -1,
                    -w, h, -d,
                    0, 0, -1,

                    w, -h, -d,
                    0, 0, -1,
                    w, h, -d,
                    0, 0, -1,

                    w, -h, -d,
                    1, 0, 0,
                    w, h, -d,
                    1, 0, 0,

                    w, -h, d,
                    1, 0, 0,
                    w, h, d,
                    1, 0, 0,

                    w, -h, d,
                    0, 0, 1,
                    w, h, d,
                    0, 0, 1,

                    -w, -h, d,
                    0, 0, 1,
                    -w, h, d,
                    0, 0, 1,

                    -w, -h, d,
                    -1, 0, 0,
                    -w, h, d,
                    -1, 0, 0,

                    -w, -h, -d,
                    -1, 0, 0,
                    -w, h, -d,
                    -1, 0, 0,

                    -w, -h, -d,
                    0, -1, 0,
                    w, -h, -d,
                    0, -1, 0,

                    w, -h, d,
                    0, -1, 0,
                    -w, -h, d,
                    0, -1, 0,

                    -w, h, -d,
                    0, 1, 0,
                    w, h, -d,
                    0, 1, 0,

                    w, h, d,
                    0, 1, 0,
                    -w, h, d,
                    0, 1, 0
                );

                const indexStart = data.indices.length;
                data.indices.push(...[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                    16, 17, 18, 18, 19, 16, 20, 21, 22, 22, 23, 20,
                    16, 17, 18, 19, 16, 20, 21, 22, 23, 20,
                    16, 20, 17, 21, 18, 22, 19, 23,
                ].map((i) => i + start));

                this.elements = [
                    { mode: gl.TRIANGLE_STRIP, count: 16, offset: indexStart * 2 },
                    { mode: gl.TRIANGLES, count: 12, offset: (16 + indexStart) * 2 },
                    { mode: gl.LINE_STRIP, count: 5, offset: (28 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 5, offset: (33 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINES, count: 8, offset: (indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const planes = [
                    { point: [this.width / 2, 0, 0], normal: [1, 0, 0] },
                    { point: [-this.width / 2, 0, 0], normal: [-1, 0, 0] },
                    { point: [0, this.height / 2, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height / 2, 0], normal: [0, -1, 0] },
                    { point: [0, 0, this.depth / 2], normal: [0, 0, 1] },
                    { point: [0, 0, -this.depth / 2], normal: [0, 0, -1] },
                ];
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const w = this.width / 2;
                const h = this.height / 2;
                const d = this.depth / 2;
                const points = [
                    [-w, -h, -d,],
                    [w, -h, -d,],
                    [w, -h, d,],
                    [-w, -h, d,],

                    [-w, h, -d,],
                    [w, h, -d,],
                    [w, h, d,],
                    [-w, h, d,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.lineTo(points[4][0], points[4][1]);

                context.moveTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.moveTo(points[2][0], points[2][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.moveTo(points[4][0], points[4][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.stroke();
            }
        }

        /**
         *
         */
        class Diamond extends (shape) {
            static make(gl, data, node, index) {
                return new Diamond(scene.gl, data, node.data.size);
            }
            static hash(node) {
                return `diamond ${node.data.size}`;
            }
            constructor(gl, data, size = 1) {
                super();
                this.size = size;
                const start = data.vertex.length / 6;
                const indexStart = data.indices.length;
                const points = [
                    [0, 1, 0,],
                    [1, 0, 0,],
                    [0, 0, 1,],

                    [0, 1, 0,],
                    [0, 0, 1,],
                    [-1, 0, 0,],

                    [0, 1, 0,],
                    [-1, 0, 0,],
                    [0, 0, -1,],

                    [0, 1, 0,],
                    [0, 0, -1,],
                    [1, 0, 0,],


                    [0, -1, 0,],
                    [1, 0, 0,],
                    [0, 0, 1,],

                    [0, -1, 0,],
                    [0, 0, 1,],
                    [-1, 0, 0,],

                    [0, -1, 0,],
                    [-1, 0, 0,],
                    [0, 0, -1,],

                    [0, -1, 0,],
                    [0, 0, -1,],
                    [1, 0, 0,],
                ].map((point) => point.map((v) => v * size));

                data.indices.push(...[
                    0, 1, 2, 0, 7, 8, 0,
                    12, 13, 14, 12, 17, 18, 12
                ].map((i) => i + start));

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINE_STRIP, count: 7, offset: (24 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 7, offset: (31 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ];

                const planes = [
                    planeFromPoints(points[0], points[2], points[1]),
                    planeFromPoints(points[0], points[3], points[2]),
                    planeFromPoints(points[0], points[4], points[3]),
                    planeFromPoints(points[0], points[1], points[4]),

                    planeFromPoints(points[5], points[1], points[2]),
                    planeFromPoints(points[5], points[2], points[3]),
                    planeFromPoints(points[5], points[3], points[4]),
                    planeFromPoints(points[5], points[4], points[1]),
                ];

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[0][0], points[0][1]);

                context.moveTo(points[5][0], points[5][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);

                context.stroke();
            }
        }

        /**
         *
         */
        class Ball extends (shape) {
            static make(gl, data, node, index) {
                const values = node.values || [];
                const size = node.data.size || values[index++] || 2;
                const depth = node.data.depth || values[index++] || 2;
                const height = node.data.height || values[index++] || 2;
                const sides = node.data.sides || values[index++] || 12;
                const strips = node.data.strips || values[index++] || 12;
                const mode = node.data.mode || values[index++] || 'solid';

                return new Ball(scene.gl, data, size, depth, height, sides, strips);
            }
            static hash(node) {
                return `ball ${node.data.size} ${node.data.height} ${node.data.depth} ${node.data.sides} ${node.data.strips}`;
            }
            constructor(gl, data, width = 2, depth = 0, height = 0, sides = 12, strips = 12) {
                super();
                depth = depth || width
                height = height || width

                this.width = width / 2;
                this.depth = depth / 2;
                this.height = height / 2;
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 6;
                const indexStart = data.indices.length;

                // Create the mesh for the ball
                data.vertex.push(0, height / 2, 0);
                data.vertex.push(0, 1, 0);
                data.vertex.push(0, -height / 2, 0);
                data.vertex.push(0, -1, 0);
                for (let j = 0; j < strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / strips);
                    for (let i = 0; i < sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / sides;
                        data.vertex.push(
                            this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians));
                        data.vertex.push(
                            radius * Math.sin(radians), ny, radius * Math.cos(radians));
                    }
                }

                const elements = [
                    addClosedTriangleFan(gl, data.indices, sides, start, start + 2),
                    addClosedTriangleFan(gl, data.indices, sides, start + 1, start + 2 + (strips - 2) * sides),
                ];

                for (let j = 0; j < strips - 2; ++j) {
                    elements.push(addClosedTriangleStrip(gl, data.indices, sides, start + 2 + j * sides, start + 2 + (j + 1) * sides, 1, 1));
                }

                this.elements = elements;
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Torus extends (shape) {
            static make(gl, data, node, index) {
                const values = node.values || [];
                const size = node.data.size || values[index++] || 2;
                const thickness = node.data.thickness || values[index++] || 1;
                const sides = node.data.sides || values[index++] || 12;
                const strips = node.data.strips || values[index++] || 12;
                const start = node.data.start || values[index++] || 0;
                const mode = node.data.mode || values[index++] || 'solid';

                return new Torus(scene.gl, data, size, thickness, sides, strips, start, mode);
            }
            static hash(node) {
                return `torus ${node.data.size} ${node.data.thickness} ${node.data.sides} ${node.data.strips}`;
            }
            constructor(gl, data, mainRadius = 2, minorRadius = 1, sides = 12, strips = 12, startAngle = 0, mode = 'solid') {
                super();
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 6;
                startAngle = startAngle * Math.PI / 180;

                // Create the mesh for the torus
                for (let j = 0; j < sides; ++j) {
                    const dx = Math.cos(2 * j * Math.PI / sides);
                    const dz = Math.sin(2 * j * Math.PI / sides);

                    for (let i = 0; i < strips; ++i) {
                        const angle = startAngle + 2 * i * Math.PI / strips;
                        const x = dx * (mainRadius + minorRadius * Math.sin(angle));
                        const y = minorRadius * Math.cos(angle);
                        const z = dz * (mainRadius + minorRadius * Math.sin(angle));
                        data.vertex.push(x, y, z);
                        data.vertex.push(dx * Math.sin(angle), y, dz * Math.sin(angle));
                    }
                }

                this.elements = [];
                if (mode !== 'wireframe') {
                    for (let j = 0; j < sides; ++j) {
                        const start1 = start + j * strips;
                        const start2 = start + ((j + 1) % sides) * strips;
                        this.elements.push(addClosedTriangleStrip(gl, data.indices, strips, start1, start2, 1, 1));
                    }
                }

                if (mode === 'lined' || mode === 'wireframe') {
                    for (let i = 0; i < sides; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, strips, start + i * strips, 1));
                    }
                    for (let i = 0; i < strips; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, sides, start + i, strips));
                    }
                }
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Frustrum extends (shape) {
            static make(gl, data, node, index) {
                return new Frustrum(scene.gl, data, node.data.radius, 0, node.data.height, node.data.sides);
            }
            static hash(node) {
                return `frustrum ${node.data.baseRadius} ${node.data.topRadius} ${node.data.height} ${node.data.sides}`;
            }
            constructor(gl, data, baseRadius = 1, topRadius = 0.5, height = 2, sides = 12) {
                super();
                height /= 2;
                this.height = height;
                this.baseRadius = baseRadius;
                this.topRadius = topRadius;
                this.sides = sides;

                const start = data.vertex.length / 6;
                const indexStart = data.indices.length;

                const angle = Math.atan((baseRadius - topRadius) / 2 * height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                for (let i = 0; i < sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / sides;
                    const topRadians = (1 + i * 2) * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(baseRadians), -height, baseRadius * Math.cos(baseRadians),
                        nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),
                        topRadius * Math.sin(topRadians), height, topRadius * Math.cos(topRadians),
                        nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians));
                }

                data.vertex.push(0, -height, 0);
                data.vertex.push(0, -1, 0);

                for (let i = 0; i < sides; ++i) {
                    const angle = i * 2 * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(angle), -height, baseRadius * Math.cos(angle),
                        0, -1, 0);
                }

                const elements = [
                    addClosedTriangleStrip(gl, data.indices, sides, start),
                    addClosedTriangleFan(gl, data.indices, sides, start + 2 * sides, 1 + start + 2 * sides),
                ];

                if (topRadius > 0) {
                    data.vertex.push(0, height, 0);
                    data.vertex.push(0, 1, 0);

                    for (let i = 0; i < sides; ++i) {
                        const angle = (1 + i * 2) * Math.PI / sides;
                        data.vertex.push(
                            topRadius * Math.sin(angle), height, topRadius * Math.cos(angle),
                            0, 1, 0);
                    }
                    elements.push(addClosedTriangleFan(gl, data.indices, sides, 1 + start + 3 * sides, 2 + start + 3 * sides));
                }

                elements.push(
                    Object.assign(addLineLoop(gl, data.indices, sides, 1 + start + 2 * sides), { colour: [1, 1, 1, 1] }));

                if (topRadius > 0) {
                    elements.push(
                        Object.assign(addLineLoop(gl, data.indices, sides, 2 + start + 3 * sides), { colour: [1, 1, 1, 1] }));
                }

                if (sides < 7) {
                    elements.push({ mode: gl.LINE_STRIP, count: sides * 2, offset: indexStart * 2, colour: [1, 1, 1, 1] });
                }
                this.elements = elements;
            }
            intersects(line) {
                const angle = Math.atan((this.baseRadius - this.topRadius) / 2 * this.height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                const planes = [
                    { point: [0, this.height, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height, 0], normal: [0, -1, 0] },
                ];

                for (let i = 0; i < this.sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / this.sides;
                    const topRadians = (1 + i * 2) * Math.PI / this.sides;

                    planes.push({
                        point: [this.baseRadius * Math.sin(baseRadians), -this.height, this.baseRadius * Math.cos(baseRadians),],
                        normal: [nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),],
                    }, {
                        point: [this.topRadius * Math.sin(topRadians), this.height, this.topRadius * Math.cos(topRadians),],
                        normal: [nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),],
                    });
                }

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Cylinder extends (Frustrum) {
            static make(gl, data, node) {
                var index = 0;
                const values = node.values || [];
                const radius = node.data.radius || values[index++];
                const height = node.data.height || values[index++];
                const sides = node.data.sides || values[index++];
                return new Cylinder(scene.gl, data, node.data.radius, node.data.height, node.data.sides);
            }
            static hash(node) {
                return `cylinder ${node.data.radius} ${node.data.height} ${node.data.sides}`;
            }
            constructor(gl, data, radius = 1, height = 2, sides = 12) {
                super(gl, data, radius, radius, height, sides);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Cone extends (Frustrum) {
            static make(gl, data, node) {
                return new Cone(scene.gl, data, node.data.radius, node.data.height, node.data.sides);
            }
            static hash(node) {
                return `cone ${node.data.radius} ${node.data.height} ${node.data.sides}`;
            }
            constructor(gl, data, radius = 1, height = 2, sides = 12) {
                super(gl, data, radius, 0, height, sides);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Tetrahedron extends (shape) {
            static make(gl, data, node, index) {
                return new Tetrahedron(scene.gl, data, node.data.size);
            }
            static hash(node) {
                return `tetrahedron ${node.data.size}`;
            }
            constructor(gl, data, size = 1) {
                super();
                const start = data.vertex.length / 6;
                this.size = 1;
                const indexStart = data.indices.length;
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [-l * l, -0.5, -0.5 * l],
                    [0, 1, 0],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((point) => point.map((v) => v * size));

                const indices = [0, 1, 1, 2, 2, 0, 3, 0, 3, 1, 3, 2].map((i) => i + start);
                data.indices.push(...indices);

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINES, count: 12, offset: (12 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const l = Math.cos(30 * Math.PI / 180);
                const sides = [
                    [[0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l]],
                    [[0, 1, 0],
                    [-l * l, -0.5, -0.5 * l],
                    [0, -0.5, l],],
                    [[0, 1, 0],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l]],
                    [[l * l, -0.5, -0.5 * l],
                    [0, -0.5, l,],
                    [-l * l, -0.5, -0.5 * l]],
                ].map((point) => point.map((v) => scaled(v, this.size)));

                const planes = sides.map((side) => planeFromPoints(...side));
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((p) => transformed(scaled(p, this.size), transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[1][0], points[1][1]);

                context.moveTo(points[3][0], points[3][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.stroke();
            }
        }

        /**
          *
          */
        class Prism extends (shape) {
            static make(gl, data, node, index) {
                return new Prism(gl, data, node.date.points, node.data.height);
            }
            static hash(node) {
                return `Prism ${node.data.points.join(',')} ${node.data.height}`;
            }
            constructor(gl, data, points = [[0, 0], [0, 1], [0, -1]], height = 1) {
                super();
                const start = data.vertex.length / 6;
                const indexStart = data.indices.length;
                this.height = height;
                this.points = points;

                const indices = [0, 1, 1, 2, 2, 0, 3, 0, 3, 1, 3, 2].map((i) => i + start);
                data.indices.push(...indices);

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINES, count: 12, offset: (12 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            get3dPoints() {
                return [
                    ...points.map((point) => [point[0], -this.height / 2, point[1]]),
                    ...points.map((point) => [point[0], this.height / 2, point[1]]),
                ];
            }
            getSides() {
                const points = this.getPoints();
                const nPoints = this.points.length;
                const faces = this.points.map((point, i) => [
                    points[i], points[(i + 1) % nPoints],
                    points[nPoints + (i + 1) % nPoints], points[i + nPoints],
                ]);
            }
            intersects(line) {
                return;
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((p) => transformed(scaled(p, this.size), transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[1][0], points[1][1]);

                context.moveTo(points[3][0], points[3][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.stroke();
            }
        }


        /**
         * Find the first node that matches the name or undefined if no match found
         */
        function findNode(name) {
            return namedNodes[name];
        }



        /**
         * Connection between two nodes
         */
        class Link {
            static make(gl, buffers, node, index, namedNodes) {
                const from = node.data.from;
                const to = node.data.to;
                const values = node.data.points;
                // Ensure points list is valid
                if (Array.isArray(values)) {
                    values.length = 3 * Math.floor(values.length / 3);
                    const points = [];
                    for (let i = 0; i < values.length; i += 3) {
                        points.push([
                            isNaN(values[i]) ? 0 : values[i],
                            isNaN(values[i + 1]) ? 0 : values[i + 1],
                            isNaN(values[i + 2]) ? 0 : values[i + 2],
                        ]);
                    }
                    return new Link(gl, buffers, from, to, points);
                } else {
                    return new Link(gl, buffers, from, to);
                }
            }
            static hash(node) {
                return `link ${++links}`;
            }
            constructor(gl, data, from, to, points = []) {
                this.from = from;
                this.to = to;
                this.points = [[0, 0, 0], ...points, [0, 0, 0]];

                const start = data.vertex.length / 6;
                const indexStart = data.indices.length;
                this.pointIndex = data.vertex.length;
                this.pointIndex2 = data.vertex.length + 6 + points.length * 6;

                data.vertex.push(...this.points.flatMap((point) => [...point, 0, 0, -1]));
                const indices = Array(this.points.length).fill(1).map((e, i) => i + start);

                data.indices.push(...indices);

                this.elements = [
                    { mode: gl.LINE_STRIP, count: this.points.length, offset: 2 * indexStart, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
            }
            updateBuffers(scene, node) {
                this.fromNode = this.fromNode || findNode(this.from) || node.parent;
                this.toNode = this.toNode || findNode(this.to) || node.parent;
                let inverse = identityMatrix();
                if (node.parent) {
                    inverse = invert(node.parent.world);
                }

                if (this.fromNode?.world && this.toNode?.world) {
                    // Update points based on object positions

                    const from = this.fromNode === node.parent ? [0, 0, 0] : transformed(transformed([0, 0, 0], this.fromNode.world), inverse);
                    const to = this.toNode === node.parent ? [0, 0, 0] : transformed(transformed([0, 0, 0], this.toNode.world), inverse);
                    scene.data.vertex[this.pointIndex] = from[0];
                    scene.data.vertex[this.pointIndex + 1] = from[1];
                    scene.data.vertex[this.pointIndex + 2] = from[2];

                    scene.data.vertex[this.pointIndex2] = to[0];
                    scene.data.vertex[this.pointIndex2 + 1] = to[1];
                    scene.data.vertex[this.pointIndex2 + 2] = to[2];
                }
            }
            draw3d(gl) {
                if (this.fromNode && this.toNode) {
                    this.elements.forEach((shape) => {
                        if (this.colour) {
                            gl.uniform4fv(node.shader.colourLocation, shape.colour);
                        }
                        gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                    });
                }
            }
            draw2d(context, transform) {
                if (this.fromNode && this.toNode) {
                    const points2d = this.points.map((point) => transform4(point, transform));

                    context.beginPath();
                    points2d.forEach((point) => context.lineTo(point[0], point[1]));
                    context.stroke();
                }
            }
        }

        /**
         * Function to update node data prior to rendering
         */
        function update(scene, origin, time) {
            this.world = matrixMultiply(this.transform, origin);
            if (this.shape) {
                this.shape.updateBuffers(scene, this);
            }
            this.children.forEach((child) => child.update(scene, this.world, time));
        }

        /**
         *
         */
        function addNode(name, parent, transform, shape, shader, colour = [1, 0, 1, 1], shininess, specularColour) {

            shininess = shininess || 1 + 5 * Math.random();

            const node = Object.assign(Object.create({ update }), {
                name, parent, transform, movement: identityMatrix(),
                shape, shader, colour, shininess, specularColour, children: [],
            });
            if (parent) {
                parent.children.push(node);
            }
            return node;
        }

        /**
         *
         */
        function drawNode(gl, origin, node, time) {
            node.world = matrixMultiply(matrixMultiply(node.transform, node.movement), origin);
            const transform = matrixMultiply(node.world, scene.modelViewMatrix);

            gl.useProgram(node.shader.program);
            gl.uniformMatrix4fv(node.shader.modelViewMatrixLocation, false, transform);
            const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
            gl.uniformMatrix3fv(node.shader.normalMatrixLocation, false, normalMatrix);
            node.shader.setNodeData(gl, node);
            if (node.shape) {
                node.shape.draw3d(gl);
            }
            node.children.forEach((child) => drawNode(gl, node.world, child, time));
            node.movement = identityMatrix();
        }

        /**
         *
         */
        function positionNode(origin, node) {
            node.world = matrixMultiply(node.transform, origin);
            node.children.forEach((child) => positionNode(node.world, child));
        }

        /**
         *
         */
        function drawNode2(gl, node, shader, time) {
            if (node.shader === shader) {
                node.world = matrixMultiply(matrixMultiply(node.transform, node.movement), origin);
                const transform = matrixMultiply(node.world, scene.modelViewMatrix);
                gl.uniformMatrix4fv(node.shader.modelViewMatrixLocation, false, transform);
                const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
                gl.uniformMatrix3fv(node.shader.normalMatrixLocation, false, normalMatrix);
                node.shader.setNodeData(gl, node);
                if (node.shape) {
                    node.shape.draw3d(gl);
                }
            }
            node.children.forEach((child) => drawNode2(gl, child, shader));
            node.movement = identityMatrix();
        }

        /**
         *
         */
        function drawScene(gl, buffers, shapes, time) {
            const clearColour = [0, 0, 0].map((e, i) => background.colour[i] || e);
            scene.gl.clearColor(...clearColour, 1.0);

            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            glErrors(gl, 'drawScene');
            glErrors(gl, 'drawScene===');
            scene.graph.forEach((node) => drawNode(scene.gl, identityMatrix(), node, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function drawScene2(gl, buffers, shapes, time) {
            const clearColour = [0, 0, 0].map((e, i) => background.colour[i] || e);
            scene.gl.clearColor(...clearColour, 1.0);

            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            glErrors(gl, 'drawScene');

            const origin = identityMatrix();
            scene.graph.forEach((node) => positionNode(origin, node));

            gl.useProgram(scene.shader3.program);
            scene.graph.forEach((node) => drawNode2(scene.gl, node, scene.shader3, time));
            gl.useProgram(scene.shader4.program);
            scene.graph.forEach((node) => drawNode2(scene.gl, node, scene.shader4, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function glErrors(gl, context = '') {
            const err = gl.getError();
            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.log(context, errors[err]);
            }
        }

        /**
         *
         */
        function initialiseShader(gl, shader, buffers, projectionMatrix) {
            const numComponents = 3;  // pull out 2 values per iteration
            const type = gl.FLOAT;    // the data in the buffer is 32bit floats
            const normalize = false;  // don't normalize
            const stride = 4 * 3 * 2;         // how many bytes to get from one set of values to the next
            // 0 = use type and numComponents above
            const offset = 0;         // how many bytes inside the buffer to start from
            gl.useProgram(shader.program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
            gl.vertexAttribPointer(
                shader.attribLocations.vertexPosition,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            gl.enableVertexAttribArray(shader.attribLocations.vertexPosition);

            if (shader.attribLocations.vertexNormal) {
                gl.vertexAttribPointer(
                    shader.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    4 * 3);
                gl.enableVertexAttribArray(shader.attribLocations.vertexNormal);
            }

            // Tell WebGL to use our program when drawing

            // Set the shader uniforms
            gl.uniformMatrix4fv(shader.projectionMatrixLocation, false, projectionMatrix);

            if (shader.lightPosition) {
                gl.uniform3fv(shader.lightPosition, shader.light.position);
            }
        }

        /**
         *
         */
        const times = [];
        let last = 0;

        /**
         *
         */
        const rotationControl = document.getElementById('move');


        /**
         * Update the Camera position
         */
        function updateCamera(string) {
            const input = document.getElementById('input');
            let text = input.value.replace(/^\s*Camera.*/, string);
            input.value = text;
        }


        /**
         *
         */
        class Camera {
            constructor(position = [0, 0, 1], target = [0, 0, 0], up = [0, 1, 0]) {
                this.initial = { position, target, up };
                this.reset();
            }
            reset() {
                this.position = [...this.initial.position];
                this.target = [...this.initial.target];
                this.up = [...this.initial.up];
            }
            getString() {
                const str = (vector, fixed = 3) => vector.map((element) => element.toFixed(fixed));
                return `Camera;lookAt=${str(camera.target)};position=${str(camera.position)};up=${str(camera.up)}`;
            }
            zAxis() {
                return normalise(subtract(this.target, this.position));
            }
            xAxis() {
                return xaxis = normalise(cross(this.zAxis(), this.up));
            }
            yAxis() {
                const zAxis = normalise(subtract(this.target, this.position));
                const xAxis = normalise(cross(zAxis, this.up));
                return cross(xAxis, zAxis);
            }
            axes() {
                const zAxis = normalise(subtract(this.target, this.position));
                const xAxis = normalise(cross(zAxis, this.up));
                const yAxis = cross(xAxis, zAxis);

                return { xAxis, yAxis, zAxis };
            }
            viewMatrix(eye, at, up) {
                const zaxis = normalise(subtract(this.target, this.position));
                const xaxis = normalise(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);

                negate(zaxis);

                return [
                    xaxis[0], yaxis[0], zaxis[0], 0,
                    xaxis[1], yaxis[1], zaxis[1], 0,
                    xaxis[2], yaxis[2], zaxis[2], 0,
                    -dot(xaxis, this.position), -dot(yaxis, this.position), -dot(zaxis, this.position), 1
                ];
            }
            zoom(distance) {
                const direction = subtract(this.target, this.position);
                const movement = scaled(direction, distance);
                this.position = add(this.position, movement);
                updateCamera(this.getString);
            }
            forward(distance) {
                const zaxis = normalise(subtract(this.target, this.position));
                const movement = scaled(zaxis, distance);
                this.position = add(this.position, movement);
                this.target = add(this.target, movement);
                updateCamera(this.getString);
            }
            rotateX(angle) {
                const zaxis = subtract(this.target, this.position);
                const xaxis = cross(zaxis, this.up);

                const offset = subtract(this.position, this.target);
                rotate(offset, xaxis, angle);
                rotate(this.up, xaxis, angle);

                this.position = add(this.target, offset);
                updateCamera(this.getString);
            }
            rotateY(angle) {
                const offset = subtract(this.position, this.target);
                rotate(offset, this.up, angle);

                this.position = add(this.target, offset);
                updateCamera(this.getString);
            }
            pitch(angle) {
                const zaxis = subtract(this.target, this.position);
                const xaxis = cross(zaxis, this.up);

                rotate(zaxis, xaxis, angle);
                rotate(this.up, xaxis, angle);
                this.target = add(this.position, zaxis);
                updateCamera(this.getString);
            }
            yaw(angle) {
                const zaxis = subtract(this.target, this.position);
                rotate(zaxis, this.up, angle);
                this.target = add(this.position, zaxis);
                updateCamera(this.getString);
            }
            roll(angle) {
                const zaxis = subtract(this.target, this.position);
                rotate(this.up, zaxis, angle);
                updateCamera(this.getString);
            }
            getLine(x, y, fieldOfView) {
                const aspect = scene.gl.canvas.clientWidth / scene.gl.canvas.clientHeight;
                const fov = fieldOfView * Math.PI / 180;
                const zaxis = normalise(subtract(this.target, this.position));
                const xaxis = normalise(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);
                const d = 1 / Math.tan(fov / 2);
                const direction = normalise(add(scaled(xaxis, x * aspect), scaled(yaxis, y), scaled(zaxis, d)));
                return { point: this.position, direction };
            }
        }

        /**
         *
         */
        const camera = new Camera([0, 0, 20], [0, 0, 0], [0, 1, 0]);
        const background = { colour: [0, 0, 0] };

        /**
         * Management of a 2 view using a canvas
         */
        class View2d {
            constructor(scene, canvasId) {
                this.projection = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
                this.scene = scene;
                this.canvas = document.getElementById(canvasId);
                this.context = this.canvas.getContext('2d');
                const scale = Math.min(this.canvas.width, this.canvas.height) / 20;
                this.projection[8] = scale;
                this.projection[5] = scale;
                /*
                this.projection[1] = scale;
                this.projection[9] = scale;
                */

                this.projection[12] = this.canvas.width / 2;
                this.projection[13] = this.canvas.height / 2;
            }
            render() {
                if (!this.canvas) return;

                this.context.globalCompositeOperation = 'source-over';
                this.context.shadowBlur = 0;
                this.context.fillStyle = 'rgb(0,0,0)';
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                //context.globalCompositeOperation = 'lighter';

                this.context.lineWidth = 1;
                this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                const renderNode = (node) => {
                    if (node.world && node.shape) {
                        if (node.colour) {
                            this.context.strokeStyle = `rgba(${node.colour[0] * 255}, ${node.colour[1] * 255}, ${node.colour[2] * 255}, ${node.colour[3]})`;
                        } else {
                            this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                        }
                        const transform = matrixMultiply(node.world, this.projection);
                        node.shape.draw2d(this.context, transform);
                    }
                }
                scene.nodes.forEach(node => renderNode(node));

                if (scene.ray) {
                    const start = transformed(scene.ray.point, this.projection);
                    const endPoint = add(scene.ray.point, scaled(scene.ray.direction, 500));
                    const end = transformed(endPoint, this.projection);

                    this.context.strokeStyle = 'rgb(255, 255, 255, 0.9)';
                    this.context.beginPath();
                    this.context.moveTo(start[0], start[1]);
                    this.context.lineTo(end[0], end[1]);
                    this.context.stroke();
                }
                if (scene.points) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    scene.points.forEach((point) => {
                        const centre = transformed(point, this.projection);
                        this.context.beginPath();
                        this.context.arc(centre[0], centre[1], 3, 0, Math.PI * 2);
                        this.context.stroke();
                    });
                }
                if (scene.lines) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    this.context.beginPath();
                    scene.lines.forEach((line) => {
                        const start = transformed(line.start, this.projection);
                        const end = transformed(line.end, this.projection);
                        this.context.moveTo(start[0], start[1]);
                        this.context.lineTo(end[0], end[1]);
                    });
                    this.context.stroke();
                }
            }
        }

        /**
         *
         */
        let topView;
        let sideView;
        const cameraMove = {};

        /**
         * Start moving camera
         */
        function moveCamera(target, position, up, duration = 1) {
            cameraMove.action = 'start';
            cameraMove.target = target || camera.target;
            cameraMove.position = position || camera.position;
            cameraMove.up = up || camera.up;
            cameraMove.duration = duration;
        }

        /**
         *
         */
        function processActiveEvents(time) {
            //report(`${scene.activeEvents.length} ${time.toFixed(2)}`);
            scene.activeEvents.filter((event) => event.endTime <= time).forEach((event) => event.transition.finish());
            scene.activeEvents = scene.activeEvents.filter((event) => event.endTime > time);
            scene.activeEvents.forEach((event) => {
                const d = (time - event.startTime) / (event.endTime - event.startTime);
                event.transition.progress(d);
            });
        }

        /**
         * Resize the canvas based on the node size
         */
        function updateCanvasSize(scene) {

            // Lookup the size the browser is displaying the canvas in CSS pixels.
            const width = scene.gl.canvas.clientWidth;
            const height = scene.gl.canvas.clientHeight;

            // Check if the canvas is not the same size.
            const resize = scene.gl.canvas.width !== width || scene.gl.canvas.height !== height;

            if (resize) {
                // Make the canvas the same size
                scene.gl.canvas.width = width;
                scene.gl.canvas.height = height;

                scene.gl.viewport(0, 0, width, height);
            }

            return resize;
        }

        /**
         *
         */
        function render(time = 0) {
            if (paused) {
                return;
            }

            const stateAction = {
                start: () => {
                    state.time = 0;
                    state.nextEvent = 0;
                },
                rewind: () => { },
                play: () => {
                    if (state.mode === 'playing') {
                        state.rate = 1;
                        state.mode = 'paused';
                    } else {
                        state.mode = 'playing';
                    }
                },
                forward: () => { },
                end: () => { },
            }[state.action];
            if (stateAction) {
                stateAction();
            }

            state.action = null;

            if (last) {
                const delta = time - last;
                times.push(delta);
                if (times.length > 5) {
                    times.shift();
                    const total = times.reduce((sum, delta) => sum + delta);
                    const average = 5000 / total;
                }
                if (state.mode === 'playing') {
                    state.time += delta / 1000;
                    while (scene.events[state.nextEvent] && state.time > scene.events[state.nextEvent].startTime) {
                        const event = scene.events[state.nextEvent];
                        event.transition.start();
                        scene.activeEvents.push(event);
                        ++state.nextEvent;
                    }
                }
            }
            processActiveEvents(state.time);
            last = time;
            if (cameraMove.action === 'start') {
                cameraStart = {
                    target: camera.target,
                    position: camera.position,
                    up: camera.up,
                    time: time,
                }
                cameraMove.action = 'move';
            }
            if (cameraMove.action === 'move') {
                const d = (time - cameraStart.time) / (1000 * (cameraMove.duration || 1));
                const s = d * d * (3 - 2 * d);
                camera.target = add(cameraStart.target, scale(subtract(cameraMove.target, cameraStart.target), s));
                camera.position = add(cameraStart.position, scale(subtract(cameraMove.position, cameraStart.position), s));
                camera.up = add(cameraStart.up, scale(subtract(cameraMove.up, cameraStart.up), s));
                if (d > 1) {
                    cameraMove.action = null;
                }
            }

            updateCanvasSize(scene);
            scene.modelViewMatrix = camera.viewMatrix();

            // Create a perspective matrix, a special matrix that is
            // used to simulate the distortion of perspective in a camera.
            // Our field of view is 45 degrees, with a width/height
            // ratio that matches the display size of the canvas
            const fieldOfView = 45;   // in degrees
            const aspect = scene.gl.canvas.clientWidth / scene.gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 1000.0;
            const projectionMatrix = perspective(fieldOfView, aspect, zNear, zFar);
            scene.projectionMatrix = projectionMatrix;// matrixMultiply(projectionMatrix, scene.modelViewMatrix);

            scene.graph.forEach((node) => node.update(scene, identityMatrix(), node, time));

            updateBuffers(scene.gl, scene.buffers, scene.data);

            initialiseShader(scene.gl, scene.shader, scene.buffers, projectionMatrix);
            initialiseShader(scene.gl, scene.shader2, scene.buffers, projectionMatrix);
            initialiseShader(scene.gl, scene.shader3, scene.buffers, projectionMatrix);
            initialiseShader(scene.gl, scene.shader4, scene.buffers, projectionMatrix);

            const split = document.getElementById('split');
            scene.gl.enable(scene.gl.BLEND)
            scene.gl.blendFunc(scene.gl.SRC_ALPHA, scene.gl.ONE_MINUS_SRC_ALPHA);
            if (split.checked) {
                drawScene2(scene.gl, scene.buffers, scene.shapes, time);
            } else {
                drawScene(scene.gl, scene.buffers, scene.shapes, time);
            }
            glErrors(scene.gl);

            topView.render();

            if (scene.overlays) {
                scene.overlays.forEach((overlay) => overlay.updateOverlay(scene.projectionMatrix));
            }

            window.requestAnimationFrame(render);
        }

        /**
         *
         */
        function matrixMultiply(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
            ];
        }

        /**
         *
         */
        function get3x3(input) {
            return [
                input[0], input[1], input[2],
                input[4], input[5], input[6],
                input[8], input[9], input[10]];
        }

        /**
         *
         */
        function transpose3x3(input) {
            return [
                input[0], input[3], input[6],
                input[1], input[4], input[7],
                input[2], input[5], input[8]];
        }

        /**
         *
         */
        function invert3x3(input) {
            let a00 = input[0], a01 = input[1], a02 = input[2];
            let a10 = input[3], a11 = input[4], a12 = input[5];
            let a20 = input[6], a21 = input[7], a22 = input[8];

            let b01 = a22 * a11 - a12 * a21;
            let b11 = -a22 * a10 + a12 * a20;
            let b21 = a21 * a10 - a11 * a20;
            // Calculate the determinant
            let det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return null;
            }
            det = 1.0 / det;
            return [
                b01 * det,
                (-a22 * a01 + a02 * a21) * det,
                (a12 * a01 - a02 * a11) * det,
                b11 * det,
                (a22 * a00 - a02 * a20) * det,
                (-a12 * a00 + a02 * a10) * det,
                b21 * det,
                (-a21 * a00 + a01 * a20) * det,
                (a11 * a00 - a01 * a10) * det];
            return out;
        }

        /**
         *
         */
        function transpose(input) {
            return [
                input[0], input[4], input[8], input[12],
                input[1], input[5], input[9], input[13],
                input[2], input[6], input[10], input[14],
                input[3], input[7], input[11], input[15]];
        }

        /**
         *
         */
        function invert(input) {
            const x0 = input[0];
            const x1 = input[1];
            const x2 = input[2];
            const x3 = input[3];
            const x4 = input[4];
            const x5 = input[5];
            const x6 = input[6];
            const x7 = input[7];
            const x8 = input[8];
            const x9 = input[9];
            const x10 = input[10];
            const x11 = input[11];
            const x12 = input[12];
            const x13 = input[13];
            const x14 = input[14];
            const x15 = input[15];

            const a0 = x0 * x5 - x1 * x4;
            const a1 = x0 * x6 - x2 * x4;
            const a2 = x0 * x7 - x3 * x4;
            const a3 = x1 * x6 - x2 * x5;
            const a4 = x1 * x7 - x3 * x5;
            const a5 = x2 * x7 - x3 * x6;
            const b0 = x8 * x13 - x9 * x12;
            const b1 = x8 * x14 - x10 * x12;
            const b2 = x8 * x15 - x11 * x12;
            const b3 = x9 * x14 - x10 * x13;
            const b4 = x9 * x15 - x11 * x13;
            const b5 = x10 * x15 - x11 * x14;
            const invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

            return [
                (+x5 * b5 - x6 * b4 + x7 * b3) * invdet,
                (-x1 * b5 + x2 * b4 - x3 * b3) * invdet,
                (+x13 * a5 - x14 * a4 + x15 * a3) * invdet,
                (-x9 * a5 + x10 * a4 - x11 * a3) * invdet,
                (-x4 * b5 + x6 * b2 - x7 * b1) * invdet,
                (+x0 * b5 - x2 * b2 + x3 * b1) * invdet,
                (-x12 * a5 + x14 * a2 - x15 * a1) * invdet,
                (+x8 * a5 - x10 * a2 + x11 * a1) * invdet,
                (+x4 * b4 - x5 * b2 + x7 * b0) * invdet,
                (-x0 * b4 + x1 * b2 - x3 * b0) * invdet,
                (+x12 * a4 - x13 * a2 + x15 * a0) * invdet,
                (-x8 * a4 + x9 * a2 - x11 * a0) * invdet,
                (-x4 * b3 + x5 * b1 - x6 * b0) * invdet,
                (+x0 * b3 - x1 * b1 + x2 * b0) * invdet,
                (-x12 * a3 + x13 * a1 - x14 * a0) * invdet,
                (+x8 * a3 - x9 * a1 + x10 * a0) * invdet];
        }

        /**
         *
         */
        function normalise(v) {
            const hypot = Math.hypot(v[0], v[1], v[2]);
            return [v[0] / hypot, v[1] / hypot, v[2] / hypot];
        }

        /**
         *
         */
        function dot(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        /**
         *
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0]];
        }

        /**
         *
         */
        function negate(v) {
            v[0] = -v[0];
            v[1] = -v[1];
            v[2] = -v[2];
        }

        /**
         *
         */
        function add(...vectors) {
            return vectors.reduce((sum, v) => [sum[0] + v[0], sum[1] + v[1], sum[2] + v[2]], [0, 0, 0]);
            return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
        }

        /**
         *
         */
        function subtract(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        /**
         *
         */
        function scale(v, s) {
            v[0] *= s;
            v[1] *= s;
            v[2] *= s;
            return v;
        }

        /**
         *
         */
        function scaled(v, s) {
            return v.map((e) => e * s);
        }

        /**
         *
         */
        function rotate(v, axis, angle) {
            angle *= Math.PI / 180;
            axis = normalise(axis);

            const s = Math.cos(angle / 2);
            const u = scaled(axis, Math.sin(angle / 2));

            const p1 = scale(cross(v, u), 2 * s);
            const p2 = scaled(v, s * s - dot(u, u));
            const p3 = scaled(u, 2 * dot(v, u));

            [v[0], v[1], v[2]] = add(p1, add(p2, p3));

            return add(p1, add(p2, p3));
        }

        /**
         *
         */
        function matrixVectorMultiply(v, matrix) {
            const x = matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12];
            const y = matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13];
            const z = matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14];
            v[0] = x;
            v[1] = y;
            v[2] = z;
            return v
        }

        /**
         * point transform (apply translation)
         */
        function transformed(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
            ];
        }

        /**
          * point transform (apply translation)
          */
        function transform4(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
                matrix[3] * v[0] + matrix[7] * v[1] + matrix[11] * v[2] + matrix[15],
            ];
        }

        /**
         * Direction transform (ignore translation)
         */
        function transformDirection(v, matrix) {
            return normalise([
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2],
            ]);
        }


        /**
         * Return the plane defined by three points
         */
        function planeFromPoints(p0, p1, p2) {
            const v0 = subtract(p0, p1);
            const v1 = subtract(p0, p2);
            const normal = normalise(cross(v0, v1));
            return { point: p0, normal };
        }

        /**
         * Return an identity matrix
         */
        function identityMatrix() {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }

        /**
         *
         */
        function lookAt(eye, at, up) {
            const zaxis = normalise(subtract(at, eye));
            const xaxis = normalise(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eye), -dot(yaxis, eye), -dot(zaxis, eye), 1
            ];
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zFar + zNear) / (zNear - zFar), -1,
                0, 0, (2 * zFar * zNear) / (zNear - zFar), 1,
            ];
        }


        /**
         *
         */
        function makeGraph(scene, bases, components) {
            scene.graph = [];
            scene.nodes = [];
            for (let j = 0; j < bases * bases; ++j) {
                let direction = [0, 2, 0];
                const t = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 3 * (-bases / 2 + j % bases), 0, 3 * (-bases / 2 + Math.floor(j / bases)), 1];
                const colour = [...hslToRgb(Math.random(), 0.5 + Math.random() * 0.5, 0.2 + 0.6 * Math.random()).map(v => v / 255), 1];

                scene.nodes.unshift(addNode(`node ${j}`, null, t, scene.shapes[0], scene.shader3, colour));
                scene.graph.push(scene.nodes[0]);

                for (let i = 0; i < components; ++i) {
                    const shader = Math.random() > 0.5 ? scene.shader3 : scene.shader4;
                    let parent = scene.nodes[0];
                    const scale = 0.9 + 0.1 * Math.random();
                    if (((i / 1000) + Math.random()) > 0.9) {
                        direction = [
                            [0, 0, 0],
                            [0, 2, 0],
                            [0, 0, 2],
                            [-2, 0, 0],
                            [0, -2, 0],
                            [0, 0, -2],
                        ][Math.floor(6 * Math.random())];
                        parent = scene.nodes[Math.floor(Math.random() * scene.nodes.length)];
                    }
                    const transform = [
                        scale, 0, 0, 0,
                        0, scale, 0, 0,
                        0, 0, scale, 0,
                        ...direction, 1,
                    ];
                    const colour = [...hslToRgb(Math.random(), 0.5 + Math.random() * 0.5, 0.5).map(v => v / 255), 1];
                    const shape = scene.shapes[Math.floor(Math.random() * scene.shapes.length)];

                    scene.nodes.unshift(addNode(`node ${j}, ${i}`, parent, transform, shape, shader, colour));
                }
            }
            scene.target = Math.floor(scene.nodes.length * Math.random());
            scene.camera = Math.floor(scene.nodes.length * Math.random());
        }

        /**
         * Find the closest point on a line to a given point
         */
        function closestPoint(line, point) {
            // line = lp + d * ld
            // point = p
            // From line to point = p - (lp + d * ld)
            // Closest when (p - (lp + d * ld)).ld = 0
            // dot product is distributive hence
            // (p - (lp + d * ld)).ld = p.ld - lp.ld + d * (ld. ld)
            // d = (lp - p).ld / ld.ld
            const numerator = dot(subtract(line.point - point), line.direction);
            const divisor = dot(line.direction, line.direction);
            return numerator / divisor;
        }

        /**
         * Return the distance between two points
         */
        function distance(point1, point2) {
            return math.hypot(point1[0] - point2[0], point1[1] - point2[1], point1[2] - point2[2]);
        }

        /**
         * Add touch controls to the given node
         */
        function planeIntercept(line, plane) {
            // plane (p - p0).n = 0
            // line p = l + dt
            // (l + dt - p0).n = 0
            // (lx + dxt - p0x)nx + (ly + dyt - p0y)ny + (lz + dzt - p0z)nz = 0
            // t(dx.nx + dy.ny + dz.nz) = nx(p0x-lx) + ny(p0y-ly) + nz(p0z-lz)
            // t = (nx(p0x-lx) + ny(p0y-ly) +nz(p0z-lz)) / (dx.nx + dy.ny + dz.nz)

            const divisor = dot(line.direction, plane.normal);
            if (divisor !== 0) {
                const offset = subtract(plane.point, line.point);
                return dot(offset, plane.normal) / divisor;
            }
        }

        /**
         * Get the point from a line and distance along it
         */
        function getPoint(line, distance) {
            return add(line.point, scaled(line.direction, distance));
        }

        /**
         * Determine the intecep of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalise(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start) {
                return [start, end];
            }
        }

        /**
         * Return the nodes at the screen coordinate 
         */
        function pickNodes(x, y) {
            const ray = camera.getLine(x, y, 45);
            scene.ray = ray;
            scene.points.length = 0;
            scene.lines.length = 0;
            const hits = scene.nodes.filter((node) => {
                if (node.shape) {
                    const inverse = invert(node.world);
                    const point = transformed(ray.point, inverse);
                    const direction = transformDirection(ray.direction, inverse);
                    const points = node.shape.intersects({ point, direction });

                    if (points) {
                        node.hit = points;
                        node.hitPoint = getPoint(ray, points[0]);
                        scene.points.push(getPoint(ray, points[0]), getPoint(ray, points[1]));
                        return true;
                    }
                    if (!event.shiftKey) {
                        node.hit = null;
                    }
                    node.sourceNode.nodes.forEach((node) => node.classList.remove('selected'));
                }
            });
            return hits;
        }

        /**
         * Process a 'click' event
         */
        function click(x, y) {
            const hits = pickNodes(x, y);
            if (hits.length > 0) {
                hits.sort((a, b) => a.hit[0] - b.hit[0]);
                if (!event.altKey) {
                    hits.slice(1).forEach((node) => node.hit = null);
                }
                hits.forEach((hit) => hit.sourceNode.nodes.forEach((node) => node.classList.add('selected')));

                if (event.ctrlKey) {
                    camera.target = hits[0].world.slice(12, 16);
                    if (hits[0].overlay) {
                        removeOverlay(hits[0]);
                    } else {
                        scene.overlays.push(addOverlay(hits[0]));
                    }
                }
                const target = transformed([0, 0, 0], hits[0].world);
                moveCamera(target);
            }
        }

        /**
         * Move a node in screen space
         */
        function dragTo(node, x, y) {

            // Get the movement plane
            const normal = camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const ray = camera.getLine(x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));

            const worldOffset = subtract(point, node.hitPoint);

            camera.target = subtract(camera.target, worldOffset);
            camera.position = subtract(camera.position, worldOffset);
        }

        /**
         * Move a node in screen space
         */
        function dragNodeTo(node, x, y) {

            // Get the movement plane
            const normal = camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const ray = camera.getLine(x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));


            // Get the origin transform for this node
            const transform = node.parent ? node.parent.world : identityMatrix();
            const inverse = invert(transform);

            const worldOffset = subtract(point, node.hitPoint);
            const offset = [
                inverse[0] * worldOffset[0] + inverse[4] * worldOffset[1] + inverse[8] * worldOffset[2],
                inverse[1] * worldOffset[0] + inverse[5] * worldOffset[1] + inverse[9] * worldOffset[2],
                inverse[2] * worldOffset[0] + inverse[6] * worldOffset[1] + inverse[10] * worldOffset[2],
            ];

            const translate = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...offset, 1];
            node.transform = matrixMultiply(node.transform, translate);
            node.hitPoint = point;
        }

        /**
         * Move a node in screen space
         */
        function rotateNode(node, x, y) {
            const inverse = invert(node.world);

            const zAxis = normalise(subtract(camera.target, camera.position));
            const xAxis = normalise(cross(zAxis, camera.up));
            const yAxis = normalise(cross(zAxis, xAxis));

            const rotateX = getRotationMatrix(-y, transformDirection(xAxis, inverse));
            const rotateY = getRotationMatrix(x, transformDirection(yAxis, inverse));

            node.transform = matrixMultiply(rotateX, node.transform);
            node.transform = matrixMultiply(rotateY, node.transform);
        }

        /**
         * Add a comment marker to the start of each line of the selected text
         */
        function comment(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                lines[firstLine + index] = `# ${line}`;
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start + 2;
            input.selectionEnd = end + (lastLine - firstLine) * 2;
        }

        /**
         * Remove comment from the selected text
         */
        function uncomment(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                lines[firstLine + index] = line.replace(/^(\s*)# ?/, '$1');
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start - 4;
            input.selectionEnd = Math.max(start - 4, end - (lastLine - firstLine) * 4);
        }

        /**
         * Indent the selected text
         */
        function indent(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                lines[firstLine + index] = `    ${line}`;
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start + 4;
            input.selectionEnd = end + (lastLine - firstLine) * 4;
        }

        /**
         * Remove indent from the selected text
         */
        function outdent(input) {
            const text = input.value;
            const lines = text.split(/\r?\n/);
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const firstLine = text.slice(0, start).split(/\n/).length - 1;
            const lastLine = text.slice(0, end).split(/\n/).length;
            lines.slice(firstLine, lastLine).forEach((line, index) => {
                if (line.charAt(0) === '\t') {
                    lines[firstLine + index] = line.slice(1);
                } else {
                    lines[firstLine + index] = line.replace(/^ {1,4}/, '');
                }
            });
            input.value = lines.join('\r\n');
            input.selectionStart = start - 4;
            input.selectionEnd = Math.max(start - 4, end - (lastLine - firstLine) * 4);
        }

        /**
         * Add touch controls to the given node
         */
        function addControls(node) {
            const start = {};
            let action;
            node.addEventListener('touchstart', (event) => {
                event.preventDefault();

                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;

                if (event.touches.length === 1) {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    const hits = pickNodes(x, y);
                    if (hits.length > 0) {
                        hits.sort((a, b) => a.hit[0] - b.hit[0]);
                        start.hit = hits[0];
                    } else {
                        start.hit = null;
                    }
                    action = 'click';
                } else if (event.touches.length === 2) {
                    start.second = {
                        x: event.touches[1].clientX,
                        y: event.touches[1].clientY,
                    };
                    action = 'pinch';
                }
                report(action);
            });

            node.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (action === 'pinch') {
                    const initial = Math.hypot(start.x - start.second.x, start.y - start.second.y);
                    const current = Math.hypot(event.touches[0].clientX - event.touches[1].clientX, event.touches[0].clientY - event.touches[1].clientY);

                    const offset = subtract(camera.position, camera.target);
                    const scale = current / initial;
                    camera.position = add(camera.target, scaled(offset, scale));

                    start.second.x = event.touches[1].clientX;
                    start.second.y = event.touches[1].clientY;
                } else if (action) {
                    action = 'drag';
                    const deltaX = event.touches[0].clientX - start.x;
                    const deltaY = event.touches[0].clientY - start.y;

                    if (start.hit) {
                        if (rotationControl.checked) {
                            rotateNode(start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.touches[0].clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.touches[0].clientY) / box.height) + 1;

                            dragTo(start.hit, x, y);
                        }
                    } else {
                        if (event.altKey) {
                            camera.yaw(deltaX / 10);
                            camera.pitch(deltaY / 10);
                        } else {
                            camera.rotateY(deltaX);
                            camera.rotateX(deltaY);
                        }
                    }
                }

                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;
            });

            node.addEventListener('touchend', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;
                    click(x, y);
                } else if (action === 'pinch') {
                    action = null;
                }
                node.classList.toggle('focus');
            });

            node.addEventListener('mousedown', (event) => {
                event.preventDefault();
                start.x = event.clientX;
                start.y = event.clientY;

                const box = node.getBoundingClientRect();

                const x = 2 * ((start.x - box.left) / box.width) - 1;
                const y = 2 * ((box.top - start.y) / box.height) + 1;

                const hits = pickNodes(x, y);
                if (hits.length > 0) {
                    hits.sort((a, b) => a.hit[0] - b.hit[0]);
                    start.hit = hits[0];
                } else {
                    start.hit = null;
                }
                action = 'click';
            });

            node.addEventListener('mousemove', (event) => {
                event.preventDefault();
                if (action) {
                    action = 'drag';
                    const deltaX = event.clientX - start.x;
                    const deltaY = event.clientY - start.y;

                    if (start.hit) {
                        if (rotationControl.checked || event.buttons & 4) {
                            rotateNode(start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.clientY) / box.height) + 1;

                            if (event.ctrlKey) {
                                dragNodeTo(start.hit, x, y);
                            } else {
                                dragTo(start.hit, x, y);
                            }
                        }
                    } else {
                        if (event.altKey) {
                            camera.yaw(deltaX / 10);
                            camera.pitch(deltaY / 10);
                        } else {
                            camera.rotateY(deltaX);
                            camera.rotateX(deltaY);
                        }
                    }
                    start.x = event.clientX;
                    start.y = event.clientY;
                }
            });

            node.addEventListener('mouseup', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    click(x, y);
                }
                action = null;
            });

            node.addEventListener('wheel', (event) => {
                const dist = event.deltaY / 1000;
                camera.zoom(dist);
                report(dist);
            });

            const input = document.getElementById('input');
            input.addEventListener('keydown', (event) => {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    if (event.shiftKey) {
                        outdent(input);
                    } else {
                        indent(input);
                    }
                }
            });

            document.getElementById('start').addEventListener('click', (event) => state.action = 'start');
            document.getElementById('rewind').addEventListener('click', (event) => state.action = 'rewind');
            document.getElementById('play').addEventListener('click', (event) => state.action = 'play');
            document.getElementById('forward').addEventListener('click', (event) => state.action = 'forward');
            document.getElementById('end').addEventListener('click', (event) => state.action = 'end');
        }

        /**
         * Add an overlay for the specified node
         */
        function addOverlay(node) {
            const box = document.getElementById('scene').getBoundingClientRect();
            const container = document.createElement('div');
            container.classList.add('overlay', 'fixed');

            const updateOverlay = (projectionMatrix) => {
                const modelViewMatrix = matrixMultiply(node.world, scene.modelViewMatrix);

                const transform = matrixMultiply(modelViewMatrix, scene.projectionMatrix);
                const position = transform4([0, 0, 0], transform);
                const x = box.left + (position[0] / position[3] + 1) * box.width / 2;
                const y = box.bottom - (position[1] / position[3] + 1) * box.height / 2;

                container.style.left = `${x}px`;
                container.style.top = `${y}px`;
                container.innerHTML = `<span>${node.name}</span><br>Position: <span>${node.transform.slice(12, 15).map((p) => p.toFixed(2)).join(', ')}</span>`;
            }
            updateOverlay(scene.projectionMatrix);

            document.body.appendChild(container);
            node.overlay = { container, updateOverlay };
            return node.overlay;
        }

        /**
         * Add an overlay for the specified node
         */
        function removeOverlay(node) {
            if (node.overlay) {
                node.overlay.container.remove();
                const pos = scene.overlays.indexOf(node.overlay);
                if (pos > -1) {
                    scene.overlays.splice(pos, 1);
                }
                node.overlay = null;
            }
        }

        /**
         * Display element
         */
        function showEntry(name, value, stack = []) {
            if (Array.isArray(value)) {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (array[${value.length}])`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                /*
                for (let i = 0; i < value.length; ++i) {
                    if (stack.includes(value[i])) {
                        content.append(showEntry(name, '...'));
                    } else {
                        stack.push(value[i]);
                        content.append(showEntry(`${i}`, value[i], stack));
                        stack.pop();
                    }
                }
                */
                return container;
            } else if (value === undefined) {
                return `${name}: undefined`;
            } else if (value === null) {
                return `${name}: null`;
            } else if (value && typeof (value) === 'object') {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (object)`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                /*
                Object.entries(value).forEach(([key, element]) => {
                    if (stack.includes(element)) {
                        content.append(showEntry(key, '...'));
                    } else {
                        stack.push(element);
                        content.append(showEntry(key, element, stack));
                        stack.pop();
                    }
                });
                */
                return container;
            }
            const container = document.createElement('div');
            container.innerText = `${name}: ${value}`;
            container.classList.add('entry');
            return container;
        }

        /**
         * Display the details for a deployed node.
         */
        function showDeployedNodeDetails(node) {
            scene.nodes.forEach((node) => node.hit = null);
            tree.nodes.forEach((node) =>
                node.nodes.forEach((node) => node.classList.remove('selected')));
            if (node.sceneNode) {
                node.sceneNode.hit = true;
            }
            node.nodes.forEach((node) => node.classList.add('selected'));
            const detailNode = document.querySelector('.detail');
            detailNode.innerHTML = '';
            Object.entries(node).map(([key, value]) =>
                detailNode.append(showEntry(key, value, [value])));

            // Show the source node.
            input = document.getElementById('input');
            const lines = input.value.split(/\r?\n/);
            const position = input.scrollHeight * (node.source.lineNumber - 1) / lines.length;
            input.focus();
            input.scrollTo(0, position);
            const start = lines.slice(0, node.source.lineNumber - 1).reduce((total, line) => total + line.length + 1, 0);
            input.selectionStart = start;
            input.selectionEnd = start + lines[node.source.lineNumber - 1].length;
        }

        /**
         *
         */
        let paused = false;
        let state = { time: 0, rate: 1, mode: 'paused', nextEvent: 0 };

        /**
         * Update the line numbers for a textarea element
         */
        function updateLineNumbers(main, lineNumbers) {
            const count = main.value.split(/\n/g).length;
            lineNumbers.value = '';
            const numbers = Array(count).fill(0).map((e, i) => i + 1);
            lineNumbers.value = numbers.join('\r\n');
            lineNumbers.cols = 1 + (count + '').length;
        }

        const actions = {};


        /**
         * Add drag control to an element
         */
        function addElementDrag(node) {
            const start = {};

            const moveNode = (eventX, eventY) => {
                const dx = eventX - start.mouseX;
                const dy = eventY - start.mouseY;
                const x = start.elementX + dx;
                const y = start.elementY + dy;
                node.style.position = 'absolute';
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.style.right = 'auto';
            }
            const mouseMove = (event) => {
                moveNode(event.clientX, event.clientY);
            }
            const touchMove = (event) => {
                moveNode(event.touches[0].clientX, event.touches[0].clientY);
            }

            node.addEventListener('mousedown', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.clientX;
                start.mouseY = event.clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.mouseMove = mouseMove;
                actions.mouseUp = (event) => actions.mouseMove = null;
            });


            node.addEventListener('touchstart', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.touches[0].clientX;
                start.mouseY = event.touches[0].clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.touchMove = touchMove;
                actions.touchEnd = (event) => actions.touchMove = null;
            });
        }

        /**
         * Update the layout based on the selection
         */
        function updateLayout(event) {
            const selectedLayout = parseInt(event.target.value);
            const layout = document.querySelector('.layout');

            const sourceView = document.getElementById('edit');
            const treeView = document.querySelector('.expanded-tree');
            const topView = document.getElementById('top-view-container');
            const dynamicView = document.getElementById('scene-container');
            const detailView = document.querySelector('.detail');

            const reset = (node) => {
                node.style.zIndex = null;
                node.style.gridColumn = null;
                node.style.gridRow = null;
                node.style.display = null;
                shaderView.hide();
            }

            const resetAll = () => {
                layout.style.gridTemplateColumns = null;
                layout.style.gridTemplateRows = null;
                reset(sourceView);
                reset(treeView);
                reset(topView);
                reset(dynamicView);
                reset(detailView);
            }

            const gridLayout = () => {
                resetAll();
            }

            const setView = (view) => {
                resetAll();
                if (view === shaderView) {
                    sourceView.style.display = 'none';
                    treeView.style.display = 'none';
                    topView.style.display = 'none';
                    dynamicView.style.display = 'none';
                    detailView.style.display = 'none';
                    layout.style.gridTemplateColumns = '1fr 1fr';
                    layout.style.gridTemplateRows = 'min-content 1fr 1fr';
                    view.show();
                } else if (view) {
                    sourceView.style.display = 'none';
                    treeView.style.display = 'none';
                    topView.style.display = 'none';
                    dynamicView.style.display = 'none';
                    detailView.style.display = 'none';
                    layout.style.gridTemplateColumns = '1fr';
                    layout.style.gridTemplateRows = 'min-content 1fr';
                    view.style.gridColumn = '1 / -1';
                    view.style.gridRow = '2 / -1';
                    view.zIndex = 5;
                    view.style.display = null;
                }
            }

            const views = [null, sourceView, treeView, dynamicView, topView, detailView, shaderView];
            setView(views[selectedLayout]);
        }

        /**
         * Create a shader view
         */
        function createShaderView() {
            const layout = document.querySelector('.layout');

            const vertexEditor = new Editor(layout);
            const fragmentEditor = new Editor(layout);
            const buildButton = document.createElement('button');
            layout.appendChild(buildButton);
            buildButton.innerHTML = 'Build';

            const show = () => {
                const removeIndent = (text) => {
                    const lines = text.split(/\n/);
                    const indent = Math.min(...lines.filter((line) => line.length).map((line) => line.length - line.trimStart().length));
                    return lines.map((line) => line.slice(indent)).join('\n');
                };
                vertexEditor.value = removeIndent(vsSource2);
                fragmentEditor.value = removeIndent(fsSource4);
                vertexEditor.container.style.display = 'flex';
                fragmentEditor.container.style.display = 'flex';
                vertexEditor.container.style.gridColumn = 1;
                vertexEditor.container.style.gridRow = 2;
                fragmentEditor.container.style.gridColumn = 2;
                fragmentEditor.container.style.gridrow = 2;
                buildButton.style.display = 'inline-block';
            };

            const hide = () => {
                vertexEditor.container.style.display = 'none';
                fragmentEditor.container.style.display = 'none';
                buildButton.style.display = 'none';
            };

            const build = () => {
                const shader = initialiseShaders(scene.gl, vertexEditor.value, fragmentEditor.value);
            }

            buildButton.addEventListener('click', (event) => build());
            
            hide();

            return {show, hide, vertexEditor, fragmentEditor};
        }

        const shaderView = createShaderView();


        /**
         * Toggle fullscreen mode
         */
        function toggleFullscreen() {
            if (document.body.webkitRequestFullscreen) {
                if (document.body.webkitIsFullScreed) {
                    document.body.webkitCancelFullScreen();
                } else {
                    document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                }
            }
            if (document.body.requestFullscreen) {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.body.requestFullscreen();
                }
            }
        }


        /**
         *
         */
        function main() {
            const canvas = document.getElementById('scene');
            const view2 = document.getElementById('top-view');

            document.body.addEventListener('mousemove', (event) => {
                if (actions.mouseMove) {
                    actions.mouseMove(event);
                }
            });
            document.body.addEventListener('mouseup', (event) => {
                if (actions.mouseUp) {
                    actions.mouseUp(event);
                }
            });

            document.body.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (actions.touchMove) {
                    actions.touchMove(event);
                }
            });
            document.body.addEventListener('touchend', (event) => {
                if (actions.touchEnd) {
                    actions.touchEnd(event);
                }
            });
            addElementDrag(document.getElementById('overlay'));

            addControls(canvas);

            const layoutSelection = document.getElementById('layout-selection');
            layoutSelection.addEventListener('change', updateLayout);

            const fullscreen = document.getElementById('fullscreen');
            fullscreen.addEventListener('click', toggleFullscreen);

            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            scene.gl = canvas.getContext('webgl');

            view2.width = view2.clientWidth;
            view2.height = view2.clientHeight;
            topView = new View2d(scene, 'top-view');
            topView.width = view2.clientWidth;
            topView.Height = view2.clientHeight;

            const shader = initialiseShaders(scene.gl, vsSource, fsSource);
            const shader2 = initialiseShaders(scene.gl, vsSource, fsSource2);
            const shader3 = initialiseShaders(scene.gl, vsSource2, fsSource3);
            const shader4 = initialiseShaders(scene.gl, vsSource2, fsSource4);

            scene.shader = {
                program: shader,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader, 'aVertexPosition'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader, 'uModelViewMatrix'),
                colourLocation: scene.gl.getUniformLocation(shader, 'uColour'),
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                },
            };

            scene.shader2 = {
                program: shader2,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader2, 'aVertexPosition'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader2, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader2, 'uModelViewMatrix'),
                colourLocation: scene.gl.getUniformLocation(shader2, 'uColour'),
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                },
            };

            scene.shader3 = {
                program: shader3,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader3, 'aPosition'),
                    vertexNormal: scene.gl.getAttribLocation(shader3, 'aNormal'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader3, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader3, 'uModelViewMatrix'),
                normalMatrixLocation: scene.gl.getUniformLocation(shader3, 'uNormalMatrix'),

                lightPosition: scene.gl.getUniformLocation(shader3, 'uLightPosition'),
                colourLocation: scene.gl.getUniformLocation(shader3, 'uDiffuseColor'),
                specularColour: scene.gl.getUniformLocation(shader3, 'uSpecularColor'),
                shininess: scene.gl.getUniformLocation(shader3, 'uShininess'),

                light: {
                    position: [2, 10, -5],
                },
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                    gl.uniform3fv(this.specularColour, node.specularColour || [0.8, 0.9, 0.3]);
                    gl.uniform1f(this.shininess, node.shininess);
                },
            };
            scene.shader4 = {
                program: shader4,
                attribLocations: {
                    vertexPosition: scene.gl.getAttribLocation(shader4, 'aPosition'),
                    vertexNormal: scene.gl.getAttribLocation(shader4, 'aNormal'),
                },
                projectionMatrixLocation: scene.gl.getUniformLocation(shader4, 'uProjectionMatrix'),
                modelViewMatrixLocation: scene.gl.getUniformLocation(shader4, 'uModelViewMatrix'),
                normalMatrixLocation: scene.gl.getUniformLocation(shader4, 'uNormalMatrix'),

                lightPosition: scene.gl.getUniformLocation(shader4, 'uLightPosition'),
                colourLocation: scene.gl.getUniformLocation(shader4, 'uDiffuseColor'),
                specularColour: scene.gl.getUniformLocation(shader4, 'uSpecularColor'),
                shininess: scene.gl.getUniformLocation(shader4, 'uShininess'),

                light: {
                    position: [2, 10, -5],
                },
                setNodeData(gl, node) {
                    if (node.hit) {
                        gl.uniform4fv(node.shader.colourLocation, [1, 0, 0, 1]);
                    } else {
                        gl.uniform4fv(node.shader.colourLocation, node.colour);
                    }
                    gl.uniform3fv(this.specularColour, node.specularColour || [0.8, 0.9, 0.3]);
                    //gl.uniform3fv(this.specularColour, [0.8, 0.9, 0.3]);
                    gl.uniform1f(this.shininess, node.shininess);
                },
            };

            // Set clear color to black, fully opaque
            const clearColour = [0, 0, 0].map((e, i) => background.colour[i] || e);
            scene.gl.clearColor(...clearColour, 1.0);
            // Clear the color buffer with specified clear color
            scene.gl.clear(scene.gl.COLOR_BUFFER_BIT);

            const lightX = document.getElementById('light-x');
            const lightY = document.getElementById('light-y');
            const lightZ = document.getElementById('light-z');

            lightX.value = scene.shader3.light.position[0];
            lightY.value = scene.shader3.light.position[1];
            lightZ.value = scene.shader3.light.position[2];

            lightX.addEventListener('input', () => {
                scene.shader3.light.position[0] = lightX.value;
                scene.shader4.light.position[0] = lightX.value;
            });
            lightY.addEventListener('input', () => {
                scene.shader3.light.position[1] = lightY.value;
                scene.shader4.light.position[1] = lightY.value;
            });
            lightZ.addEventListener('input', () => {
                scene.shader3.light.position[2] = lightZ.value;
                scene.shader4.light.position[2] = lightZ.value;
            });

            const reset = document.getElementById('reset');
            reset.addEventListener('click', () => camera.reset());

            //const treeNode = document.querySelector('.tree');
            const expandedTreeNode = document.querySelector('.expanded-tree');

            const input = document.getElementById('input');

            const deployedNodeActions = {
                click: (event, node) => showDeployedNodeDetails(node),
            };

            input.addEventListener('input', (event) => {
                localStorage.setItem('structure', input.value);
                const structure = getStructure(input.value);
                const deployed = parseStructure(structure);
                expandedTreeNode.innerHTML = '';
                getGraph(deployed, scene);
                expandedTreeNode.appendChild(getView(deployed, deployedNodeActions));
                //treeNode.innerHTML = '';
                //treeNode.appendChild(getView(parseStructure(structure)));
                const lines = document.querySelector('.line-numbers');
                updateLineNumbers(input, lines);
            });

            const structure = getStructure(input.value);
            const fullStructure = parseStructure(structure);
            const definition = parseStructure(structure);

            //treeNode.appendChild(getView(definition));
            //expandedTreeNode.appendChild(getView(fullStructure));

            document.getElementById('comment').addEventListener('click',
                (event) => {
                    comment(input);
                    input.focus();
                });
            document.getElementById('uncomment').addEventListener('click',
                (event) => {
                    uncomment(input);
                    input.focus();
                });
            document.getElementById('indent').addEventListener('click',
                (event) => {
                    indent(input);
                    input.focus();
                });
            document.getElementById('outdent').addEventListener('click',
                (event) => {
                    outdent(input);
                    input.focus();
                });


            scene.buffers = {
                vertex: scene.gl.createBuffer(),
                indices: scene.gl.createBuffer(),
            }
            //makeGraph(scene, bases, components);

            const content = localStorage.getItem('structure');
            if (content) {
                input.value = content;
                const structure = getStructure(content);
                const deployed = parseStructure(structure);
                expandedTreeNode.innerHTML = '';
                getGraph(deployed, scene);
                expandedTreeNode.appendChild(getView(deployed, deployedNodeActions));
                //treeNode.innerHTML = '';
                //treeNode.appendChild(getView(parseStructure(structure)));
            }
            updateLineNumbers(input, document.querySelector('.line-numbers'));
            input.addEventListener('scroll', (event) =>
                document.querySelector('.line-numbers').scrollTop = input.scrollTop);

            render();
        }

        /**
         * Return a matrix representing a rotation
         */
        function getRotationMatrix(angle, axis) {
            angle *= Math.PI / 180;
            axis = normalise(axis);

            const a = Math.cos(angle / 2);
            const b = Math.sin(angle / 2) * axis[0];
            const c = Math.sin(angle / 2) * axis[1];
            const d = Math.sin(angle / 2) * axis[2];

            return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
            2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
            2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                0, 0, 0, a * a + b * b + c * c + d * d];
        }

        /**
         * Quaternion constructor
         *
         * @param {*} w
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Quaternion {
            constructor(w, x, y, z) {
                this.w = w === undefined ? 1 : w;
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
            }
            clone() {
                return new Quaternion(this.w, this.x, this.y, this.z);
            }
            static create(w, x, y, z) {
                var v;
                if (w instanceof Vector3d && x == undefined) {
                    return new Quaternion(0, w.x, w.y, w.z);
                } else if (w instanceof Vector3d) {
                    return Quaternion.createRotation(w, x);
                } else if (w && Array.isArray(w) && w.length === 4) {
                    return new Quaternion(w[0], w[1], w[2], w[3])
                } else if (w && w.w !== undefined) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else if (x instanceof Vector3d) {
                    return Quaternion.createRotation(x, w);
                } else if (w instanceof Quaternion) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else {
                    return new Quaternion(w === undefined ? 1 : w, x || 0, y || 0, z || 0);
                }
            }
            static createFromObject(obj) {
                return new Quaternion(obj.w, obj.x, obj.y, obj.z);
            }
            static createRotation(axis, angle) {
                const v = axis.normal();
                return new Quaternion(
                    Math.cos(angle / 2),
                    Math.sin(angle / 2) * v.x,
                    Math.sin(angle / 2) * v.y,
                    Math.sin(angle / 2) * v.z);
            }
            get length() {
                return Math.hypot(this.w, this.x, this.y, this.z);
            }

            get values() {
                return [this.w, this.x, this.y, this.z];

            }
            get inverse() {
                return this.conjugate();
            }
            get s() {
                return this.w;
            }
            get v() {
                return new Vector3d(this.x, this.y, this.z);
            }
            invert() {
                this.x *= -1;
                this.y *= -1;
                this.z *= -1;
                return this;
            }
            conjugate() {
                return new Quaternion(this.w, -this.x, -this.y, -this.z);
            }
            apply(v) {
                var vp = this.multiply(new Quaternion(0, v.x, v.y, v.z)).multiply(this.conjugate());
                return new Vector3d(vp.x, vp.y, vp.z);
                var u = new Vector3d(this.x, this.y, this.z);
                var s = this.w;
                var udotv = u.dotProduct(v);
                var udotu = u.dotProduct(u);
                var uxv = u.crossProduct(v);
                u.scale(2 * udotv);
                v.scale(s * s - udotu);
                uxv.scale(2 * s);
                return uxv.add(u).add(v);
            }
            rotate(other, angle) {
                if (angle !== undefined) {
                    other = Quaternion.createRotation(other, angle);
                }
                const s = this.s * other.s - this.v.dot(other.v);
                const v = other.v.scaled(this.s).add(this.v.scaled(other.s)).add(this.v.crossProduct(other.v));
                this.w = s;
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return;
            }
            scale(value) {
                this.w *= value;
                this.x *= value;
                this.y *= value;
                this.z *= value;
                return this;
            }
            scaled(value) {
                const result = this.clone();
                return result.scale(value);
            }
            multiply(other) {
                return new Quaternion(
                    this.w * other.w - this.x * other.x - this.y * other.y - this.z * other.z,// 1
                    this.w * other.x + this.x * other.w + this.y * other.z - this.z * other.y,// i
                    this.w * other.y - this.x * other.z + this.y * other.w + this.z * other.x,// j
                    this.w * other.z + this.x * other.y - this.y * other.x + this.z * other.w // k
                );
            }
            dot(other) {
                return this.w * other.w + this.x * other.x + this.y * other.y + this.z * other.z;
            }
            getMatrix() {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
                2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
                2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                    0, 0, 0, a * a + b * b + c * c + d * d];
            }
            setMatrix(matrix) {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                matrix[0] = a * a + b * b - c * c - d * d;
                matrix[1] = 2 * (b * c - a * d);
                matrix[2] = 2 * (b * d + a * c);
                matrix[3] = 0;
                matrix[4] = 2 * (b * c + a * d);
                matrix[5] = a * a - b * b + c * c - d * d;
                matrix[6] = 2 * (c * d - a * b);
                matrix[7] = 0;
                matrix[8] = 2 * (b * d - a * c);
                matrix[9] = 2 * (c * d + a * b);
                matrix[10] = a * a - b * b - c * c + d * d;
                matrix[11] = 0;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = 0;
                matrix[15] = a * a + b * b + c * c + d * d;
            }
        }


        /**
         * Vector3d constructor
         *
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Vector3d {
            constructor(x, y, z) {
                this.x = x || 0
                this.y = y || 0
                this.z = z || 0
            }
            static create(x, y, z) {
                if (x instanceof Vector3d) {
                    return x.clone();
                } else if (x && Array.isArray(x) && x.length === 3) {
                    return new Vector3d(x[0], x[1], x[2]);
                } else if (x && x.x !== undefined) {
                    return new Vector3d(x.x, x.y, x.z);
                }
                return new Vector3d(x, y, z);
            }
            clone() {
                return new Vector3d(this.x, this.y, this.z);
            }
            static createFromObject(obj) {
                return new Vector3d(obj.x, obj.y, obj.z);
            }
            get length() {
                return Math.hypot(this.x, this.y, this.z);
            }
            get array() {
                return [this.x, this.y, this.z, 0];
            }
            get array3() {
                return [this.x, this.y, this.z];
            }
            dotProduct(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            crossProduct(other) {
                return new Vector3d(this.y * other.z - this.z * other.y,
                    this.z * other.x - this.x * other.z,
                    this.x * other.y - this.y * other.x);
            }
            cross(other) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                this.x = y * other.z - z * other.y;
                this.y = z * other.x - x * other.z;
                this.z = x * other.y - y * other.x;
                return this;
            }
            normalise() {
                var n = this.length || 1;
                this.x /= n;
                this.y /= n;
                this.z /= n;
                return this;
            }
            normal() {
                var result = this.clone();
                return result.normalise()
            }
            scale(value) {
                this.x *= value
                this.y *= value
                this.z *= value
                return this
            }
            scaled(value) {
                var result = this.clone();
                return result.scale(value);
            }
            add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                return this;
            }
            subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                return this;
            }
            plus(other) {
                var result = this.clone();
                return result.add(other);
            }
            minus(other) {
                var result = this.clone();
                return result.subtract(other);
            }
            rotate(q, angle) {
                if (angle) {
                    q = Quaternion.createRotation(q, angle);
                }

                let s = q.w;
                let u = new Vector3d(q.x, q.y, q.z);
                let v = this.clone();

                this.cross(u).scale(2 * s)
                    .add(v.scaled(s * s - u.dot(u))).add(u.scaled(2 * v.dot(u)));
                return this;
            }
            transform(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];

                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            transform2(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];
                const w = matrix[3] * this.x + matrix[7] * this.y + matrix[11] * this.z + matrix[15];

                this.x = x / w;
                this.y = y / w;
                this.z = z / w;
                return this;
            }
            getProjection(rd) {
                if (rd === this.z) {
                    return { x: 0, y: 0 }
                } else {
                    return {
                        x: this.x / (1 + -this.z / rd),
                        y: -this.y / (1 + -this.z / rd)
                    }
                }
            }
        }

        /**
         *
         */
        const mat4 = {
            create: function () {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]
            },
            perspective: function (matrix, fieldOfView, aspect, zNear, zFar) {
                var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
                matrix[0] = f / aspect;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 0;
                matrix[4] = 0;
                matrix[5] = f;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = 0;
                matrix[9] = 0;
                matrix[10] = (zFar + zNear) / (zNear - zFar)
                matrix[11] = -1;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = (2 * zFar * zNear) / (zNear - zFar);
                matrix[15] = 1;
            },
            translate: function (input, output, change) {
                var m = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    change[0], change[1], change[2], 1
                ]
                this.multiply(input, m, output);
            },
            copy: function (input, output) {
                output[0] = input[0];
                output[1] = input[1];
                output[2] = input[2];
                output[3] = input[3];
                output[4] = input[4];
                output[5] = input[5];
                output[6] = input[6];
                output[7] = input[7];
                output[8] = input[8];
                output[9] = input[9];
                output[10] = input[10];
                output[11] = input[11];
                output[12] = input[12];
                output[13] = input[13];
                output[14] = input[14];
                output[15] = input[15];
            },
            rotate2d: function (input, output, angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                var m = [
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                ]
                var t = this.create();
                this.multiply(input, m, t);
                this.copy(t, output);
            },
            rotate: function (input, output, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                this.multiply(input, q.getMatrix(), output);
            },
            rotated: function (input, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                return matrixMultiply(input, q.getMatrix());
            },
            multiply: function (a, b, out) {
                var result = this.create();
                result[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
                result[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
                result[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
                result[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

                result[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
                result[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
                result[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
                result[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

                result[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
                result[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
                result[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
                result[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

                result[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
                result[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
                result[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
                result[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
                this.copy(result, out);
            },
            transpose: function (input, output) {
                var temp = this.create();
                this.copy(input, temp);
                output[1] = temp[4];
                output[2] = temp[8];
                output[3] = temp[12];
                output[4] = temp[2];
                output[6] = temp[9];
                output[7] = temp[13];
                output[8] = temp[2];
                output[9] = temp[6];
                output[11] = temp[14];
                output[12] = temp[3];
                output[13] = temp[7];
                output[14] = temp[11];
            },
            invert: function (input, output) {
                var x0 = input[0];
                var x1 = input[4];
                var x2 = input[8];
                var x3 = input[12];
                var x4 = input[1];
                var x5 = input[5];
                var x6 = input[9];
                var x7 = input[13];
                var x8 = input[2];
                var x9 = input[6];
                var x10 = input[10];
                var x11 = input[14];
                var x12 = input[3];
                var x13 = input[7];
                var x14 = input[11];
                var x15 = input[15];

                var a0 = x0 * x5 - x1 * x4;
                var a1 = x0 * x6 - x2 * x4;
                var a2 = x0 * x7 - x3 * x4;
                var a3 = x1 * x6 - x2 * x5;
                var a4 = x1 * x7 - x3 * x5;
                var a5 = x2 * x7 - x3 * x6;
                var b0 = x8 * x13 - x9 * x12;
                var b1 = x8 * x14 - x10 * x12;
                var b2 = x8 * x15 - x11 * x12;
                var b3 = x9 * x14 - x10 * x13;
                var b4 = x9 * x15 - x11 * x13;
                var b5 = x10 * x15 - x11 * x14;
                var invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

                output[0] = (+x5 * b5 - x6 * b4 + x7 * b3) * invdet;
                output[4] = (-x1 * b5 + x2 * b4 - x3 * b3) * invdet;
                output[8] = (+x13 * a5 - x14 * a4 + x15 * a3) * invdet;
                output[12] = (-x9 * a5 + x10 * a4 - x11 * a3) * invdet;
                output[1] = (-x4 * b5 + x6 * b2 - x7 * b1) * invdet;
                output[5] = (+x0 * b5 - x2 * b2 + x3 * b1) * invdet;
                output[9] = (-x12 * a5 + x14 * a2 - x15 * a1) * invdet;
                output[13] = (+x8 * a5 - x10 * a2 + x11 * a1) * invdet;
                output[2] = (+x4 * b4 - x5 * b2 + x7 * b0) * invdet;
                output[6] = (-x0 * b4 + x1 * b2 - x3 * b0) * invdet;
                output[10] = (+x12 * a4 - x13 * a2 + x15 * a0) * invdet;
                output[14] = (-x8 * a4 + x9 * a2 - x11 * a0) * invdet;
                output[3] = (-x4 * b3 + x5 * b1 - x6 * b0) * invdet;
                output[7] = (+x0 * b3 - x1 * b1 + x2 * b0) * invdet;
                output[11] = (-x12 * a3 + x13 * a1 - x14 * a0) * invdet;
                output[15] = (+x8 * a3 - x9 * a1 + x10 * a0) * invdet;

                return this;
            }
        }

        /**
         * Return the point of intersection of a line and plane, if line parallel to plane return undefined
         * @param {*} line 
         * @param {*} plane 
         */
        function linePlaneIntersection(line, plane) {
            var dv = plane.point.minus(line.point);
            var product = line.direction.dotProduct(plane.normal);
            if (product !== 0) {
                return line.direction.scaled(dv.dotProduct(plane.normal) / product).add(line.point);
            }
        }


        /**
         * Vector definition of a line
         */
        function Line(point, direction) {
            this.point = point.clone();
            this.direction = direction.clone();
        }

        /**
         *
         */
        Line.prototype = {
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t)
                return v.add(this.point)
            },
            intersection(other) {
                if (other instanceof Plane) {
                    return linePlaneIntersection(this, other)
                    return this.planeIntersection(other)
                } else {
                    return this.lineIntersection(other)
                }
            },
            planeIntersection(plane) {
                const v = this.direction.clone();
                const dv = plane.point.minus(this.point);
                const div = v.dot(plane.normal);
                if (div) {
                    var a = dv.dot(plane.normal) / div;
                    return v.scale(a).add(this.point);
                }
            },
            lineIntersection(line) {
                if ((this.direction.x * line.direction.y - this.direction.y * line.direction.x) !== 0) {
                    var s = (this.direction.x * (line.point.y - this.point.y) + this.direction.y * (line.point.x - this.point.x))
                        / (this.direction.x * line.direction.y - this.direction.y * line.direction.x)
                } else {
                    var s = (this.direction.z * (line.point.y - this.point.y) + this.direction.y * (line.point.z - this.point.z))
                        / (this.direction.z * line.direction.y - this.direction.y * line.direction.z)
                }
                return line.point.plus(this.direction.scaled(s));
            }
        }


        /**
         * Definition of a segment
         */
        class Segment {
            constructor(start, end) {
                this.start = start.clone();
                this.end = end.clone();
            }

            get direction() {
                return (this.end.minus(this.start)).normalise();
            }
            set direction(direction) {
                this.end = this.start.plus(direction);
            }
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t);
                return v.add(this.start);
            }
        }

        /**
         * Vector definition of a plane
         */
        function Plane(point, normal) {
            this.point = point.clone();
            this.normal = normal.clone();
            this.normal.normalise();
            this.bounds = [];
        }

        /**
         *
         */
        Plane.prototype = {
            intersection(other) {
                if (other instanceof Plane) {
                    return this.planeIntersection(other)
                } else {
                    return linePlaneIntersection(other, this)
                    return other.planeIntersection(this)
                }
            },
            planeIntersection(plane) {
                var d = this.normal.crossProduct(plane.normal)
                var v = d.crossProduct(this.normal)
                if (v.length === 0) {
                    return
                }
                var dv = plane.point.minus(this.point)
                var a = (dv.x * plane.normal.x + dv.y * plane.normal.y + dv.z * plane.normal.z) / (v.x * plane.normal.x + v.y * plane.normal.y + v.z * plane.normal.z)
                var p = v.scale(a).add(this.point)
                return new Line(p, d)
            },
            addBoundary(other) {
                this.bounds.push(other)
                other.bounds.push(this)
            },
            getBoundary() {
                var line = this.intersection(this.bounds[this.bounds.length - 1])
                var segments = []
                this.bounds.forEach(function (bound, index, all) {
                    var point = line.intersection(bound)
                    var segment = new Segment(point, point)
                    if (segments.length > 0) {
                        segments[segments.length - 1].end = point
                    }
                    segments.push(segment)
                    line = this.intersection(bound)
                }, this)
                segments[segments.length - 1].end = segments[0].start

                return segments
            }
        }

        /**
         *
         */
        class Triangle {
            constructor(p1, p2, p3) {
                this.p1 = Vector3d.create(p1);
                this.p2 = Vector3d.create(p2);
                this.p3 = Vector3d.create(p3);
            }
            get plane() {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                return new Plane(this.p1, n);
            }
            intersects(line) {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                const p = line.planeIntersection(new Plane(this.p1, n));
                if (p) {
                    const dt = (d1.x * d2.y - d2.x * d1.y);
                    if (dt !== 0 && d1.x !== 0) {
                        const t = (d1.x * (p.y - d1.y) + d1.y * (d1.x - p.x)) / dt;
                        const s = (p.x - t * d2.x - this.p1.x) / d1.x;
                        return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                    } else {
                        const dt = (d1.y * d2.z - d2.y * d1.z);
                        if (dt !== 0 && d1.y !== 0) {
                            const t = (d1.y * (p.z - d1.z) + d1.z * (d1.y - p.y)) / dt;
                            const s = (p.y - t * d2.y - this.p1.y) / d1.y;
                            return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                        } else {
                            const dt = (d1.z * d2.x - d2.z * d1.x);
                            if (dt !== 0 && d1.z !== 0) {
                                const t = (d1.z * (p.x - d1.x) + d1.x * (d1.z - p.z)) / dt;
                                const s = (p.z - t * d2.z - this.p1.z) / d1.z;
                                return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                            }
                        }
                    }
                }
                return false;
            }
        }
    </script>
</body>

</html>
