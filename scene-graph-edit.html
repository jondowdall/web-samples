<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>Structure View</title>
    <style>
        html {
            font-family: sans-serif;
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            width: 100vw;
            height: 100dvh;
            padding: 0.25rem;
            overflow: hidden;
            background-color: lightgray;
        }

        table,
        td,
        th {
            border-collapse: collapse;
        }

        td,
        th {
            border: 1px solid darkgray;
            padding: 0.2rem;
        }

        th {
            font-weight: bold;
            background-color: lightgray;
        }

        td {
            background-color: white;
        }

        .heading-row th {
            position: sticky;
            top: 0;
        }

        .undefined {
            background-color: lightblue;
        }

        #overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            position: fixed;
            bottom: 0;
            right: 0;
            z-index: 10;
            background: rgb(10, 10, 10, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
        }

        .overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            z-index: 10;
            background: rgb(10, 10, 50, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
            transform: translate(-50%, -50%);
            pointer-events: none;
            white-space: nowrap;
        }

        .fixed {
            position: fixed;
        }

        .shape {
            font-style: italic;
        }

        .scene-node {
            font-weight: bold;
        }

        .scene {
            flex-grow: 1;
        }

        .number {
            width: 40vw;
        }

        .existing-file {
            font-weight: bold;
        }

        .light-position {
            width: 100%;
        }

        .grid-tree-view .tree {
            display: grid;
            grid-template-columns: 1rem 1rem max-content 1fr 1fr;
            grid-auto-rows: min-content;
            grid-gap: 0;
        }

        .branch-content {
            margin-left: 1em;
            transition: max-height 0.3s ease-in;
        }

        .expander {
            display: inline-block;
            width: 1.1em;
            cursor: default;
        }

        .frame {
            position: relative;
            overflow: auto;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            background: lightblue;
            padding-left: 1rem;
            border-radius: 0.5rem;
            
            box-shadow: 1px 3px 5px 2px rgb(100, 100, 100, 0.75);
            margin-top: 0.1rem;
            margin-left: 0.1rem;
            margin-bottom: 0.5rem;
            margin-right: 0.5rem;

            transition: width 0.3s ease-in-out, height 0.3s ease-in-out;

            transition: filter 0.1s ease-in, box-shadow 0.2s;
            filter: blur(0.5px);
            filter: brightness(75%);
        }

        .selected-frame {
            filter: none;
            background: blue;
        }
        
        .frame-title {
            transform: rotate(-90deg);
            transform-origin: top left;
            position: absolute;
            bottom: 0;
            left: 0;
            font-size: 80%;
            font-style: italic;
            background: lightblue;
            padding: 0 0.5em;
            border-radius: 0.5em;
            z-index: 10;
        }

        .frame-content {
            overflow: auto;
            max-height: 100%;
        }

        .frame-control-toggle {
            position: absolute;
            z-index: 100;
            top: 0;
            right: 0;
        }

        .sidebar {
            position: absolute;
            top: 0;
            right: 0;
            width: 25%;
            height: 100%;
            overflow: auto;
            padding: 0.5em;
            z-index: 100;
            background: rgb(50, 50, 50, 0.1);
            transition: transform 1s ease-in-out;
        }
        
        .hide-right {
            transform: translate(110%, 0);
        }

        .hide-right90 {
            right: -20%;
        }
        
        .sidebar > .frame {
            padding-left: 0.5em;
            background: lightblue;
            box-shadow: 0px 3px 5px #333;
            border-radius: 0.5em;
            overflow: hidden;
            margin-bottom: 0.5em;
            margin-right: 0.5em;
            transition: width 0.3s ease-in-out, height 0.3s ease-in-out;
            min-width: 10vw;
            aspect-ratio: 4 / 3;
        }
        
        .frame:not(.sidebar *) {
            min-height: 100%;
        }

        .placeholder {
            border-radius: 2em;
            border: 4px dashed gray;
            overflow: hidden;
            
        }

        .sidebar > .placeholder {
            aspect-ratio: 4 / 3;
            margin-bottom: 0.5em;
            
        }
                
        .sidebar-view {
            background: white;
            overflow: auto;
            height: 100%;
            transition: opacity width height 0.2s;
        }

        .sidebar-view:focus-within {
            box-shadow: 3px 5px 8px #333;
        }
        
        .dragging {
            opacity: 50%;
            position: fixed;
            /*
            max-width: 30vw;
            max-height: 30vh;
            aspect-ratio: 4 / 3;
            */
            z-index: 100;
            filter: blur(2px);
        }
        
        .close-button {
            position: absolute;
            right: 0;
            top: 0;
            background: white;
            text-align: center;
            border: none;
            border-radius: 0.5em;
            width: 1em;
            height: 1em;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: min-content 1fr;
            width: 100%;
            height: 100%;
            grid-gap: 2px;
            background-color: lightgray;
        }
        
        .layout-main {
            position: relative;
            overflow: hidden;
        }

        .layout-column {
            display: grid;
            background-color: lightgray;
            overflow: hidden;
            height: 100%;
        }

        .layout-row {
            display: grid;
            background-color: lightgray;
            overflow: hidden;
            height: 100%;
        }

        .vertical-bar {
            width: 2rem;
            cursor: ew-resize;
        }

        .horizontal-bar {
            height: 2rem;
            cursor: ns-resize;
        }


        .vertical-bar,
        .horizontal-bar {
            opacity: 50%;
            margin: -0.5rem -0.5rem -0.5rem -0.5rem;
        }

        .controls {
            grid-column: 1 / -1;
            grid-row: 1;
            position: relative;
        }

        .main-controls {
            z-index: 100;
            background: lightgray;
            display: flex;
        }

        #interactive-update {
            margin: 0 0.5em;
        }

        #secondary-controls {
            background: lightgray;
            border: 1px outset gray;
            padding: 0.25em;
            min-height: 2em;
            z-index: 50;
            position: absolute;
            top: 100%;
            left: 0;
            transition: transform 0.3s ease-in-out;
        }

        .hide-up {
            transform: translateY(calc(-100% - 5px));
        }

        .hide-left {
            transform: translateX(-100%);
        }

        .right {
            float: right;
        }

        #playback-contols {
            grid-column: 4 / 7;
        }

        .editor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .editor {
            display: flex;
            font-family: monospace;
            flex-grow: 1;
            tab-size: 4;
        }

        .line-numbers {
            text-align: end;
            background: lightgray;
            resize: none;
            overflow: hidden;
            font-variant-numeric: tabular-nums;
        }

        .shader-program-editor {
            display: grid;
            grid-template-columns: max-content 1fr;
        }

        .shader-program-editor .update {
            grid-column: 1 / -1;
        }

        .shader-program-editor .uniforms {
            grid-column: 1 / -1;
        }

        .view {
            background: lightgray;
        }
        
        .view-selection {
            text-align: center;
        }

        .view-selection li {
            list-style: none;
            color: blue;
        }

        .main {
            flex-grow: 1;
            resize: none;
        }

        #input {
            width: 100%;
            height: 100%;
            overflow: auto;
            grid-column: 1 / -1;
            flex-grow: 1;
            resize: none;
            font-family: monospace;
            /*white-space: nowrap;*/
        }

        .clock-view {
            position: relative;
            overflow: hidden;
            height: 100%;
            max-width: 100%;
        }

        .full-canvas {
            position: relative;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background: black;
        }

        .detail-view {
            height: 100%;
            width: 100%;
            padding: 0.25rem;
        }
        
        .diagram-view {
            position: relative;
            overflow: hidden;
            height: 100%;
            max-width: 100%;
        }

        .diagram {
            position: relative;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        .gl-view {
            position: relative;
            overflow: hidden;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .svg-view {
            width: 100%;
            height: 100%
        }

        #top-view-container {
            position: relative;
            overflow: hidden;
        }

        #top-view {
            width: 100%;
            height: 100%;
        }

        .structure-tree {
            overflow: auto;
        }

        .search-controls {
            display: flex;
        }

        .search {
            border-radius: 50px;
            flex-grow: 1;
            outline: none;
        }

        .detail {
            position: relative;
            overflow: auto;
        }

        
        .calendar-view h2 {
            position: relative;
            margin-top: 0.5rem;
            padding: 0 2rem;
        }

        .calendar-view .previous-month {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .calendar-view .next-month {
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
        }

        .calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            justify-items: center;
            overflow: hidden;
            border-radius: 0.3em;
            background: white;
            margin: 0.2em;
        }

        .calendar-day {
            padding: 0.3em 0.3em 1em;
            border-radius: 0.3em;
            position: relative;
            top: 1px;
            left: 1px;
            width: calc(100% - 4px);
            height: calc(100% - 4px);
            text-align: center;
        }

        .calendar-day-weekend {
            background: lightgray;
        }
        
        .calendar-day-shade {
            color: gray;
        }


        .vector-sliders {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
        }

        .group {
            position: relative;
            border-left: 1px solid gray;
            border-top-left-radius: 0.5em;
            border-bottom-left-radius: 0.5em;

            border: 1px solid gray;
            border-radius: 0.5em;
            margin: 0 1px;

            transition: max-height 0.3s ease-in;
        }

        .expand {
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
            transition: max-height 0.3s ease-in;
            max-height: 1.2em;
            overflow: hidden;
        }

        .shader-controls {
            display: flex;
        }

        .shader-name {
            flex-grow: 1;
        }

        .content {
            white-space: nowrap;
            max-height: 1.2em;
            transition: max-height 0.3s ease-in;
            overflow: hidden;
        }

        .range {
            font-style: italic;
            color: blue;
        }

        .control-node {
            font-style: italic;
            color: blue;
        }

        .range-expanded {
            font-style: italic;
            color: lightgray;
        }

        .collapse {
            max-height: 0;
            /*border: none;*/
        }

        .entry {
            padding-left: 1.1em;
        }

        .entry-content {
            padding-left: 1.1em;
        }

        .selected {
            background-color: yellow;
            fill: yellow !important;
        }

        .media-button {
            padding: 0;
            margin: 0;
            background: none;
            border: none;
            font-size: 150%;
        }

        #external-names {
            grid-column: 1 / -1;
            grid-row: 4;
            overflow: auto;
            padding: 0.5rem;
        }

        .header {
            background-color: lightgray;
            font-weight: bold;
            position: sticky;
            padding: 0.25rem;
            text-align: center;
        }

        .cell {
            background-color: white;
            padding: 0.25rem;
            width: 100%;
        }

        .attributes,
        .uniforms {
            display: grid;
            grid-gap: 1px;
        }

        .attributes {
            grid-template-columns: repeat(3, 1fr);
        }

        .uniforms {
            grid-template-columns: repeat(4, 1fr);
        }

        .settings {
            z-index: 10;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            /*            height: 100%; */
            background: lightgray;
            display: grid;
            grid-template-columns: max-content 1fr;
            box-shadow: 0px 3px 5px #333;
            transition: transform 0.3s ease-in-out;
        }

        .settings label {
            text-align: right;
        }

        .hidden {
            display: none !important;
        }

        .hide {
            max-height: 0;
            overflow: hidden;
        }

        #search-button {
            width: 100px;
            height: 50px;
        }

        #search-button svg {
            width: 25px;
            height: 25px;
        }

        .svg-icon {
            width: 16px;
            height: 16px;
        }
    </style>
</head>

<body>
    <div id="overlay"></div>
    <datalist id="shader-object-list"></datalist>
    <datalist id="shader-program-list"></datalist>
    <template id="frame-template">
        <div class="frame"></div>
    </template>

    <template id="editor-template">
        <div class="view editor-container">
            <div>
                <button class="comment">Comment</button>
                <button class="uncomment">Uncomment</button>
                <button class="unindent">&larr;</button>
                <button class="indent">&rarr;</button>
                <input class="spell-check" type="checkbox" />
            </div>
            <div class="editor">
                <textarea class="line-numbers"></textarea>
                <textarea class="main" wrap="off" spellcheck="false" autocapitalize="off"></textarea>
            </div>
            <div class="settings hide-up">
                <label>Shader:</label>
                <input class="shader-name" type="text" placeholder="Shader Name" list="shader-object-list" />
            </div>
        </div>
    </template>

    <template id="shader-program-editor-template">
        <div class="view shader-program-editor">
            <label>View: </label>
            <select class="gl-view-selection"></select>
            <label>Name: </label>
            <input class="program-name" type="text" list="shader-programs /">
            <label>Vertex Shader:</label>
            <select class="vertex-shader"></select>
            <label>Fragment Shader:</label>
            <select class="fragment-shader"></select>
            <button class="update">Update</button>
            <div class="uniforms"></div>
        </div>
    </template>

    <template id="tree-view-template">
        <div class="view tree-view">
            <div class="search-controls">
                <input class="search" type="text" />
            </div>
            <div class="tree"></div>
            <div class="settings hide-up">
                <label>Case Sensitive: </label>
                <input class="case-sensitive" title="Case Sensitive" type="checkbox" />
                <label>Regular Expression: </label>
                <input class="regular-expression" title="Regular Expression" type="checkbox" checked />
            </div>
        </div>
    </template>

    <template id="grid-tree-view-template">
        <div class="view grid-tree-view">
            <!--div class="search-controls">
                <input class="search" type="text" />
                <input class="case-sensitive" title="Case Sensitive" type="checkbox" />
                <input class="regular-expression" title="Regular Expression" type="checkbox" checked />
            </div-->
            <div class="tree"></div>
            <div class="settings hide-up"></div>
        </div>
    </template>

    <template id="shader-controls-template">
        <div class="view shader-controls">
            <input class="shader-name" placeholder="Shader Name" list="shader-list">
            <button class="build-shader">Build</button>
        </div>
    </template>

    <template id="diagram-view-template">
        <div class="view diagram-view">
            <canvas class="diagram" tabindex="1"></canvas>
            <div class="settings hide-up">
            </div>
    </template>

    <template id="gl-view-template">
        <div class="view gl-view">
            <div id="light-direction" class="vector-sliders">
                <input class="light-x light-position" type="range" min="-100" max="100" value="-75">
                <input class="light-y light-position" type="range" min="-100" max="100" value="-90">
                <input class="light-z light-position" type="range" min="-100" max="100">
            </div>
            <canvas class="scene" tabindex="1"></canvas>
            <div class="settings hide-up">
                <label for="split">Split</label><input class="split" type="checkbox">
                <label for="move">Move</label><input class="move" type="checkbox">
                <button class="reset" style="margin:0;padding:0;">
                    <svg id="upright-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M18 1 L16 9 L21 11 M20 7 L16 9" stroke="gray" fill="none" />
                        <path d="M12 4 L12 12 L20 12" stroke="black" fill="none" />
                        <circle cx="12" cy="12" r="3" stroke="black" fill="none" />
                    </svg>
                </button>
                <button class="upright">
                    <svg id="upright-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M12 21 L21 6" stroke="lightgray" fill="none" />
                        <path d="M12 21 L12 3 M21 6 A18 18 0 0 0 12 3 L15 1.5 L14.5 5 L12 3" stroke="black"
                            fill="none" />
                    </svg>
                </button>
                <label for="depth-test">Depth Test</label><input class="depth-test" type="checkbox" checked>
            </div>
        </div>
    </template>

    <template id="svg-view-template">
        <div class="view svg-view">
            <svg class="svg" viewBox="0 0 1024 1024" width="1024" height="1024"></svg>
            <div class="settings hide-up">
                <label>Nodes: </label><input class="root-nodes" type="text" value="svg" />
                <label>Filter: </label><input class="filter" type="text" />
                <label>Context: </label><select class="context-selection"></select>
            </div>
        </div>
    </template>

    <template id="table-view-template">
        <div class="view table-view">
            <table>
                <thead></thead>
                <tbody></tbody>
            </table>
            <div class="settings hide-up">
                <label>Headings: </label><select class="headings-list" multiple="true"></select>
                <label>Hide Empty Rows: </label><input class="hide-empty-rows" type="checkbox" />
            </div>
        </div>
    </template>

    <template id="detail-view-template">
        <div class="view detail-view">
            <h2 class="title"></h2>
            <div class="detail"></div>
            <div class="settings hide-up">
                <label>Update: </label><input class="auto-update" type="checkbox" checked>
                <label>Context: </label><select class="context-selection"></select>
            </div>
        </div>
    </template>

    <template id="clock-view-template">
        <div class="view clock-view">
            <canvas class="full-canvas">Argh, no canvas how old is this browser?</canvas>
            <div class="settings hide-up">
                <label>Update: </label><input class="auto-update" type="checkbox" checked>
                <label>Context: </label><select class="context-selection"></select>
            </div>
        </div>
    </template>

    <template id="calendar-view-template">
        <div class="view calendar-view">

            <h2 class="month">
                <button class="previous-month">&lt;</button>
                <span class="month-label"></span>
                <button class="next-month">&gt;</button>
            </h2>
            <div class="calendar">
                <span>Mon</span>
                <span>Tue</span>
                <span>Wed</span>
                <span>Thu</span>
                <span>Fri</span>
                <span>Sat</span>
                <span>Sun</span>
            </div>
            
            <div class="settings hide-up">
                <label>Update: </label><input class="auto-update" type="checkbox" checked>
                <label>Context: </label><select class="context-selection"></select>
            </div>
        </div>
    </template>

    <div class="layout">
        <div class="controls">
            <div class="main-controls">
                <datalist id="files"></datalist>
                <div id="file-controls">
                    <input id="filename" list="files" placeholder="Name" value="New Scene">
                    <button id="save">&#x1F4BE;</button>
                    <button id="load">&#x1F4C2;</button>
                </div>
                <select id="view-selection"></select>
                <button id="view-settings">
                    <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="4" stroke="black" fill="none" />
                        <path
                            d="M12 19 L13.366 18.865 L15.827 21.239 L17.556 20.315 L16.950 16.950 L17.820 15.889 L21.239 15.827 L21.808 13.951 L19 12 L18.865 10.634 L21.239 8.173 L20.315 6.444 L16.950 7.050 L15.889 6.180 L15.827 2.761 L13.951 2.192 L12 5 L10.634 5.135 L8.173 2.761 L6.444 3.685 L7.050 7.050 L6.180 8.111 L2.761 8.173 L2.192 10.049 L5 12 L5.135 13.366 L2.761 15.827 L3.685 17.556 L7.050 16.950 L8.111 17.820 L8.173 21.239 L10.049 21.808 L12 19"
                            stroke="black" fill="none" />
                    </svg>
                </button>

                <div id="playback-controls">
                    <button id="start" class="media-button">&#x23ee;</button>
                    <button id="rewind" class="media-button">&#x23ea;</button>
                    <button id="play" class="media-button">&#x23ef;</button>
                    <button id="forward" class="media-button">&#x23e9;</button>
                    <button id="end" class="media-button">&#x23ed;</button>
                </div>
                <input id="interactive-update" type="checkbox" checked />
                <select id="add-view-selection"></select>
                <button id="toggle-secondary-controls">&#9776;</button>
                <button id="toggle-sidebar">Sidebar</button>
            </div>
            <div id="secondary-controls" class="hide-left">
                <!--button id="toggle-tabbed-layout">
                <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                    <path d="M0 10 L4 6 L10 6 L14 10 L24 10 L24 24 L0 24L 0 10 M12 8 L14 6 L18 6 L22 10"
                            stroke="black" fill="none"/>
                </svg>
            </button-->
                <button id="toggle-tabbed-layout">
                    <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M14 14 L24 14 L24 24 L14 24 L14 14 M12 24 L0 24 L0 0 L24 0 L24 12" stroke="black"
                            fill="none" />
                    </svg>
                </button>
                <button id="fullscreen">
                    <svg id="vertical-split-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M0 4 L0 0 L4 0 M20 0 L24 0 L 24 4 M24 20 L24 24 L20 24 M4 24 L0 24 L0 20"
                            stroke="black" fill="none" />
                    </svg>
                </button>
                <button id="add-column">
                    <svg id="vertical-split-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path
                            d="M0 6 L8 6 L8 22 L0 22L0 6 M8 6 L16 6 L16 22 L8 22 M16 0 L24 0 L24 16 L16 16 L16 0 M20 11 L20 18 L22 18 L20 20 L18 18 L20 18"
                            stroke="black" fill="none" />
                    </svg>
                </button>
                <button id="add-row">
                    <svg id="vertical-split-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path
                            d="M6 0 L6 8 L22 8 L22 0 L6 0 M6 8 L6 16 L22 16 L22 8 M0 16 L0 24 L16 24 L16 16 L0 16 M11 20 L18 20 L18 22 L20 20 L18 18 L18 20"
                            stroke="black" fill="none" />
                    </svg>
                </button>

                <button id="save-png">PNG</button>
                <button id="close-current-frame">&#10006;</button>

                <select id="view-type-selection"></select>
                <button id="hide-menu">&ShortLeftArrow;</button>
            </div>
        </div>
        <div class="layout-main">
            <div class="sidebar hide-right"></div>
        </div>

    </div>

    <script>
        /**
         *
         */
        addEventListener('load', function (e) {
            main();
        });

        /**
         * Display the text in overlay div.
         */
        function report(text, sep) {
            if (sep) {
                document.getElementById('overlay').innerText += sep + text;
            } else {
                document.getElementById('overlay').innerText = text;
            }
        }

        /**
         * Converts an HSL colour value to RGB. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSL_colour_space.
         * Assumes h, s, and l are contained in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         *
         * @param   {number}  h       The hue
         * @param   {number}  s       The saturation
         * @param   {number}  l       The lightness
         * @return  {Array}           The RGB representation
         */
        function hslToRgb(h, s, l) {
            var r, g, b;

            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                var hue2rgb = function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        /**
         * Utility function to support downloading generated content.
         */
        function download(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }

        /**
         * Save a canvas as png
         */
        function savePNG(canvas) {
            const data = canvas.toDataURL('image/png');
            //.replace(/^data:image\/[^;]*/, 'data:application/octet-stream');
            //.replace(/^data:image\/[^;]*/, 'data:application/octet-stream;headers=Content-Disposition%3A%20attachment%3B%20filename=canvas.png');

            // Create an anchor, and set the href value to our data URL
            const link = document.createElement('a');
            link.href = data;

            // This is the name of our downloaded file
            link.download = "download-this-canvas";

            // Click the download button, causing a download, and then remove it
            link.click();
            link.remove();
        }

        class FrameContainer {
            static all = [];
            constructor(...content) {
                this.node = document.createElement('div');
                this.node.classList.add('layout-row');
                this.bar = this.node.classList.contains('layout-row') ? uiControls.newVerticalBar : uiControls.newHorizontalBar;
                this.content = [];
                this.style = window.getComputedStyle(this.node);
                if (content.length) {
                    this.setContent(...content);
                }
                FrameContainer.all.push(this);
            }
            row() {
                if (this.node.classList.contains('layout-row')) {
                    return;
                }
                this.node.classList.add('layout-row');
                this.node.classList.remove('layout-column');

                this.bar = uiControls.newVerticalBar;

                for (const node of this.node.querySelectorAll(':scope > .horizontal-bar')) {
                    node.replaceWith(uiControls.newVerticalBar());
                }
                
                const content = Array.from(this.node.children).filter((s, i) => (i % 2) === 0);
                const style = window.getComputedStyle(this.node);

                if (style.gridTemplateRows) {
                    const sizes = style.gridTemplateRows.split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0); 
                    const total = sizes.reduce((sum, size) => sum + size, 0);   
                    this.node.style.gridTemplateColumns = sizes.map((size) => `${size / total}fr`).join(' min-content ');
                    this.node.style.gridTemplateRows = '1fr';
                } else {
                    this.node.style.gridTemplateColumns = content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateRows = '1fr';
                }
            }
            column() {
                if (!this.node.classList.contains('layout-row')) {
                    return;
                }
                this.node.classList.add('layout-column');
                this.node.classList.remove('layout-row');

                this.bar = uiControls.newHorizontalBar;

                for (const node of this.node.querySelectorAll(':scope > .vertical-bar')) {
                    node.replaceWith(uiControls.newHorizontalBar());
                }

                const content = Array.from(this.node.children).filter((s, i) => (i % 2) === 0);
                const style = window.getComputedStyle(this.node);

                if (style.gridTemplateColumns) {
                    const sizes = style.gridTemplateColumns.split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0); 
                    const total = sizes.reduce((sum, size) => sum + size, 0);   
                    this.node.style.gridTemplateRows = sizes.map((size) => `${size / total}fr`).join(' min-content ');
                    this.node.style.gridTemplateColumns = '1fr';
                } else {
                    this.node.style.gridTemplateRows = content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateColumns = '1fr';
                }
            }
            setContent(...content) {
                this.content = content;
                content.forEach((frame, index) => {
                    this.node.append(frame.node || frame);
                    if (index < this.content.length - 1) {
                        this.node.append(this.bar());
                    }
                });
                if (this.node.classList.contains('layout-row')) {
                    this.node.style.gridTemplateColumns = this.content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateRows = '1fr';
                } else {
                    this.node.style.gridTemplateRows = this.content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateColumns = '1fr';
                }
            }
            insert(view, bar) {
                const container = bar.parentElement;
                const gridTemplate = container.classList.contains('layout-row') ? 'gridTemplateColumns' : 'gridTemplateRows';
                const content = Array.from(container.children);
                const style = window.getComputedStyle(container);
                const sizes = style[gridTemplate].split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                
                const index = (1 + content.indexOf(bar)) / 2;
                const total = sizes.reduce((sum, size) => sum + size, 0);
                const newSize = sizes.map((size) => `${size / total}fr`);
                newSize.splice(index, 0, `${1 / sizes.length}fr`);

                if (container.classList.contains('layout-row')) {
                    container.insertBefore(uiControls.newVerticalBar(), bar);
                } else {
                    container.insertBefore(uiControls.newHorizontalBar(), bar);       
                }
                container.insertBefore(view, bar);
                container.style[gridTemplate] = newSize.join(' min-content ');
            }
            split(newFrame, existing, after) {
                const currentContainer = existing.parentElement;
                const container = new FrameContainer();
                if (currentContainer.classList.contains('layout-row')) {
                    container.column();
                }
                existing.replaceWith(container.node);
                if (after) {
                    container.setContent(existing, newFrame);
                } else {
                    container.setContent(newFrame, existing);
                }
            }
            remove(frame) {
                const content = Array.from(this.node.children);
                const heights = this.style.gridTemplateRows.split(' ').map((height) => parseFloat(height));
                const index = content.indexOf(frame.node);
                if (index === 0) {
                    frame.node.nextSibling.remove();
                    frame.node.remove();
                    heights.splice(index, 2);
                } else if (index > 0) {
                    frame.node.previousSibling.remove();
                    frame.node.remove();
                    heights.splice(index - 1, 2);
                }
                if (heights.length > 1) {
                    const sizes = heights.map((height, index) =>
                        (index % 2) ? 'min-content' : `${height}fr`);
                    this.node.style.gridTemplateRows = sizes.join(' ');
                } else {
                    const other = this.content.find((other) => other != frame);
                    this.node.replaceWith(other.node);
                    other.container = this.container;
                    if (this.container) {
                        this.container.content = this.container.content.map((frame) => frame === this ? other : frame);
                    }
                }
                const pos = FrameContainer.all.indexOf(this);
                if (pos > -1) {
                    FrameContainer.all.splice(pos, 1);
                }
            }
        }
        
        
        
        /**
         * Create nodes from a template
         */
        class Templated {
            constructor(templateName) {
                const template = document.getElementById(templateName);
                this.node = template.content.firstElementChild.cloneNode(true);
            }
            getNodes(map) {
                this.nodes = {};
                Object.entries(map).forEach(([name, selector]) => {
                    this.nodes[name] = this.node.querySelector(selector);
                    if (!this.nodes[name]) {
                        console.log(`Warning: selector ${selector} not found in template for ${this.constructor.name}`);
                    }
                });
            }
        }

        /**
         * Process the nodes based on the roots and filters.
         */
        function process(action, roots, filter) {
            const fullName = (node) => {
                const path = [node];
                while (node[symbols.container]) {
                    node = node[symbols.container];
                    path.unshift(node);
                }
                return path;
            }
            if (roots) {
                roots = roots.split(/;/).map((str) => str.trim())
                    .flatMap((name) => Core.find((node) => node.name === name || fullName(node).join('.') === name) || []);
            } else {
                roots = Core.structure;
            }

            if (filter) {
                const test = filter.split(/( AND | OR | && | \|\| |\(|\))/)
                    .map((item) => item.trim())
                    .map((test) => {
                        if (test === 'AND' || test === '&&') {
                            return '&&';
                        } else if (test === 'OR' || test === '||') {
                            return '||';
                        } else if (test === '(' || test === ')') {
                            return test;
                        } else if (test.startsWith('$')) {
                            return test.replace(/^\$/, 'node');
                        } else if (test.includes('=')) {
                            const [attr, value] = test.split('=');
                            return `node[${attr}] === ${value}`;
                        } else {
                            return `node[${test}] !== undefined`;
                        }
                    }).join(' ');
                filter = new Function('node', `return ${test};`);
            } else {
                filter = (node) => true;
            }

            const walk = (node) => {
                action(node);
                node[symbols.content].filter(filter).forEach((node) => walk(node));
            }
            roots.forEach((node) => walk(node));
        }

        /**
         * View component
         */
        class View extends Templated {
            constructor(templateName, settingsMap) {
                super(templateName);
                if (settingsMap) {
                    this.getSettingsNodes(settingsMap);
                }
                Core.views.push(this);
            }
            getSettingsNodes(settingsMap) {
                this.settings = {};
                Object.entries(settingsMap).forEach(([name, selector]) => {
                    this.settings[name] = this.node.querySelector(selector);
                    if (!this.settings[name]) {
                        console.log(`Warning: selector ${selector} not found in template for ${this.constructor.name}`);
                    }
                });
            }
            toggleSettings() {
                const settings = this.node.querySelector('.settings');
                if (settings) {
                    settings.classList.toggle('hide-up');
                }
            }
            update(time) {

            }
            remove() {
                Core.views = Core.views.filter((view) => view !== this);
            }
        }

        /**
        * Editor component
        */
        class Editor extends View {
            constructor(title = '', config = {}, settingsMap) {
                super('editor-template', settingsMap);
                this.config = config;
                this.lineNumbers = this.node.querySelector('.line-numbers');
                this.main = this.node.querySelector('.main');

                this.main.addEventListener('scroll', (event) =>
                    this.lineNumbers.scrollTop = this.main.scrollTop);

                this.main.addEventListener('input', (event) => this.updateLineNumbers());
                this.title = title;

                this.node.querySelector('.comment').addEventListener('click',
                    (event) => {
                        this.comment();
                        this.main.focus();
                    });
                this.node.querySelector('.uncomment').addEventListener('click',
                    (event) => {
                        this.uncomment();
                        this.main.focus();
                    });
                this.node.querySelector('.indent').addEventListener('click',
                    (event) => {
                        this.indent();
                        this.main.focus();
                    });
                this.node.querySelector('.unindent').addEventListener('click',
                    (event) => {
                        this.unindent();
                        this.main.focus();
                    });
                this.main.addEventListener('keydown', (event) => {
                    if (event.key === 'Tab') {
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.unindent();
                        } else {
                            this.indent();
                        }
                    }
                });
                this.updateLineNumbers();
            }
            updateLineNumbers() {
                const count = this.main.value.split(/\n/g).length;
                this.lineNumbers.value = '';
                const numbers = Array(count).fill(0).map((e, i) => i + 1);
                this.lineNumbers.value = numbers.join('\r\n');
                this.lineNumbers.cols = 1 + (count + '').length;
            }
            get value() {
                return this.main.value;
            }
            set value(text) {
                this.main.value = text;
                this.updateLineNumbers();
            }
            modifySelection(modify) {
                const text = this.value;
                const lines = text.split(/\r?\n/);
                const start = this.main.selectionStart;
                const end = this.main.selectionEnd;
                const firstLine = text.slice(0, start).split(/\n/).length - 1;
                const lastLine = text.slice(0, end).split(/\n/).length;

                lines.splice(firstLine, lastLine - firstLine, ...lines.slice(firstLine, lastLine).map(modify));

                this.value = lines.join('\r\n');
                this.main.selectionStart = start + 2;
                this.main.selectionEnd = end + (lastLine - firstLine) * 2;

            }
            /**
             * Add a comment marker to the start of each line of the selected text
             */
            comment() {
                const comment = this.config.comment || '#';
                this.modifySelection((line) => `${comment} ${line}`);
            }
            /**
             * Remove comment from the selected text
             */
            uncomment() {
                this.modifySelection((line) => line.replace(/^(?<indent>\s*)(#|\/\/) ?/, '$<indent>'));
            }
            /**
             * Indent the selected text
             */
            indent() {
                const indent = this.config.indent || '    ';
                this.modifySelection((line) => `${indent}${line}`);
            }
            /**
             * Remove indent from the selected text
             */
            unindent() {
                this.modifySelection((line) =>
                    line.charAt(0) === '\t' ? line.slice(1) : line.replace(/^ {1,4}/, ''));
            }
        }

        /**
         * Specialisation of Editor for editing the structure
         */
        class StructureEditor extends Editor {
            constructor(title, configuration) {
                super(title, configuration);
                this.value = Core.source;
                this.main.addEventListener('change', (event) => {
                    Core.source = this.value;
                });

                this.main.addEventListener('input', (event) => {
                    if (document.getElementById('interactive-update').checked) {
                        Core.source = this.value;
                    }
                    updateLineNumbers(Core.mainEditor.main, Core.mainEditor.lineNumbers);
                });
                const spellcheck = this.node.querySelector('.spell-check');
                spellcheck.addEventListener('change', (event) => {
                    this.main.spellcheck = spellcheck.checked;
                    this.main.focus();
                });
            }
            set source(source) {
                this.value = source;
            }
            set currentNode(node) {
                // Show the source node.
                if (!(document.activeElement === this.main)) {
                    const lines = this.value.split(/\r?\n/);
                    const position = this.main.scrollHeight * (node[symbols.source][0].lineNumber - 1) / lines.length;
                    this.main.focus();
                    this.main.scrollTo(0, position);
                    const start = lines.slice(0, node[symbols.source][0].lineNumber - 1).reduce((total, line) => total + line.length + 1, 0);
                    this.main.selectionStart = start;
                    this.main.selectionEnd = start + lines[node[symbols.source][0].lineNumber - 1].length;
                }
            }
        }

        /**
         * Specialisation of Editor for editing shaders
         */
        class ShaderEditor extends Editor {
            static settingsMap = {
                name: '.shader-name',
            }
            constructor(title, configuration) {
                super(title, { comment: '//' }, ShaderEditor.settingsMap);
                this.settings.name.addEventListener('change', (event) => {
                    const name = this.settings.name.value;
                    this.shader = shaderObjects.find((shader) => shader.name === name);
                    this.value = this.shader.source;
                });
            }
        }

        function glTypeName(gl, type) {
            const types = [];
            types[gl.FLOAT] = 'gl.FLOAT';
            types[gl.FLOAT_VEC2] = 'gl.FLOAT_VEC2';
            types[gl.FLOAT_VEC3] = 'gl.FLOAT_VEC3';
            types[gl.FLOAT_VEC4] = 'gl.FLOAT_VEC4';
            types[gl.INT] = 'gl.INT';
            types[gl.INT_VEC2] = 'gl.INT_VEC2';
            types[gl.INT_VEC3] = 'gl.INT_VEC3';
            types[gl.INT_VEC4] = 'gl.INT_VEC4';
            types[gl.BOOL] = 'gl.BOOL';
            types[gl.BOOL_VEC2] = 'gl.BOOL_VEC2';
            types[gl.BOOL_VEC3] = 'gl.BOOL_VEC3';
            types[gl.BOOL_VEC4] = 'gl.BOOL_VEC4';
            types[gl.FLOAT_MAT2] = 'gl.FLOAT_MAT2';
            types[gl.FLOAT_MAT3] = 'gl.FLOAT_MAT3';
            types[gl.FLOAT_MAT4] = 'gl.FLOAT_MAT4';
            types[gl.SAMPLER_2D] = 'gl.SAMPLER_2D';
            types[gl.SAMPLER_CUBE] = 'gl.SAMPLER_CUBE';
            return types[type];

            /*
            When using a WebGL 2 context, the following values are possible additionally:
            gl.UNSIGNED_INT
            gl.UNSIGNED_INT_VEC2
            gl.UNSIGNED_INT_VEC3
            gl.UNSIGNED_INT_VEC4
            gl.FLOAT_MAT2x3
            gl.FLOAT_MAT2x4
            gl.FLOAT_MAT3x2
            gl.FLOAT_MAT3x4
            gl.FLOAT_MAT4x2
            gl.FLOAT_MAT4x3
            gl.SAMPLER_3D
            gl.SAMPLER_2D_SHADOW
            gl.SAMPLER_2D_ARRAY
            gl.SAMPLER_2D_ARRAY_SHADOW
            gl.SAMPLER_CUBE_SHADOW
            gl.INT_SAMPLER_2D
            gl.INT_SAMPLER_3D
            gl.INT_SAMPLER_CUBE
            gl.INT_SAMPLER_2D_ARRAY
            gl.UNSIGNED_INT_SAMPLER_2D
            gl.UNSIGNED_INT_SAMPLER_3D
            gl.UNSIGNED_INT_SAMPLER_CUBE
            gl.UNSIGNED_INT_SAMPLER_2D_ARRAY
            */
        }


        /**
         * Specialisation of Editor for editing shaders
         */
        class ProgramEditor extends View {
            static nodeMap = {
                name: '.program-name',
                viewSelection: '.gl-view-selection',
                vertexShader: '.vertex-shader',
                fragmentShader: '.fragment-shader',
                update: '.update',
                uniforms: '.uniforms',
            }
            constructor(title, configuration) {
                super('shader-program-editor-template');
                this.uniforms = {};

                this.getNodes(ProgramEditor.nodeMap);

                this.setOptions();
                this.nodes.vertexShader.addEventListener('change', (event) =>
                    this.vertexShader = shaderObjects.find((shader) =>
                        shader.name === this.nodes.vertexShader.value && shader.type === 'vertex'));

                this.nodes.fragmentShader.addEventListener('change', (event) =>
                    this.fragmentShader = shaderObjects.find((shader) =>
                        shader.name === this.nodes.fragmentShader.value && shader.type === 'fragment'));

                this.nodes.update.addEventListener('click', (event) =>
                    this.updateUniforms());

                this.updateViewSelection();
                this.view = Core.views.find((view) => view.constructor.name === 'GLView');
            }
            updateViewSelection() {
                const views = Core.views.filter((view) => view.constructor.name === 'GLView');
                views.forEach((view, index) => {
                    const option = document.createElement('option');
                    option.innerText = view.title || `GL View ${index + 1}`;
                    option.value = index;
                    this.nodes.viewSelection.append(option);
                });
                this.nodes.viewSelection.addEventListener('change', (event) =>
                    this.view = views[this.nodes.viewSelection.value]);
            }
            setOptions() {
                shaderObjects.forEach((shader) => {
                    const option = document.createElement('option');
                    option.innerText = shader.title || shader.name;
                    option.value = shader.name;
                    if (shader.type === 'vertex') {
                        this.nodes.vertexShader.append(option);
                    } else {
                        this.nodes.fragmentShader.append(option);
                    }
                });
                this.vertexShader = shaderObjects.find((shader) => shader.type === 'vertex');
                this.fragmentShader = shaderObjects.find((shader) => shader.type === 'fragment');
            }
            updateUniforms() {
                if (this.view && this.vertexShader && this.fragmentShader) {
                    const context = this.view.context;
                    this.program = initialiseShaders(context, this.vertexShader.source, this.fragmentShader.source);
                    const numUniforms = context.getProgramParameter(this.program, context.ACTIVE_UNIFORMS);
                    this.nodes.uniforms.innerHTML = `
                    <table>
                      <thead>
                        <tr>
                          <th rowspan="2">Name</th>
                          <th rowspan="2">Type</th>
                          <th colspan="3">Mapping</th>
                        </tr>
                        <tr><th>Scene</th><th>Node</th><th>Shape</th></tr>
                      </thead>
                      <tbody></tbody>
                    </table>`;
                    const table = this.nodes.uniforms.querySelector('table');
                    const body = this.nodes.uniforms.querySelector('tbody');
                    const makeInputCell = (name, type) => {
                        const cell = document.createElement('td');
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.setAttribute('list', `${type}-parameters`);
                        input.value = this.uniforms[name][type] || '';
                        input.addEventListener('input', (event) =>
                            this.uniforms[name][type] = input.value);
                        cell.append(input);
                        return cell;
                    };

                    for (let i = 0; i < numUniforms; ++i) {
                        const row = document.createElement('tr');
                        const info = context.getActiveUniform(this.program, i);
                        this.uniforms[info.name] = this.uniforms[info.name] || {};
                        row.innerHTML = `<td>${info.name}</td><td>${glTypeName(context, info.type)}</td>`;
                        let cell = document.createElement('cell');
                        const scene = document.createElement('input');
                        row.append(makeInputCell(info.name, 'scene'));
                        row.append(makeInputCell(info.name, 'node'));
                        row.append(makeInputCell(info.name, 'shape'));
                        body.append(row);
                    }
                }
            }
        }

        
        /**
         * Split text into lines based on the given width
         */
        function fitText(text, width, measure, split=/(\s+)/) {
            const lines = [];
            const parts = text.split(/(\s+)/).filter((i) => i);
            
            let count;
            while (parts.length) {
                count = 2;
                while ((count <= parts.length) && (measure(parts.slice(0, count)) < width)) {
                    ++count;
                }
                --count;
                if ((count === 1) && (measure(parts[0]) > length) && (split !== '')) {
                    lines.push(...fitText(parts[0], width, measure, ''));
                    parts.shift();
                } else {
                    lines.push(parts.splice(0, count).join('').trim());
                }                
            }
            return lines.filter((line) => line.trim());
        }
        
        
        /**
         * Diagram class
         */
        class DiagramView extends View {
            static settingsMap = {

            }
            constructor() {
                super('diagram-view-template');
                this.title = 'Diagram';
                this.transform = [1, 0, 0, 1, 0, 0];
                this.canvas = this.node.querySelector('.diagram');
                this.context = this.canvas.getContext('2d');
                this.context.setTransform(1, 0, 0, 1, 0, 0);
                this.content = [];
                this.addControls();
                this.structure = Core.structure;
            }
            set structure(structure) {
                this.content = [];
                const actions = {
                    rect: (contxt, [x, y, w, h]) => (context) => context.strokeRect(x, y, w, h),
                    path: (context, d) => {
                        const path = new Path2D(d);
                        return (context) => context.stroke(path);
                    },
                    text: (context, [text, x, y, width, lineHeight]) => {
                        let lines;
                        
                        if (width) {
                            lines = fitText(text, width, (text) => context.measureText(text).width);
                            lineHeight =  lineHeight || Math.max(...lines.map((line) => {
                                const metrics = context.measureText(text);
                                return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            }));
                        } else {
                            lines = [text];
                            context.fillText(text, x || 0, y || 0);
                        }    
                        return (context) => {
                            let tx = x || 0;
                            let ty = y || 0;
                            lines.forEach((line) =>     {
                                context.fillText(line, tx, ty);
                                ty += lineHeight;
                            });
                        }
                    },
                    pie: (context, [radius, sort], nodes) => {
                        if (radius && nodes.length) {
                            nodes = nodes.filter((node) => node[symbols.value]);
                            const total = nodes.reduce((sum, node) => sum += node[symbols.value] || 0, 0);
                            let angle = -Math.PI / 2;
                            if (sort) {
                                nodes.sort((a, b) => b[symbols.value] - a[symbols.value]);
                            }
                            const segments = nodes.map((node) => {
                                const span = 2 * node[symbols.value] * Math.PI / total;
                                const path = new Path2D();
                                path.moveTo(0, 0);
                                path.arc(0, 0, radius, angle, angle + span);
                                path.lineTo(0, 0);
                                angle += span;
                                return {
                                    path, fill: `hsl(${angle}rad 50% 50%)`, label: node.name,
                                }
                            });  
                            const lineHeight = Math.max(...segments.map((segment) => {
                                const metrics = context.measureText(segment.label);
                                return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            }));
                            return (context) => {
                                let y = lineHeight - radius;
                                segments.forEach((segment) => {
                                    context.fillStyle = segment.fill;
                                    context.fill(segment.path);
                                    context.stroke(segment.path);
                                    context.fillText(segment.label, 5 + radius, y );
                                    y += lineHeight;
                                });
                            };
                        }
                    },
                    xy: (context, [width, height, sort, xOrigin, yOrigin], nodes) => {
                        width = width ?? 100;
                        height = height ?? 100;
                        if (nodes.length) {
                            nodes = nodes.filter((node) => (node.x !== undefined) && (node.y !== undefined));
                            const xMin = xOrigin === '*' ? Math.min(...nodes.map((node) => node.x)) : (xOrigin || 0);
                            const xMax = Math.max(...nodes.map((node) => node.x));
                            const yMin = yOrigin === '*' ? Math.min(...nodes.map((node) => node.y)) : (yOrigin || 0);
                            const yMax = Math.max(...nodes.map((node) => node.y));

                            if (sort) {
                                nodes.sort((a, b) => a.x - b.x);
                            }
                            const points = nodes.map((node) => ({
                                label: name,
                                source: node,
                                x: width * (node.x - xMin) / (xMax - xMin),
                                y: height * (1 - ((node.y - yMin)  / (yMax - yMin))),
                            }));

                            return (context) => {
                                context.strokeStyle = 'black';
                                context.beginPath();
                                context.moveTo(0, 0);
                                context.lineTo(0, height);
                                context.lineTo(width, height);
                                context.stroke();
                                context.strokeStyle = 'red';
                                if (points.length) {
                                    context.beginPath();
                                    context.moveTo(points[0].x, points[0].y);
                                    points.forEach((point) => context.lineTo(point.x, point.y));
                                    context.stroke();
                                }
                            };
                        }
                    },
                    line: (context, [width, height, sort], nodes) => { 
                        if (width, height) {
                            const blockWidth = width / nodes.length;
                            nodes = nodes.filter((node) => node[symbols.value]);
                            const max = Math.max(...nodes.map((node) => node[symbols.value]));
                            if (sort) {
                                nodes.sort((a, b) => b[symbols.value] - a[symbols.value]);
                            }
                            const points = nodes.map((node, i) => ({
                                fill: `hsl(${2 * Math.PI * i / nodes.length}rad 50% 50%)`,
                                label: name,
                                x: (i + 0.5) * blockWidth, y: height * (1 - node[symbols.value] / max),
                                width: blockWidth, height: height * node[symbols.value] / max,
                            }));
                            return (context) => {
                                context.strokeStyle = 'red';
                                context.beginPath();
                                context.moveTo(points[0].x, points[0].y);
                                points.forEach((point) => context.lineTo(point.x, point.y));
                                context.stroke();
                            };
                        }
                    },
                    histogram: (context, [width, height, sort], nodes) => {
                        if (width, height, width) {
                            const blockWidth = width / nodes.length;
                            nodes = nodes.filter((node) => node[symbols.value]);
                            const max = Math.max(...nodes.map((node) => node[symbols.value]));
                            if (sort) {
                                nodes.sort((a, b) => b[symbols.value] - a[symbols.value]);
                            }
                            const blocks = nodes.map((node, i) => ({
                                fill: `hsl(${2 * Math.PI * i / nodes.length}rad 50% 50%)`,
                                label: node.name,
                                x: i * blockWidth, y: height * (1 - node[symbols.value] / max),
                                width: blockWidth, height: height * node[symbols.value] / max,
                            }));
                            const lineHeight = Math.max(...blocks.map((block) => {
                                const metrics = context.measureText(block.label);
                                return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            }));
                            return (context) => {
                                context.textAlign = "end";
                                context.textBaseline="middle";
                                blocks.forEach((block) => {
                                    context.fillStyle = block.fill;
                                    context.fillRect(block.x, block.y, block.width, block.height);
                                    context.strokeRect(block.x, block.y, block.width, block.height);
                                    context.rotate(-Math.PI/2);
                                    context.fillText(block.label, -height - lineHeight / 2, block.x + block.width / 2);
                                    context.rotate(Math.PI/2); 
                                });
                            };
                        }
                    },
                }
                const stateChange = {
                    stoke: (colour) => (context) => context.strokeStyle = colour,
                    fill: (colour) => (context) => context.fillStyle = colour,
                    font: (font) => (context) => context.font = font,
                }
                const stack = [this];
                const processNode = (node) => {
                    let childParser = processNode;
                    let finalisation;
                    const children = [];
                    let pop = false;
                    if (node[symbols.views] && node[symbols.views]['diagram']) {
                        const item = {
                            actions: [],
                            content: [],
                        };
                        stack[0].content.push(item);
                        stack.unshift(item);
                        pop = true;
                        Object.entries(node[symbols.views]['diagram']).forEach(([key, value]) => {
                            value = value || [];
                            if (actions[key]) {
                                const action = actions[key](this.context, [value].flatMap((v) => v), node[symbols.content]);
                                if (action) {
                                    item.actions.push(action);
                                }
                            } else if (stateChange[key]) {
                                const change = stateChange[key](value);
                                if (change) {
                                    change(this.context);
                                    item.actions.unshift(change);
                                }
                            } else if (key === 'position' && Array.isArray(value)) {
                                item.transform = [1, 0, 0, 1, ...value];
                            } else if (key === 'transform') {
                                item.transform = [...value];
                            }
                        });
                    }
                    if (node[symbols.content]) {
                        node[symbols.content].forEach((node) => processNode(node));
                    }
                    if (pop) {
                        stack.shift();
                    }
                }
                structure.forEach((node) => processNode(node));
            }
            addControls() {
                const last = {};
                let action;
                const drag = (event, x, y) => {
                    const dx = x - last.x;
                    const dy = y - last.y;

                    this.context.transform(1, 0, 0, 1, dx, dy);

                    last.x = x;
                    last.y = y;
                };
                const transform = (event, x, y) => {
                    const c = this.context.getTransform();
                    const m = [c.a, c.b, c.e, c.c, c.d, c.f, 0, 0, 1];
                    const t = c.inverse();
                    const inverse = [t.a, t.b, t.e, t.c, t.d, t.f, 0, 0, 1];

                    const box = this.canvas.getBoundingClientRect();

                    if (event.touches.length === 2) {
                        const p1 = { x: last.x - box.x, y: last.y - box.y };
                        const p2 = { x: last.second.x - box.x, y: last.second.y - box.y };
                        const q1 = { x: event.touches[0].clientX - box.x, y: event.touches[0].clientY - box.y };
                        const q2 = { x: event.touches[1].clientX - box.x, y: event.touches[1].clientY - box.y };

                        const v1 = { x: p2.x - p1.x, y: p2.y - p1.y };
                        const v2 = { x: q2.x - q1.x, y: q2.y - q1.y };

                        const l2 = v1.x * v1.x + v1.y * v1.y;
                        const scaledCosAngle = (v2.x * v1.x + v1.y * v2.y) / l2;
                        const scaledSinAngle = (v1.x * v2.y - v1.y * v2.x) / l2;
                        const tx = (v1.x * (q1.x * p2.x - p1.x * q2.x) + v1.y * (q1.x * p2.y - q2.x * p1.y) + v2.y * (p2.x * p1.y - p1.x * p2.y)) / l2;
                        const ty = (v2.x * (p1.x * p2.y - p2.x * p1.y) + v1.y * (q1.y * p2.y - q2.y * p1.y) + v1.x * (q1.y * p2.x - q2.y * p1.x)) / l2;

                        const transform = matrixMultiply3x3([
                            scaledCosAngle, scaledSinAngle, tx,
                            -scaledSinAngle, scaledCosAngle, ty,
                            0, 0, 1], last.transform);

                        this.context.setTransform(
                            transform[0], transform[1], transform[3], transform[4], transform[2], transform[5]);
                    }
                };
                this.canvas.addEventListener('touchstart', (event) => {
                    last.x = event.touches[0].clientX;
                    last.y = event.touches[0].clientY;
                    const before = this.context.getTransform();
                    last.transform = [
                        before.a, before.b, before.e,
                        before.c, before.d, before.f,
                        0, 0, 1];

                    if (event.touches.length === 1) {
                        action = drag;
                    } else if (event.touches.length === 2) {
                        event.preventDefault();
                        last.second = {
                            x: event.touches[1].clientX,
                            y: event.touches[1].clientY,
                        };
                        action = transform;
                    }
                });

                this.canvas.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    if (action) {
                        action(event, event.touches[0].clientX, event.touches[0].clientY);
                    }
                });

                this.canvas.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    action = null;
                });

                this.canvas.addEventListener('mousedown', (event) => {
                    event.preventDefault();
                    last.x = event.clientX;
                    last.y = event.clientY;
                    action = drag;
                });

                this.canvas.addEventListener('mousemove', (event) => {
                    event.preventDefault();
                    if (action) {
                        action(event, event.clientX, event.clientY);
                    }
                });

                this.canvas.addEventListener('mouseup', (event) => {
                    event.preventDefault();
                    action = null;
                });

                this.canvas.addEventListener('wheel', (event) => {
                    const delta = Math.pow(2, event.deltaY / 1000);
                    const transform = this.context.getTransform();
                    transform.a *= delta;
                    transform.b *= delta;
                    transform.c *= delta;
                    transform.d *= delta;
                    this.context.setTransform( 
                            transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
                });

                this.canvas.addEventListener('keydown', (event) => {
                    report(event.key);
                    event.preventDefault();
                    const scale = event.ctrlKey ? 0.1 : 1;
                    if (event.key === 'u') {
                        view.camera.up = [0, 1, 0];
                    }
                    if (event.key === 'ArrowUp') {
                    }
                    if (event.key === 'ArrowDown') {
                    }
                    if (event.key === 'ArrowLeft') {
                    }
                    if (event.key === 'ArrowRight') {
                    }
                });
            }
            update(time) {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;

                if (this.canvas.width != width || this.canvas.height != height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }

                this.context.save();
                this.context.setTransform(1, 0, 0, 1, 0, 0);
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.context.restore();
                
                this.context.fillStyle = 'black';
                this.context.strokeStyle = 'black';
                
                const draw = (node) => {
                    if (node.transform && node.transform.length === 6) {
                        this.context.save();
                        this.context.transform(...node.transform);
                    }
                    node.actions.forEach((action) => action(this.context));
                    node.content.forEach((item) => draw(item));
                    if (node.transform) {
                        this.context.restore();
                    }
                }
                this.content.forEach((item) => draw(item));
            }
        }

        /**
         * GLView component
         */
        class GLView extends View {
            static settingsMap = {
                split: '.split',
                move: '.move',
                reset: '.reset',
                upright: '.upright',
                depthTest: '.depth-test',
            };
            constructor(title, camera) {
                super('gl-view-template', GLView.settingsMap);
                // Add to the DOM so that safari can get context
                document.body.append(this.node);
                this.canvas = this.node.querySelector('.scene');

                this.shapes = [];
                this.points = [];
                this.lines = [];
                this.graph = [];
                this.nodes = [];
                this.overlays = [];
                this.events = [];
                this.activeEvents = [];
                this.light = [{ position: [-75, -90, 0] }];
                this.data = {
                    vertex: [],
                    indices: [],
                };
                this.gl = this.context;

                this.title = title;
                this.camera = camera || new Camera([14.638, -0.074, 27.731], [6.762, 1.357, 7.673], [0, 1, 0]);
                this.background = [0.9, 0.9, 1, 1];

                const lightX = this.node.querySelector('.light-x');
                const lightY = this.node.querySelector('.light-y');
                const lightZ = this.node.querySelector('.light-z');

                lightX.value = -75;
                lightY.value = -90;
                lightZ.value = 0;

                lightX.addEventListener('input', (event) =>
                    this.light[0].position[0] = lightX.value);
                lightY.addEventListener('input', (event) =>
                    this.light[0].position[1] = lightY.value);
                lightZ.addEventListener('input', (event) =>
                    this.light[0].position[2] = lightZ.value);

                addControls(this.canvas, this);

                this.vertexBuffer = this.context.createBuffer();
                this.indexBuffer = this.context.createBuffer();

                this.settings.reset.addEventListener('click', () => {
                    this.camera.reset();
                    this.canvas.focus();
                    document.body.style.backgroundColour = 'pink';
                });

                this.settings.upright.addEventListener('click', () => {
                    this.camera.up = [0, 1, 0];
                    updateCamera(this.camera.getString());
                    this.canvas.focus();
                });
                this.structure = Core.structure;
            }
            get context() {
                return this.canvas.getContext('webgl');
            }
            setShaders(shaders) {
                this.shaders = shaders.reduce((shaders, definition) => {
                    shaders[definition.name] = makeShader(definition, this.context);
                    return shaders;
                }, {});
                glErrors(this.context, `${this.title} setShaders`);
            }
            get structure() {
                return this._structure || [];
            }
            set structure(structure = []) {
                this._structure = structure;
                getGraph(this._structure, this);
            }
            setGraph(graph) {
                //this.graph = graph;
            }
            updateBuffers(data) {
                const gl = this.context;

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertex), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data.indices), gl.STATIC_DRAW);
                glErrors(this.context, `${this.title} updateBuffers`);
            }
            focus() {
                this.canvas.focus();
            }
            updateSize() {
                // Lookup the size the browser is displaying the canvas in CSS pixels.
                const box = this.canvas.getBoundingClientRect();

                const width = box.width;
                const height = box.height;

                // Check if the canvas is not the same size.
                const resize = this.canvas.width !== width || this.canvas.height !== height;

                if (resize) {
                    // Make the canvas the same size
                    this.canvas.width = width;
                    this.canvas.height = height;

                    this.context.viewport(0, 0, width, height);
                }

                return resize;
            }
            initialiseShader(shader, projectionMatrix) {
                const context = this.context;
                const numComponents = 3;
                const type = context.FLOAT;    // the data in the buffer is 32bit floats
                const normalize = false;  // don't normalize
                const stride = 4 * (3 + 3 + 2);         // how many bytes to get from one set of values to the next
                // 0 = use type and numComponents above
                const offset = 0;         // how many bytes inside the buffer to start from
                context.useProgram(shader.program);
                context.bindBuffer(context.ARRAY_BUFFER, this.vertexBuffer);

                context.vertexAttribPointer(
                    shader.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                context.enableVertexAttribArray(shader.attribLocations.vertexPosition);

                if (shader.attribLocations.vertexNormal) {
                    context.vertexAttribPointer(
                        shader.attribLocations.vertexNormal,
                        numComponents,
                        type,
                        true,  // normalise normals
                        stride,
                        4 * 3);
                    context.enableVertexAttribArray(shader.attribLocations.vertexNormal);
                }

                if (shader.attribLocations.vertexTexture) {
                    context.vertexAttribPointer(
                        shader.attribLocations.vertexTexture,
                        2,     // numcomponents
                        type,
                        normalize,
                        stride,
                        4 * (3 + 3));
                    context.enableVertexAttribArray(shader.attribLocations.vertexTexture);
                }

                shader.setSceneData(this);

                glErrors(this.context, `${this.title} initialiseShaders`);
            }
            update(time) {
                const gl = this.context;
                this.updateSize();

                this.modelViewMatrix = this.camera.viewMatrix();

                glErrors(gl, `${this.title} update 1`);
                // Create a perspective matrix, a special matrix that is
                // used to simulate the distortion of perspective in a camera.
                // Our field of view is 45 degrees, with a width/height
                // ratio that matches the display size of the canvas
                const fieldOfView = 45;   // in degrees
                const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                const zNear = 0.1;
                const zFar = 1000.0;
                const projectionMatrix = perspective(fieldOfView, aspect, zNear, zFar);
                this.projectionMatrix = projectionMatrix;

                this.graph.forEach((node) => node.update(this, identityMatrix(), node, time));

                this.updateBuffers(this.data);

                glErrors(gl, `${this.title} update 2`);

                Object.values(this.shaders).forEach((shader) =>
                    this.initialiseShader(shader, projectionMatrix));

                // if (this.title ==='New GL View') return;
                bindTextures(gl);
                glErrors(gl, `${this.title} update 3`);
                gl.enable(gl.BLEND)
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                // Set clear colour to black, fully opaque
                gl.clearColor(...this.background);
                // Clear the colour buffer with specified clear colour

                glErrors(gl, `${this.title} update 4`);

                gl.clearDepth(1.0);                 // Clear everything
                if (this.settings.depthTest.checked) {
                    gl.enable(gl.DEPTH_TEST);           // Enable depth testing
                } else {
                    gl.disable(gl.DEPTH_TEST);           // Enable depth testing
                    this.graph.sort((a, b) => a.z - b.z);
                }
                gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
                glErrors(gl, `${this.title} update 5`);
                // Clear the canvas before we start drawing on it.

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                if (this.settings.split.checked) {
                    drawScene2(this, gl, this.structure, this.shaders, time);
                } else {
                    drawScene(this, gl, this.structure, this.shaders, time);
                }
                glErrors(gl, `${this.title} update 6`);

                //topView.render();

                if (this.overlays) {
                    this.overlays.forEach((overlay) => overlay.updateOverlay(projectionMatrix));
                }
                if (this.savePNG) {
                    savePNG(this.canvas);
                    this.savePNG = false;
                }
                glErrors(gl, `${this.title} update end`);
            }
        }

        /**
         * SVGView component
         */
        class SVGView extends View {
            static ns = 'http://www.w3.org/2000/svg';
            static namedArributes = Symbol('named attributes');
            static settingsMap = {
                rootNodes: '.root-nodes',
                filter: '.filter',
                context: '.context-selection',
            }
            constructor(structure, title) {
                super('svg-view-template', SVGView.settingsMap);
                // Add to the DOM so that safari can get context
                this.svg = this.node.querySelector('svg');
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
                this.title = title || 'SVG Diagram';
                this.structure = structure;
            }
            update(time) {
                //this.node.innerHTML = Core.mainEditor.value;
            }
            /*
            oldconstructor(width = 100, height = 100) {
                this.node = document.createElementNS(Svg.ns, 'svg');
                this.node.setAttribute('width', `${width}`);
                this.node.setAttribute('height', `${height}`);
                this.node.setAttribute('viewBox', `0 0 ${width} ${height}`);
                this.node.setAttribute('stroke', 'black');
                this.node.setAttribute('fill', 'white');
                this.node.setAttribute('xmlns', 'http://www.w3.org/2000/xmlns/');
                this.node.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
                this.node.classList.add('svg');
                //this.defs = document.createElementNS(Svg.ns, 'defs');
                //this.node = this.node.appendChild(this.defs);
            }
            */
            make(type, attributes, content, classes) {
                const element = document.createElementNS(SVGView.ns, type);
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);
                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                //this.node.appendChild(element);
                if (content) {
                    element.append(content);
                    //element.innerHTML = content;
                }
                if (classes) {
                    element.classList.add(...classes)
                }
                return element;
            }
            add(type, attributes, content, classes, parent) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.appendChild(element);
                return element;
            }
            set contexts(contexts) {
                this.settings.context.innerHTML =
                    '<option value="" selected>None</option>';
                if (contexts) {
                    contexts.forEach((context) => {
                        const option = document.createElement('option');
                        option.innerText = context;
                        option.value = context;
                        this.settings.context.append(option);
                    });
                }
            }
            set structure(structure) {
                this.svg.innerHTML = '';
                this._structure = structure;
                this.render();
            }
            render() {
                // Use a handler to extract data from specified view
                const view = this.settings.view;

                const handler = {
                    get(target, prop, receiver) {
                        if (target[symbols.views][view]) {
                            if (target[symbols.views][view][prop] !== undefined) {
                                return target[symbols.views][view][prop];
                            }
                        }
                        return original[prop];
                    },
                };

                // Generate SVG nodes from structure
                const makeSVG = (node) => {
                    if (this._structure.includes(node)) {
                        return;
                    }
                    this.add(node.name, node, node[symbols.content], [], this.svg);
                    if (view) {
                        node = new Proxy(node, handler);
                    }
                };
                process(makeSVG, this.settings.rootNodes.value, this.settings.filter.value);
                const extents = {
                    left: 0,
                    top: 0,
                    right: 100,
                    bottom: 100,
                }
                this.svg.setAttribute('viewBox', `${extents.left} ${extents.top} ${extents.right} ${extents.bottom}`);
                this.svg.setAttribute('width', `${extents.right - extents.left}`);
                this.svg.setAttribute('height', `${extents.bottom - extents.top}`);

                this.svg.style.width = `${extents.right - extents.left}px`;
                this.svg.style.height = `${extents.bottom - extents.top}px`;

            }
        }

        /**
         * SVG representation of the tree
         */
        class SVGTreeDiagram extends SVGView {
            static defaults = {
                topMargin: 10,
                leftMargin: 10,
                rightMargin: 10,
                bottomMargin: 10,
                columnGap: 10,
                rowGap: 22,
                nodeContent(node) {
                    return node.content;
                },
                nodeText(node) {
                    return node.value;
                },
            };
            constructor(title = "SVG Tree Diagram", structure, configuration) {
                super(title);
                this.configuration = Object.assign({}, SVGTreeDiagram.defaults, configuration);
                this.structure = structure;
            }
            set structure(structure) {
                this.svg.innerHTML = '';
                this._structure = structure;
                this.render();
            }
            set currentNode(node) {
                for (const svgNode of this.node.querySelectorAll('.selected')) {
                    svgNode.classList.remove('selected');
                }
                this.all.filter((treeNode) => treeNode.value === node)
                    .forEach((treeNode) => treeNode.svgNodes.forEach((node) => node.classList.add('selected')));
            }
            render() {
                // Construct a new tree that maps to the structure but includes the layout data
                const layout = [];
                this.all = [];
                const leaves = [];
                const roots = this._structure.map((node) => ({
                    value: node,
                    width: 100,
                    height: 60,
                    box: {},
                    svgNodes: [],
                    leftEdge: [],
                    rightEdge: [],
                }));
                const stack = [...roots];
                
                const lerp = (line, point) => line[0].x + (line[1].x - line[0].x) * 
                    (point.y - line[0].y) / (line[1].y - line[0].y);

                const getOffset = (rightEdge, leftEdge) => {
                    let offset = 0;
                    let left = [...leftEdge];
                    let right = [...rightEdge];

                    left.sort((a, b) => a.y - b.y);
                    right.sort((a, b) => a.y - b.y);

                    while ((left.length > 1) && (right.length > 1)) {
                        if (left[0].y > right[0].y) {
                            if (left[0].y < right[1].y) {
                                offset = Math.max(offset, lerp(right, left[0]) - left[0].x);
                            }
                            right.shift();
                        } else if (right[0].y > left[0].y) {
                            if (right[0].y < left[1].y) {
                                offset = Math.max(offset, right[0].x - lerp(left, right[0]));
                            }
                            left.shift();
                        } else {
                            offset = Math.max(offset, right[0].x - left[0].x);
                            if (left[1].y < right[1].y) {
                                left.shift();
                            } else if (left[1].y > right[1].y) {
                                right.shift();
                            } else {
                                right.shift();
                                left.shift();
                            }
                        }
                    }
                    if (offset === -Infinity) {
                        return 0;
                    }
                    return offset + this.configuration.columnGap;
                };

                const root = {
                    height: 0,
                    rightEdge: [],
                    value: {[symbols.views]: {'Tree Diagram': {layout: 'Horizontal'}}},
                }                
                
                // Perform a depth first walk of the graph creating a 'treenode' for each node
                while (stack.length > 0) {
                    const treeNode = stack.shift();
                    if (treeNode.nodes === undefined) {
                        // Put this node on the stack to be processed after its contents
                        stack.unshift(treeNode);
                        const nodes = this.configuration.nodeContent(treeNode.value) || [];
                        treeNode.nodes = nodes.map((node) => ({
                            value: node,
                            parent: treeNode,
                            width: 100,
                            height: 60,
                            box: {},
                            svgNodes: [],
                            leftEdge: [],
                            rightEdge: [],
                        }));
                        stack.unshift(...treeNode.nodes);
                    } else {
                        const parent = treeNode.parent || root;
                        this.all.push(treeNode);
                        // Determine the width and height of the 'box' and the position of the label
                        // calculate the edges
                        treeNode.y = 0;

                        if (treeNode.nodes.length) {
                            const first = treeNode.nodes[0];
                            const last = treeNode.nodes[treeNode.nodes.length - 1];
                            treeNode.box.width = Math.max(treeNode.width, ...treeNode.nodes.map((node) => node.box.x + node.box.width));
                            treeNode.box.height = Math.max(treeNode.height, ...treeNode.nodes.map((node) => node.box.y + node.box.height));

                            if (treeNode.value[symbols.views]['Tree Diagram']?.layout === 'Vertical') {
                                treeNode.x = 0;

                                treeNode.leftEdge = [
                                    { y: 0, x: 0 },
                                    { y: treeNode.height, x: 0 },
                                    { y: treeNode.height, x: this.configuration.columnGap },
                                    { y: last.height / 2 - this.configuration.rowGap, x: 2 * this.configuration.columnGap },
                                ];
                                treeNode.rightEdge = treeNode.nodes.flatMap((childNode) =>
                                    childNode.rightEdge.map((point) => ({
                                        x: childNode.box.x + point.x,
                                        y: childNode.box.y + point.y, })));
                            } else {
                                treeNode.x = (first.box.x + first.x + first.width / 2 + 
                                    last.box.x + last.x + last.width / 2 - treeNode.width) / 2;
                                
                                treeNode.leftEdge = [
                                    { y: 0, x: treeNode.x },
                                    { y: treeNode.height, x: treeNode.x },
                                    { y: treeNode.height, x: treeNode.x + treeNode.width / 2},
                                    { y: treeNode.height + this.configuration.rowGap / 2, x: treeNode.x + treeNode.width / 2 },
                                    { y: treeNode.height + this.configuration.rowGap / 2, x: first.box.x + first.x + first.width / 2 },
                                    ...first.leftEdge.map((point) => ({
                                        y: point.y + first.box.y, x: point.x + first.box.x,
                                    })),
                                ];
                                let y = Math.max(...first.leftEdge.map((point) => point.y));
                                treeNode.nodes.forEach((childNode) => {
                                    const points = childNode.leftEdge.map((point) => ({
                                        y: point.y + childNode.box.y, x: point.x + childNode.box.x,
                                    })).filter((point) => point.y >= y);
                                    treeNode.leftEdge.push(...points);
                                    y = Math.max(...points.map((point) => point.y));
                                });
                                
                                treeNode.rightEdge = [
                                    { y: 0, x: treeNode.x + treeNode.width },
                                    { y: treeNode.height, x: treeNode.x + treeNode.width},
                                    { y: treeNode.height, x: treeNode.x + treeNode.width / 2},
                                    { y: treeNode.height + this.configuration.rowGap / 2, x: treeNode.x + treeNode.width / 2 },
                                    { y: treeNode.height + this.configuration.rowGap / 2, x: last.box.x + last.x + last.width / 2 },
                                    ...last.rightEdge.map((point) => ({
                                        y: point.y + last.box.y, x: point.x + last.box.x,
                                    })),
                                ];
                                y = Math.max(...last.rightEdge.map((point) => point.y));
                                treeNode.nodes.toReversed().forEach((childNode) => {
                                    const points = childNode.rightEdge.map((point) =>
                                        ({ y: point.y + childNode.box.y, x: point.x + childNode.box.x, }))
                                        .filter((point) => point.y >= y);
                                    treeNode.rightEdge.push(...points);
                                    y = Math.max(...points.map((point) => point.y));
                                });
                            }
                        } else {
                            treeNode.x = 0;
                            treeNode.box.width = treeNode.width;
                            treeNode.box.height = treeNode.height;
                            treeNode.leftEdge = [{ y: 0, x: 0 }, { y: treeNode.height, x: 0 }];
                            treeNode.rightEdge = [{ y: 0, x: treeNode.width }, { y: treeNode.height, x: treeNode.width }];
                        }

                        // Calculate the position of the box based on its parent layout data
                        if (parent.value[symbols.views]['Tree Diagram']?.layout === 'Vertical') {
                            treeNode.box.x = 2 * this.configuration.columnGap;
                            treeNode.box.y = parent.nextY || (parent.height + this.configuration.rowGap);
                            parent.nextY = treeNode.box.y + treeNode.box.height + this.configuration.rowGap;
                        } else {
                            const rightEdge = parent.rightEdge;

                            const offset = getOffset(rightEdge, treeNode.leftEdge);

                            treeNode.box.x = offset;
                            treeNode.box.y = treeNode.parent ? treeNode.parent.height + this.configuration.rowGap : 0;

                            const max = Math.max(...rightEdge.map((point) => point.y));
                            const filtered = rightEdge.filter((point) => point.y >= max);
                            rightEdge.length = 0;
                            rightEdge.push(
                                ...treeNode.rightEdge.map((point) => ({x: point.x + offset, y: point.y,})),
                                ...filtered);
                        }
                    }
                }

                let index = 0;
                const addNode = (node, parent) => {
                    const groupAttrs = {
                        transform: `translate(${node.box.x}, ${node.box.y})`,
                    };
                    const group = this.add('g', groupAttrs, null, [], parent);
                    node.svgNodes.push(group);

                    const boxAttrs = {
                        x: node.x, y: node.y,
                        width: node.width, height: node.height,
                        fill: 'white', stroke: 'black',
                    };
                    const rect = this.add('rect', boxAttrs, null, [], group);
                    rect.addEventListener('click', (event) => {
                        Core.currentNode = node.value;
                    });
                    node.svgNodes.push(rect);
                    const clipRect = this.make('rect', { x: node.x, y: node.y, width: node.width, height: node.height });
                    //this.add('clipPath', { id: `clip${index}` }, clipRect, [], group);
                    const textAttrs = {
                        x: node.x + node.width / 2,
                        y: node.y + 20,
                        font: '13px sans-serif',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'Auto',
                        fill: 'black',
                        //'clip-path': `url(#clip${index})`,
                    };
                    this.add('text', textAttrs, this.configuration.nodeText(node.value), [], group);
                    textAttrs.y += 20;
                    this.add('text', textAttrs, node.xOffset, [], group);
                    if (node.nodes.length) {
                        const pathAttrs = { fill: 'none', stroke: 'black' };
                        if (node.value[symbols.views]['Tree Diagram']?.layout === 'Vertical') {
                            const x = node.x + this.configuration.columnGap;
                            const start = node.y + node.height;
                            const lastNode = node.nodes[node.nodes.length - 1];
                            const end = lastNode.box.y + lastNode.y + lastNode.height / 2;
                            pathAttrs.d = `M${x} ${start} V${end} `;
                            pathAttrs.d += node.nodes.map((node) =>
                                `M${x} ${node.box.y + node.y + node.height / 2} H${node.box.x + node.x}`).join(' ');
                        } else {
                            const start = node.nodes[0].box.x + node.nodes[0].box.width / 2;
                            const end = node.nodes[node.nodes.length - 1].box.x + node.nodes[node.nodes.length - 1].box.width / 2;
                            const height = node.y + node.height + this.configuration.rowGap / 2;
                            pathAttrs.d = `M${node.x + node.width / 2} ${node.y + node.height} V${height} M${start} ${height} H${end} `,
                                pathAttrs.d += node.nodes.map((node) =>
                                    `M${node.box.x + node.x + node.width / 2} ${node.box.y + node.y} v-${this.configuration.rowGap / 2}`).join(' ');
                        }
                        this.add('path', pathAttrs, null, [], group);
                    }
                    node.nodes.forEach((node) => addNode(node, group));
                    ++index;
                }

                const width = Math.max(...roots.map((node) => node.box.x + node.box.width));
                const height = Math.max(...roots.map((node) => node.box.y + node.box.height));

                const extents = {
                    top: 0,
                    left: 0,
                    right: this.configuration.leftMargin + width + this.configuration.rightMargin,
                    bottom: this.configuration.topMargin + height + this.configuration.bottomMargin,
                }

                this.svg.setAttribute('viewBox', `${extents.left} ${extents.top} ${extents.right} ${extents.bottom}`);
                this.svg.setAttribute('width', `${extents.right - extents.left}`);
                this.svg.setAttribute('height', `${extents.bottom - extents.top}`);

                this.svg.style.width = `${extents.right - extents.left}px`;
                this.svg.style.height = `${extents.bottom - extents.top}px`;
                
                roots.forEach((node) => addNode(node));
            }
        }

        /**
         * Display a table view for the selected data
         */
        class TableView extends View {
            static settingsMap = {
                headings: '.headings-list',
                hideEmpty: '.hide-empty-rows',
            }
            static defaults = {};
            constructor(roots, configuration) {
                super('table-view-template', TableView.settingsMap);

                this.configuration = Object.assign({}, TableView.defaults, configuration);
                this.roots = roots;
                this.title = 'Table View';
                this.head = this.node.querySelector('thead');
                this.body = this.node.querySelector('tbody');
                this.getNodes();
                this.getHeadings();
                this.render();
                this.settings.headings.addEventListener('change', (event) => this.render());
                this.settings.hideEmpty.addEventListener('change', (event) => this.render());
            }
            getNodes() {
                this.nodes = [];
                this.fields = new Set();
                const stack = [...this.roots];
                while (stack.length) {
                    const node = stack.shift();
                    this.nodes.push(node);
                    const next = node[symbols.content];
                    stack.unshift(...next);
                    Object.keys(node).forEach((key) => this.fields.add(key));
                }
            }
            getHeadings() {
                this.headings = Array.from(this.fields);
                this.headings.forEach((heading, index) => {
                    const option = document.createElement('option');
                    option.innerText = heading;
                    option.value = heading;
                    option.selected = true;
                    this.settings.headings.append(option);
                });
            }
            render() {
                this.head.innerHTML = '';
                this.body.innerHTML = '';
                const row = document.createElement('tr');
                row.classList.add('heading-row');
                this.head.append(row);
                const headings = Array.from(this.settings.headings.options)
                    .filter((option) => option.selected)
                    .map((option) => option.value);
                headings.forEach((heading, index) => {
                    const cell = document.createElement('th');
                    cell.innerText = heading;
                    cell.classList.add(`column-${index}`);
                    cell.draggable = true;
                    cell.addEventListener('dragstart', (event) => {
                        event.dataTransfer.setData('text/heading-index', index);
                        event.dataTransfer.setData('text/plain', heading);
                        for (const node of this.node.querySelectorAll(`.column-${index}`)) {
                            node.classList.add('dragging');
                        }
                        this.headings.splice(index, 1);
                    });
                    cell.addEventListener('dragend', (event) => this.render());
                    cell.addEventListener('dragover', (event) => event.preventDefault());
                    cell.addEventListener('drop', (event) => {
                        event.preventDefault();
                        const draggedIndex = parseInt(event.dataTransfer.getData('text/heading-index'));
                        for (const node of this.body.querySelectorAll(`column-${draggedIndex}`)) {
                            node.classList.remove('dragging');
                        }
                        const draggedHeading = event.dataTransfer.getData('text/plain');
                        this.headings.splice(index, 0, draggedHeading);
                    });
                    row.append(cell);
                });
                this.nodes.forEach((node, rowIndex) => {
                    const row = document.createElement('tr');
                    let show = !this.settings.hideEmpty.checked;
                    headings.forEach((heading, index) => {
                        const cell = document.createElement('td');
                        cell.innerText = node[heading] !== undefined ? node[heading] : '';
                        if (index > 0) {
                            show = show || (node[heading] !== undefined);
                        }
                        cell.classList.add(`column-${index}`, `row-${rowIndex}`);
                        if (node[heading] === undefined) {
                            cell.classList.add('undefined');
                        }
                        cell.addEventListener('dragover', (event) => event.preventDefault());
                        cell.addEventListener('drop', (event) => {
                            event.preventDefault();
                            const draggedIndex = parseInt(event.dataTransfer.getData('text/heading-index'));
                            for (const node of this.body.querySelectorAll(`column-${draggedIndex}`)) {
                                node.classList.remove('dragging');
                            }
                            const draggedHeading = event.dataTransfer.getData('text/plain');
                            this.headings.splice(index, 0, draggedHeading);
                        });
                        cell.addEventListener('click', (event) => Core.currentNode = node);
                        row.append(cell);
                    });
                    if (show) {
                        this.body.append(row);
                    }
                });
            }
        }

        /**
         * View selection component used for empty frames
         */
        class DetailView extends View {
            static settingsMap = {
                update: '.auto-update',
                context: '.context-selection',
            }
            constructor() {
                super('detail-view-template', DetailView.settingsMap);

                this.contexts = Core.contexts;
                this.title = 'Detail View';
                this.detail = this.node.querySelector('.detail');
                this.settings.context.addEventListener('change', (event) => this.render());
            }
            set currentNode(node) {
                this._currentNode = node;
                if (this.settings.update.checked) {
                    this.render();
                }
            }
            set contexts(contexts) {
                this.settings.context.innerHTML =
                    '<option value="" selected>None</option>';
                if (contexts) {
                    contexts.forEach((context) => {
                        const option = document.createElement('option');
                        option.innerText = context;
                        option.value = context;
                        this.settings.context.append(option);
                    });
                }
            }
            render() {
                if (this._currentNode) {
                    //console.log(this.node.querySelector('.title'));
                    this.node.querySelector('.title').innerText = this._currentNode.name;
                    this.detail.innerHTML = '';
                    Object.entries(this._currentNode).map(([key, value]) =>
                        this.detail.append(showEntry(key, value, [value])));
                    if (this.settings.context.value) {
                        const view = this._currentNode[symbols.views][this.settings.context.value];
                        if (view) {
                            Object.entries(view).map(([key, value]) =>
                                this.detail.append(showEntry(key, value, [value])));
                        }
                    }
                } else {
                    console.log('Current node undefined');
                }
                
            }
        }

        function flatten(structure) {
            const list = [];
            if (structure) {
                const stack = [...structure];
                while (stack.length > 0) {
                    const node = stack.shift();
                    list.push(node);
                    if (node[symbols.content].length) {
                        stack.unshift(...node[symbols.content]);
                    }
                }
            }
            
            return list;
        }        
        
        
        /**
         * View component for calendar display
         */
        class ClockView extends View {
            static settingsMap = {
                update: '.auto-update',
                context: '.context-selection',
            }
            constructor(date) {
                super('clock-view-template', ClockView.settingsMap);
                this.canvas = this.node.querySelector('canvas');
                this.context = this.canvas.getContext('2d');
                this.title = 'Local Time';
                this.last = new Date();
            }
            update(time) {
                const current = new Date();
                const width = this.canvas.clientWidth / 2;
                const height = this.canvas.clientHeight / 2;
                
                if (this.canvas.width !== this.canvas.clientWidth ||
                    this.canvas.height !== this.canvas.clientHeight) {
                    this.canvas.width = this.canvas.clientWidth;
                    this.canvas.height = this.canvas.clientHeight;
                    this.render(current);
                    this.last = current;
                } else if (current.toLocaleTimeString() !== this.last.toLocaleTimeString() || this.constant) {
                    this.render(current);
                    this.last = current;
                }
            }
            render(time) {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const width = this.canvas.clientWidth / 2;
                const height = this.canvas.clientHeight / 2;

                const hours = Math.PI * (time.getHours() % 12) / 6;
                const minutes = Math.PI * time.getMinutes() / 30;
                const seconds = Math.PI * time.getSeconds() / 30;
                                
                const s = Math.min(width, height);
                
                this.context.strokeStyle = 'white';
                this.context.beginPath();
                for(let i = 0; i < 60; ++i) {
                    const a = Math.PI * i / 30;
                    const inner = s * ((i % 5) ? 0.98 : 0.9); 
                    this.context.moveTo(width + s * Math.sin(a), height + s * Math.cos(a));
                    this.context.lineTo(width + inner * Math.sin(a), height + inner * Math.cos(a));
                }
                this.context.stroke();
                
                this.context.fillStyle = 'gray';
                this.context.font = `bold ${s/5}px monospace`;
                this.context.textBaseline = 'hanging';
                this.context.textAlign = 'center';
                this.context.fillText(time.toLocaleTimeString(), width, height);
                this.context.fillText(time.toLocaleDateString(), width, height + s / 4);
                
                this.context.strokeStyle = 'white';
                this.context.lineWidth = 3;
                this.context.beginPath();
                this.context.moveTo(width, height);
                this.context.lineTo(width + s * 0.6 * Math.sin(hours), height - s * 0.6 * Math.cos(hours));
                this.context.stroke();
                
                this.context.lineWidth = 2;
                this.context.beginPath();
                this.context.moveTo(width, height);
                this.context.lineTo(width + s * 0.8 * Math.sin(minutes), height - s * 0.8 * Math.cos(minutes));
                this.context.stroke();
                
                this.context.lineWidth = 1;
                this.context.beginPath();
                this.context.moveTo(width, height);
                this.context.lineTo(width + s * 0.9 * Math.sin(seconds), height - s * 0.9 * Math.cos(seconds));
                this.context.stroke();
            }
        }

        /**
         * View component for calendar display
         */
        class CalendarView extends View {
            static settingsMap = {
                update: '.auto-update',
                context: '.context-selection',
            }
            constructor(date) {
                super('calendar-view-template', CalendarView.settingsMap);
                this.title = 'Calendar';
                this.date = date || new Date();
                this.contexts = Core.contexts;
                this._structure = Core.structure;
                this.title = 'Calendar View';
                this.calendarNode = this.node.querySelector('.calendar');
                this.monthLabel = this.node.querySelector('.month-label');
                this.next = this.node.querySelector('.next-month');
                this.previous = this.node.querySelector('.previous-month');
                this.settings.context.addEventListener('change', (event) => this.render());
                this.render();
                this.previous.addEventListener('click', (event) => this.previousMonth());
                this.next.addEventListener('click', (event) => this.nextMonth());
            }
            previousMonth() {
                this.date.setMonth(this.date.getMonth() - 1);
                this.render();
            }
            nextMonth() {
                this.date.setMonth(this.date.getMonth() + 1);
                this.render();
            }
            set currentNode(node) {
                this._currentNode = node;
                if (this.settings.update.checked) {
                    this.render();
                }
            }
            set structure(structure) {
                this._structure = structure;
                this.render();
            }
            render() {
                const start = (node) => {
                    const date = node.start || node.date;
                    if (!(date instanceof Date)) {
                        return;
                    }
                    date.setHours(0);
                    date.setMinutes(0);
                    date.setSeconds(0);
                    return date;
                }
                const end = (node) => {
                    const date = node.end && (node.end instanceof Date) ? node.end : start(node);
                    if (!(date instanceof Date)) {
                        return s;
                    }
                    date.setHours(23);
                    date.setMinutes(59);
                    date.setSeconds(59);
                    return date;
                }

                const nodes = flatten(this._structure).filter((node) => start(node)?.getMonth &&
                    ((start(node).getMonth() - this.date.getMonth()) <= 1) &&
                    ((this.date.getMonth() - start(node).getMonth()) >= -1));
                for (const node of this.calendarNode.querySelectorAll('.calendar-day')) {
                    node.remove();
                }
                const year = this.date.getFullYear() === (new Date).getFullYear() ? '' : ` ${this.date.getFullYear()}`;
                this.monthLabel.innerHTML = this.date.toLocaleDateString('en-AU', {month: 'long'}) + year;
                const day = new Date(this.date.getTime());
                day.setDate(1);
                const dayOfWeek = (day.getDay() + 6) % 7;
                day.setDate(1 - dayOfWeek);

                const nextMonth = new Date(day.getTime());
                nextMonth.setMonth(nextMonth.getMonth() + 1);
                while ((day.getTime() < nextMonth.getTime()) || (day.getDay() !== 1)) {
                    const dayNode = document.createElement('div');
                    dayNode.innerHTML = day.getDate();
                    dayNode.classList.add('calendar-day');
                    if ((day.getDay() > 0) && (day.getDay() < 6)) {
                        dayNode.classList.add('calendar-day-weekday');
                    } else {
                        dayNode.classList.add('calendar-day-weekend');
                    }
                    if (day.getMonth() !== this.date.getMonth()) {
                        dayNode.classList.add('calendar-day-shade');
                    }
                    const dayNodes = nodes.find((node) => (start(node) <= day) && (end(node) >= day));
                    if (dayNodes) {
                        dayNode.style.backgroundColor = 'pink';
                    }
                    this.calendarNode.append(dayNode);
                    day.setDate(day.getDate() + 1);
                }
            }
        }
        
        const Views = [
            { name: 'Calendar View', make() { return new CalendarView(); }, },
            { name: 'Clock View', make() { return new ClockView(); }, },
            {
                name: '3D View', make() {
                    const view = new GLView('3D Scene');
                    view.setShaders(defaultShaders);
                    return view;
                },
            },
            { name: 'Detail View', make() { return new DetailView(); }, },
            { name: 'Diagram', make() { return new DiagramView(); }, },
            { name: 'Editor', make() { return new Editor(); }, },
            { name: 'Scene Graph', make() {
                    const tree = new TreeView([], 'Scene Graph', {
                        getTitle: (node) => node.item[symbols.value] + '\n' + Object.entries(node.item).map(([key, value]) => `${key}: ${value}`).join('\n'),
                        actions: {},
                    });
                    return tree;
                }, 
            },            
            { name: 'Shader Editor', make() { return new ShaderEditor(); }, },
            { name: 'Shader Program Editor', make() { return new ProgramEditor(); }, },
            { name: 'Structure Editor', make() { return new StructureEditor(); }, },
            { name: 'SVG Diagram', make() { return new SVGView(Core.structure); }, },
            { name: 'Table', make() { return new TableView(Core.structure, {}); }, },
            { name: 'Tree View', make() { return new TreeView(Core.structure); }, },
            {
                name: 'Tree Diagram', make() {
                    return new SVGTreeDiagram('Tree Diagram', Core.structure, {
                        nodeContent: (node) => node[symbols.content],
                        nodeText: (node) => node.name,
                    });
                },
            },
        ];
        const addAllViews = () => {
            Views.forEach((view) => uiControls.newSidebarFrame(view.make()));
        }

        /**
         * Extract group data from match data.
         */
        function getGroupData(listDefinition) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*\|\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(listDefinition);
            const list = [];
            if (!isNaN(count)) {
                for (let i = 1; i <= count; ++i) {
                    list.push(i);
                }
            } else {
                list.push(...listDefinition.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return item.trim();
                }));
            }
            return list;
        }

        /*
         * Symbols used to provide attributes of the nodes that are independent of user attributes.
         */
        const symbols = {
            name: Symbol('name'),
            title: Symbol('title'),
            source: Symbol('source'),
            content: Symbol('content'),
            container: Symbol('container'),
            value: Symbol('value'),
            values: Symbol('values'),
            links: Symbol('links'),
            views: Symbol('views'),
            viewData: Symbol('view data'),
            name: Symbol('name'),
            fullName: Symbol('fullName'),
        };

        /**
         * Classes of the nodes in the template structure.
         */
        class MetaNode {
            constructor(value, level, lineNumber) {
                this.value = value;
                this.level = level;
                this.lineNumber = lineNumber;
                this.content = [];
            }
            makeNode(context) {
                const node = {
                    [symbols.source]: [this],
                    [symbols.container]: context.scope[0].node,
                    [symbols.content]: [],
                    [symbols.links]: {},
                    [symbols.value]: '',
                    [symbols.values]: [],
                    [symbols.views]: {},
                    [symbols.viewData]: new Map(),
                    [symbols.name]: '',
                    [symbols.fullName]() {
                        const name = this[symbols.name] || this.name;
                        return (this[symbols.container] ? [this[symbols.container], this] : [this]).map((node) => node.name);
                    },
                };
                this.startScope(context, node);
                this.parseValue(context, node);
                this.endScope(context);
                return node;
            }
            startScope(context, node) {
                const scope = {
                    node,
                    values: {},
                    modifiers: [],
                    finalisation: [],
                }
                context.scope.unshift(scope);
                return scope;
            }
            endScope(context) {
                const scope = context.scope.shift();
                scope.finalisation.forEach((finaliser) => finaliser(context));
            }
            parseValue(context, node, newNode = true) {
                node[symbols.source].push(this);
                context.parse(node, this.value, newNode);
                context.parsers.forEach((parser) => parser.apply(node, context));

                if (newNode) {
                    context.nodeList.push(node);
                    if (context.scope.length < 3) {
                        context.rootNodes.push(node);
                    }
                }

                node[symbols.content].push(...this.content.flatMap((node) => node.expand(context)));
                node[symbols.value] += `${this.value};`;
            }
        }

        class ContinuationNode extends MetaNode {
            static pattern = /^\&(?<value>.+)$/;
            static match(value) {
                return ContinuationNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ContinuationNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                this.parseValue(context, context.scope[0].node, false);
                return this.content.flatMap((node) => node.expand(context));
            }
        }

        class VariableNode extends MetaNode {
            static pattern = /^\$(?<value>.+)$/;
            static match(value) {
                return VariableNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(VariableNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const values = {};
                context.parse(values, this.value);
                const content = this.content.flatMap((node) => node.expand(context));
                if (content.length) {
                    Object.entries(values).forEach(([key, value]) => {
                        const data = content.filter((node) => key in node).map((node) => node[key]);
                        if (value === 'join') {
                            values[key] = data.join(' ');
                        } else if (value === 'sum') {
                            values[key] = data.reduce((sum, value) => sum + value, 0);
                        } else {
                            values[key] = data;
                        }
                    });
                    /*
                    const collapse = (node, key) =>
                        node[symbols.content].reduce((sum, node) => sum + collapse(node, key), node[key] || '');
                    Object.entries(values).forEach(([key, value]) =>
                        values[key] = content.reduce((sum, node) => sum + collapse(node, key), value));
                        */
                }
                Object.assign(context.scope[0].values, values);
                return [];
            }
        }

        class ExtensionNode extends MetaNode {
            static pattern = /^\*(?<value>.+)$/;
            static match(value) {
                return ExtensionNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ExtensionNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                // Check for template node
                const templateMatch = this.value.match(/ \[(?<definition>[^\[\]]+)\]$/);
                const values = [];
                let value;
                const defaults = (context.defaultValue.length > 0) ? `;${context.defaultValue.join(' ')}` : '';

                if (templateMatch) {
                    const list = getGroupData(templateMatch.groups.definition);
                    const rawValue = `${this.value.replace(/ \[[^\[\]]+\]$/, '')}${defaults}`;
                    list.forEach((item, index) => {
                        context.scope[0].values[''] = context.scope[0].values['_'] = item;
                        context.scope[0].values['_n'] = index;
                        value = rawValue;
                        context.modifiers.forEach((modifier) => value = modifier.apply(value));
                        values.push(context.resolve(value));
                    });
                } else {
                    value = `${this.value}${defaults}`;
                    context.modifiers.forEach((modifier) => value = modifier.apply(value));
                    values.push(context.resolve(value));
                }
                
                values.forEach((value) => {
                    this.value = value;
                    const name = value.split(/[\t\|;]/)[0].trim();
                    
                    // Generate a temporary node    
                    let referencedNode;
                    let level = 0;
                    const indexed = name.match(/^(?<name>[^\[]+)\[(?<index>[^\]]+)\]$/);
    
                    if (indexed) {
                        const name = indexed.groups.name;
                        const index = parseInt(indexed.groups.index);
    
                        while(!referencedNode && level < context.scope.length) {
                            const nodes = context.scope[level]?.node[symbols.content].filter((child) => child.name === name);
                            referencedNode = nodes[index];
                            ++level;
                        }
                        
                        if (!referencedNode) {
                            referencedNode = context.nodeList.filter((existing) => existing.name === name)[index];
                        }                    
                    } else {
                        while(!referencedNode && level < context.scope.length) {
                            referencedNode = context.scope[level]?.node[symbols.content].find((child) => child.name === name);
                            ++level;
                        }
                        
                        if (!referencedNode) {
                            referencedNode = context.nodeList.find((existing) => existing.name === name);
                        }
                    }
    
                    // If the name is found add the data otherwise return a new node
                    if (referencedNode) {
                        this.startScope(context, referencedNode);
                        this.parseValue(context, referencedNode, false);
                        this.endScope(context);
                    } else {
                        console.log(`NO MATCH for ${name}`);
                    }
                });
                return [];//super.makeNode(context);
            }
        }


        class GeneratorNode extends MetaNode {
            static pattern = /^\+(?<value>.+)$/;
            static match(value) {
                return GeneratorNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(GeneratorNode.pattern);
                this.value = match.groups.value;
            }
            select(rules, context) {
                const nodes = rules.startsWith('*') ? context.nodeList : context.rootNodes;
                rules = rules.replace(/^\*/, '');
                rules = rules.split(/,/).flatMap((rule) => {
                    const match = rule.match(/(?<name>[^=><]+)(?<test>[=\/><])(?<values>.*)/);
                    if (!match) {
                        return (node) => node.name === rule;
                    }
                    const name = match.groups.name;
                    const test = match.groups.test;
                    const values = match.groups.values.split(',').map((v) => numberOrString(v));
                    switch (test) {
                        case '=':
                            return (node) => values.includes(node[name]);
                        case '/':
                            const patterns = values.map((value) => new RegExp(value));
                            return (node) => patterns.some((pattern) => pattern.test(node[name]));
                        case '<':
                            return (node) => values.some((value) => value > node[name]);
                        case '>':
                            return (node) => values.some((value) => value < node[name]);
                    }
                    return [];
                });
                return nodes.filter((node) => rules.some((rule) => rule(node)));
            }
            map(context, node, mapping) {
                const newNode = {
                    [symbols.source]: [node[symbols.source][0], this],
                    [symbols.container]: context.scope[0].node,
                    [symbols.content]: [],
                    [symbols.links]: {},
                    [symbols.value]: '',
                    [symbols.values]: [],
                    [symbols.views]: {},
                    [symbols.name]: '',
                    [symbols.fullName]() {
                        const name = this[symbols.name] || this.name;
                        return (this[symbols.container] ? [this[symbols.container], this] : [this]).map((node) => node.name);
                    },
                };
                if (mapping.values.length > 0) {
                    mapping.values.forEach(([to, from]) => newNode[to] = from(node));
                } else {
/*                    Object.entries(([key, value]) => node[key] = value);
                    console.log(newNode);
                    console.log(node);
*/
                    Object.assign(newNode, node);   
                    console.log(newNode);
                    console.log(node);
                }
                return newNode;
            }
            expand(context) {
                // ToDo: allow for templated generator
                const [selector, ...values] = this.value.split(/;/);
                const nodes = this.select(selector, context);
                const mapping = {
                    options: values.filter((value) => !value.includes('=')).map((value) => value.trim().toLowerCase()),
                    values: values.filter((value) => value.includes('=')).map((value) => {
                        const [to, from] = value.split('=');
                        return [to.trim(), (node) => node[from.trim()]];
                    }),
                };
                const expanded = mapping.options.includes('content') ? nodes.flatMap((node) => node[symbols.content]) : nodes;
                if (mapping.options.includes('flatten')) {
                    const flat = (node) => [node, ...node[symbols.content].flatMap((node) => flat(node))];
                    expanded.splice(0, expanded.length, ...structure.flatMap((node) => flat(node)));
                }
                if (mapping.options.includes('count')) {
                    const values = {};
                    if (mapping.values.length === 0) {
                        expanded.forEach((node) =>
                            Object.values(node).forEach((value) => {
                                values[value] = values[value] || [];
                                values[value].push(node);
                            }));
                        } else {
                        expanded.forEach((node) =>
                            mapping.values.forEach(([to, from]) => {
                                const value = from(node);
                                values[value] = values[value] || [];
                                values[value].push(node);
                            }));
                    }
                    return Object.entries(values).map(([key, nodes]) => ({
                        [symbols.source]: nodes.map((node) => node[symbols.source][0]),
                        [symbols.container]: context.scope[0].node,
                        [symbols.content]: [],
                        [symbols.links]: {},
                        [symbols.value]: nodes.length,
                        [symbols.values]: [],
                        [symbols.views]: {},
                        [symbols.name]: '',
                        [symbols.fullName]() {
                            const name = this[symbols.name] || this.name;
                            return (this[symbols.container] ? [this[symbols.container], this] : [this]).map((node) => node.name);
                        },
                        name: key,
                        value: nodes.length,
                    }));
                }
                if (mapping.options.includes('transpose')) {
                    const keys = {};
                    expanded.forEach((node) =>
                        Object.keys(node).forEach((key) => {
                            if (key !== 'name') {
                                keys[key] = keys[key] || { name: key, [symbols.source] : node[symbols.source]};
                                keys[key][node.name] = node[key];
                            }
                        }));
                    return Object.values(keys).map((node) => this.map(context, node, mapping));
                }
                if (!mapping.values.find((map) => map[0] === 'name')) {
                    mapping.values.push(['name', (node) => `(${node.name})`]);
                }
                return expanded.flatMap((node) => this.map(context, node, mapping));
            }
        }

        /**
         * Node in which all content consists of JSON definition
         */
        class JSONNode extends MetaNode {
            static pattern = /^!JSON(?<value>.+)$/;
            static match(value) {
                return JSONNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
            }
            expand(context) {
                // consolidate the content of this node
                const getContent = (str, node) =>
                    str + `${node.value}\n${this.content.reduce(getContent, '')}`;
                const content = this.content.reduce(getContent, '');
                try {
                    return JSON.parse(content);
                } catch (error) {
                    context.warning(`Failed to parse the JSON at line ${this.lineNumber}`);
                }
                return [];
            }
        }

        /**
         * Update all nodes matching the pattern defined by the node content
         */
        class UpdateNode extends MetaNode {
            static pattern = /^\~(?<value>.+)$/;
            static match(value) {
                return UpdateNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(UpdateNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                // Generate a temporary node
                if (context.defaultValue.length > 0) {
                    this.value = `${this.value};${context.defaultValue.join(' ')}`;
                }
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const testNode = this.makeNode(context);

                let nodes = [...context.nodeList];
                if (testNode.name && testNode.name.startsWith('/')) {
                    try {
                        const re = new RegExp(testNode.name.slice(1, -1));
                        nodes = nodes.filter((node) => re.test(node.name));
                    } catch (error) {

                    }
                }
                const testKeys = Object.keys(testNode).filter((key) => key.startsWith('*'))
                    .map((key) => key.replace(/^\*/, ''));
                const valueKeys = Object.keys(testNode).filter((key) => !key.startsWith('*') && key !== 'name');

                const test = (node) => testKeys.every((key) => node[key] === testNode[`*${key}`]);
                nodes = nodes.filter((node) => test(node));

                if (nodes.length) {
                    nodes.forEach((node) => {
                        valueKeys.forEach((key) => node[key] = testNode[key]);
                    });
                    return [];
                }
                return testNode;
            }
        }

        class DefaultNode extends MetaNode {
            static pattern = /^\!(?<value>.+)$/;
            static match(value) {
                return DefaultNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(DefaultNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.defaultValue.push(this.value);
                const content = this.content.flatMap((node) => node.expand(context));
                context.defaultValue.pop();
                return content;
            }
        }

        class ViewNode extends MetaNode {
            static pattern = /^::(?<value>.+)$/;
            static match(value) {
                return ViewNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ViewNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.views.push(this.value);
                const content = this.content.flatMap((node) => node.expand(context));
                context.views.pop();
                return content;
            }
        }

        class GroupNode extends MetaNode {
            static pattern = /^\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
            static match(content) {
                const pattern = /^\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
                const match = value.match(pattern);
                this.list = match.groups.list;
                this.name = match.groups.name || '';
            }
            expand(context) {
                // Process the elements of the value based on the context
                context.modifiers.forEach((modifier) => {
                    this.list = modifier.apply(this.list);
                    this.name = modifier.apply(this.name);
                });
                this.group = getGroupData(this.list);
                this.name = (this.name || '').trim();
                const content = this.group.flatMap((item, index) => {
                    context.scope[0].values[this.name] = item;
                    context.scope[0].values[`${this.name}_n`] = index;
                    return this.content.flatMap((node) => node.expand(context));
                });
                return content;
            }
        }

        class TemplateNode extends MetaNode {
            static match(content) {
                const pattern = /^(?<value>\S.*)\[(?<list>[^\]]+)\]\s*$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^(?<value>\S.*)\[(?<list>[^\]]+)\]\s*$/;
                const match = value.match(pattern);

                this.value = match.groups.value;
                this.list = match.groups.list;
            }
            expand(context) {
                // Process the elements of the value based on the context
                if (context.defaultValue.length > 0) {
                    this.value = `${this.value};${context.defaultValue.join(' ')}`;
                }
                context.modifiers.forEach((modifier) => {
                    this.list = modifier.apply(this.list);
                    this.value = modifier.apply(this.value);
                });

                this.group = getGroupData(this.list);
                this.name = (this.name || '').trim();
                const content = this.group.flatMap((item, index) => {
                    context.scope[0].values[this.name || '_'] = item;
                    context.scope[0].values[''] = item;
                    context.scope[0].values[`${this.name}_n`] = index;
                    return super.makeNode(context);
                });
                return content;
            }
        }

        class ReferenceNode extends MetaNode {
            static pattern = /^<(?<parameter>[^=]+)=(?<value>[^>]+)>$/;
            static match(content) {
                return ReferenceNode.pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ReferenceNode.pattern);

                this.parameter = match.groups.parameter;
                this.value = match.groups.value;
            }
            expand(context) {
                // Process the elements of the value based on the context
                context.modifiers.forEach((modifier) => {
                    this.parameter = modifier.apply(this.parameter);
                    this.value = modifier.apply(this.value);
                });

                const refNode = context.nodeList.find((node) => node[this.parameters] === this.value);
                if (refNode) {
                    return refNode.source.expand(context);
                }
                context.warnings.push(`Unresolved refernce ${this.parameter} = ${this.value} on line: $(this.lineNumber}`);

                return super.makeNode(context);
            }
        }

        class ConditionalNode extends MetaNode {
            static match(content) {
                const pattern = /^\?\[(?<expr>[^\]]+)\]\s*(?<content>.*)/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\?\[(?<expr>[^\]]+)\]\s*(?<value>.*)/;
                const match = value.match(pattern);

                this.value = match.groups.value;
                this.expr = match.groups.expr;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.expr = modifier.apply(this.expr);
                    this.value = modifier.apply(this.value);
                });

                const expr = `return ${context.resolve(this.expr)}`;
                try {
                    const variables = context.scope.toReversed().reduce((values, scope) =>
                        Object.assign(values, scope.values), {});
                    const names = Object.keys(variables).map((name) => name ? name : '_');
                    const values = Object.values(variables);
                    const func = new Function(...names, expr);
                    if (func(...values)) {
                        return this.content.flatMap((node) => node.expand(context));
                    }
                } catch (e) {
                    console.log(`Invalid expression on line ${this.lineNumber} (${expr})`);
                }
                // Return an empty list on test failure or exception;
                return [];
            }
        }

        class PatternNode extends MetaNode {
            static pattern = /^!\/(?<pattern>[^\/]+)\/(?<flags>[ig])?\s*->\s*(?<replacement>.+)$/;
            static match(content) {
                return this.pattern.test(content);
            }
            constructor(value, level, lineNumber, context) {
                super(value, level, lineNumber);

                const match = value.match(PatternNode.pattern);

                this.replacement = match.groups.replacement.trim();
                try {
                    this.expression = new RegExp(match.groups.pattern, match.groups.flags);
                } catch (error) {

                }
            }
            preprocess(node) {
                node.value = node.value.replace(this.expression, this.replacement);
            }
            expand(context) {
                return this.content.flatMap((node) => node.expand(context));
            }
        }
        
        class ImportNode extends MetaNode {
            static cache = {};
            static pattern = /^<(?<url>[^>]+)>\s*/;
            static match(content) {
                return this.pattern.test(content);
            }
            static clearCache() {
                ImportNode.cache = {};
            } 
            constructor(value, level, lineNumber, context) {
                super(value, level, lineNumber);

                const match = value.match(ImportNode.pattern);

                this.url = match.groups.url.trim();
            }
            expand(context) {
                if (ImportNode.cache[this.url] === undefined) {
                    ImportNode.cache[this.url] = '';                    
                    fetch(this.url).then((response) => {
                        response.text().then((text) => {
                            ImportNode.cache[this.url] = text;
                            Core.parse();
                        });
                    });
                }
                const structure = getStructure(ImportNode.cache[this.url]);
                return expand(structure, valueParser);//this.content.flatMap((node) => node.expand(context));
            }
        }

        class ParsedPatternNode extends MetaNode {
            static pattern = /^\/(?<pattern>[^\/]+)\/(?<flags>[ig])?\s*->\s*(?<replacement>.+)$/;
            static match(content) {
                return ParsedPatternNode.pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const match = value.match(ParsedPatternNode.pattern);

                this.pattern = match.groups.pattern;
                this.flags = match.groups.flags;
                this.replacement = match.groups.replacement.trim();
            }
            expand(context) {
                try {
                    this.expr = new RegExp(this.pattern, this.flags);
                    this.apply = (value) => value.replace(this.expr, this.replacement);
                } catch (e) {
                    console.log(`Invalid Regular expression on line ${lineNumber}`);
                    this.apply = (value) => value;
                }
                context.modifiers.unshift(this);
                const content = this.content.flatMap((node) => node.expand(context));
                context.modifiers.shift();
                return content;
            }
        }

        class FormatNode extends MetaNode {
            static match(content) {
                const pattern = /^\$(?<format>(<[^>]+>[^<]+)*(<[^>]+>))\s*;?\s*$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const pattern = /^\$(?<format>(<[^>]+>[^<]+)*(<[^>]+>))\s*;?\s*$/;
                const match = value.match(pattern);
            }
            apply(value) {

            }
            expand(context) {
                const content = this.content.flatMap((node) => node.expand(context));
                return content;
            }
        }

        class TableNode extends MetaNode {
            static pattern = /^\|(?<headings>[^\t;\|]+([\t;\|][^\t;\|]+)*)\|?$/;
            static match(value) {
                return TableNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const match = value.match(TableNode.pattern);
                this.headings = match.groups.headings.split(/[\t;\|]/g);
            }
            apply(node, context) {
                const nodes = context.views.length ? context.views.map((view) => {
                    node[symbols.views][view] = node[symbols.views][view] || { [symbols.values]: [] };
                    return node[symbols.views][view];
                }) : [node];

                this.headings.forEach((heading, index) => {
                    nodes.forEach((node) => {
                        const value = node[symbols.values][index];

                        if (value !== undefined) {
                            heading = heading.trim();
                            // Use the heading ending with '*' as the name of the object
                            if (heading.endsWith('*')) {
                                node.name = node[symbols.values][index];
                                heading = heading.replace(/\*\s*$/, '');
                            }
                            if ((value + '').trim().startsWith('^')) {
                                const referenced = value.length > 1 ? value.slice(1) : heading;
                                Object.defineProperty(node, heading, {
                                    enumerable: true,
                                    get() {
                                        let container = this[symbols.container];
                                        while (container && container[referenced] === undefined) {
                                            container = container[symbols.container];
                                        }
                                        if (container) {
                                            return container[referenced];
                                        }
                                        return value;
                                    }
                                });
                            } else {
                                node[heading] = value;
                            }
                        }
                    });
                });
            }
            expand(context) {
                context.parsers.unshift(this);
                const content = this.content.flatMap((node) => node.expand(context));
                context.parsers.shift(this);
                return content;
            }
        }

        class PathNode extends MetaNode {
            static match(content) {
                const pattern = /^[\./].+$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
            }
            expand(context) {
                if (context.defaultValue.length > 0) {
                    this.value = `${this.value};${context.defaultValue.join(' ')}`;
                }
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const node = super.makeNode(context);
                const path = (node[symbols.values][0] + '').replace(/[\./]+$/, '').split(/([\./])/g);

                if (path.length > 2) {
                    const containerID = numberOrString(path.slice(0, -2).join(''));
                    const container = context.scope.find((scope) =>
                        scope.node && scope.node[symbols.values][0] === containerID)?.node ||
                        context.nodeList.find((node) =>
                            node[symbols.values][0] === containerID);
                    if (container) {
                        container[symbols.content].push(node);
                        return [];
                    }
                }
                return node;
            }
        }

        class PlainNode extends MetaNode {
            static match(content) {
                const pattern = /^.*$/;   // Match anything not already matched
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
            }
            expand(context) {
                if (context.defaultValue.length > 0) {
                    this.value = `${this.value};${context.defaultValue.join(' ')}`;
                }
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                return super.makeNode(context);
            }
        }

        /**
         * convert string definition to structure
         */
        function getStructure(definition) {
            const lines = definition.split(/\r?\n/);
            const structure = [];
            const stack = [];
            const names = {};

            // The structure is determined by indentation, level, or 'path' style.
            // When using indentation a tab is equivelent to 4 spaces.
            // Level is indicated by > at the start of a line followed by integer
            // at start of line.
            // Path is indicated by optional whitespace followed by a '.'
            // separated path, including a leading and trailling '.'.

            let lineNumber = 0;
            for (const line of lines) {
                ++lineNumber;
                if (/^\s*(#|$)/.test(line)) {
                    continue;
                }

                // Level can be determined by indentaion or numerically
                // Convert a leading integer into that number of spaces
                let level = 0;
                let levelCount = '';
                let offset = 0;
                let i = 0;
                const lineStructure = /^(?<indent>\s*[\^-]?\s*([0-9]+\s+)?)(?<value>.*)$/
                const match = line.match(lineStructure);
                const indent = match.groups.indent || ''; //line.replace(/(\s*([0-9]+\s+)?)(.*)/, '$1');
                for (let i = 0; i < indent.length; ++i) {
                    const c = indent[i];
                    if (/[0-9]/.test(c)) {
                        levelCount += c;
                    } else if (c === '^' && stack.length) {
                        offset = stack[0].level;
                    } else if (c === '-') {
                        offset = 0;
                    } else if (c === '\t') {
                        level += 4 - (level % 4);
                    } else {
                        level += 1;
                    }
                }
                level += offset;
                if (levelCount) {
                    level += parseInt(levelCount);
                }

                while (stack.length && stack[0].level >= level) {
                    stack.shift();
                }

                const value = match.groups.value;

                const node = {
                    value, lineNumber, level, content: [],
                }
                if (stack[0]) {
                    stack[0].content.push(node);
                } else {
                    structure.push(node)
                }
                stack.unshift(node);
            }
            return structure;
        }

        /**
         *
         */
        function numberOrString(input) {
            const num = Number(input);
            if (isNaN(num)) {
                const date = new Date(input);
                if (isNaN(date.getTime())) {
                    return input.trim();
                }
                return date;                
            }
            return num;
        }

        /**
         *
         */
        function setProperty(obj, name, input) {
            if (input.trim().startsWith('=')) {
                const expr = input.trim().slice(1);
                try {
                    const func = new Function(`
                    try {
                        return ${expr};
                    } catch (error) {
                        return 0;
                    }`);
                    Object.defineProperty(obj, name, {
                        enumerable: true,
                        get: func,
                    });
                } catch (e) {
                    console.log(e);
                    obj[name] = input;
                }
            } else {
                obj[name] = numberOrString(input);
            }
        }

        const sum = (list) => list.reduce((t, i) => t + i, 0);
        const mean = (list) => list.reduce((t, i) => t + i, 0) / list.length;
        const mediam = (list) => {
            list.sort((a, b) => a - b);
            if (list.length % 2) {
                return (list[(list.length / 2) - 1] + list[list.length / 2]) / 2;
            }
            return list[(list.length - 1) / 2];
        }
        const mode = (list) => {
            const counts = list.reduce((o, i) => {
                o[i] ? ++o[i] : 1;
                return o[i]; 
            }, {});
            let mode;
            let max = 0;
            Object.entries(counts).forEach(([value, count]) => {
                if (count > max) {
                    mode = value;
                    max = count;
                }
            });
            return mode;
        };  
        const concat = (list) => list.join();
        
        /**
         * Generate a node parameters from the value string and context
         */
        function valueParser(node, value, context, newNode) {
            if (value) {
                const nodes = context.views.length ? context.views.map((view) => {
                    node[symbols.views][view] = node[symbols.views][view] || { [symbols.values]: [] };
                    return node[symbols.views][view];
                }) : [node];

                const [...data] = value.split(/[\|\t;]/g);
                
                /*. todo add view parsing
                data.forEach((item) => {
                    item = item.trim();
                    if (item.includes('=')) {
                        const [name, ...valueArr] = item.split(/=/);
                        
                        const value = valueArr.join('=');
                        if (value.trim() === '') {
                            node[name] = null;
                        } else if (/^"[^"]+"$/.test(value)) {
                            node[name] = value.replace(/^"([^"]+)"$/, '$1');
                        } else if (value.startsWith('^')) {
                            const referenced = value.length > 1 ? value.slice(1) : name;
                            let container = context.container.find((container) => container[referenced] !== undefined);
                            if (container) {
                                node[name] = container[referenced];
                            } else {
                                node[name] = value;
                            }
                        } else if (value.includes(',')) {
                            node[name] = [];
                            value.split(/,/g).forEach((val, index) => setProperty(node[name], index, val));
                        } else {
                            setProperty(node, name, value);
                        }
                    }
                }
                */
                
                nodes.forEach((node) => {
                    if (newNode) {
                        node.name = data[0].trim();
                    }
                    data.forEach((item) => {
                        item = item.trim();
                        if (item.includes('=')) {
                            const [name, ...valueArr] = item.split(/=/);
                            const value = valueArr.join('=');
                            if (value.includes('...')) {
                                context.scope[0].finalisation.push((context) => {
                                    const values = node[symbols.content].map((node) => node[name]);
                                    if (value.trim() === 'sum(...)') {
                                        node[name] = sum(values);
                                    } else {
                                        node[name] = values;
                                    }
                                });
                            } else if (value.trim() === '') {
                                node[name] = null;
                            } else if (/^"[^"]+"$/.test(value)) {
                                node[name] = value.replace(/^"([^"]+)"$/, '$1');
                            } else if (value.startsWith('^')) {
                                const referenced = value.length > 1 ? value.slice(1) : name;
                                let container = context.container.find((container) => container[referenced] !== undefined);
                                if (container) {
                                    node[name] = container[referenced];
                                } else {
                                    node[name] = value;
                                }
                            } else if (value.includes(',')) {
                                node[name] = [];
                                value.split(/,/g).forEach((val, index) => setProperty(node[name], index, val));
                            } else {
                                setProperty(node, name, value);
                            }
                        } else if (item.startsWith('@')) {
                            const name = item.slice(1);
                            const referencedNode = context.nodeList.find((node) => node.name === name);
                            if (referencedNode) {
                                Object.entries(referencedNode).forEach(([key, value]) =>
                                    node[key] = key in node ? node[key] : value);
                            } else {
                                node[symbols.values].push(item);
                            }
                        } else {
                            if (/^"[^"]+"$/.test(item)) {
                                node[symbols.values].push(item);
                            } else if (item.includes(',')) {
                                node[symbols.values].push(item.split(/,/g).map((val) => numberOrString(val)));
                            } else {
                                node[symbols.values].push(numberOrString(item));
                            }
                        }
                    });
                });
            }
        }

        /**
         * Expand the structure
         */
        function expand(structure, parser) {
            const context = {
                nodeTypes: [
                    ImportNode,
                    PatternNode,
                    ContinuationNode,
                    VariableNode,
                    DefaultNode,
                    ViewNode,
                    ExtensionNode,
                    GeneratorNode,
                    UpdateNode,
                    ConditionalNode,
                    GroupNode,
                    TemplateNode,
                    ReferenceNode,
                    ParsedPatternNode,
                    FormatNode,
                    TableNode,
                    PathNode,
                    PlainNode],
                scope: [{ node: {[symbols.values]: [],[symbols.content]: []}, values: {}, modifiers: [] }],
                names: {},
                rootNodes: [],
                nodeList: [],
                modifiers: [],
                parsers: [],
                defaultValue: [],
                views: [],
                warnings: [],
                resolve(value) {
                    if (value) {
                        // Convert any variables in the string to the values in the context.
                        const variables = context.scope.toReversed().reduce((values, scope) =>
                            Object.assign(values, scope.values), {});
                        value = value.replace(/<([^>]*)>/g, (match, name) =>
                            variables[name] !== undefined ? variables[name] : `<${name}>`);
                        //value = value.replace(/\{([^:\}]+)(:0+)?\}(?<loop>\[[^\]]+\]([^\s;\t\|]+))?/g, (match, expr, format, loop, loopVar) => {
                        value = value.replace(/\{([^\+][^\}]*)\}(?<loop>\[[^\]]+\]([^\s;\t\|]+))?/g, (match, expr, loop, loopVar) => {
                            let result = match;
                            const names = Object.keys(variables).map((name) => name ? name : '_');
                            const values = Object.values(variables);
                            if (loop) {
                                const list = getGroupData(loop.replace(/\[([^\]]+)\][^\s;\t\|]+/, '$1'));
                                names.push(loopVar);
                                try {
                                    const func = new Function(...names, `return ${expr}`);
                                    result = list.reduce((ans, value) => ans + func(...values, value), '');
                                } catch (e) {
                                    console.log(`Info: expression ${expr} unresolved`);
                                }
                            } else {
                                try {
                                    result = new Function(...names, `return ${expr}`)(...values);
                                } catch (error) {
                                    console.log(variables);
                                    console.log(error.name);
                                    console.log(error.message);
                                    console.log(`Info: expression ${expr} unresolved`);
                                }
                            }
                            /*
                            if (format) {
                                result = (result + '').pad(format.length - 1, format[1]);
                            }
                            */
                            return result;
                        });
                        return value;
                    }
                },
                parse(node, value, newNode) {
                    return parser(node, this.resolve(value), this, newNode);
                },
            };

            // Determine node type based on content
            const definitionScope = [{ modifiers: [] }];
            const define = (node) => {
                const modifiers = definitionScope.flatMap((scope) => scope.modifiers);
                modifiers.forEach((modifier) => modifier.preprocess(node));
                const type = context.nodeTypes.find((type) => type.match(node.value));
                if (type) {
                    const typedNode = new type(node.value, node.level, node.lineNumber);
                    if (typedNode.preprocess) {
                        definitionScope[0].modifiers.push(typedNode);
                    } else {
                        definitionScope.unshift({ modifiers: [] });
                    }
                    typedNode.content = node.content.flatMap((node) => define(node));
                    if (definitionScope.length && !typedNode.preprocess || typedNode.content.length) {
                        definitionScope.shift();
                    }
                    return typedNode;
                }
                console.log(`Unrecognised node type on line: ${lineNumber}`);
                return [];
            }
            const defined = structure.flatMap((node) => define(node));

            const expanded = defined.flatMap((node) => node.expand(context));
            return expanded;
        }

        /**
         * Node in a tree View
         */
        class TreeViewNode {
            constructor(item, tree, container) {
                this.item = item;
                this.container = container;
                this.tree = tree;
                this.node = document.createElement('div');
                this.expander = document.createElement('span');
                this.node.append(this.expander);
                this.expander.classList.add('expander');
                this.labelNode = document.createElement('span');
                this.labelNode.innerText = this.label;
                if (this.title) {
                    this.labelNode.title = this.title;
                }
                this.node.append(this.labelNode);
                this.contentNode = document.createElement('div');
                this.node.append(this.contentNode);
                this.contentNode.classList.add('branch-content');
                this.contentNode.classList.remove('hide');
                this.structure = false;

                this.expander.addEventListener('click', (event) => this.toggle(event.ctrlKey));
                this.expander.innerHTML = this.indicator;

                if (tree.config.actions) {
                    Object.entries(tree.config.actions).forEach(([event, action]) =>
                        this.labelNode.addEventListener(event, (event) =>
                            action(event, this)));
                }
            }
            expand(recursive) {
                const content = this.content;
                this.contentNode.innerHTML = '';
                this.contentNode.classList.remove('hide');
                this.nodes = content.map((item) => {
                    const node = this.content.find((existing) => existing.item === item) ||
                        new TreeViewNode(item, this.tree, this);
                    this.contentNode.append(node.node);
                    if (recursive) {
                        node.expand(recursive);
                    }
                    return node;
                });
                this.structure = true;
                this.expander.innerHTML = this.indicator;
            }
            collapse(recursive) {
                this.contentNode.classList.add('hide');
                if (recursive) {
                    this.content.forEach((item) => node.collapse(recursive));
                }
                this.structure = false;
                this.expander.innerHTML = this.indicator;
            }
            toggle(recursive) {
                if (this.structure) {
                    this.collapse(recursive);
                } else {
                    this.expand(recursive);
                }
            }
            get indicator() {
                if (this.content.length > 0) {
                    return this.structure ? '&#9661' : '&#9655';
                }
                return '';
            }
            get label() {
                if (this.tree.config.getLabel) {
                    return this.tree.config.getLabel(this);
                }
                return this.item.name;
            }
            get title() {
                if (this.tree.config.getTitle) {
                    return this.tree.config.getTitle(this);
                }
            }
            get content() {
                if (this.tree.config.getContent) {
                    return this.tree.config.getContent(this.item);
                }
                return this.item.content || [];
            }
        }

        /**
         * Class for managing tree views
         */
        class TreeView extends View {
            static settingsMap = {
                caseSensitive: '.case-sensitive',
                regularExpression: '.regular-expression',
            }
            static defaults = {
                getContent(node) { return node[symbols.content] },
                getLabel(node) { return node.item[symbols.name] || node.item.name },
                getTitle(node) { return node.item[symbols.description] || node.item[symbols.name] || node.item.name },
                actions: {
                    'click': (event, node) => Core.currentNode = node.item,
                }
            }
            constructor(content = [], title = 'Tree', config = {}) {
                super('tree-view-template', TreeView.settingsMap);
                this.main = this.node.querySelector('.tree');
                this.title = title;

                this.config = Object.assign({}, TreeView.defaults, config);
                this.searchStack = [];
                this.path = [];
                this.setContent(content);

                const search = this.node.querySelector('.search');
                search.addEventListener('input', (event) => this.incrementalSearch());
                search.addEventListener('change', (event) => this.search());
                this.resetSearch();
            }
            setContent(content) {
                this.main.innerHTML = '';
                this.content = content;
                this.nodes = this.content.map((item) => {
                    const node = new TreeViewNode(item, this);
                    this.main.append(node.node);
                    return node;
                });
                this.resetSearch();
            }
            set currentNode(node) {
                const allNodes = [];
                const stack = [...this.nodes];
                while (stack.length) {
                    const next = stack.shift();
                    allNodes.push(next);
                    next.labelNode.classList.remove('selected');
                    stack.unshift(...(next.nodes || []));
                }

                const treeNode = allNodes.find((treeNode) => treeNode.item === node);
                if (treeNode) {
                    treeNode.labelNode.classList.add('selected');
                    treeNode.node.scrollIntoView();
                }
            }
            expand(path) {
                let nodes = this.nodes;
                let node;
                path.forEach((item) => {
                    node = nodes.find((node) => node.item === item);
                    node.expand();
                    nodes = node.nodes;
                });
                if (node) {
                    Core.currentNode = node.item;
                }
            }
            resetSearch() {
                this.searchStack.length = 0;
                this.path = [];
                this.first = true;
                this.stack = [...this.content];
            }
            search() {
                const search = this.node.querySelector('.search');

                if (search.value) {
                    const caseSensitive = this.settings.caseSensitive.checked;
                    const regularExpression = this.settings.regularExpression.checked;
                    const flags = caseSensitive ? '' : 'i';
                    const pattern = new RegExp(search.value, flags);

                    const content = this.config.getContent || ((item) => item.content);
                    const test = (node) => this.config.test ? this.config.test(node, pattern) : pattern.test(node.name);

                    while (this.stack.length) {
                        const item = this.stack.shift();
                        if (item) {
                            this.path.push(item);
                            if (test(item)) {
                                break;
                            }
                            this.stack.unshift(...content(item), null);
                        } else {
                            this.path.pop();
                        }
                    }

                    if (this.path.length) {
                        this.expand(this.path);
                    }
                } else {
                    this.resetSearch();
                }
            }
            incrementalSearch() {

            }
        }

        /**
         * Toggle the expansion of a node.
         */
        function toggleExpansion(viewNode, recursive) {
            viewNode.structure = !viewNode.structure;

            const expand = (viewNode) => {
                if (recursive) {
                    viewNode.structure = true;
                }
                viewNode.nodes.forEach((node) => node.classList.remove('collapse'));
                if (viewNode.structure) {
                    viewNode.content.forEach((part) => expand(part));
                } else {
                    viewNode.nodes[1].classList.add('collapse');
                }
            };

            const collapse = (viewNode) => {
                if (recursive) {
                    viewNode.structure = false;
                }
                viewNode.nodes.forEach((node) => node.classList.add('collapse'));
                viewNode.content.forEach((part) => collapse(part));
            };

            if (viewNode.structure) {
                viewNode.content.forEach((part) => expand(part));
                viewNode.nodes[0].innerHTML = '&CircleMinus;';
                viewNode.nodes[1].classList.remove('collapse');
            } else {
                viewNode.content.forEach((part) => collapse(part));
                viewNode.nodes[0].innerHTML = '&CirclePlus;';
                viewNode.nodes[1].classList.add('collapse');
            }
        }

        class GridTreeView extends View {
            static settingsMap = {

            }
            constructor(title = 'GridTree', config = {}, content = []) {
                super('grid-tree-view-template', GridTreeView.settingsMap);
                this.main = this.node.querySelector('.tree');
                this.title = title;

                this.config = config;

                /*
                const search = this.node.querySelector('.search');
                search.addEventListener('input', (event) => this.incrementalSearch());
                search.addEventListener('change', (event) => this.search());

                this.searchStack = [];
                this.path = [];
                */
                this.structure = content;
            }
            set structure(structure) {
                const actions = {
                    click: (event, node) => Core.currentNode = node,
                };
                this.main.innerHTML = '';

                this.nodes = [];

                const flatten = (node, level = 1) => {
                    const viewNode = {
                        node, level
                    };
                    this.nodes.push(viewNode);
                    viewNode.content = node[symbols.content].map((part) => flatten(part, level + 1));
                    return viewNode;
                };

                const tree = structure.map((part) => flatten(part));

                let depth = Math.max(...this.nodes.map((node) => node.level));

                let row = 0;
                const addNode = (viewNode) => {
                    row += 1;
                    let text = viewNode.node.name;
                    viewNode.structure = true;
                    viewNode.row = row;
                    viewNode.nodes = [];

                    const group = document.createElement('div');
                    this.main.appendChild(group);
                    group.style.gridColumn = viewNode.level;
                    const expander = document.createElement('div');
                    expander.classList.add('expand');
                    viewNode.nodes.push(expander);
                    viewNode.nodes.push(group);
                    group.appendChild(expander);
                    const content = document.createElement('div');
                    content.classList.add('content');

                    /*
                    if (controlNode) {
                        content.classList.add('control-node');
                        if (viewNode.unrolled) {
                            content.classList.add('range-expanded');
                        }
                        content.addEventListener('click', (event) => {
                            viewNode.unrolled = !viewNode.unrolled;
                            this.main.innerHTML = '';
                            row = 0;
                            structure.forEach((part) => addNode(part));
                        });
                    }
                    */
                    viewNode.nodes.push(content);
                    content.style.gridColumn = `${viewNode.level + 1}/${depth + 2}`;
                    this.main.appendChild(content);
                    const data = Object.entries(viewNode.node).map(([name, value]) => `${name} = ${value}`).join(', ');
                    content.innerText = `${text}`;// (${data})`;
                    content.title = `${viewNode.node.uniqueName} ${data}`;
                    if (viewNode.node.shape) {
                        content.classList.add('shape');
                    }
                    if (viewNode.node.sceneNode) {
                        content.classList.add('scene-node');
                    }
                    Object.entries(actions).forEach(([event, action]) =>
                        content.addEventListener(event, (event) => action(event, viewNode.node)));

                    if (viewNode.content.length) {
                        group.classList.add('group');
                        expander.innerHTML = '&CircleMinus;';
                        expander.addEventListener('click', (event) => toggleExpansion(viewNode, event.ctrlKey));
                        expander.addEventListener('dblclick', (event) => toggleExpansion(viewNode, true));

                        const startRow = row;
                        viewNode.content.forEach((viewNode) => addNode(viewNode));
                        group.style.gridRow = `${startRow}/${row + 1}`;
                        group.style.background = `hsl(${360 * Math.random()} 50% 50%)`;
                    }
                };

                const columns = `repeat(${depth}, 1em) max-content 1fr`;
                this.main.style.gridTemplateColumns = columns;

                tree.forEach((node) => addNode(node));
            }
            set currentNode(node) {
                for (const domNode of this.node.querySelectorAll('.selected')) {
                    domNode.classList.remove('selected');
                }
                this.nodes.filter((viewNode) => viewNode.node === node)
                    .forEach((viewNode) => viewNode.nodes.forEach((node) => node.classList.add('selected')));
            }
        }

        const namedNodes = {};

        class Transition {
            constructor(node) {
                this.node = node.sceneNode;
            }
            start() { }
            finish() { }
        }

        class Translate extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
                }
                const p = d * d * (3 - 2 * d);
                const v = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    ...v, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
            }
        }

        class Rotate extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
                if (this.value.length < 4) {
                    const start = this.value.length;
                    this.value.length = 4;
                    this.value.fill(0, start);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        getRotationMatrix(this.value[0], this.value.slice(1)));
                }
                const p = d * d * (3 - 2 * d);
                const angle = this.value[0] * p;
                this.node.movement = matrixMultiply(this.node.movement,
                    getRotationMatrix(angle, this.value.slice(1)));
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    getRotationMatrix(this.value[0], this.value.slice(1)));
            }
        }

        class Scale extends Transition {
            constructor(node, value) {
                super();
                if (Array.isArray(value)) {
                    this.value = value;
                } else {
                    this.value = Array(3).fill(value);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement, [
                        this.value[0], 0, 0, 0,
                        0, this.value[1], 0, 0,
                        0, 0, this.value[2], 0,
                        0, 0, 0, 1,
                    ]);
                }
                const p = d * d * (3 - 2 * d);
                const s = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    s[0], 0, 0, 0,
                    0, s[1], 0, 0,
                    0, 0, s[2], 0,
                    0, 0, 0, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform, [
                    this.value[0], 0, 0, 0,
                    0, this.value[1], 0, 0,
                    0, 0, this.value[2], 0,
                    0, 0, 0, 1,
                ]);
            }
        }

        class ColourChange extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            start() {
                this.intialColour = this.node.colour;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const v = this.value.forEach((v, i) =>
                    this.intialColour[i] + (v - this.intialColour[i]) * p);
                this.node.colour = v;
            }
        }

        class Fade extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            start() {
                this.initialAlpha = this.node.colour[3];
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const f = this.initialAlpha + (this.value - this.initialAlpha) * p;
                this.node.colour[3] = f;
            }
        }

        const nodeTransitions = {
            Translate, Rotate, Scale, ColourChange, Fade,
        };

        /**
         * Generate scene graph for the given structure
         */
        function getGraph(structure, view) {
            view.data.vertex.length = 0;
            view.data.indices.length = 0;

            let links = 0;

            const types = {
                Box, Ball, Frustrum, Cylinder, Cone, Diamond, Tetrahedron, Torus, Prism, Link,
            }
            view.shapes = [];
            const shapes = {};

            const stack = [];
            view.graph = [];
            view.nodes = [];

            function getEvents(node, sceneNode) {
                const eventPattern = /^@(?<trigger>[^,]+)\s*,\s*(?<transition>[^=]+)/
                const triggerPattern = /^(?<time>[^\/]+)\/(?<duration>[^\/]+)/
                return Object.entries(node).map(([item, value]) => {
                    const event = item.match(eventPattern);
                    if (event) {
                        const transition = nodeTransitions[event.groups.transition];
                        const triggerWithDuration = event.groups.trigger.match(triggerPattern);
                        let startTime;
                        let endTime;
                        if (triggerWithDuration) {
                            endTime = numberOrString(triggerWithDuration.groups.time);
                            const duration = numberOrString(triggerWithDuration.groups.duration);
                            startTime = endTime - duration;
                        } else {
                            endTime = numberOrString(event.groups.trigger)
                            startTime = endTime - 1;
                        }
                        if (transition) {
                            return {
                                node: sceneNode,
                                startTime,
                                endTime,
                                transition: new transition(node, value),
                            };
                        }
                    }
                }).filter((i) => i);
            }

            const handler = {};

            const add = (node) => {
                const original = node;
                handler.get = (target, prop, receiver) => {
                    if (target[symbols.views][view.title]) {
                        if (target[symbols.views][view.title][prop] !== undefined) {
                            return target[symbols.views][view.title][prop];
                        }
                    }
                    return original[prop];
                };
                node = new Proxy(node, handler);
                let index = 0;
                let positionalName = null;
                let position = node.position;

                const shapeName = positionalName || (node?.shape ? node.shape.toLowerCase() : 'none');
                const typeName = shapeName.slice(0, 1).toUpperCase() + shapeName.slice(1).toLowerCase();
                report(typeName);

                let shape;
                if (typeName && types[typeName]) {
                    const hash = types[typeName].hash(node);
                    shapes[hash] = shapes[hash] || types[typeName].make(view.context, view.data, node, index, namedNodes);
                    shape = shapes[hash];
                    view.shapes.push(shape);
                }

                let endScope = false;
                if (node.name === 'Camera') {
                    if (node.lookAt && node.lookAt.length === 3) {
                        //camera.lookAt = node.lookAt;
                    }
                    if (node.position && node.position.length === 3) {
                        //camera.position = node.position;
                    }
                    if (node.up && node.up.length === 3) {
                        //camera.up = node.up;
                    }
                } else if (node.name === 'Background') {
                    if (node.colour) {
                        background.colour = node.colour;
                    }
                } else if (position && position.length === 3) {
                    position = position.map((v) => isNaN(v) ? 0 : v);
                    const shader = node.shader || 'shader4';
                    const transform = [];
                    if (node.rotation && node.rotation.length === 4) {
                        node.rotation = node.rotation.map((v) => isNaN(v) ? 0 : v);
                        const angle = Math.PI * node.rotation[0] / 180;
                        const axis = normalised([...node.rotation.slice(1)]);
                        const q = new Quaternion(
                            Math.cos(angle / 2),
                            Math.sin(angle / 2) * axis[0],
                            Math.sin(angle / 2) * axis[1],
                            Math.sin(angle / 2) * axis[2]);
                        q.setMatrix(transform);
                        transform[12] = position[0];
                        transform[13] = position[1];
                        transform[14] = position[2];
                    } else {
                        transform.push(
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            ...position, 1);
                    }
                    if (node.scale && !isNaN(node.scale)) {
                        transform[0] *= node.scale;
                        transform[5] *= node.scale;
                        transform[10] *= node.scale;
                    }
                    const parent = node.parent;
                    let colour = node.colour;
                    let ancestor = parent;
                    while (ancestor && !colour) {
                        colour = ancestor.colour;
                        ancestor = ancestor.parent;
                    }

                    if (Array.isArray(colour)) {
                        colour = [1, 0.9, 0.5, 1].map((v, i) => colour[i] != undefined ? colour[i] : v);
                    } else {
                        colour = [1, 0.9, 0.5, 1];
                    }
                    if (Array.isArray(node.specularColour) && node.specularColour.length === 3) {

                    }

                    const sceneNode = addNode(node, transform, shape, shader, colour);
                    node[symbols.viewData].set(view, sceneNode);
                    namedNodes[node.name] = sceneNode;
                    if (stack.length > 0) {
                        stack[0][symbols.content].push(sceneNode);
                    } else {
                        view.graph.push(sceneNode);
                    }
                    sceneNode.sourceNode = original;
                    stack.unshift(sceneNode);
                    endScope = true;
                } else {
                    //console.log(node.name + ': ' + position);
                }

                if (node[symbols.content].length) {
                    node[symbols.content].forEach((part) => add(part));
                }

                if (endScope) {
                    stack.shift();
                }
            };

            structure.forEach((part) => add(part));
            //view.events.sort((a, b) => (a.startTime) - (b.startTime));

            glErrors(view.gl, '>>> Update Buffers');
        }

        /**
         *
         */
        function associateArray(node, arr, action) {
            let index = 0;
            const update = (index) => {
                return (event, value) => arr[index] = event.target.valueAsNumber;
            }

            for (const input of node.querySelectorAll('input')) {
                input.value = arr[index];
                input.addEventListener('input', update(index));
                index += 1;
            }
        }

        /**
         * Vertex shader program
         */
        const shaderObjects = [
            {
                name: 'vsSource',
                type: 'vertex',
                source: `
attribute vec4 aVertexPosition;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

varying vec4 vPosition;

void main() {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    vPosition = gl_Position;
}
                `,
            },
            {
                name: 'vsSource2',
                type: 'vertex',
                source: `
attribute vec3 aPosition;
attribute vec3 aNormal;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    // Transform vertex position and normal to eye coordinates
    vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
    vPosition = eyePosition.xyz;
    vNormal = normalize(uNormalMatrix * aNormal);

    // Output vertex position in clip coordinates
    gl_Position = uProjectionMatrix * eyePosition;
}
                `,
            },
            {
                name: 'vsSource3',
                type: 'vertex',
                source: `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTextureCoord;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

varying vec3 vPosition;
varying vec3 vNormal;
varying highp vec2 vTextureCoord;

void main() {
    // Transform vertex position and normal to eye coordinates
    vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
    vPosition = eyePosition.xyz;
    vNormal = normalize(uNormalMatrix * aNormal);

    // Output vertex position in clip coordinates
    gl_Position = uProjectionMatrix * eyePosition;
    vTextureCoord = aTextureCoord;
}`,
            },
            {
                name: 'fsSource',
                type: 'fragment',
                source: `
precision mediump float;
varying vec4 vPosition;

uniform vec4 uColour;

void main() {
    gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
    vec4 colour = vPosition * 0.15 + 0.5;
    gl_FragColor = uColour;
}`,
            },
            {
                name: 'fsSource2',
                type: 'fragment',
                source: `
precision mediump float;
varying vec4 vPosition;

uniform vec4 uColour;

void main() {
    vec4 colour = vPosition * 0.5 + 0.5;
    gl_FragColor = colour * uColour;
}`,
            },
            {
                name: 'fsSource3',
                type: 'fragment',
                source: `
precision highp float;

uniform vec3 uLightPosition;
uniform vec4 uAmbientColour;
uniform vec4 uDiffuseColour;
uniform vec3 uSpecularColour;
uniform float uShininess;

varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    // ambient
    vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;

    // Calculate diffuse lighting contribution
    vec3 lightDirection = normalize(uLightPosition - vPosition);
    float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
    vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

    // Calculate specular lighting contribution
    vec3 viewDirection = normalize(-vPosition);
    vec3 reflectionDirection = reflect(-lightDirection, vNormal);
    float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
    vec3 specular = uSpecularColour * specularIntensity;

    // Combine diffuse and specular contributions
    vec3 colour = ambient + diffuse + specular;

    // Output final colour
    gl_FragColor = vec4(colour, uDiffuseColour.a);
}
                `,
            },
            {
                name: 'fsSource4',
                type: 'fragment',
                source: `
precision highp float;

uniform vec3 uLightPosition;
uniform vec4 uAmbientColour;
uniform vec4 uDiffuseColour;
uniform vec3 uSpecularColour;
uniform float uShininess;

varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    // ambient

    // Calculate diffuse lighting contribution
    vec3 lightDirection = normalize(uLightPosition - vPosition);
    float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
    vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

    // Calculate specular lighting contribution
    vec3 viewDirection = normalize(-vPosition);
    vec3 reflectionDirection = reflect(-lightDirection, vNormal);
    float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
    vec3 specular = uSpecularColour * specularIntensity;

    float edge = clamp(1.0 - vNormal.z, 0.0, 1.0);
    vec3 ambient = edge * vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;
    // Combine diffuse and specular contributions
    vec3 colour = ambient + diffuse + specular;

    // Output final colour
    gl_FragColor = vec4(colour, uDiffuseColour.a);
}
                `,
            },
            {
                name: 'fsSource5',
                type: 'fragment',
                source: `
precision highp float;

uniform vec3 uLightPosition;
uniform vec4 uAmbientColour;
uniform vec4 uDiffuseColour;
uniform vec3 uSpecularColour;
uniform float uShininess;

varying vec3 vPosition;
varying vec3 vNormal;

float rand(float co) {
    return fract(sin(co*(91.3458)) * 47453.5453);
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float rand(vec3 co){
    return rand(co.xy+rand(co.z));
}

void main() {
    // ambient
    vec3 ambient = vec3(0.25) * uAmbientColour.rgb;

    // Calculate diffuse lighting contribution
    vec3 lightDirection = normalize(uLightPosition - vPosition);
    float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
    vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

    // Calculate specular lighting contribution
    vec3 viewDirection = normalize(-vPosition);
    vec3 reflectionDirection = reflect(-lightDirection, vNormal);
    float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
    vec3 specular = uSpecularColour * specularIntensity;

    // Combine diffuse and specular contributions
    vec3 colour = ambient + diffuse + specular;

    // Output final colour
    gl_FragColor = vec4(colour, 1.0);
}
                `,
            },
            {
                name: 'fsSource6',
                type: 'fragment',
                source: `
precision mediump float;
varying vec3 vPosition;
varying highp vec2 vTextureCoord;

uniform vec4 uDiffuseColour;
uniform sampler2D uSampler;

void main() {
    gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
    vec4 colour = vec4(vPosition * 0.15 + 0.5, 1);
    gl_FragColor = uDiffuseColour   ;
    gl_FragColor = texture2D(uSampler, vTextureCoord);
}
                `,
            },
        ];


        const vsSource = `
            attribute vec4 aVertexPosition;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;

            varying vec4 vPosition;

            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vPosition = gl_Position;
            }`;

        /**
         * Vertex shader
         */
        const vsSource2 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
            }`;

        /**
         * Vertex shader
         */
        const vsSource3 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;
            varying highp vec2 vTextureCoord;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
                vTextureCoord = aTextureCoord;
            }`;

        /**
         *
         */
        const fsSource = `
            precision mediump float;
            varying vec4 vPosition;

            uniform vec4 uColour;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 colour = vPosition * 0.15 + 0.5;
                gl_FragColor = uColour;
            }`;

        /**
         *
         */
        const fsSource2 = `
            precision mediump float;
            varying vec4 vPosition;

            uniform vec4 uColour;

            void main() {
                vec4 colour = vPosition * 0.5 + 0.5;
                gl_FragColor = colour * uColour;
            }`;


        /**
         *
         */
        const fsSource3 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient
                vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, uDiffuseColour.a);
            }`;

        /**
         *
         */
        const fsSource4 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                float edge = clamp(1.0 - vNormal.z, 0.0, 1.0);
                vec3 ambient = edge * vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;
                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, uDiffuseColour.a);

            }`;

        /**
         *
         */
        const fsSource5 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            float rand(float co) {
                return fract(sin(co*(91.3458)) * 47453.5453);
            }

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            float rand(vec3 co){
                return rand(co.xy+rand(co.z));
            }

            void main() {
                // ambient
                vec3 ambient = vec3(0.25) * uAmbientColour.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, 1.0);
            }`;

        /**
         *
         */
        const fsSource6 = `
            precision mediump float;
            varying vec3 vPosition;
            varying highp vec2 vTextureCoord;

            uniform vec4 uDiffuseColour;
            uniform sampler2D uSampler;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 colour = vec4(vPosition * 0.15 + 0.5, 1);
                gl_FragColor = uDiffuseColour   ;
                gl_FragColor = texture2D(uSampler, vTextureCoord);
            }`;


        const defaultShaders = [
            {
                name: 'shader1',
                vertex: vsSource, fragment: fsSource,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aVertexPosition' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'colour', uniform: 'uColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                ],
            },
            {
                name: 'shader2',
                vertex: vsSource, fragment: fsSource2,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aVertexPosition' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'colour', uniform: 'uColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                ],
            },
            {
                name: 'shader3',
                vertex: vsSource2, fragment: fsSource3,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aPosition' },
                    { name: 'vertexNormal', attribute: 'aNormal' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', },
                    { name: 'normalMatrix', uniform: 'uNormalMatrix', },
                    { name: 'lightPosition', uniform: 'uLightPosition', },
                    { name: 'ambient', uniform: 'uAmbientColour', },
                    { name: 'colour', uniform: 'uDiffuseColour', },
                    { name: 'specularColour', uniform: 'uSpecularColour', },
                    { name: 'shininess', uniform: 'uShininess', },
                ],
            },
            {
                name: 'shader4',
                vertex: vsSource2, fragment: fsSource4,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aPosition' },
                    { name: 'vertexNormal', attribute: 'aNormal' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'normalMatrix', uniform: 'uNormalMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix3fv(location, false, value) },

                    { name: 'lightPosition', uniform: 'uLightPosition', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                    { name: 'ambient', uniform: 'uAmbientColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                    { name: 'colour', uniform: 'uDiffuseColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                    { name: 'specularColour', uniform: 'uSpecularColour', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                    { name: 'shininess', uniform: 'uShininess', }, //, set: (location, value) => scene.gl.uniform1f(location, value) },
                ],
            },
            {
                name: 'textured',
                vertex: vsSource3, fragment: fsSource6,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aPosition' },
                    { name: 'vertexNormal', attribute: 'aNormal' },
                    { name: 'vertexTexture', attribute: 'aTextureCoord' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', type: 'mat4' },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', type: 'mat4' },
                    { name: 'normalMatrix', uniform: 'uNormalMatrix', type: 'mat3' },

                    { name: 'lightPosition', uniform: 'uLightPosition', type: 'vec3' },
                    { name: 'colour', uniform: 'uDiffuseColour', type: 'vec4' },
                    { name: 'specularColour', uniform: 'uSpecularColour', type: 'vec3' },
                    { name: 'shininess', uniform: 'uShininess', type: 'float' },
                    { name: 'texture', uniform: 'uSampler', type: 'sampler2D' },
                ],
            },
        ];

        //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        /**
         *
         */
        function initialiseShaders(gl, vsSource, fsSource) {
            //document.body.style.background = 'purple';

            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            //document.body.style.background = 'green';

            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            //document.body.style.background = 'cyan';

            const shaderProgram = gl.createProgram();
            //document.body.style.background = 'blue';

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        /**
         * creates a shader of the given type, uploads the source and
         * compiles it.
         */
        function loadShader(gl, type, source) {
            //document.body.style.background = 'red';

            const shader = gl.createShader(type);
            //document.body.style.background = 'green';
            report('1844');
            report(shader);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            //document.body.style.background = 'yellow';

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        /**
         * Create the indexes for a strip of quads formed from pairs of triangles.
         */
        function addClosedTriangleStrip(gl, indexBuffer, nQuads, start1, start2, step1 = 2, step2) {
            const offset = indexBuffer.length * 2;
            step2 = step2 || step1;
            start2 = start2 !== undefined ? start2 : start1 + 1;
            for (let i = 0; i < nQuads; ++i) {
                indexBuffer.push(start1 + i * step1);
                indexBuffer.push(start2 + i * step2);
            }
            indexBuffer.push(start1);
            indexBuffer.push(start2);
            const count = 2 + nQuads * 2
            return { mode: gl.TRIANGLE_STRIP, count, offset };
        }

        /**
         *
         */
        function addTriangles(gl, vertex, indexBuffer, points) {
            const offset = indexBuffer.length * 2;
            let index = vertex.length / 8;
            const nTriangles = Math.floor(points.length / 3);
            for (let i = 0; i < nTriangles; ++i) {
                const p0 = points[i * 3].slice(0, 3);
                const p1 = points[i * 3 + 1].slice(0, 3);
                const p2 = points[i * 3 + 2].slice(0, 3);
                const v1 = subtract(p0, p1);//[p0[0] - p1[0], p0[1] - p1[1], p0[2] - p1[2]];
                const v2 = subtract(p1, p2);//[p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];
                const n = normalised((v1, v2));
                vertex.push(...p0.slice(0, 3), ...n, ...points[i * 3].slice(3));
                indexBuffer.push(index++);
                vertex.push(...p1.slice(0, 3), ...n, ...points[i * 3 + 1].slice(3));
                indexBuffer.push(index++);
                vertex.push(...p2.slice(0, 3), ...n, ...points[i * 3 + 2].slice(3));
                indexBuffer.push(index++);
            }

            return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
        }

        /**
         *
         */
        function addClosedTriangleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;

            if (true) {
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(centre);
                    indexBuffer.push(first + i * step);
                    indexBuffer.push(first + ((i + 1) % nTriangles) * step);
                }
                return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
            } else {
                indexBuffer.push(centre);
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(first + i * step);
                }
                indexBuffer.push(first);
                const count = 2 + nTriangles
                return { mode: gl.TRIANGLE_FAN, count, offset };
            }
        }

        /**
         *
         */
        function addOpenTraingleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;
            indexBuffer.push(centre);
            for (let i = 0; i <= nTriangles; ++i) {
                indexBuffer.push(first + i * step);
            }
            const count = 2 + nTriangles
            return { mode: gl.TRIANGLE_FAN, count, offset };
        }

        /**
         *
         */
        function addLineLoop(gl, indexBuffer, nSegments, first, step = 1) {
            const offset = indexBuffer.length * 2;
            for (let i = 0; i < nSegments; ++i) {
                indexBuffer.push(first + i * step);
            }
            indexBuffer.push(first);
            const count = 1 + nSegments
            return { mode: gl.LINE_STRIP, count, offset, colour: [0, 0, 0.2, 1.0] };
        }


        /**
         * Initialize a texture and load an image.
         * When the image finished loading copy it into the texture.
         */
        function loadTexture(gl, url) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Because images have to be downloaded over the internet
            // they might take a moment until they are ready.
            // Until then put a single pixel in the texture so we can
            // use it immediately. When the image has finished downloading
            // we'll update the texture with the contents of the image.
            const level = 0;
            const internalFormat = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
            gl.texImage2D(
                gl.TEXTURE_2D,
                level,
                internalFormat,
                width,
                height,
                border,
                srcFormat,
                srcType,
                pixel,
            );

            const image = new Image();
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    level,
                    internalFormat,
                    srcFormat,
                    srcType,
                    image,
                );

                // WebGL1 has different requirements for power of 2 images
                // vs. non power of 2 images so check if the image is a
                // power of 2 in both dimensions.
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    // Yes, it's a power of 2. Generate mips.
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    // No, it's not a power of 2. Turn off mips and set
                    // wrapping to clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
            };
            image.src = url;

            return texture;
        }

        function isPowerOf2(value) {
            return (value & (value - 1)) === 0;
        }

        const textures = [];

        /**
         * Add a texture to teh library
         */
        function getTexture(url, view) {
            const current = textures.find((texture) => texture.url === url);
            if (!current) {
                textures.push({ url, texture: loadTexture(view.gl, url) });
            }
            return current;
        }

        /**
         * 
         */
        function bindTextures(gl) {
            textures.forEach((texture, index) => {
                // Tell WebGL we want to affect texture unit 0
                gl.activeTexture(gl.TEXTURE0 + index);

                // Bind the texture to texture unit 0
                gl.bindTexture(gl.TEXTURE_2D, texture.texture);

                // Tell the shader we bound the texture to texture unit 0
                //gl.uniform1i(programInfo.uniformLocations.uSampler, index);
            });
        }


        class shape {
            constructor(data) { }
            updateBuffers(gl) { }
            draw3d(gl, shader) {
                this.elements.forEach((shape) => {
                    if (shape.colour) {
                        gl.uniform4fv(shader.colour, shape.colour);
                    }
                    gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                });
            }
        }

        /**
         *
         */
        class Box extends shape {
            static parameters(node) {
                const size = node.size || [1, 1, 1];
                const width = node.width || size[0] || 1;
                const height = node.height || size[1] || size[0] || 1;
                const depth = node.depth || size[2] || size[0] || 1;
                const mapping = node.mapping;
                return [width, height, depth, mapping, node.sides, node.lines];
            }
            static make(gl, data, node, index) {
                return new Box(gl, data, ...Box.parameters(node));
            }
            static hash(node) {
                return `box ${Box.parameters(node)}`;
            }
            constructor(gl, data, width = 1, height = 1, depth = 1, mapping, sides = [1, 1, 1, 1, 1, 1], lines) {
                super();
                if (!Array.isArray(sides)) {
                    sides = [];
                }
                for (let i = 0; i < 6; ++i) {
                    sides[i] = sides[i] === undefined ? true : sides[i];
                }
                this.width = width;
                this.height = height;
                this.depth = depth;
                const w = width;
                const h = height;
                const d = depth;
                const start = data.vertex.length / 8;

                const addFace = (p1, p2, p3, p4, normal, mapping) => {
                    const start = data.vertex.length / 8;
                    if (mapping !== undefined) {
                        const u1 = (mapping % 4) / 4;
                        const v1 = Math.floor(mapping / 4) / 3;
                        const u2 = ((mapping % 4) + 1) / 4;
                        const v2 = (Math.floor(mapping / 4) + 1) / 3;
                        data.vertex.push(...p1, ...normal, u1, v1);
                        data.vertex.push(...p2, ...normal, u1, v2);
                        data.vertex.push(...p3, ...normal, u2, v1);
                        data.vertex.push(...p4, ...normal, u2, v2);
                    } else {
                        data.vertex.push(...p1, ...normal, 0, 0);
                        data.vertex.push(...p2, ...normal, 0, 1);
                        data.vertex.push(...p3, ...normal, 1, 0);
                        data.vertex.push(...p4, ...normal, 1, 1);
                    }
                    data.indices.push(...[0, 1, 2, 3, 2, 1].map((i) => i + start));
                };
                const indexStart = data.indices.length;
                const points = [
                    [0, 0, 0],
                    [0, h, 0],

                    [w, 0, 0],
                    [w, h, 0],

                    [w, 0, d],
                    [w, h, d],

                    [0, 0, d],
                    [0, h, d],
                ];
                points.forEach((point) => {
                    data.vertex.push(...point, 0, 0, 1, 0, 0);
                });
                data.indices.push(...[
                    0, 2, 4, 6, 0, 1, 3, 5, 7, 1,
                    2, 3, 4, 5, 6, 7,
                ].map((i) => i + start));
                mapping = mapping || Array(6);

                let count = 0;
                if (sides[0]) {
                    addFace(points[0], points[1], points[2], points[3], [0, 0, 1], mapping[0]);
                    count += 6;
                }
                if (sides[1]) {
                    addFace(points[2], points[3], points[4], points[5], [1, 0, 0], mapping[1]);
                    count += 6;
                }
                if (sides[2]) {
                    addFace(points[4], points[5], points[6], points[7], [0, 0, -1], mapping[2]);
                    count += 6;
                }
                if (sides[3]) {
                    addFace(points[6], points[7], points[0], points[1], [-1, 0, 0], mapping[3]);
                    count += 6;
                }
                if (sides[4]) {
                    addFace(points[0], points[2], points[6], points[4], [0, -1, 0], mapping[4]);
                    count += 6;
                }
                if (sides[5]) {
                    addFace(points[1], points[3], points[7], points[5], [0, 1, 0], mapping[5]);
                    count += 6;
                }

                this.elements = [];
                if (count) {
                    this.elements.push({ mode: gl.TRIANGLES, count, offset: (16 + indexStart) * 2 });
                }
                if (lines) {
                    this.elements.push(
                        { mode: gl.LINE_STRIP, count: 10, offset: (indexStart) * 2, colour: [1, 1, 1, 1] },
                        { mode: gl.LINES, count: 6, offset: (10 + indexStart) * 2, colour: [1, 1, 1, 1] });
                }
            }
            intersects(line) {
                const planes = [
                    { point: [this.width / 2, 0, 0], normal: [1, 0, 0] },
                    { point: [-this.width / 2, 0, 0], normal: [-1, 0, 0] },
                    { point: [0, this.height / 2, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height / 2, 0], normal: [0, -1, 0] },
                    { point: [0, 0, this.depth / 2], normal: [0, 0, 1] },
                    { point: [0, 0, -this.depth / 2], normal: [0, 0, -1] },
                ];
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const w = this.width / 2;
                const h = this.height / 2;
                const d = this.depth / 2;
                const points = [
                    [-w, -h, -d,],
                    [w, -h, -d,],
                    [w, -h, d,],
                    [-w, -h, d,],

                    [-w, h, -d,],
                    [w, h, -d,],
                    [w, h, d,],
                    [-w, h, d,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.lineTo(points[4][0], points[4][1]);

                context.moveTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.moveTo(points[2][0], points[2][1]);
                context.lineTo(points[6][0], points[6][1]);
                context.moveTo(points[4][0], points[4][1]);
                context.lineTo(points[7][0], points[7][1]);
                context.stroke();
            }
        }

        /**
         *
         */
        class Diamond extends shape {
            static make(gl, data, node, index) {
                return new Diamond(gl, data, node.size);
            }
            static hash(node) {
                return `diamond ${node.size}`;
            }
            constructor(gl, data, size = 1) {
                super();
                this.size = size;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;
                const points = [
                    [0, 1, 0, 0.125, 0],
                    [1, 0, 0, 0, 0.5],
                    [0, 0, 1, 0.25, 0.5],

                    [0, 1, 0, 0.375, 0],
                    [0, 0, 1, 0.25, 0.5],
                    [-1, 0, 0, 0.5, 0.5],

                    [0, 1, 0, 0.625, 0],
                    [-1, 0, 0, 0.5, 0.5],
                    [0, 0, -1, 0.75, 0.5],

                    [0, 1, 0, 0.875, 0],
                    [0, 0, -1, 0.75, 0.5],
                    [1, 0, 0, 1, 0.5],


                    [0, -1, 0, 0.125, 1],
                    [1, 0, 0, 0, 0.5],
                    [0, 0, 1, 0.25, 0.5],

                    [0, -1, 0, 0.375, 1],
                    [0, 0, 1, 0.25, 0.5],
                    [-1, 0, 0, 0.5, 0.5],

                    [0, -1, 0, 0.625, 1],
                    [-1, 0, 0, 0.5, 0.5],
                    [0, 0, -1, 0.75, 0.5],

                    [0, -1, 0, 0.875, 1],
                    [0, 0, -1, 0.75, 0.5],
                    [1, 0, 0, 1, 0.5],
                ].map((point) => point.map((v, i) => i < 3 ? v * size : v));

                data.indices.push(...[
                    0, 1, 2, 0, 7, 8, 0,
                    12, 13, 14, 12, 17, 18, 12
                ].map((i) => i + start));

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINE_STRIP, count: 7, offset: (24 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 7, offset: (31 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ];

                const planes = [
                    planeFromPoints(points[0], points[2], points[1]),
                    planeFromPoints(points[0], points[3], points[2]),
                    planeFromPoints(points[0], points[4], points[3]),
                    planeFromPoints(points[0], points[1], points[4]),

                    planeFromPoints(points[5], points[1], points[2]),
                    planeFromPoints(points[5], points[2], points[3]),
                    planeFromPoints(points[5], points[3], points[4]),
                    planeFromPoints(points[5], points[4], points[1]),
                ];

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ].map((p) => transformed(p, transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[0][0], points[0][1]);

                context.moveTo(points[5][0], points[5][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[5][0], points[5][1]);
                context.lineTo(points[4][0], points[4][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[5][0], points[5][1]);

                context.stroke();
            }
        }

        /**
         *
         */
        class Ball extends shape {
            static make(gl, data, node, index) {
                const values = node.parameters || [];
                const size = node.size || values[index++] || 2;
                const width = node.width || size[0] || values[index++] || 2;
                const depth = node.depth || size[1] || values[index++] || 2;
                const height = node.height || size[2] || values[index++] || 2;
                const sides = node.sides || values[index++] || 12;
                const strips = node.strips || values[index++] || 12;
                const mode = node.mode || values[index++] || 'solid';

                return new Ball(gl, data, width, depth, height, sides, strips);
            }
            static hash(node) {
                return `ball ${node.size} ${node.height} ${node.depth} ${node.sides} ${node.strips}`;
            }
            constructor(gl, data, width = 2, depth = 0, height = 0, sides = 12, strips = 12) {
                super();
                depth = depth || width
                height = height || width

                this.width = width / 2;
                this.depth = depth / 2;
                this.height = height / 2;
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                // Create the mesh for the ball
                data.vertex.push(0, height / 2, 0);
                data.vertex.push(0, 1, 0);
                data.vertex.push(0.5, 0);
                data.vertex.push(0, -height / 2, 0);
                data.vertex.push(0, -1, 0);
                data.vertex.push(0.5, 1);
                for (let j = 0; j < strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / strips);
                    for (let i = 0; i < sides; ++i) {
                        const radians = (i * 2) * Math.PI / sides;
                        data.vertex.push(
                            this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians));
                        data.vertex.push(
                            radius * Math.sin(radians), ny, radius * Math.cos(radians));
                        data.vertex.push(i / (sides - 1), j / (strips - 1));
                    }
                }

                const elements = [
                    addClosedTriangleFan(gl, data.indices, sides, start, start + 2),
                    addClosedTriangleFan(gl, data.indices, sides, start + 1, start + 2 + (strips - 2) * sides),
                ];

                for (let j = 0; j < strips - 2; ++j) {
                    elements.push(addClosedTriangleStrip(gl, data.indices, sides, start + 2 + j * sides, start + 2 + (j + 1) * sides, 1, 1));
                }

                this.elements = elements;
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Torus extends shape {
            static make(gl, data, node, index) {
                const values = node.parameters || [];
                const size = node.size || values[index++] || 2;
                const thickness = node.thickness || values[index++] || 1;
                const sides = node.sides || values[index++] || 12;
                const strips = node.strips || values[index++] || 12;
                const start = node.start || values[index++] || 0;
                const mode = node.mode || values[index++] || 'solid';

                return new Torus(gl, data, size, thickness, sides, strips, start, mode);
            }
            static hash(node) {
                return `torus ${node.size} ${node.thickness} ${node.sides} ${node.strips}`;
            }
            constructor(gl, data, mainRadius = 2, minorRadius = 1, sides = 12, strips = 12, startAngle = 0, mode = 'solid') {
                super();
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 8;
                startAngle = startAngle * Math.PI / 180;

                // Create the mesh for the torus
                for (let j = 0; j < sides; ++j) {
                    const dx = Math.cos(2 * j * Math.PI / sides);
                    const dz = Math.sin(2 * j * Math.PI / sides);

                    for (let i = 0; i < strips; ++i) {
                        const angle = startAngle + 2 * i * Math.PI / strips;
                        const x = dx * (mainRadius + minorRadius * Math.sin(angle));
                        const y = minorRadius * Math.cos(angle);
                        const z = dz * (mainRadius + minorRadius * Math.sin(angle));
                        data.vertex.push(x, y, z);
                        data.vertex.push(dx * Math.sin(angle), y, dz * Math.sin(angle));
                        data.vertex.push(j / (sides - 1), i / (strips - 1));
                    }
                }

                this.elements = [];
                if (mode !== 'wireframe') {
                    for (let j = 0; j < sides; ++j) {
                        const start1 = start + j * strips;
                        const start2 = start + ((j + 1) % sides) * strips;
                        this.elements.push(addClosedTriangleStrip(gl, data.indices, strips, start1, start2, 1, 1));
                    }
                }

                if (mode === 'lined' || mode === 'wireframe') {
                    for (let i = 0; i < sides; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, strips, start + i * strips, 1));
                    }
                    for (let i = 0; i < strips; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, sides, start + i, strips));
                    }
                }
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Frustrum extends shape {
            static make(gl, data, node, index) {
                return new Frustrum(gl, data, node.baseRadius, node.topRadius, node.height, node.sides);
            }
            static hash(node) {
                return `frustrum ${node.baseRadius} ${node.topRadius} ${node.height} ${node.sides}`;
            }
            constructor(gl, data, baseRadius = 1, topRadius = 0.5, height = 2, sides = 12) {
                super();
                height /= 2;
                this.height = height;
                this.baseRadius = baseRadius;
                this.topRadius = topRadius;
                this.sides = sides;

                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                const angle = Math.atan((baseRadius - topRadius) / 2 * height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                for (let i = 0; i < sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / sides;
                    const topRadians = (1 + i * 2) * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(baseRadians), -height, baseRadius * Math.cos(baseRadians),
                        nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),
                        i / (sides - 1), 0.25,
                        topRadius * Math.sin(topRadians), height, topRadius * Math.cos(topRadians),
                        nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),
                        i / (sides - 1), 0.75);
                }

                data.vertex.push(0, -height, 0);
                data.vertex.push(0, -1, 0);
                data.vertex.push(0.5, 0);

                for (let i = 0; i < sides; ++i) {
                    const angle = i * 2 * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(angle), -height, baseRadius * Math.cos(angle),
                        0, -1, 0,
                        i / (sides - 1), 0.25);
                }

                const elements = [
                    addClosedTriangleStrip(gl, data.indices, sides, start),
                    addClosedTriangleFan(gl, data.indices, sides, start + 2 * sides, 1 + start + 2 * sides),
                ];

                if (topRadius > 0) {
                    data.vertex.push(0, height, 0);
                    data.vertex.push(0, 1, 0);
                    data.vertex.push(0.5, 1);

                    for (let i = 0; i < sides; ++i) {
                        const angle = (1 + i * 2) * Math.PI / sides;
                        data.vertex.push(
                            topRadius * Math.sin(angle), height, topRadius * Math.cos(angle),
                            0, 1, 0,
                            i / (sides - 1), 0.75);
                    }
                    elements.push(addClosedTriangleFan(gl, data.indices, sides, 1 + start + 3 * sides, 2 + start + 3 * sides));
                }

                elements.push(
                    Object.assign(addLineLoop(gl, data.indices, sides, 1 + start + 2 * sides), { colour: [1, 1, 1, 1] }));

                if (topRadius > 0) {
                    elements.push(
                        Object.assign(addLineLoop(gl, data.indices, sides, 2 + start + 3 * sides), { colour: [1, 1, 1, 1] }));
                }

                if (sides < 7) {
                    elements.push({ mode: gl.LINE_STRIP, count: sides * 2, offset: indexStart * 2, colour: [1, 1, 1, 1] });
                }
                this.elements = elements;
            }
            intersects(line) {
                const angle = Math.atan((this.baseRadius - this.topRadius) / 2 * this.height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                const planes = [
                    { point: [0, this.height, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height, 0], normal: [0, -1, 0] },
                ];

                for (let i = 0; i < this.sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / this.sides;
                    const topRadians = (1 + i * 2) * Math.PI / this.sides;

                    planes.push({
                        point: [this.baseRadius * Math.sin(baseRadians), -this.height, this.baseRadius * Math.cos(baseRadians),],
                        normal: [nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),],
                    }, {
                        point: [this.topRadius * Math.sin(topRadians), this.height, this.topRadius * Math.cos(topRadians),],
                        normal: [nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),],
                    });
                }

                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Cylinder extends Frustrum {
            static make(gl, data, node) {
                var index = 0;
                const values = node[symbols.values] || [];
                const radius = node.radius || values[index++];
                const height = node.height || values[index++];
                const sides = node.sides || values[index++];
                return new Cylinder(gl, data, node.radius, node.height, node.sides);
            }
            static hash(node) {
                return `cylinder ${node.radius} ${node.height} ${node.sides}`;
            }
            constructor(gl, data, radius = 1, height = 2, sides = 12) {
                super(gl, data, radius, radius, height, sides);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Cone extends Frustrum {
            static make(gl, data, node) {
                return new Cone(gl, data, node.radius, node.height, node.sides);
            }
            static hash(node) {
                return `cone ${node.radius} ${node.height} ${node.sides}`;
            }
            constructor(gl, data, radius = 1, height = 2, sides = 12) {
                super(gl, data, radius, 0, height, sides);
            }
            draw2d(context, transform) {
            }
        }

        /**
         *
         */
        class Tetrahedron extends shape {
            static make(gl, data, node, index) {
                return new Tetrahedron(gl, data, node.size);
            }
            static hash(node) {
                return `tetrahedron ${node.size}`;
            }
            constructor(gl, data, size = 1) {
                super();
                const start = data.vertex.length / 8;
                this.size = 1;
                const indexStart = data.indices.length;
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0, 0.25, 0],
                    [0, -0.5, l, 0, 0.5],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],

                    [0, 1, 0, 0.5, 0],
                    [0, -0.5, l, 2 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 1 / 3, 0.5],

                    [0, 1, 0, 0.25, 0],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 2 / 3, 0.5],

                    [0, -0.5, l, 0, 0.5],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 1 / 6, 1],
                ].map((point) => point.map((v, i) => i < 3 ? v * size : v));

                const indices = [0, 1, 1, 2, 2, 0, 3, 0, 3, 1, 3, 2].map((i) => i + start);
                data.indices.push(...indices);

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINES, count: 12, offset: (12 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const l = Math.cos(30 * Math.PI / 180);
                const sides = [
                    [[0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l]],
                    [[0, 1, 0],
                    [-l * l, -0.5, -0.5 * l],
                    [0, -0.5, l],],
                    [[0, 1, 0],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l]],
                    [[l * l, -0.5, -0.5 * l],
                    [0, -0.5, l,],
                    [-l * l, -0.5, -0.5 * l]],
                ].map((point) => point.map((v) => scaled(v, this.size)));

                const planes = sides.map((side) => planeFromPoints(...side));
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((p) => transformed(scaled(p, this.size), transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[1][0], points[1][1]);

                context.moveTo(points[3][0], points[3][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.stroke();
            }
        }

        /**
          *
          */
        class Prism extends shape {
            static getPoints(node) {
                const points = [];
                if (Array.isArray(node.points)) {
                    for (let i = 0; i < node.points.length; i += 2) {
                        points.push([node.points[i], node.points[i + 1] || 0]);
                    }
                }
                if (Array.isArray(node.path)) {
                    let x = 0;
                    let z = 0;
                    if (points.length > 0) {
                        x = points[points.length - 1][0];
                        z = points[points.length - 1][1];
                    }

                    for (let i = 0; i < node.path.length; i += 2) {
                        x += node.path[i] || 0;
                        z += node.path[i + 1] || 0;
                        points.push([x, z]);
                    }
                }
                return points;
            }
            static make(gl, data, node, index) {
                return new Prism(gl, data, Prism.getPoints(node), node.height, node.smooth, node.sides, node.lines);
            }
            static hash(node) {
                const points = Prism.getPoints(node);
                return `Prism ${points.join(',')} ${node.height} ${node.smooth}, ${node.sides}`;
            }
            constructor(gl, data, points = [[0, 0], [0, 1], [0, -1]], height = 1, smooth, sides = [], lines) {
                super();
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                this.height = height;
                this.points = points;

                const addFace = (p1, p2, p3, p4, mapping) => {
                    const start = data.vertex.length / 8;
                    const v1 = subtract(p2, p1);
                    const v2 = subtract(p3, p1);
                    const normal = normalised(cross(v1, v2));
                    if (mapping !== undefined) {
                        const u1 = (mapping % 4) / 4;
                        const v1 = Math.floor(mapping / 4) / 3;
                        const u2 = ((mapping % 4) + 1) / 4;
                        const v2 = (Math.floor(mapping / 4) + 1) / 3;
                        data.vertex.push(...p1, ...normal, u1, v1);
                        data.vertex.push(...p2, ...normal, u1, v2);
                        data.vertex.push(...p3, ...normal, u2, v1);
                        data.vertex.push(...p4, ...normal, u2, v2);
                    } else {
                        data.vertex.push(...p1, ...normal, 0, 0);
                        data.vertex.push(...p2, ...normal, 0, 1);
                        data.vertex.push(...p3, ...normal, 1, 0);
                        data.vertex.push(...p4, ...normal, 1, 1);
                    }
                    data.indices.push(...[0, 1, 2, 3, 2, 1].map((i) => i + start));
                };

                const base = (point) => [point[0], 0, point[1]];
                const top = (point) => [point[0], height, point[1]];
                let count = 0;
                points.forEach((point, index) => {
                    const next = points[(index + 1) % points.length];
                    if (sides[index] === undefined || sides[index]) {
                        addFace(base(point), top(point), base(next), top(next));
                        count += 6;
                    }
                });
                this.elements = [];

                const offset = data.indices.length * 2;
                const baseIndex = data.vertex.length / 8;
                data.vertex.push(...points.flatMap((point) => [point[0], 0, point[1], 0, -1, 0, 0, 0]));
                const topIndex = data.vertex.length / 8;
                data.vertex.push(...points.flatMap((point) => [point[0], height, point[1], 0, 1, 0, 0, 0]));

                const det = (u, v) => u[0] * v[1] - u[1] * v[0];

                const winding = (p0, p1, p2) => {
                    const v1 = [p1[0] - p0[0], p1[1] - p0[1]];
                    const v2 = [p2[0] - p1[0], p2[1] - p1[1]];

                    return det(v1, v2) / (Math.hypot(...v1) * Math.hypot(...v2));
                }

                const inside = (p0, d1, d2, point) => {
                    const a = (det(point, d2) - det(p0, d2)) / det(d1, d2);
                    const b = (det(p0, d1) - det(point, d1)) / det(d1, d2);

                    return (a > 0) && (b > 0) && (a + b < 1);;
                }

                const empty = (p0, p1, p2) => {
                    const d1 = [p0[0] - p1[0], p0[1] - p1[1]];
                    const d2 = [p2[0] - p1[0], p2[1] - p1[1]];

                    return !points.some((point) => inside(p1, d1, d2, point));
                }

                const d = [];
                for (let j = 0; j < points.length; ++j) {
                    const i = (j + points.length - 1) % points.length;
                    const k = (j + 1) % points.length;
                    d.push(winding(points[i], points[j], points[k]));
                }

                const sign = d.reduce((sum, d) => sum + d, 0);
                const drawBase = sides[points.length] === undefined || sides[points.length];
                const drawTop = sides[points.length + 1] === undefined || sides[points.length + 1];

                if (drawBase || drawTop) {
                    const remaining = points.map((point, index) => index);
                    let current = 0;
                    let loops = 0;
                    let indices = [];
                    while (remaining.length > 2 && loops < 1000) {
                        const prior = (current + remaining.length - 1) % remaining.length;
                        const next = (current + 1) % remaining.length;
                        const p0 = points[remaining[prior]];
                        const p1 = points[remaining[current]];
                        const p2 = points[remaining[next]];
                        if (winding(p0, p1, p2) * sign > 0 && empty(p0, p1, p2)) {
                            indices.push(remaining[prior], remaining[current], remaining[next]);
                            remaining.splice(current, 1);
                        } else {
                            current = next;
                        }
                        current = current % remaining.length;
                        ++loops;
                    }
                    if (drawBase) {
                        data.indices.push(...indices.map((i) => i + baseIndex));
                        count += indices.length;
                    }
                    if (drawTop) {
                        data.indices.push(...indices.map((i) => i + topIndex));
                        count += indices.length;
                    }
                }
                if (count > 0) {
                    this.elements.push({ mode: gl.TRIANGLES, count, offset: indexStart * 2 });
                }
                if (lines) {
                    this.elements.push(addLineLoop(gl, data.indices, points.length, baseIndex));
                    this.elements.push(addLineLoop(gl, data.indices, points.length, topIndex));
                    {
                        const offset = data.indices.length * 2;
                        for (let i = 0; i < points.length; ++i) {
                            data.indices.push(baseIndex + i, topIndex + i);
                        }
                        this.elements.push({ mode: gl.LINES, count: points.length * 2, offset });
                    }
                }
            }
            get3dPoints() {
                return [
                    ...this.points.map((point) => [point[0], 0, point[1]]),
                    ...this.points.map((point) => [point[0], this.height, point[1]]),
                ];
            }
            getSides() {
                const points = this.getPoints();
                const nPoints = this.points.length;
                const faces = this.points.map((point, i) => [
                    points[i], points[(i + 1) % nPoints],
                    points[nPoints + (i + 1) % nPoints], points[i + nPoints],
                ]);
            }
            intersects(line) {
                return false;
                const planes = this.points.map((point, index) => {
                    const next = this.points[(index + 1) % this.points.length];
                    const v1 = [next[0] - point[0], 0, next[1] - point[1]]
                    const v2 = [0, 1, 0];
                    const normal = normalised(cross(v1, v2));
                    return { point: [point[0], 0, point[1]], normal };
                });
                return convexHullIntercept(line, planes);
            }
            draw2d(context, transform) {
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l],
                ].map((p) => transformed(scaled(p, this.size), transform));

                context.beginPath();
                context.moveTo(points[0][0], points[0][1]);
                context.lineTo(points[1][0], points[1][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.lineTo(points[0][0], points[0][1]);
                context.lineTo(points[3][0], points[3][1]);
                context.lineTo(points[1][0], points[1][1]);

                context.moveTo(points[3][0], points[3][1]);
                context.lineTo(points[2][0], points[2][1]);
                context.stroke();
            }
        }

        /**
         * Find the first node that matches the name or undefined if no match found
         */
        function findNode(name) {
            return namedNodes[name];
        }

        /**
         * Connection between two nodes
         */
        class Link {
            static make(gl, buffers, node, index, namedNodes) {
                const from = node.from;
                const to = node.to;
                const values = node.points;
                // Ensure points list is valid
                if (Array.isArray(values)) {
                    values.length = 3 * Math.floor(values.length / 3);
                    const points = [];
                    for (let i = 0; i < values.length; i += 3) {
                        points.push([
                            isNaN(values[i]) ? 0 : values[i],
                            isNaN(values[i + 1]) ? 0 : values[i + 1],
                            isNaN(values[i + 2]) ? 0 : values[i + 2],
                        ]);
                    }
                    return new Link(gl, buffers, from, to, points);
                } else {
                    return new Link(gl, buffers, from, to);
                }
            }
            static hash(node) {
                return `link ${++links}`;
            }
            constructor(gl, data, from, to, points = []) {
                this.from = from;
                this.to = to;
                this.points = [[0, 0, 0], ...points, [0, 0, 0]];

                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;
                this.pointIndex = data.vertex.length;
                this.pointIndex2 = data.vertex.length + 8 + points.length * 8;

                data.vertex.push(...this.points.flatMap((point) => [...point, 0, 0, -1, 0, 0]));
                const indices = Array(this.points.length).fill(1).map((e, i) => i + start);

                data.indices.push(...indices);

                this.elements = [
                    { mode: gl.LINE_STRIP, count: this.points.length, offset: 2 * indexStart, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
            }
            updateBuffers(scene, node) {
                this.fromNode = this.fromNode || findNode(this.from) || node.parent;
                this.toNode = this.toNode || findNode(this.to) || node.parent;
                let inverse = identityMatrix();
                if (node.parent) {
                    inverse = invert(node.parent.world);
                }

                if (this.fromNode?.world && this.toNode?.world) {
                    const from = this.fromNode === node.parent ?
                        [0, 0, 0] : transformed(transformed([0, 0, 0], this.fromNode.world), inverse);

                    const to = this.toNode === node.parent ?
                        [0, 0, 0] : transformed(transformed([0, 0, 0], this.toNode.world), inverse);

                    scene.data.vertex[this.pointIndex] = from[0];
                    scene.data.vertex[this.pointIndex + 1] = from[1];
                    scene.data.vertex[this.pointIndex + 2] = from[2];

                    scene.data.vertex[this.pointIndex2] = to[0];
                    scene.data.vertex[this.pointIndex2 + 1] = to[1];
                    scene.data.vertex[this.pointIndex2 + 2] = to[2];
                }
            }
            draw3d(gl, shader) {
                if (this.fromNode && this.toNode) {
                    this.elements.forEach((shape) => {
                        if (shape.colour) {
                            gl.uniform4fv(shader.colour, shape.colour);
                        }
                        gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                    });
                }
            }
            draw2d(context, transform) {
                if (this.fromNode && this.toNode) {
                    const points2d = this.points.map((point) => transform4(point, transform));

                    context.beginPath();
                    points2d.forEach((point) => context.lineTo(point[0], point[1]));
                    context.stroke();
                }
            }
        }

        /**
         * Function to update node data prior to rendering
         */
        function update(scene, origin, time) {
            this.world = matrixMultiply(this.transform, origin);
            if (this.shape) {
                this.shape.updateBuffers(scene, this);
            }
            this[symbols.content].forEach((child) => child.update(scene, this.world, time));
        }

        /**
         *
         */
        function addNode(source, transform, shape, shader, colour = [1, 0, 1, 1]) {

            shininess = source.specular || 1 + 5 * Math.random();

            const node = Object.assign(Object.create({ update }), {
                name: source.name, parent, transform, movement: identityMatrix(),
                shape, shader, colour, shininess, specularColour: source.specularColour, [symbols.content]: [],
            });
            if (source.texture) {
                node.texture = getTexture(texture, scene);
            }
            return node;
        }

        /**
         *
         */
        function drawNode(view, gl, origin, node, shaders, time) {
            const sceneNode = node[symbols.viewData]?.get(view);
            if (sceneNode) {
                const shader = shaders[sceneNode.shader];
                sceneNode.world = matrixMultiply(matrixMultiply(sceneNode.transform, sceneNode.movement), origin);
                const transform = matrixMultiply(sceneNode.world, view.modelViewMatrix);
                sceneNode.z = transform[14];
    
                gl.useProgram(shader.program);
                gl.uniformMatrix4fv(shader.modelViewMatrix, false, transform);
                const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
                gl.uniformMatrix3fv(shader.normalMatrix, false, normalMatrix);
                shader.setNodeData(gl, sceneNode);
                if (sceneNode.shape) {
                    sceneNode.shape.draw3d(gl, sceneNode.shader);
                }
                origin = sceneNode.world;
            }
            node[symbols.content].sort((a, b) => a.z - b.z);
            node[symbols.content].forEach((child) => drawNode(view, gl, origin, child, shaders, time));
            node.movement = identityMatrix();
        }

        /**
         *
         */
        function positionNode(origin, node) {
            node.world = matrixMultiply(node.transform, origin);
            node[symbols.content].forEach((child) => positionNode(node.world, child));
        }

        /**
         *
         */
        function drawNode2(view, gl, node, shader, time) {
            const sceneNode = node[symbols.viewData].get(view);
            if (sceneNode && sceneNode.shader === shader) {
                sceneNode.world = matrixMultiply(matrixMultiply(sceneNode.transform, sceneNode.movement), origin);
                const transform = matrixMultiply(sceneNode.world, scene.modelViewMatrix);
                sceneNode.z = transform[14];

                gl.uniformMatrix4fv(sceneNode.shader.modelViewMatrix, false, transform);
                const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));

                gl.uniformMatrix3fv(sceneNode.shader.normalMatrix, false, normalMatrix);
                sceneNode.shader.setNodeData(gl, sceneNode);
                if (sceneNode.shape) {
                    sceneNode.shape.draw3d(gl, sceneNode.shader);
                }
            }
            node[symbols.content].sort((a, b) => a.z - b.z);
            node[symbols.content].forEach((child) => drawNode2(view, gl, child, shader, time));
            node.movement = identityMatrix();
        }

        /**
         *
         */
        function drawScene(view, context, graph, shaders, time) {
            glErrors(context, 'drawScene start');
            graph.forEach((node) =>
                drawNode(view, context, identityMatrix(), node, shaders, time));
            glErrors(context, 'drawScene end');
        }

        /**
         *
         */
        function drawScene2(view, context, graph, time) {
            const origin = identityMatrix();
            graph.forEach((node) => positionNode(origin, node));

            gl.useProgram(scene.shaders.shader3.program);
            graph.forEach((node) => drawNode2(view, context, node, scene.shaders.shader3, time));
            gl.useProgram(scene.shaders.shader4.program);
            graph.forEach((node) => drawNode2(view, context, node, scene.shaders.shader4, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function glErrors(gl, context = '') {
            const err = gl.getError();

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.log(context, errors[err]);
                report(errors[err]);
                Core.paused = true;
            }
        }

        /**
         *
         */
        function initialiseShader(context, shader, projectionMatrix) {
            const numComponents = 3;
            const type = context.FLOAT;    // the data in the buffer is 32bit floats
            const normalize = false;  // don't normalize
            const stride = 4 * (3 + 3 + 2);         // how many bytes to get from one set of values to the next
            // 0 = use type and numComponents above
            const offset = 0;         // how many bytes inside the buffer to start from
            context.useProgram(shader.program);
            context.bindBuffer(context.ARRAY_BUFFER, scene.buffers.vertex);

            context.vertexAttribPointer(
                shader.attribLocations.vertexPosition,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            context.enableVertexAttribArray(shader.attribLocations.vertexPosition);

            if (shader.attribLocations.vertexNormal) {
                context.vertexAttribPointer(
                    shader.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    true,  // normalise normals
                    stride,
                    4 * 3);
                context.enableVertexAttribArray(shader.attribLocations.vertexNormal);
            }

            if (shader.attribLocations.vertexTexture) {
                context.vertexAttribPointer(
                    shader.attribLocations.vertexTexture,
                    2,     // numcomponents
                    type,
                    normalize,
                    stride,
                    4 * (3 + 3));
                context.enableVertexAttribArray(shader.attribLocations.vertexTexture);
            }
            shader.setSceneData(scene);
        }

        /**
         *
         */
        const times = [];
        let last = 0;

        /**
         * Update the Camera position
         */
        function updateCamera(string) {
            let text = Core.mainEditor.value.replace(/^\s*Camera.*/, string);
            Core.mainEditor.value = text;
        }


        /**
         *
         */
        class Camera {
            constructor(position = [0, 0, 1], lookAt = [0, 0, 0], up = [0, 1, 0]) {
                this.initial = { position, lookAt, up };
                this.reset();
            }
            reset() {
                this.position = [...this.initial.position];
                this.lookAt = [...this.initial.lookAt];
                this.up = [...this.initial.up];
            }
            getString() {
                const str = (vector, fixed = 3) => vector.map((element) => element.toFixed(fixed));
                return `Camera;lookAt=${str(this.lookAt)};position=${str(this.position)};up=${str(this.up)}`;
            }
            zAxis() {
                return normalised(subtract(this.lookAt, this.position));
            }
            xAxis() {
                return xaxis = normalised(cross(this.zAxis(), this.up));
            }
            yAxis() {
                const zAxis = normalised(subtract(this.lookAt, this.position));
                const xAxis = normalised(cross(zAxis, this.up));

                return cross(xAxis, zAxis);
            }
            axes() {
                const zAxis = normalised(subtract(this.lookAt, this.position));
                const xAxis = normalised(cross(zAxis, this.up));
                const yAxis = cross(xAxis, zAxis);

                return { xAxis, yAxis, zAxis };
            }
            viewMatrix(eye, at, up) {
                const zaxis = normalised(subtract(this.lookAt, this.position));
                const xaxis = normalised(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);

                negate(zaxis);

                return [
                    xaxis[0], yaxis[0], zaxis[0], 0,
                    xaxis[1], yaxis[1], zaxis[1], 0,
                    xaxis[2], yaxis[2], zaxis[2], 0,
                    -dot(xaxis, this.position), -dot(yaxis, this.position), -dot(zaxis, this.position), 1
                ];
            }
            zoom(distance) {
                const direction = subtract(this.lookAt, this.position);
                const movement = scaled(direction, distance);
                this.position = add(this.position, movement);
                updateCamera(this.getString());
            }
            forward(distance) {
                const zaxis = normalised(subtract(this.lookAt, this.position));
                const movement = scaled(zaxis, distance);
                this.position = add(this.position, movement);
                this.lookAt = add(this.lookAt, movement);
                updateCamera(this.getString());
            }
            rotateX(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                const xaxis = cross(zaxis, this.up);

                const offset = subtract(this.position, this.lookAt);
                rotate(offset, xaxis, angle);
                rotate(this.up, xaxis, angle);

                this.position = add(this.lookAt, offset);
                updateCamera(this.getString());
            }
            rotateY(angle) {
                const offset = subtract(this.position, this.lookAt);
                rotate(offset, this.up, angle);

                this.position = add(this.lookAt, offset);
                updateCamera(this.getString());
            }
            spinY(angle) {
                const offset = subtract(this.lookAt, this.position);
                rotate(offset, [0, 1, 0], angle);
                rotate(this.up, [0, 1, 0], angle);

                this.lookAt = add(this.position, offset);
                updateCamera(this.getString());
            }
            pitch(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                const xaxis = cross(zaxis, this.up);

                rotate(zaxis, xaxis, angle);
                rotate(this.up, xaxis, angle);
                this.lookAt = add(this.position, zaxis);
                updateCamera(this.getString());
            }
            yaw(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                rotate(zaxis, this.up, angle);
                this.lookAt = add(this.position, zaxis);
                updateCamera(this.getString());
            }
            roll(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                rotate(this.up, zaxis, angle);
                updateCamera(this.getString());
            }
            getLine(aspect, x, y, fieldOfView) {
                const fov = fieldOfView * Math.PI / 180;
                const zaxis = normalised(subtract(this.lookAt, this.position));
                const xaxis = normalised(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);
                const d = 1 / Math.tan(fov / 2);
                const direction = normalised(add(scaled(xaxis, x * aspect), scaled(yaxis, y), scaled(zaxis, d)));

                return { point: this.position, direction };
            }
        }

        /**
         *
         */
        //const camera = new Camera([0, 0, 20], [0, 0, 0], [0, 1, 0]);
        const background = { colour: [0, 0, 0] };

        /**
         * Management of a 2d view using a canvas
         */
        class View2d {
            constructor(scene, canvasId) {
                this.projection = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
                this.scene = scene;
                this.canvas = document.getElementById(canvasId);
                this.context = this.canvas.getContext('2d');
                const scale = Math.min(this.canvas.width, this.canvas.height) / 20;
                this.projection[8] = scale;
                this.projection[5] = scale;
                /*
                this.projection[1] = scale;
                this.projection[9] = scale;
                */

                this.projection[12] = this.canvas.width / 2;
                this.projection[13] = this.canvas.height / 2;
            }
            render() {
                if (!this.canvas) return;

                this.context.globalCompositeOperation = 'source-over';
                this.context.shadowBlur = 0;
                this.context.fillStyle = 'rgb(0,0,0)';
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                //context.globalCompositeOperation = 'lighter';

                this.context.lineWidth = 1;
                this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                const renderNode = (node) => {
                    if (node.world && node.shape) {
                        if (node.colour) {
                            this.context.strokeStyle = `rgba(${node.colour[0] * 255}, ${node.colour[1] * 255}, ${node.colour[2] * 255}, ${node.colour[3]})`;
                        } else {
                            this.context.strokeStyle = 'rgba(255, 240, 100, 0.9)';
                        }
                        const transform = matrixMultiply(node.world, this.projection);
                        node.shape.draw2d(this.context, transform);
                    }
                }
                scene.nodes.forEach(node => renderNode(node));

                if (scene.ray) {
                    const start = transformed(scene.ray.point, this.projection);
                    const endPoint = add(scene.ray.point, scaled(scene.ray.direction, 500));
                    const end = transformed(endPoint, this.projection);

                    this.context.strokeStyle = 'rgb(255, 255, 255, 0.9)';
                    this.context.beginPath();
                    this.context.moveTo(start[0], start[1]);
                    this.context.lineTo(end[0], end[1]);
                    this.context.stroke();
                }
                if (scene.points) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    scene.points.forEach((point) => {
                        const centre = transformed(point, this.projection);
                        this.context.beginPath();
                        this.context.arc(centre[0], centre[1], 3, 0, Math.PI * 2);
                        this.context.stroke();
                    });
                }
                if (scene.lines) {
                    this.context.strokeStyle = 'rgb(255, 200, 255, 0.9)';
                    this.context.beginPath();
                    scene.lines.forEach((line) => {
                        const start = transformed(line.start, this.projection);
                        const end = transformed(line.end, this.projection);
                        this.context.moveTo(start[0], start[1]);
                        this.context.lineTo(end[0], end[1]);
                    });
                    this.context.stroke();
                }
            }
        }

        /**
         *
         */
        let topView;
        let sideView;
        const cameraMove = {};

        /**
         * Start moving camera
         */
        function moveCamera(camera, lookAt, position, up, duration = 1) {
            cameraMove.camera = camera;
            cameraMove.action = 'start';
            cameraMove.lookAt = lookAt || camera.lookAt;
            cameraMove.position = position || camera.position;
            cameraMove.up = up || camera.up;
            cameraMove.duration = duration;
        }

        /**
         *
         */
        function processActiveEvents(time) {
            return;
            //report(`${scene.activeEvents.length} ${time.toFixed(2)}`);
            scene.activeEvents.filter((event) => event.endTime <= time).forEach((event) => event.transition.finish());
            scene.activeEvents = scene.activeEvents.filter((event) => event.endTime > time);
            scene.activeEvents.forEach((event) => {
                const d = (time - event.startTime) / (event.endTime - event.startTime);
                event.transition.progress(d);
            });
        }

        /**
         * Resize the canvas based on the node size
         */
        function updateCanvasSize(view) {
            //return;
            // Lookup the size the browser is displaying the canvas in CSS pixels.
            const width = view.gl.canvas.clientWidth;
            const height = view.gl.canvas.clientHeight;

            // Check if the canvas is not the same size.
            const resize = view.gl.canvas.width !== width || view.gl.canvas.height !== height;

            if (resize) {
                // Make the canvas the same size
                view.gl.canvas.width = width;
                view.gl.canvas.height = height;

                scene.gl.viewport(0, 0, width, height);
            }

            return resize;
        }

        /**
         *
         */
        function render(time = 0) {
            if (Core.paused) {
                return;
            }

            const stateAction = {
                start: () => {
                    state.time = 0;
                    state.nextEvent = 0;
                },
                rewind: () => { },
                play: () => {
                    if (state.mode === 'playing') {
                        state.rate = 1;
                        state.mode = 'paused';
                    } else {
                        state.mode = 'playing';
                    }
                },
                forward: () => { },
                end: () => { },
            }[state.action];
            if (stateAction) {
                stateAction();
            }

            state.action = null;

            if (last) {
                const delta = time - last;
                times.push(delta);
                if (times.length > 5) {
                    times.shift();
                    const total = times.reduce((sum, delta) => sum + delta);
                    const average = 5000 / total;
                }
                if (state.mode === 'playing') {
                    state.time += delta / 1000;
                    while (scene.events[state.nextEvent] && state.time > scene.events[state.nextEvent].startTime) {
                        const event = scene.events[state.nextEvent];
                        event.transition.start();
                        scene.activeEvents.push(event);
                        ++state.nextEvent;
                    }
                }
            }
            processActiveEvents(state.time);
            last = time;
            if (cameraMove.action === 'start') {
                cameraStart = {
                    lookAt: cameraMove.camera.lookAt,
                    position: cameraMove.camera.position,
                    up: cameraMove.camera.up,
                    time: time,
                }
                cameraMove.action = 'move';
            }
            if (cameraMove.action === 'move') {
                const d = (time - cameraStart.time) / (1000 * (cameraMove.duration || 1));
                const s = d * d * (3 - 2 * d);
                cameraMove.camera.lookAt = add(cameraStart.lookAt, scale(subtract(cameraMove.lookAt, cameraStart.lookAt), s));
                cameraMove.camera.position = add(cameraStart.position, scale(subtract(cameraMove.position, cameraStart.position), s));
                cameraMove.camera.up = add(cameraStart.up, scale(subtract(cameraMove.up, cameraStart.up), s));
                if (d > 1) {
                    cameraMove.action = null;
                }
            }

            Core.views.forEach((view) =>
                view.update(time));

            window.requestAnimationFrame(render);
        }

        /**
         *
         */
        function matrixMultiply3x3(a, b) {
            return [
                a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
                a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
                a[0] * b[2] + a[1] * b[5] + a[2] * b[8],

                a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
                a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
                a[3] * b[2] + a[4] * b[5] + a[5] * b[8],

                a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
                a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
                a[6] * b[2] + a[7] * b[5] + a[8] * b[8],
            ];
        }

        /**
         *
         */
        function matrixMultiply(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
            ];
        }

        /**
         *
         */
        function get3x3(input) {
            return [
                input[0], input[1], input[2],
                input[4], input[5], input[6],
                input[8], input[9], input[10]];
        }

        /**
         *
         */
        function transpose3x3(input) {
            return [
                input[0], input[3], input[6],
                input[1], input[4], input[7],
                input[2], input[5], input[8]];
        }

        /**
         *
         */
        function invert3x3(input) {
            const a00 = input[0], a01 = input[1], a02 = input[2];
            const a10 = input[3], a11 = input[4], a12 = input[5];
            const a20 = input[6], a21 = input[7], a22 = input[8];

            const b01 = a22 * a11 - a12 * a21;
            const b11 = -a22 * a10 + a12 * a20;
            const b21 = a21 * a10 - a11 * a20;
            // Calculate the determinant
            const det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return null;
            }
            const idet = 1.0 / det;
            return [
                b01 * idet,
                (-a22 * a01 + a02 * a21) * idet,
                (a12 * a01 - a02 * a11) * idet,
                b11 * idet,
                (a22 * a00 - a02 * a20) * idet,
                (-a12 * a00 + a02 * a10) * idet,
                b21 * idet,
                (-a21 * a00 + a01 * a20) * idet,
                (a11 * a00 - a01 * a10) * idet];
        }

        /**
         *
         */
        function transpose(input) {
            return [
                input[0], input[4], input[8], input[12],
                input[1], input[5], input[9], input[13],
                input[2], input[6], input[10], input[14],
                input[3], input[7], input[11], input[15]];
        }

        /**
         *
         */
        function invert(input) {
            const x0 = input[0];
            const x1 = input[1];
            const x2 = input[2];
            const x3 = input[3];
            const x4 = input[4];
            const x5 = input[5];
            const x6 = input[6];
            const x7 = input[7];
            const x8 = input[8];
            const x9 = input[9];
            const x10 = input[10];
            const x11 = input[11];
            const x12 = input[12];
            const x13 = input[13];
            const x14 = input[14];
            const x15 = input[15];

            const a0 = x0 * x5 - x1 * x4;
            const a1 = x0 * x6 - x2 * x4;
            const a2 = x0 * x7 - x3 * x4;
            const a3 = x1 * x6 - x2 * x5;
            const a4 = x1 * x7 - x3 * x5;
            const a5 = x2 * x7 - x3 * x6;
            const b0 = x8 * x13 - x9 * x12;
            const b1 = x8 * x14 - x10 * x12;
            const b2 = x8 * x15 - x11 * x12;
            const b3 = x9 * x14 - x10 * x13;
            const b4 = x9 * x15 - x11 * x13;
            const b5 = x10 * x15 - x11 * x14;
            const invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

            return [
                (+x5 * b5 - x6 * b4 + x7 * b3) * invdet,
                (-x1 * b5 + x2 * b4 - x3 * b3) * invdet,
                (+x13 * a5 - x14 * a4 + x15 * a3) * invdet,
                (-x9 * a5 + x10 * a4 - x11 * a3) * invdet,
                (-x4 * b5 + x6 * b2 - x7 * b1) * invdet,
                (+x0 * b5 - x2 * b2 + x3 * b1) * invdet,
                (-x12 * a5 + x14 * a2 - x15 * a1) * invdet,
                (+x8 * a5 - x10 * a2 + x11 * a1) * invdet,
                (+x4 * b4 - x5 * b2 + x7 * b0) * invdet,
                (-x0 * b4 + x1 * b2 - x3 * b0) * invdet,
                (+x12 * a4 - x13 * a2 + x15 * a0) * invdet,
                (-x8 * a4 + x9 * a2 - x11 * a0) * invdet,
                (-x4 * b3 + x5 * b1 - x6 * b0) * invdet,
                (+x0 * b3 - x1 * b1 + x2 * b0) * invdet,
                (-x12 * a3 + x13 * a1 - x14 * a0) * invdet,
                (+x8 * a3 - x9 * a1 + x10 * a0) * invdet];
        }

        /**
         * Normalise the input vector
         */
        function normalise(vector) {
            const length = Math.hypot(...vector);
            for (let i = 0; i < vector.length; ++i) {
                vector[i] /= length;
            }
            return vector;
        }

        /**
         * Return a normalised copy of the input vector
         */
        function normalised(vector) {
            const length = Math.hypot(...vector);
            return vector.map((element) => element / length);
        }

        /**
         *
         */
        function dot(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        /**
         *
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0]];
        }

        /**
         *
         */
        function negate(v) {
            v[0] = -v[0];
            v[1] = -v[1];
            v[2] = -v[2];
        }

        /**
         *
         */
        function add(...vectors) {
            return vectors.reduce((sum, v) => [sum[0] + v[0], sum[1] + v[1], sum[2] + v[2]], [0, 0, 0]);
        }

        /**
         *
         */
        function addInPlace(...vectors) {
            const scale = Array.isArray(vectors[vectors.length - 1]) ? 1 : vectors.pop();
            vectors.slice(1).forEach((v) => v.forEach((a, i) => vectors[0][i] += a * scale));
        }

        /**
         *
         */
        function subtract(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        /**
         *
         */
        function scale(v, s) {
            v[0] *= s;
            v[1] *= s;
            v[2] *= s;
            return v;
        }

        /**
         *
         */
        function scaled(v, s) {
            return v.map((e) => e * s);
        }

        /**
         *
         */
        function rotate(v, axis, angle) {
            angle *= Math.PI / 180;
            axis = normalised(axis);

            const s = Math.cos(angle / 2);
            const u = scaled(axis, Math.sin(angle / 2));

            const p1 = scale(cross(v, u), 2 * s);
            const p2 = scaled(v, s * s - dot(u, u));
            const p3 = scaled(u, 2 * dot(v, u));

            [v[0], v[1], v[2]] = add(p1, add(p2, p3));

            return add(p1, add(p2, p3));
        }

        /**
         *
         */
        function transformVector2d(v, matrix) {
            const x = matrix[0] * v[0] + matrix[1] * v[1] + matrix[2];
            const y = matrix[3] * v[0] + matrix[4] * v[1] + matrix[5];
            v[0] = x;
            v[1] = y;
            return v;
        }

        /**
         *
         */
        function matrixVectorMultiply(v, matrix) {
            const x = matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12];
            const y = matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13];
            const z = matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14];
            v[0] = x;
            v[1] = y;
            v[2] = z;
            return v
        }

        /**
         * point transform (apply translation)
         */
        function transformed(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
            ];
        }

        /**
          * point transform (apply translation)
          */
        function transform4(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
                matrix[3] * v[0] + matrix[7] * v[1] + matrix[11] * v[2] + matrix[15],
            ];
        }

        /**
         * Direction transform (ignore translation)
         */
        function transformDirection(v, matrix) {
            return normalised([
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2],
            ]);
        }


        /**
         * Return the plane defined by three points
         */
        function planeFromPoints(p0, p1, p2) {
            const v0 = subtract(p0, p1);
            const v1 = subtract(p0, p2);
            const normal = normalised(cross(v0, v1));
            return { point: p0, normal };
        }

        /**
         * Return an identity matrix
         */
        function identityMatrix() {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }

        /**
         *
         */
        function lookAt(eye, at, up) {
            const zaxis = normalised(subtract(at, eye));
            const xaxis = normalised(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eye), -dot(yaxis, eye), -dot(zaxis, eye), 1
            ];
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zFar + zNear) / (zNear - zFar), -1,
                0, 0, (2 * zFar * zNear) / (zNear - zFar), 1,
            ];
        }


        /**
         * Find the closest point on a line to a given point
         */
        function closestPoint(line, point) {
            // line = lp + d * ld
            // point = p
            // From line to point = p - (lp + d * ld)
            // Closest when (p - (lp + d * ld)).ld = 0
            // dot product is distributive hence
            // (p - (lp + d * ld)).ld = p.ld - lp.ld + d * (ld. ld)
            // d = (lp - p).ld / ld.ld
            const numerator = dot(subtract(line.point - point), line.direction);
            const divisor = dot(line.direction, line.direction);
            return numerator / divisor;
        }

        /**
         * Return the distance between two points
         */
        function distance(point1, point2) {
            return math.hypot(point1[0] - point2[0], point1[1] - point2[1], point1[2] - point2[2]);
        }

        /**
         * Add touch controls to the given node
         */
        function planeIntercept(line, plane) {
            // plane (p - p0).n = 0
            // line p = l + dt
            // (l + dt - p0).n = 0
            // (lx + dxt - p0x)nx + (ly + dyt - p0y)ny + (lz + dzt - p0z)nz = 0
            // t(dx.nx + dy.ny + dz.nz) = nx(p0x-lx) + ny(p0y-ly) + nz(p0z-lz)
            // t = (nx(p0x-lx) + ny(p0y-ly) +nz(p0z-lz)) / (dx.nx + dy.ny + dz.nz)

            const divisor = dot(line.direction, plane.normal);
            if (divisor !== 0) {
                const offset = subtract(plane.point, line.point);
                return dot(offset, plane.normal) / divisor;
            }
        }

        /**
         * Get the point from a line and distance along it
         */
        function getPoint(line, distance) {
            return add(line.point, scaled(line.direction, distance));
        }

        /**
         * Determine the intecep of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalised(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start) {
                return [start, end];
            }
        }

        /**
         * Return the nodes at the screen coordinate 
         */
        function pickNodes(view, x, y) {
            const aspect = view.canvas.width / view.canvas.height;
            const ray = view.camera.getLine(aspect, x, y, 45);
            view.ray = ray;
            view.points.length = 0;
            view.lines.length = 0;
            const hits = view.nodes.filter((node) => {
                if (node.shape) {
                    const inverse = invert(node.world);
                    const point = transformed(ray.point, inverse);
                    const direction = transformDirection(ray.direction, inverse);
                    const points = node.shape.intersects({ point, direction });

                    if (points) {
                        node.hit = points;
                        node.hitPoint = getPoint(ray, points[0]);
                        scene.points.push(getPoint(ray, points[0]), getPoint(ray, points[1]));
                        return true;
                    }
                    if (!event.shiftKey) {
                        node.hit = null;
                    }
                }
            });
            return hits;
        }

        /**
         * Process a 'click' event
         */
        function click(view, x, y) {
            const hits = pickNodes(view, x, y);
            if (hits.length > 0) {
                hits.sort((a, b) => a.hit[0] - b.hit[0]);
                if (!event.altKey) {
                    hits.slice(1).forEach((node) => node.hit = null);
                }
                if (event.ctrlKey) {
                    camera.lookAt = hits[0].world.slice(12, 16);
                    if (hits[0].overlay) {
                        removeOverlay(hits[0]);
                    } else {
                        scene.overlays.push(addOverlay(hits[0]));
                    }
                }
                const lookAt = transformed([0, 0, 0], hits[0].world);
                moveCamera(view.camera, lookAt);

                Core.selectedNodes = hits.map((hit) => hit.sourceNode);
                Core.currentNode = hits[0].sourceNode;
            }
        }

        /**
         * Move a node in screen space
         */
        function dragTo(view, node, x, y) {

            // Get the movement plane
            const normal = view.camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const aspect = view.canvas.width / view.canvas.height;
            const ray = view.camera.getLine(aspect, x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));

            const worldOffset = subtract(point, node.hitPoint);

            view.camera.lookAt = subtract(view.camera.lookAt, worldOffset);
            view.camera.position = subtract(view.camera.position, worldOffset);
        }

        /**
         * Move a node in screen space
         */
        function dragNodeTo(view, node, x, y) {

            // Get the movement plane
            const normal = view.camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const aspect = view.canvas.width / view.canvas.height;
            const ray = view.camera.getLine(x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));


            // Get the origin transform for this node
            const transform = node.parent ? node.parent.world : identityMatrix();
            const inverse = invert(transform);

            const worldOffset = subtract(point, node.hitPoint);
            const offset = [
                inverse[0] * worldOffset[0] + inverse[4] * worldOffset[1] + inverse[8] * worldOffset[2],
                inverse[1] * worldOffset[0] + inverse[5] * worldOffset[1] + inverse[9] * worldOffset[2],
                inverse[2] * worldOffset[0] + inverse[6] * worldOffset[1] + inverse[10] * worldOffset[2],
            ];

            const translate = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...offset, 1];
            node.transform = matrixMultiply(node.transform, translate);
            node.hitPoint = point;
        }

        /**
         * Move a node in screen space
         */
        function rotateNode(view, node, x, y) {
            const inverse = invert(node.world);

            const zAxis = normalised(subtract(view.camera.lookAt, view.camera.position));
            const xAxis = normalised(cross(zAxis, camera.up));
            const yAxis = normalised(cross(zAxis, xAxis));

            const rotateX = getRotationMatrix(-y, transformDirection(xAxis, inverse));
            const rotateY = getRotationMatrix(x, transformDirection(yAxis, inverse));

            node.transform = matrixMultiply(rotateX, node.transform);
            node.transform = matrixMultiply(rotateY, node.transform);
        }

        /**
         * Add touch controls to the given node
         */
        function addControls(node, view) {
            const start = {};
            let action;
            node.addEventListener('touchstart', (event) => {
                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;

                if (event.touches.length === 1) {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    const hits = pickNodes(view, x, y);
                    if (hits.length > 0) {
                        hits.sort((a, b) => a.hit[0] - b.hit[0]);
                        start.hit = hits[0];
                    } else {
                        start.hit = null;
                    }
                    action = 'click';
                } else if (event.touches.length === 2) {
                    start.second = {
                        x: event.touches[1].clientX,
                        y: event.touches[1].clientY,
                    };
                    action = 'pinch';
                }
                report(action);
            });

            node.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (action === 'pinch') {
                    // Use movement of centre to control rotation
                    const cx = (start.x + start.second.x);
                    const cy = (start.y + start.second.y);
                    const vs = normalise([start.x - start.second.x, start.y - start.second.y]);
                    const vn = normalise([event.touches[0].clientX - event.touches[1].clientX, event.touches[0].clientY - event.touches[1].clientY]);
                    const deltaZ = Math.asin(vs[0] * vn[1] - vs[1] * vn[0]) * 180 / Math.PI;
                    const deltaX = (event.touches[0].clientX + event.touches[1].clientX - cx) / 2;
                    const deltaY = (event.touches[0].clientY + event.touches[1].clientY - cy) / 2;

                    view.camera.rotateY(deltaX);
                    view.camera.rotateX(deltaY);
                    view.camera.roll(deltaZ);

                    const initial = Math.hypot(start.x - start.second.x, start.y - start.second.y);
                    const current = Math.hypot(event.touches[0].clientX - event.touches[1].clientX, event.touches[0].clientY - event.touches[1].clientY);

                    const offset = subtract(view.camera.position, view.camera.lookAt);
                    const scale = current / initial;
                    view.camera.position = add(view.camera.lookAt, scaled(offset, scale));

                    start.second.x = event.touches[1].clientX;
                    start.second.y = event.touches[1].clientY;
                } else if (action) {
                    action = 'drag';
                    const deltaX = event.touches[0].clientX - start.x;
                    const deltaY = event.touches[0].clientY - start.y;

                    if (start.hit) {
                        if (view.settings.move.checked) {
                            rotateNode(view, start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.touches[0].clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.touches[0].clientY) / box.height) + 1;

                            dragTo(view, start.hit, x, y);
                        }
                    } else {
                        if (event.altKey) {
                            view.camera.yaw(deltaX / 10);
                            view.camera.pitch(deltaY / 10);
                        } else {
                            view.camera.rotateY(deltaX);
                            view.camera.rotateX(deltaY);
                        }
                    }
                }
                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;
            });

            node.addEventListener('touchend', (event) => {
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;
                    click(view, x, y);
                } else if (action === 'pinch') {
                    action = null;
                }
                node.focus();
            });

            node.addEventListener('mousedown', (event) => {
                event.preventDefault();
                start.x = event.clientX;
                start.y = event.clientY;

                const box = node.getBoundingClientRect();

                const x = 2 * ((start.x - box.left) / box.width) - 1;
                const y = 2 * ((box.top - start.y) / box.height) + 1;

                const hits = pickNodes(view, x, y);
                if (hits.length > 0) {
                    hits.sort((a, b) => a.hit[0] - b.hit[0]);
                    start.hit = hits[0];
                } else {
                    start.hit = null;
                }
                action = 'click';
            });

            node.addEventListener('mousemove', (event) => {
                event.preventDefault();
                if (action) {
                    action = 'drag';
                    const deltaX = event.clientX - start.x;
                    const deltaY = event.clientY - start.y;

                    if (start.hit) {
                        if (view.settings.move.checked || event.buttons & 4) {
                            rotateNode(view, start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.clientY) / box.height) + 1;

                            if (event.ctrlKey) {
                                dragNodeTo(view, start.hit, x, y);
                            } else {
                                dragTo(view, start.hit, x, y);
                            }
                        }
                    } else {
                        if (event.altKey) {
                            view.camera.yaw(deltaX / 10);
                            view.camera.pitch(deltaY / 10);
                        } else {
                            view.camera.rotateY(deltaX);
                            view.camera.rotateX(deltaY);
                        }
                    }
                    start.x = event.clientX;
                    start.y = event.clientY;
                }
            });

            node.addEventListener('mouseup', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    click(view, x, y);
                }
                action = null;
                node.focus();
            });

            node.addEventListener('wheel', (event) => {
                const dist = event.deltaY / 1000;
                view.camera.zoom(dist);
                report(dist);
            });

            node.addEventListener('keydown', (event) => {
                report(event.key);
                event.preventDefault();
                const yAxis = normalised(view.camera.up);
                const zAxis = normalised(subtract(view.camera.lookAt, view.camera.position));
                const xAxis = cross(zAxis, yAxis);
                if (true) {
                    yAxis[0] = 0;
                    yAxis[1] = 1;
                    yAxis[0] = 0;

                    xAxis[1] = 0;
                    zAxis[1] = 0;

                    normalise(xAxis);
                    normalise(zAxis);
                }
                const scale = event.ctrlKey ? 0.1 : 1;
                if (event.key === 'u') {
                    view.camera.up = [0, 1, 0];
                }
                if (event.key === 'ArrowUp') {
                    if (event.shiftKey) {
                        if (event.altKey) {
                            view.camera.rotateX(10 * scale);
                        } else {
                            view.camera.pitch(-10 * scale);
                        }
                    } else {
                        if (event.altKey) {
                            addInPlace(view.camera.lookAt, yAxis, scale);
                            addInPlace(view.camera.position, yAxis, scale);
                        } else {
                            addInPlace(view.camera.lookAt, zAxis, scale);
                            addInPlace(view.camera.position, zAxis, scale);
                        }
                    }
                }
                if (event.key === 'ArrowDown') {
                    if (event.shiftKey) {
                        if (event.altKey) {
                            view.camera.rotateX(-10 * scale);
                        } else {
                            view.camera.pitch(10 * scale);
                        }
                    } else {
                        if (event.altKey) {
                            addInPlace(view.camera.lookAt, yAxis, -scale);
                            addInPlace(view.camera.position, yAxis, -scale);
                        } else {
                            addInPlace(view.camera.lookAt, zAxis, -scale);
                            addInPlace(view.camera.position, zAxis, -scale);
                        }
                    }
                }
                if (event.key === 'ArrowLeft') {
                    if (event.shiftKey) {
                        addInPlace(view.camera.lookAt, xAxis, -scale);
                        addInPlace(view.camera.position, xAxis, -scale);
                    } else {
                        if (event.altKey) {
                            view.camera.rotateY(-10 * scale);
                        } else {
                            view.camera.spinY(-10 * scale);
                        }
                    }
                }
                if (event.key === 'ArrowRight') {
                    if (event.shiftKey) {
                        addInPlace(view.camera.lookAt, xAxis, scale);
                        addInPlace(view.camera.position, xAxis, scale);
                    } else {
                        if (event.altKey) {
                            view.camera.rotateY(10 * scale);
                        } else {
                            view.camera.spinY(10 * scale);
                        }
                    }
                }
            });

            document.getElementById('start').addEventListener('click', (event) => state.action = 'start');
            document.getElementById('rewind').addEventListener('click', (event) => state.action = 'rewind');
            document.getElementById('play').addEventListener('click', (event) => state.action = 'play');
            document.getElementById('forward').addEventListener('click', (event) => state.action = 'forward');
            document.getElementById('end').addEventListener('click', (event) => state.action = 'end');
        }


        /**
         * Add touch controls to the verical and horizontal separators
         */
        function addUIControls() {
            let action = null;
            const start = {};
            let before = null;
            let after = null;

            const horizontalDrag = (event, x, y) => {
                event.preventDefault();
                const delta = x - start.x;
                start.sizes[start.index - 1] += delta;
                start.sizes[start.index + 1] -= delta;
                start.container.style.gridTemplateColumns = start.sizes.map((size) => `${size}px`).join(' ');
                start.x = x;
            }

            const startHorizontalDrag = (vbar, x) => {
                start.x = x;
                start.container = vbar.parentElement;
                const content = Array.from(vbar.parentElement.children);
                const style = window.getComputedStyle(vbar.parentElement);
                start.sizes = style.gridTemplateColumns.split(' ').map((v) => parseFloat(v));//content.map((element) => element.clientWidth);
                start.index = content.indexOf(vbar);
                action = horizontalDrag;
            }

            const verticalBars = document.querySelectorAll('.vertical-bar');

            const newVerticalBar = (vbar) => {
                if (!vbar) {
                    vbar = document.createElement('div');
                    vbar.classList.add('vertical-bar');
                }
                vbar.addEventListener('mousedown', (event) => {
                    startHorizontalDrag(vbar, event.clientX);
                });
                vbar.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (event.touches.length > 0) {
                        startHorizontalDrag(vbar, event.touches[0].clientX);
                    }
                });
                return vbar;
            };

            for (const vbar of verticalBars) {
                newVerticalBar(vbar);
            }

            const verticalDrag = (event, x, y) => {
                event.preventDefault();
                const delta = y - start.y;
                start.sizes[start.index - 1] += delta;
                start.sizes[start.index + 1] -= delta;
                start.container.style.gridTemplateRows = start.sizes.map((size) => `${size}px`).join(' ');
                start.y = y;
            }

            const startVerticalDrag = (hbar, y) => {
                start.y = y;
                start.container = hbar.parentElement;
                const content = Array.from(hbar.parentElement.children);
                const style = window.getComputedStyle(hbar.parentElement);
                start.sizes = style.gridTemplateRows.split(' ').map((v) => parseFloat(v));//content.map((element) => element.clientWidth);
                //start.sizes = content.map((element) => element.clientHeight);
                start.index = content.indexOf(hbar);
                action = verticalDrag;
            }

            const horizontalBars = document.querySelectorAll('.horizontal-bar');
            const newHorizontalBar = (hbar) => {
                if (!hbar) {
                    hbar = document.createElement('div');
                    hbar.classList.add('horizontal-bar');
                }
                hbar.addEventListener('mousedown', (event) => {
                    startVerticalDrag(hbar, event.clientY);
                });
                hbar.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (event.touches.length > 0) {
                        startVerticalDrag(hbar, event.touches[0].clientY);
                    }
                });
                return hbar;
            };

            for (const hbar of horizontalBars) {
                newHorizontalBar(hbar);
            }
            document.body.addEventListener('mousemove', (event) => {
                if (action) {
                    action(event, event.clientX, event.clientY);
                }
            });

            document.body.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (action && event.touches.length === 1) {
                    action(event, event.touches[0].clientX, event.touches[0].clientY);
                }
            });

            document.body.addEventListener('mouseenter', (event) => {
                action = null
            });

            document.body.addEventListener('mouseup', (event) => {
                action = null;
            });

            document.body.addEventListener('touchend', (event) => {
                //event.preventDefault();
                action = null;
            });

            
            const placeholder = document.createElement('div');
            placeholder.classList.add('placeholder');
            const sidebar = document.querySelector('.sidebar');
            
            sidebar.addEventListener('click', (event) => {
                if (event.target === sidebar) {
                    sidebar.classList.toggle('hide-right');
                }
            });
            
            const insertFrame = (frame, bar) => {
                const container = bar.parentElement;
                const gridTemplate = container.classList.contains('layout-row') ? 'gridTemplateColumns' : 'gridTemplateRows';
                const content = Array.from(container.children);
                const style = window.getComputedStyle(container);
                const sizes = style[gridTemplate].split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                
                const index = (1 + content.indexOf(bar)) / 2;
                const total = sizes.reduce((sum, size) => sum + size, 0);
                const newSize = sizes.map((size) => `${size / total}fr`);
                newSize.splice(index, 0, `${1 / sizes.length}fr`);

                container.insertBefore(frame, bar);
                if (container.classList.contains('layout-row')) {
                    container.insertBefore(uiControls.newVerticalBar(), frame);
                } else {
                    container.insertBefore(uiControls.newHorizontalBar(), frame);       
                }
                container.style[gridTemplate] = newSize.join(' min-content ');
            }
            
            const removeFrame = (frame) => {
                const container = frame.parentElement;
                
                const content = Array.from(container.children);
                const index = content.indexOf(frame) / 2;

                if (frame.nextSibling) {
                    frame.nextSibling.remove();
                } else {
                    frame.previousSibling.remove();
                }
                frame.remove();
                if (container.childNodes.length === 1) {
                    container.replaceWith(container.firstChild);
                } else {
                    const gridTemplate = container.classList.contains('layout-row') ? 'gridTemplateColumns' : 'gridTemplateRows';
                    const style = window.getComputedStyle(container);

                    const sizes = style[gridTemplate].split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                    sizes.splice(index, 1);
                        
                    const total = sizes.reduce((sum, size) => sum + size, 0);
                    const newSize = sizes.map((size) => `${size / total}fr`);
    
                    container.style[gridTemplate] = newSize.join(' min-content ');
                }
            }
            
            
            const newFrame = (view) => {
                const frame = document.createElement('div');
                const title = document.createElement('div');
                title.innerHTML = view.title;
                title.classList.add('frame-title');
                frame.appendChild(title);
                frame.addEventListener('focusin', (event) => frame.classList.add('selected-frame'));
                frame.append(view.node);

                frame.classList.add('frame')
                const actions = {};
                const start = {};
                
                const frames = [];
                frame.addEventListener('click', (event) => Core.currentFrame = frame);
                
                const dragStart = (event, x, y) => {
                    const position = frame.getBoundingClientRect();
                    frame.classList.add('dragging')
                    frame.style.left = `${position.x}px`;
                    frame.style.top = `${position.y}px`;
                    start.x = x;
                    start.y = y;
                    start.position = position;
                    actions.move = dragBox;
                    actions.end = dragEnd;
                    frame.parentElement.insertBefore(placeholder, frame);
                    sidebar.classList.remove('hide-right');
                    sidebar.classList.add('hide-right90');
                    frames.length = 0;
                    frames.push(...Array.from(document.querySelectorAll('.frame'))
                        .map((frame) => ({frame, bounds: frame.getBoundingClientRect()})));
                };
                
                const dragBox = (event, x, y) => {
                    const dx = x - start.x;
                    const dy = y - start.y;
                    frame.style.left = `${start.position.x + dx}px`;
                    frame.style.top = `${start.position.y + dy}px`;
                    actions.x = x;
                    actions.y = y;
                    actions.end = dragEnd;
                    const elements = document.elementsFromPoint(x, y);
                    const vbar = elements.find((element) => element.classList.contains('vertical-bar'));
                    const hbar = elements.find((element) => element.classList.contains('horizontal-bar'));
                    if (vbar) {
                        const rect = vbar.getBoundingClientRect();
                        frame.classList.add('vbar-hover');
                        frame.classList.remove('hbar-hover');
                    } else if (hbar) {
                        frame.classList.add('hbar-hover');
                        frame.classList.remove('vbar-hover');
                        const rect = hbar.getBoundingClientRect();
                    } else {
                        frame.classList.remove('vbar-hover');
                        frame.classList.remove('hbar-hover');
                    }
                };

                const dragEnd = (event) => {
                    frame.classList.remove('dragging');
                    placeholder.remove();
                    if (actions.x !== undefined && actions.y !== undefined) {
                        const elements = document.elementsFromPoint(actions.x, actions.y);
                        if (elements[0].classList.contains('layout-main')) {
                            report('swap single');
                            elements[0].appendChild(frame);
                        } else if (elements[0].classList.contains('sidebar')) {
                            report('add to sidebar');
                            
                            if (!sidebar.contains(frame)) {
                                removeFrame(frame);
                                sidebar.appendChild(frame)
                            }
                        } else {
                            const bar = elements.find((element) => element.classList.contains('vertical-bar')) ||
                                elements.find((element) => element.classList.contains('horizontal-bar'));
                            const target = frames.find((test) =>
                                (test.bounds.x < actions.x) && (actions.x < test.bounds.x + test.bounds.width) &&
                                (test.bounds.y < actions.y) && (actions.y < test.bounds.y + test.bounds.height));
    
                            if (bar) {
                                report('insert');
                                const container = FrameContainer.all.find((container) => container.node === bar.parentElement);
                                if (sidebar.contains(frame)) {
                                    container.insert(frame, bar);
                                } else if (bar.parentElement === frame.parentElement) {
                                    if (bar !== frame.nextSibling && bar !== frame.previousSibling) {
                                        report('reorder');
                                        const container = bar.parentElement;
                                        if (frame.nextSibling) {
                                            container.insertBefore(frame.nextSibling, bar);
                                            container.insertBefore(frame, bar);
                                        } else {
                                            container.insertBefore(frame.previousSibling, bar);
                                            container.insertBefore(frame, bar);
                                        }
                                    }
                                } else {
                                    removeFrame(frame);
                                    container.insert(frame, bar);
                                }
                                frame.classList.remove('vbar-hover');
                                frame.classList.remove('hbar-hover');
                            } else if (target) {
                                if (target.frame === frame) {
                                    report('cancel move');
                                } else if (event.ctrlKey) {
                                    report('split');
                                    if (!sidebar.contains(frame)) {
                                        removeFrame(frame);
                                    }
                                    const after = target.frame.parentElement.classList.contains('layout-row') ?
                                        ((actions.x - target.bounds.x) / target.bounds.width) > 0.5 :
                                        ((actions.y - target.bounds.y) / target.bounds.height) > 0.5;

                                    const container = FrameContainer.all.find((container) => container.node === target.frame.parentElement);
                                    if (container) {
                                        container.split(frame, target.frame, after);
                                    } else {
                                        const parent = target.frame.parentElement;
                                        const container = new FrameContainer(target.frame, frame);
                                        parent.appendChild(container.node);
                                    }
                                } else {
                                    report('swap');
                                    frame.parentElement.insertBefore(placeholder, frame);
                                    target.frame.replaceWith(frame);
                                    placeholder.replaceWith(target.frame);
                                }
                            } else {
                                report('remove');
                                view.node.remove();
                                removeFrame(frame);
                            }
                        }
                    }
                    frame.style.left = `unset`;
                    frame.style.top = `unset`;
                    actions.move = null;
                    actions.end = null;
                    sidebar.classList.remove('hide-right90');
                    sidebar.classList.add('hide-right');
                };

                title.addEventListener('mousedown', (event) =>
                    dragStart(event, event.clientX, event.clientY));

                title.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 1) {
                        dragStart(event, event.touches[0].clientX, event.touches[0].clientY);
                    }
                });

                frame.addEventListener('mousedown', (event) => {
                    if (event.target === frame) {
                        dragStart(event, event.clientX, event.clientY);
                    }
                });
                
                frame.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 1 && event.target === frame) {
                        dragStart(event, event.touches[0].clientX, event.touches[0].clientY);
                    }
                });
                
                const endTouch = (event) => {
                    if (actions.end) {
                        actions.end(event);
                    }                        
                }
                
                document.body.addEventListener('mouseup', (event) => endTouch(event));

                window.addEventListener('touchend', (event) => {
                    if (event.touches.length === 0) {
                        endTouch(event);
                    }                        
                });

                const move = (event, x, y) => {
                    if (actions.move) {
                        event.preventDefault();
                        actions.move(event, x, y);
                    }
                }
                
                document.body.addEventListener('mousemove', (event) =>
                    move(event, event.clientX, event.clientY));

                document.body.addEventListener('touchmove', (event) =>
                    move(event, event.touches[0].clientX, event.touches[0].clientY));
                return frame;
            };
            
            const newSidebarFrame = (view) => {
                const frame = newFrame(view);
                view.node.classList.add('sidebar-view');
                sidebar.append(frame);
                sidebar.classList.remove('hide-right');
            }
            
            return { newVerticalBar, newHorizontalBar, newFrame, newSidebarFrame };
        }
        const uiControls = addUIControls();

        /**
         * Add an overlay for the specified node
         */
        function addOverlay(node) {
            const box = document.getElementById('scene').getBoundingClientRect();
            const container = document.createElement('div');
            container.classList.add('overlay', 'fixed');

            const updateOverlay = (projectionMatrix) => {
                const modelViewMatrix = matrixMultiply(node.world, scene.modelViewMatrix);

                const transform = matrixMultiply(modelViewMatrix, scene.projectionMatrix);
                const position = transform4([0, 0, 0], transform);
                const x = box.left + (position[0] / position[3] + 1) * box.width / 2;
                const y = box.bottom - (position[1] / position[3] + 1) * box.height / 2;

                container.style.left = `${x}px`;
                container.style.top = `${y}px`;
                container.innerHTML = `<span>${node.name}</span><br>Position: <span>${node.transform.slice(12, 15).map((p) => p.toFixed(2)).join(', ')}</span>`;
            }
            updateOverlay(scene.projectionMatrix);

            document.body.appendChild(container);
            node.overlay = { container, updateOverlay };
            return node.overlay;
        }

        /**
         * Add an overlay for the specified node
         */
        function removeOverlay(node) {
            if (node.overlay) {
                node.overlay.container.remove();
                const pos = scene.overlays.indexOf(node.overlay);
                if (pos > -1) {
                    scene.overlays.splice(pos, 1);
                }
                node.overlay = null;
            }
        }

        /**
         * Display element
         */
        function showEntry(name, value) {
            if (Array.isArray(value)) {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (array[${value.length}])`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                container.addEventListener('toggle', (event) => {
                    if (container.open) {
                        content.innerHTML = '';
                        value.forEach((element, i) =>
                            content.append(showEntry(`${i}`, element)));
                    }
                });
                return container;
            } else if (value === undefined) {
                return `${name}: undefined`;
            } else if (value === null) {
                return `${name}: null`;
            } else if (value && typeof (value) === 'object' && !value.toISOString) {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (object)`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                container.addEventListener('toggle', (event) => {
                    if (container.open) {
                        content.innerHTML = '';
                        Object.entries(value).forEach(([key, value]) =>
                            content.append(showEntry(`${key}`, value)));
                    }
                });
                return container;
            }
            const container = document.createElement('div');
            if (value.toISOString) {
                container.innerText = `${name}: ${value.toISOString()}`;
            } else {
                container.innerText = `${name}: ${value}`;
            }
            container.classList.add('entry');
            return container;
        }

        /**
         *
         */
        let state = { time: 0, rate: 1, mode: 'paused', nextEvent: 0 };

        /**
         * Update the line numbers for a textarea element
         */
        function updateLineNumbers(main, lineNumbers) {
            const count = main.value.split(/\n/g).length;
            lineNumbers.value = '';
            const numbers = Array(count).fill(0).map((e, i) => i + 1);
            lineNumbers.value = numbers.join('\r\n');
            lineNumbers.cols = 1 + (count + '').length;
        }

        const actions = {};

        /**
         * Add drag control to an element
         */
        function addElementDrag(node) {
            const start = {};

            const moveNode = (eventX, eventY) => {
                const dx = eventX - start.mouseX;
                const dy = eventY - start.mouseY;
                const x = start.elementX + dx;
                const y = start.elementY + dy;
                node.style.position = 'absolute';
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.style.right = 'auto';
            }
            const mouseMove = (event) => {
                moveNode(event.clientX, event.clientY);
            }
            const touchMove = (event) => {
                moveNode(event.touches[0].clientX, event.touches[0].clientY);
            }

            node.addEventListener('mousedown', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.clientX;
                start.mouseY = event.clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.mouseMove = mouseMove;
                actions.mouseUp = (event) => actions.mouseMove = null;
            });


            node.addEventListener('touchstart', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.touches[0].clientX;
                start.mouseY = event.touches[0].clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.touchMove = touchMove;
                actions.touchEnd = (event) => actions.touchMove = null;
            });
        }


        /**
         * Create a shader view
         */
        function createShaderView() {
            let shader;
            const layout = document.querySelector('.layout');

            const template = document.getElementById('shader-controls-template');
            const controls = template.content.firstElementChild.cloneNode(true);
            layout.appendChild(controls);
            controls.style.gridColumn = '1 / -1';
            controls.style.gridRow = '2';

            const vertexEditor = new Editor(layout);
            const fragmentEditor = new Editor(layout);

            const nameSelection = controls.querySelector('.shader-name');
            nameSelection.addEventListener('change', (event) => {
                const name = nameSelection.value;
                if (scene.shaders[name]) {
                    shader = scene.shaders[name];
                    update(scene.shaders[name]);
                }
            });
            nameSelection.value = 'shader4';

            const buildButton = controls.querySelector('.build-shader');
            const externalNames = document.getElementById('external-names');

            const attributes = [];
            const uniforms = [];

            vertexEditor.main.addEventListener('input', (event) => shader.vertex = vertexEditor.value);
            fragmentEditor.main.addEventListener('input', (event) => shader.fragment = fragmentEditor.value);

            const getNames = (shader) => {
                const attrTable = externalNames.querySelector('.attributes');
                const attributePattern = /^\s*attribute\s+(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;

                const uniformTable = externalNames.querySelector('.uniforms');
                const uniformPattern = /^\s*uniform\s+(highp\s+)?(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;
                const lines = shader.definition.vertex.split('\n');
                lines.push(...shader.definition.fragment.split('\n'));

                setters = {
                    mat4: (location, value) => view.gl.uniformMatrix4fv(location, false, value),
                    mat3: (location, value) => view.gl.uniformMatrix3fv(location, false, value),
                    vec3: (location, value) => view.gl.uniform3fv(location, value),
                    vec4: (location, value) => view.gl.uniform4fv(location, value),
                    float: (location, value) => view.gl.uniform1f(location, value),
                    sampler2D: (location, value) => view.gl.uniform1i(location, value),
                };

                lines.forEach((line) => {
                    const attrMatch = line.match(attributePattern);
                    const uniformMatch = line.match(uniformPattern);

                    if (attrMatch) {
                        const definition = shader.definition.attributes.find((def) => def.attribute === attrMatch.groups.name);
                        const attribute = {
                            attribute: attrMatch.groups.name,
                            name: definition ? definition.name : '',
                            type: attrMatch.groups.type,
                        };
                        const name = document.createElement('span');
                        attrTable.appendChild(name);
                        name.innerHTML = attrMatch.groups.name;
                        name.classList.add('cell');
                        const input = document.createElement('input');
                        attrTable.appendChild(input);
                        input.classList.add('cell');
                        input.value = attribute.name;
                        input.addEventListener('change', (event) => attribute.name = input.value);
                        const type = document.createElement('span');
                        attrTable.appendChild(type);
                        type.innerHTML = attrMatch.groups.type;
                        type.classList.add('cell');
                        attributes.push(attribute);
                    }
                    if (uniformMatch) {
                        const definition = shader.definition.uniforms.find((def) => def.uniform === uniformMatch.groups.name);
                        const uniform = {
                            uniform: uniformMatch.groups.name,
                            name: definition ? definition.name : '',
                            type: uniformMatch.groups.type,
                            set: setters[uniformMatch.groups.type],
                        };

                        const name = document.createElement('span');
                        uniformTable.appendChild(name);
                        name.innerHTML = uniformMatch.groups.name;
                        name.classList.add('cell');
                        const input = document.createElement('input');
                        uniformTable.appendChild(input);
                        input.classList.add('cell');
                        input.value = uniform.name;
                        input.addEventListener('change', (event) => uniform.name = input.value);
                        const type = document.createElement('span');
                        uniformTable.appendChild(type);
                        type.innerHTML = uniformMatch.groups.type;
                        type.classList.add('cell');
                        const defaultValue = document.createElement('input');
                        uniformTable.appendChild(defaultValue)
                        defaultValue.classList.add('cell');
                        uniforms.push(uniform);
                    }
                });
            }

            const update = (shader) => {
                attributes.length = 0;
                uniforms.length = 0;
                vertexEditor.value = shader.vertex || shader.definition.vertex;
                fragmentEditor.value = shader.fragment || shader.definition.fragment;
                for (let cell of externalNames.querySelectorAll('.cell')) {
                    cell.remove();
                }

                getNames(shader);
            }

            const show = () => {
                const shaderList = document.getElementById('shader-list');
                shaderList.innerHTML = '';
                Object.keys(scene.shaders).forEach((shaderName) => {
                    const node = document.createElement('option');
                    shaderList.appendChild(node);
                    node.innerHTML = shaderName;
                });
                layout.style.gridTemplateRows = 'min-content min-content 1fr 1fr';
                shader = shader || scene.shaders.shader4;
                update(shader);
                vertexEditor.container.style.display = 'flex';
                fragmentEditor.container.style.display = 'flex';
                vertexEditor.container.style.gridColumn = 1;
                vertexEditor.container.style.gridRow = 3;
                fragmentEditor.container.style.gridColumn = 2;
                fragmentEditor.container.style.gridrow = 3;
                buildButton.style.display = 'inline-block';
                externalNames.classList.remove('hidden');
            };

            const hide = () => {
                vertexEditor.container.style.display = 'none';
                fragmentEditor.container.style.display = 'none';
                buildButton.style.display = 'none';
                externalNames.classList.add('hidden');
            };

            const build = () => {
                const definition = {
                    name: nameSelection.value,
                    vertex: vertexEditor.value,
                    fragment: fragmentEditor.value,
                    attributes, uniforms,
                };
                scene.shaders[definition.name] = makeShader(definition);
                const shaders = Object.values(scene.shaders);
                localStorage.setItem('shaders', JSON.stringify(shaders, null, 2));

                Core.source = Core.mainEditor.value;
            }

            buildButton.addEventListener('click', (event) => build());

            hide();

            return { show, hide, vertexEditor, fragmentEditor };
        }

        /**
         * Build a shader from a definition.
         */
        function makeShader(definition, context) {
            const removeIndent = (text) => {
                const lines = text.split(/\n/);
                const indent = Math.min(...lines.filter((line) => line.length).map((line) => line.length - line.trimStart().length));
                return lines.map((line) => line.slice(indent)).join('\n');
            };

            definition.vertex = removeIndent(definition.vertex);
            definition.fragment = removeIndent(definition.fragment);

            const shader = {
                attribLocations: {},
                definition,
                toJSON() {
                    return this.definition
                },
            };

            shader.program = initialiseShaders(context, definition.vertex, definition.fragment);

            if (shader.program) {
                definition.attributes.forEach((attribute) =>
                    shader.attribLocations[attribute.name] = context.getAttribLocation(shader.program, attribute.attribute));
                definition.uniforms.forEach((uniform) =>
                    shader[uniform.name] = context.getUniformLocation(shader.program, uniform.uniform));
            }

            const setters = {
                mat4: (location, value) => context.uniformMatrix4fv(location, false, value),
                mat3: (location, value) => context.uniformMatrix3fv(location, false, value),
                vec3: (location, value) => context.uniform3fv(location, value),
                vec4: (location, value) => context.uniform4fv(location, value),
                float: (location, value) => context.uniform1f(location, value),
                sampler2D: (location, value) => context.uniform1i(location, value),
            };

            // Extract the declaration of uniforms from the source
            const uniformPattern = /^\s*uniform\s+(highp\s+)?(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;
            const full = (definition.vertex + definition.fragment).split(';');
            const definedUniforms = full.map((line) => line.match(uniformPattern))
                .flatMap((match) => match ? match.groups : [])
                .reduce((obj, uniform) => { obj[uniform.name] = uniform.type; return obj }, {});

            // Generate 'setters' for each uniform
            const uniforms = definition.uniforms.map((uniform) => ({
                name: uniform.name,
                uniform: uniform.uniform,
                set: uniform.set || setters[definedUniforms[uniform.uniform]],
            })).filter((uniform) => uniform.set);

            Object.keys(definedUniforms).forEach((name) => {
                if (!uniforms.find((match) => match.uniform === name)) {
                    console.log(`Warning ${name} not mapped for ${definition.name} shader`);
                }
            });

            shader.setSceneData = (scene) => {
                uniforms.forEach((uniform) => {
                    if (scene[uniform.name]) {
                        uniform.set(shader[uniform.name], scene[uniform.name]);
                    }
                });
            }
            shader.setNodeData = (gl, node) => {
                uniforms.forEach((uniform) => {
                    if (node[uniform.name]) {
                        uniform.set(shader[uniform.name], node[uniform.name]);
                    }
                });
                /*
                if (node.hit) {
                    gl.uniform4fv(shader.colour, [1, 0, 0, 1]);
                }
                */
            }
            shader.setElementData = (element) => {
                uniforms.forEach((uniform) => {
                    if (element[uniform.name]) {
                        uniform.set(shader[uniform.name], element[uniform.name]);
                    }
                });
            }

            return shader;
        }

        /**
         * Toggle fullscreen mode
         */
        function toggleFullscreen() {
            if (document.body.webkitRequestFullscreen) {
                if (document.body.webkitIsFullScreed) {
                    document.body.webkitCancelFullScreen();
                } else {
                    document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                }
            }
            if (document.body.requestFullscreen) {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.body.requestFullscreen();
                }
            }
        }

        /**
         * Save the content of the editor
         */
        function save() {
            const text = Core.mainEditor.value;
            const name = document.getElementById('filename').value;

            download(text, name);
            /*
            if (!config.files.includes(name)) {
                config.files.push(name);
            }
            localStorage.setItem(name, input.value);
            config.current = name;
            localStorage.setItem('scene-config', JSON.stringify(config));
            */
        }

        /**
         * Load a selected file
         */
        async function load(editor) {
            const name = 'test-scene.txt';//document.getElementById('filename').value;

            const response = await fetch(`${name}`);
            const content = await response.text();

            if (content) {
                Core.source = content;

                config.current = name;
                localStorage.setItem('scene-config', JSON.stringify(config));
                document.getElementById('filename').classList.add('existing-file');
            }
        }

        let config = {
            files: [],
            current: 'New Scene',
            saveState: false,
        };

        const Core = {
            viewSelection: document.getElementById('view-selection'),
            singleFrame: false,
            frames: [],
            mainTrees: [],
            sceneGraphTrees: [],
            views: [],
            initialise() {
                this.mainEditor = new StructureEditor('Main');
                this.viewSelection.addEventListener('change', (event) =>
                    this.currentFrame = this.frames[this.viewSelection.value]);

                const toggle = document.getElementById('toggle-secondary-controls');
                toggle.addEventListener('click', (event) =>
                    document.getElementById('secondary-controls').classList.toggle('hide-left'));

                const toggleSidebar = document.getElementById('toggle-sidebar');
                toggleSidebar.addEventListener('click', (event) =>
                    document.querySelector('.sidebar').classList.toggle('hide-right'));

                const hideMenu = document.getElementById('hide-menu');
                hideMenu.addEventListener('click', (event) =>
                    document.getElementById('secondary-controls').classList.add('hide-left'));

                const vsplit = document.getElementById('add-column');
                vsplit.addEventListener('click', (event) =>
                    this._frame ? this._frame.container.verticalSplit(this._frame) : undefined);

                const hsplit = document.getElementById('add-row');
                hsplit.addEventListener('click', (event) =>
                    this._frame ? this._frame.container.horizontalSplit(this._frame) : undefined);

                const saveCanvas = document.getElementById('save-png');
                saveCanvas.addEventListener('click', (event) => this._frame.content.savePNG = true);

                const tabbed = document.getElementById('toggle-tabbed-layout');
                tabbed.addEventListener('click', (event) => this.toggleSingleFrame());

                const close = document.getElementById('close-current-frame');
                close.addEventListener('click', (event) => this._frame ? this._frame.remove() : undefined);

                const addViewSelection = document.getElementById('add-view-selection');
                addViewSelection.innerHTML = `<option value="">Add View</option>`

                Views.forEach((view, index) => {
                    const option = document.createElement('option');
                    option.innerHTML = view.name;
                    option.value = index;
                    addViewSelection.append(option);
                });
                const option = document.createElement('option');
                option.innerHTML = '<strong>All</strong>';
                option.value = 'all';
                addViewSelection.append(option);

                addViewSelection.addEventListener('change', (event) => {
                    if (addViewSelection.value === 'all') {
                        addAllViews();
                    } else if (addViewSelection.value !== '') {
                        uiControls.newSidebarFrame(Views[addViewSelection.value].make());
                    }
                });
                
                const viewTypeSelection = document.getElementById('view-type-selection');
                Views.forEach((view, index) => {
                    const option = document.createElement('option');
                    option.innerHTML = view.name;
                    option.value = index;
                    viewTypeSelection.append(option);
                });

                viewTypeSelection.addEventListener('change', (event) => {
                    const view = Views[viewTypeSelection.value].make();
                    if (this._frame.content) {
                        if (this._frame.content.remove) {
                            this._frame.content.remove();
                        }
                        this._frame.content.node.replaceWith(view.node);
                    } else {
                        this._frame.node.append(view.node);
                    }
                    this._frame.content = view;
                });

                const settings = document.getElementById('view-settings');
                settings.addEventListener('click', (event) =>
                    this?._frame?.querySelector('.settings')?.classList.toggle('hide-up'));
            },
            process() {
                this.allNodes = [];
                const views = new Set();
                const flatten = (node) => {
                    try {
                    Object.keys(node[symbols.views]).forEach((key) => views.add(key));
                } catch (e) {
                    console.log(node);
                    console.log(node[symbols.views]);
                }
                    this.allNodes.push(node);
                    node[symbols.content].forEach((node) => flatten(node));
                }

                this.structure.forEach((node) => flatten(node));
                this.contexts = Array.from(views);
                this.views.forEach((view) => view.contexts = this.contexts);
            },
            find(test) {
                return this.allNodes.find(test);
            },
            select(rules) {
                const nodes = rules.startsWith('*') ? this.allNodes : this.structure;
                rules = rules.replace(/^\*/, '');
                rules = rules.split(/,/).flatMap((rule) => {
                    const match = rule.match(/(?<name>[^=><]+)(?<test>[=\/><])(?<values>.*)/);
                    if (!match) {
                        let parent = this.structure.find((node) => node.name === rule);
                        if (parent) {
                            return (node) => node[symbols.container] === parent;
                        }
                        parent = this.allNodes.find((node) => node.name === rule);
                        if (parent) {
                            return (node) => node[symbols.container] === parent;
                        }
                        return [];
                    }
                    const name = match.groups.name;
                    const test = match.groups.test;
                    const values = match.groups.values.split(',').map((v) => numberOrString(v));
                    switch (test) {
                        case '=':
                            return (node) => values.includes(node[name]);
                        case '/':
                            const patterns = values.map((value) => new RegExp(value));
                            return (node) => patterns.some((pattern) => pattern.test(node[name]));
                        case '<':
                            return (node) => values.some((value) => value > node[name]);
                        case '>':
                            return (node) => values.some((value) => value < node[name]);
                    }
                    return [];
                });
                return nodes.filter((node) => rules.some((rule) => rule(node)));
            },
            get source() {
                return this._source;
            },
            set source(content) {
                this._source = content;
                this.views.forEach((view) => view.source = content);
                this.parse();
            },
            parse() {
                const name = this?.currentNode?.name;
                this.sourceStructure = getStructure(this.source);
                this.structure = expand(this.sourceStructure, valueParser);
                this.process();
                this.views.forEach((view) => view.structure = this.structure);
                if (name) {
                    const current = this.allNodes.find((node) => node.name === name);
                    if (current) {
                        this.currentNode = current;
                    }
                }
            },
            get currentNode() {
                return this._currentNode;
            },
            set currentNode(node) {
                this._currentNode = node;
                this.views.forEach((view) => view.currentNode = node);
            },
            addFrame(frame) {
                const option = document.createElement('option');
                option.innerText = frame.content.title;
                option.value = this.frames.length;
                this.viewSelection.append(option);
                this.frames.push(frame);
                this.currentFrame = frame;
            },
            removeFrame(frame) {
                const index = this.frames.indexOf(frame);
                this.viewSelection.querySelector(`:nth-child(${index})`).remove();
                this.frames = this.frames.filter((existing) => existing !== frame);
            },
            toggleSingleFrame() {
                this.singleFrame = !this.singleFrame;
                const layout = document.querySelector('.layout');
                if (this.singleFrame) {
                    this.referenceNode = this._frame.node.nextSibling;
                    this.frames.forEach((frame) => frame.node.classList.add('hidden'));
                    for (const node of document.querySelectorAll('.vertical-bar')) {
                        node.classList.add('hidden');
                    }
                    for (const node of document.querySelectorAll('.horizontal-bar')) {
                        node.classList.add('hidden');
                    }
                    this._frame.node.classList.remove('hidden');
                    layout.append(this._frame.node);
                    layout.querySelector('.root-frame').classList.add('hidden');
                } else {
                    this.frames.forEach((frame) => frame.node.classList.remove('hidden'));
                    for (const node of document.querySelectorAll('.vertical-bar')) {
                        node.classList.remove('hidden');
                    }
                    for (const node of document.querySelectorAll('.horizontal-bar')) {
                        node.classList.remove('hidden');
                    }
                    this._frame.container.node.insertBefore(this._frame.node, this.referenceNode);
                    layout.querySelector('.root-frame').classList.remove('hidden');
                }
            },
            get currentFrame() {
                return this._frame;
            },
            set currentFrame(frame) {
                if (this._frame !== frame) {
                    this.frames.forEach((frame) => frame.classList.remove('selected-frame'));
                    if (this.singleFrame) {
                        this.frames.forEach((frame) => frame.classList.add('hidden'));
                        // put previous frame back
                        this._frame.parentElement.insertBefore(this._frame, this.referenceNode);
                        // Update reference
                        this.referenceNode = frame.nextSibling;
                        const layout = document.querySelector('.layout');
                        layout.append(frame);
                    }
                    this._frame = frame;

                    frame.classList.remove('hidden');
                    frame.classList.add('selected-frame');
                    this.viewSelection.value = this.frames.indexOf(frame);
                    if (frame.firstChild && frame.firstChild.focus) {
                        frame.firstChild.focus();
                    }
                    const saveCanvas = document.getElementById('save-png');
                    saveCanvas.disabled = frame?.firstChild?.canvas === undefined;
                }
            }
        }

        /**
         *
         */
        function main() {
            Core.initialise();

            const editorFrame = uiControls.newFrame(Core.mainEditor);

            const glView = new GLView('3D Scene');
            const sceneFrame = uiControls.newFrame(glView);

            const gridTreeframe = uiControls.newFrame(new GridTreeView());
            const detailFrame = uiControls.newFrame(new DetailView());
            
            const column1 = new FrameContainer(editorFrame, gridTreeframe);
            const column2 = new FrameContainer(sceneFrame, detailFrame);
            const row = new FrameContainer(column1, column2);
            column1.column();
            column2.column();

            const layout = document.querySelector('.layout-main');
            layout.append(row.node);
            row.node.classList.add('root-frame');

            document.body.addEventListener('mousemove', (event) => {
                if (actions.mouseMove) {
                    actions.mouseMove(event);
                }
            });
            document.body.addEventListener('mouseup', (event) => {
                if (actions.mouseUp) {
                    actions.mouseUp(event);
                }
            });

            document.body.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (actions.touchMove) {
                    actions.touchMove(event);
                }
            });
            document.body.addEventListener('touchend', (event) => {
                if (actions.touchEnd) {
                    actions.touchEnd(event);
                }
            });
            addElementDrag(document.getElementById('overlay'));

            const saveButton = document.getElementById('save');
            saveButton.addEventListener('click', save);

            const loadButton = document.getElementById('load');
            loadButton.addEventListener('click', load);

            const filename = document.getElementById('filename');
            filename.addEventListener('input', (event) => {
                save.disabled = !filename.value;
                if (config.files.includes(filename.value)) {
                    filename.classList.add('existing-file');
                } else {
                    filename.classList.remove('existing-file');
                }
            });
            filename.addEventListener('change', load);
            const fullscreen = document.getElementById('fullscreen');
            fullscreen.addEventListener('click', toggleFullscreen);

            let savedShaders;
            try {
                savedShaders = localStorage.getItem('shaders');
            } catch (error) {
                console.log(error.toString());
                report(error);
            }

            const shaders = savedShaders ? JSON.parse(savedShaders) : defaultShaders;
            glView.setShaders(shaders);

            let configStr;
            try {
                configStr = localStorage.getItem('scene-config');
            } catch (e) {

            }

            if (configStr) {
                config = JSON.parse(configStr);
                config.files.forEach((name) => {
                    const option = document.createElement('option');
                    option.innerText = name;
                    document.getElementById('files').append(option);
                });
            }
            document.getElementById('filename').value = config.current;

            load(Core.mainEditor);

            const shaderObjectList = document.getElementById('shader-object-list');
            shaderObjectList.innerHTML = '';
            shaderObjects.forEach((shader) => {
                const node = document.createElement('option');
                shaderObjectList.appendChild(node);
                node.innerHTML = shader.title || shader.name;
                node.value = shader.name;
            });
            const shaderProgramList = document.getElementById('shader-program-list');
            shaderProgramList.innerHTML = '';
            defaultShaders.forEach((shader) => {
                const node = document.createElement('option');
                shaderProgramList.appendChild(node);
                node.innerHTML = shader.name;
            });

            render();
        }

        /**
         * Return a matrix representing a rotation
         */
        function getRotationMatrix(angle, axis) {
            angle *= Math.PI / 180;
            axis = normalise(axis);

            const a = Math.cos(angle / 2);
            const b = Math.sin(angle / 2) * axis[0];
            const c = Math.sin(angle / 2) * axis[1];
            const d = Math.sin(angle / 2) * axis[2];

            return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
            2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
            2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                0, 0, 0, a * a + b * b + c * c + d * d];
        }

        /**
         * Quaternion constructor
         *
         * @param {*} w
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Quaternion {
            constructor(w, x, y, z) {
                this.w = w === undefined ? 1 : w;
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
            }
            clone() {
                return new Quaternion(this.w, this.x, this.y, this.z);
            }
            static create(w, x, y, z) {
                var v;
                if (w instanceof Vector3d && x == undefined) {
                    return new Quaternion(0, w.x, w.y, w.z);
                } else if (w instanceof Vector3d) {
                    return Quaternion.createRotation(w, x);
                } else if (w && Array.isArray(w) && w.length === 4) {
                    return new Quaternion(w[0], w[1], w[2], w[3])
                } else if (w && w.w !== undefined) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else if (x instanceof Vector3d) {
                    return Quaternion.createRotation(x, w);
                } else if (w instanceof Quaternion) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else {
                    return new Quaternion(w === undefined ? 1 : w, x || 0, y || 0, z || 0);
                }
            }
            static createFromObject(obj) {
                return new Quaternion(obj.w, obj.x, obj.y, obj.z);
            }
            static createRotation(axis, angle) {
                const v = axis.normal();
                return new Quaternion(
                    Math.cos(angle / 2),
                    Math.sin(angle / 2) * v.x,
                    Math.sin(angle / 2) * v.y,
                    Math.sin(angle / 2) * v.z);
            }
            get length() {
                return Math.hypot(this.w, this.x, this.y, this.z);
            }

            get values() {
                return [this.w, this.x, this.y, this.z];

            }
            get inverse() {
                return this.conjugate();
            }
            get s() {
                return this.w;
            }
            get v() {
                return new Vector3d(this.x, this.y, this.z);
            }
            invert() {
                this.x *= -1;
                this.y *= -1;
                this.z *= -1;
                return this;
            }
            conjugate() {
                return new Quaternion(this.w, -this.x, -this.y, -this.z);
            }
            apply(v) {
                var vp = this.multiply(new Quaternion(0, v.x, v.y, v.z)).multiply(this.conjugate());
                return new Vector3d(vp.x, vp.y, vp.z);
            }
            rotate(other, angle) {
                if (angle !== undefined) {
                    other = Quaternion.createRotation(other, angle);
                }
                const s = this.s * other.s - this.v.dot(other.v);
                const v = other.v.scaled(this.s).add(this.v.scaled(other.s)).add(this.v.crossProduct(other.v));
                this.w = s;
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return;
            }
            scale(value) {
                this.w *= value;
                this.x *= value;
                this.y *= value;
                this.z *= value;
                return this;
            }
            scaled(value) {
                const result = this.clone();
                return result.scale(value);
            }
            multiply(other) {
                return new Quaternion(
                    this.w * other.w - this.x * other.x - this.y * other.y - this.z * other.z,// 1
                    this.w * other.x + this.x * other.w + this.y * other.z - this.z * other.y,// i
                    this.w * other.y - this.x * other.z + this.y * other.w + this.z * other.x,// j
                    this.w * other.z + this.x * other.y - this.y * other.x + this.z * other.w // k
                );
            }
            dot(other) {
                return this.w * other.w + this.x * other.x + this.y * other.y + this.z * other.z;
            }
            getMatrix() {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
                2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
                2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                    0, 0, 0, a * a + b * b + c * c + d * d];
            }
            setMatrix(matrix) {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                matrix[0] = a * a + b * b - c * c - d * d;
                matrix[1] = 2 * (b * c - a * d);
                matrix[2] = 2 * (b * d + a * c);
                matrix[3] = 0;
                matrix[4] = 2 * (b * c + a * d);
                matrix[5] = a * a - b * b + c * c - d * d;
                matrix[6] = 2 * (c * d - a * b);
                matrix[7] = 0;
                matrix[8] = 2 * (b * d - a * c);
                matrix[9] = 2 * (c * d + a * b);
                matrix[10] = a * a - b * b - c * c + d * d;
                matrix[11] = 0;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = 0;
                matrix[15] = a * a + b * b + c * c + d * d;
            }
        }


        /**
         * Vector3d constructor
         *
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Vector3d {
            constructor(x, y, z) {
                this.x = x || 0
                this.y = y || 0
                this.z = z || 0
            }
            static create(x, y, z) {
                if (x instanceof Vector3d) {
                    return x.clone();
                } else if (x && Array.isArray(x) && x.length === 3) {
                    return new Vector3d(x[0], x[1], x[2]);
                } else if (x && x.x !== undefined) {
                    return new Vector3d(x.x, x.y, x.z);
                }
                return new Vector3d(x, y, z);
            }
            clone() {
                return new Vector3d(this.x, this.y, this.z);
            }
            static createFromObject(obj) {
                return new Vector3d(obj.x, obj.y, obj.z);
            }
            get length() {
                return Math.hypot(this.x, this.y, this.z);
            }
            get array() {
                return [this.x, this.y, this.z, 0];
            }
            get array3() {
                return [this.x, this.y, this.z];
            }
            dotProduct(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            crossProduct(other) {
                return new Vector3d(this.y * other.z - this.z * other.y,
                    this.z * other.x - this.x * other.z,
                    this.x * other.y - this.y * other.x);
            }
            cross(other) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                this.x = y * other.z - z * other.y;
                this.y = z * other.x - x * other.z;
                this.z = x * other.y - y * other.x;
                return this;
            }
            normalise() {
                var n = this.length || 1;
                this.x /= n;
                this.y /= n;
                this.z /= n;
                return this;
            }
            normal() {
                var result = this.clone();
                return result.normalise()
            }
            scale(value) {
                this.x *= value
                this.y *= value
                this.z *= value
                return this
            }
            scaled(value) {
                var result = this.clone();
                return result.scale(value);
            }
            add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                return this;
            }
            subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                return this;
            }
            plus(other) {
                var result = this.clone();
                return result.add(other);
            }
            minus(other) {
                var result = this.clone();
                return result.subtract(other);
            }
            rotate(q, angle) {
                if (angle) {
                    q = Quaternion.createRotation(q, angle);
                }

                let s = q.w;
                let u = new Vector3d(q.x, q.y, q.z);
                let v = this.clone();

                this.cross(u).scale(2 * s)
                    .add(v.scaled(s * s - u.dot(u))).add(u.scaled(2 * v.dot(u)));
                return this;
            }
            transform(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];

                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            transform2(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];
                const w = matrix[3] * this.x + matrix[7] * this.y + matrix[11] * this.z + matrix[15];

                this.x = x / w;
                this.y = y / w;
                this.z = z / w;
                return this;
            }
            getProjection(rd) {
                if (rd === this.z) {
                    return { x: 0, y: 0 }
                } else {
                    return {
                        x: this.x / (1 + -this.z / rd),
                        y: -this.y / (1 + -this.z / rd)
                    }
                }
            }
        }

        /**
         *
         */
        const mat4 = {
            create: function () {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]
            },
            perspective: function (matrix, fieldOfView, aspect, zNear, zFar) {
                var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
                matrix[0] = f / aspect;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 0;
                matrix[4] = 0;
                matrix[5] = f;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = 0;
                matrix[9] = 0;
                matrix[10] = (zFar + zNear) / (zNear - zFar)
                matrix[11] = -1;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = (2 * zFar * zNear) / (zNear - zFar);
                matrix[15] = 1;
            },
            translate: function (input, output, change) {
                var m = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    change[0], change[1], change[2], 1
                ]
                this.multiply(input, m, output);
            },
            copy: function (input, output) {
                output[0] = input[0];
                output[1] = input[1];
                output[2] = input[2];
                output[3] = input[3];
                output[4] = input[4];
                output[5] = input[5];
                output[6] = input[6];
                output[7] = input[7];
                output[8] = input[8];
                output[9] = input[9];
                output[10] = input[10];
                output[11] = input[11];
                output[12] = input[12];
                output[13] = input[13];
                output[14] = input[14];
                output[15] = input[15];
            },
            rotate2d: function (input, output, angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                var m = [
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                ]
                var t = this.create();
                this.multiply(input, m, t);
                this.copy(t, output);
            },
            rotate: function (input, output, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                this.multiply(input, q.getMatrix(), output);
            },
            rotated: function (input, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                return matrixMultiply(input, q.getMatrix());
            },
            multiply: function (a, b, out) {
                var result = this.create();
                result[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
                result[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
                result[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
                result[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

                result[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
                result[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
                result[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
                result[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

                result[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
                result[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
                result[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
                result[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

                result[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
                result[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
                result[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
                result[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
                this.copy(result, out);
            },
            transpose: function (input, output) {
                var temp = this.create();
                this.copy(input, temp);
                output[1] = temp[4];
                output[2] = temp[8];
                output[3] = temp[12];
                output[4] = temp[2];
                output[6] = temp[9];
                output[7] = temp[13];
                output[8] = temp[2];
                output[9] = temp[6];
                output[11] = temp[14];
                output[12] = temp[3];
                output[13] = temp[7];
                output[14] = temp[11];
            },
            invert: function (input, output) {
                var x0 = input[0];
                var x1 = input[4];
                var x2 = input[8];
                var x3 = input[12];
                var x4 = input[1];
                var x5 = input[5];
                var x6 = input[9];
                var x7 = input[13];
                var x8 = input[2];
                var x9 = input[6];
                var x10 = input[10];
                var x11 = input[14];
                var x12 = input[3];
                var x13 = input[7];
                var x14 = input[11];
                var x15 = input[15];

                var a0 = x0 * x5 - x1 * x4;
                var a1 = x0 * x6 - x2 * x4;
                var a2 = x0 * x7 - x3 * x4;
                var a3 = x1 * x6 - x2 * x5;
                var a4 = x1 * x7 - x3 * x5;
                var a5 = x2 * x7 - x3 * x6;
                var b0 = x8 * x13 - x9 * x12;
                var b1 = x8 * x14 - x10 * x12;
                var b2 = x8 * x15 - x11 * x12;
                var b3 = x9 * x14 - x10 * x13;
                var b4 = x9 * x15 - x11 * x13;
                var b5 = x10 * x15 - x11 * x14;
                var invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

                output[0] = (+x5 * b5 - x6 * b4 + x7 * b3) * invdet;
                output[4] = (-x1 * b5 + x2 * b4 - x3 * b3) * invdet;
                output[8] = (+x13 * a5 - x14 * a4 + x15 * a3) * invdet;
                output[12] = (-x9 * a5 + x10 * a4 - x11 * a3) * invdet;
                output[1] = (-x4 * b5 + x6 * b2 - x7 * b1) * invdet;
                output[5] = (+x0 * b5 - x2 * b2 + x3 * b1) * invdet;
                output[9] = (-x12 * a5 + x14 * a2 - x15 * a1) * invdet;
                output[13] = (+x8 * a5 - x10 * a2 + x11 * a1) * invdet;
                output[2] = (+x4 * b4 - x5 * b2 + x7 * b0) * invdet;
                output[6] = (-x0 * b4 + x1 * b2 - x3 * b0) * invdet;
                output[10] = (+x12 * a4 - x13 * a2 + x15 * a0) * invdet;
                output[14] = (-x8 * a4 + x9 * a2 - x11 * a0) * invdet;
                output[3] = (-x4 * b3 + x5 * b1 - x6 * b0) * invdet;
                output[7] = (+x0 * b3 - x1 * b1 + x2 * b0) * invdet;
                output[11] = (-x12 * a3 + x13 * a1 - x14 * a0) * invdet;
                output[15] = (+x8 * a3 - x9 * a1 + x10 * a0) * invdet;

                return this;
            }
        }

        /**
         * Return the point of intersection of a line and plane, if line parallel to plane return undefined
         * @param {*} line 
         * @param {*} plane 
         */
        function linePlaneIntersection(line, plane) {
            var dv = plane.point.minus(line.point);
            var product = line.direction.dotProduct(plane.normal);
            if (product !== 0) {
                return line.direction.scaled(dv.dotProduct(plane.normal) / product).add(line.point);
            }
        }


        /**
         * Vector definition of a line
         */
        function Line(point, direction) {
            this.point = point.clone();
            this.direction = direction.clone();
        }

        /**
         *
         */
        Line.prototype = {
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t)
                return v.add(this.point)
            },
            intersection(other) {
                if (other instanceof Plane) {
                    return linePlaneIntersection(this, other)
                } else {
                    return this.lineIntersection(other)
                }
            },
            planeIntersection(plane) {
                const v = this.direction.clone();
                const dv = plane.point.minus(this.point);
                const div = v.dot(plane.normal);
                if (div) {
                    var a = dv.dot(plane.normal) / div;
                    return v.scale(a).add(this.point);
                }
            },
            lineIntersection(line) {
                if ((this.direction.x * line.direction.y - this.direction.y * line.direction.x) !== 0) {
                    var s = (this.direction.x * (line.point.y - this.point.y) + this.direction.y * (line.point.x - this.point.x))
                        / (this.direction.x * line.direction.y - this.direction.y * line.direction.x)
                } else {
                    var s = (this.direction.z * (line.point.y - this.point.y) + this.direction.y * (line.point.z - this.point.z))
                        / (this.direction.z * line.direction.y - this.direction.y * line.direction.z)
                }
                return line.point.plus(this.direction.scaled(s));
            }
        }


        /**
         * Definition of a segment
         */
        class Segment {
            constructor(start, end) {
                this.start = start.clone();
                this.end = end.clone();
            }

            get direction() {
                return (this.end.minus(this.start)).normalise();
            }
            set direction(direction) {
                this.end = this.start.plus(direction);
            }
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t);
                return v.add(this.start);
            }
        }

        /**
         * Vector definition of a plane
         */
        function Plane(point, normal) {
            this.point = point.clone();
            this.normal = normal.clone();
            this.normal.normalise();
            this.bounds = [];
        }

        /**
         *
         */
        Plane.prototype = {
            intersection(other) {
                if (other instanceof Plane) {
                    return this.planeIntersection(other)
                } else {
                    return linePlaneIntersection(other, this)
                }
            },
            planeIntersection(plane) {
                var d = this.normal.crossProduct(plane.normal)
                var v = d.crossProduct(this.normal)
                if (v.length === 0) {
                    return
                }
                var dv = plane.point.minus(this.point)
                var a = (dv.x * plane.normal.x + dv.y * plane.normal.y + dv.z * plane.normal.z) / (v.x * plane.normal.x + v.y * plane.normal.y + v.z * plane.normal.z)
                var p = v.scale(a).add(this.point)
                return new Line(p, d)
            },
            addBoundary(other) {
                this.bounds.push(other)
                other.bounds.push(this)
            },
            getBoundary() {
                var line = this.intersection(this.bounds[this.bounds.length - 1])
                var segments = []
                this.bounds.forEach(function (bound, index, all) {
                    var point = line.intersection(bound)
                    var segment = new Segment(point, point)
                    if (segments.length > 0) {
                        segments[segments.length - 1].end = point
                    }
                    segments.push(segment)
                    line = this.intersection(bound)
                }, this)
                segments[segments.length - 1].end = segments[0].start

                return segments
            }
        }

        /**
         *
         */
        class Triangle {
            constructor(p1, p2, p3) {
                this.p1 = Vector3d.create(p1);
                this.p2 = Vector3d.create(p2);
                this.p3 = Vector3d.create(p3);
            }
            get plane() {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                return new Plane(this.p1, n);
            }
            intersects(line) {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                const p = line.planeIntersection(new Plane(this.p1, n));
                if (p) {
                    const dt = (d1.x * d2.y - d2.x * d1.y);
                    if (dt !== 0 && d1.x !== 0) {
                        const t = (d1.x * (p.y - d1.y) + d1.y * (d1.x - p.x)) / dt;
                        const s = (p.x - t * d2.x - this.p1.x) / d1.x;
                        return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                    } else {
                        const dt = (d1.y * d2.z - d2.y * d1.z);
                        if (dt !== 0 && d1.y !== 0) {
                            const t = (d1.y * (p.z - d1.z) + d1.z * (d1.y - p.y)) / dt;
                            const s = (p.y - t * d2.y - this.p1.y) / d1.y;
                            return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                        } else {
                            const dt = (d1.z * d2.x - d2.z * d1.x);
                            if (dt !== 0 && d1.z !== 0) {
                                const t = (d1.z * (p.x - d1.x) + d1.x * (d1.z - p.z)) / dt;
                                const s = (p.z - t * d2.z - this.p1.z) / d1.z;
                                return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                            }
                        }
                    }
                }
                return false;
            }
        }
    </script>
</body>
</html>
