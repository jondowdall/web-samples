<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width" />
    <title>Structure View</title>
    <style>
        html {
            font-family: sans-serif;
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            width: 100vw;
            height: 100dvh;
            padding: 0.25rem;
            overflow: hidden;
            background-color: lightgray;
        }

        table,
        td,
        th {
            border-collapse: collapse;
        }

        td,
        th {
            border: 1px solid darkgray;
            padding: 0.2rem 0.5rem;
        }

        th {
            font-weight: bold;
            background-color: lightgray;
        }

        td {
            background-color: white;
        }

        .heading-row th {
            position: sticky;
            top: 0;
        }

        .undefined {
            background-color: lightblue;
        }

        #overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            position: fixed;
            bottom: 0;
            right: 0;
            z-index: 10;
            background: rgb(10, 10, 10, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
        }

        .overlay {
            font-weight: bold;
            font-size: 100%;
            color: orange;
            z-index: 10;
            background: rgb(10, 10, 50, 0.5);
            padding: 0.5em;
            border-radius: 0.5em;
            transform: translate(-50%, -50%);
            pointer-events: none;
            white-space: nowrap;
        }

        .fixed {
            position: fixed;
        }

        .shape {
            font-style: italic;
        }

        .scene-node {
            font-weight: bold;
        }

        .scene {
            flex-grow: 1;
        }

        .number {
            width: 40vw;
        }

        .existing-file {
            font-weight: bold;
        }

        .light-position {
            width: 100%;
        }

        .table-view {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .search-controls button {
            border: none;
            background: none;
            color: darkgray;
            font-weight: bold;
        }

        .search-controls .on {
            color: white;
        }

        .grid-tree-view .tree {
            display: grid;
            grid-template-columns: 1rem 1rem max-content 1fr 1fr;
            grid-auto-rows: min-content;
            grid-gap: 0;
        }

        .branch-content {
            margin-left: 1em;
            transition: max-height 0.3s ease-in;
        }

        .expander {
            display: inline-block;
            width: 1.1em;
            cursor: default;
            font-size: 70%;
        }

        .frame {
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            background: #c4cccf;
            padding-left: 1rem;
            border-radius: 0.5rem;

            box-shadow: 1px 3px 5px 2px rgb(100, 100, 100, 0.75);
            margin-top: 0.1rem;
            margin-left: 0.1rem;
            margin-bottom: 0.5rem;
            margin-right: 0.5rem;

            transition: width 0.3s ease-in-out, height 0.3s ease-in-out;

            transition: filter 0.1s ease-in, box-shadow 0.2s;
            filter: blur(0.5px);
            filter: brightness(75%);
        }

        .selected-frame {
            filter: none;
            background: lightblue;
        }

        .frame-title {
            transform: rotate(-90deg);
            transform-origin: top left;
            position: absolute;
            bottom: 0;
            left: 0;
            font-size: 80%;
            font-style: italic;
            background: lightblue;
            padding: 0 0.5em;
            border-radius: 0.5em;
            z-index: 10;
        }

        .frame-content {
            overflow: auto;
            max-height: 100%;
        }

        .frame-control-toggle {
            position: absolute;
            z-index: 100;
            top: 0;
            right: 0;
        }

        .sidebar {
            position: absolute;
            top: 0;
            right: 0;
            width: 25%;
            height: 100%;
            overflow: auto;
            padding: 0.5em;
            z-index: 100;
            background: rgb(50, 50, 50, 0.1);
            transition: transform 1s ease-in-out;
        }

        .hide-right {
            transform: translate(110%, 0);
        }

        .hide-right90 {
            right: -20%;
        }

        .sidebar>.frame {
            padding-left: 0.5em;
            background: lightblue;
            box-shadow: 0px 3px 5px #333;
            border-radius: 0.5em;
            overflow: hidden;
            margin-bottom: 0.5em;
            margin-right: 0.5em;
            transition: width 0.3s ease-in-out, height 0.3s ease-in-out;
            min-width: 10vw;
            aspect-ratio: 4 / 3;
        }

        .frame:not(.sidebar *) {
            min-height: 100%;
        }

        .view {
            height: 100%;
            overflow: auto;
        }

        .placeholder {
            border-radius: 2em;
            border: 4px dashed gray;
            overflow: hidden;

        }

        .sidebar>.placeholder {
            aspect-ratio: 4 / 3;
            margin-bottom: 0.5em;

        }

        .sidebar .view {
            background: white;
            overflow: auto;
            height: 100%;
            transition: opacity width height 0.2s;
        }

        .sidebar .view:focus-within {
            box-shadow: 3px 5px 8px #333;
        }

        .dragging {
            opacity: 50%;
            position: fixed;
            /*
            max-width: 30vw;
            max-height: 30vh;
            aspect-ratio: 4 / 3;
            */
            z-index: 100;
            filter: blur(2px);
        }

        .close-button {
            position: absolute;
            right: 0;
            top: 0;
            background: white;
            text-align: center;
            border: none;
            border-radius: 0.5em;
            width: 1em;
            height: 1em;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: min-content 1fr;
            width: 100%;
            height: 100%;
            grid-gap: 2px;
            background-color: lightgray;
        }

        .layout-main {
            position: relative;
            overflow: hidden;
        }

        .layout-column {
            display: grid;
            background-color: lightgray;
            overflow: hidden;
            height: 100%;
        }

        .layout-row {
            display: grid;
            background-color: lightgray;
            overflow: hidden;
            height: 100%;
        }

        .vertical-bar {
            width: 1rem;
            cursor: ew-resize;
        }

        .horizontal-bar {
            height: 2rem;
            cursor: ns-resize;
        }


        .vertical-bar,
        .horizontal-bar {
            opacity: 50%;
            margin: -0.5rem -0.5rem -0.5rem -0.5rem;
        }

        .controls {
            grid-column: 1 / -1;
            grid-row: 1;
            position: relative;
        }

        .main-controls {
            z-index: 100;
            background: lightgray;
            display: flex;
        }

        #interactive-update {
            margin: 0 0.5em;
        }

        #secondary-controls {
            background: lightgray;
            border: 1px outset gray;
            padding: 0.25em;
            min-height: 2em;
            z-index: 50;
            position: absolute;
            top: 100%;
            left: 0;
            transition: transform 0.3s ease-in-out;
        }

        .hide-up {
            transform: translateY(calc(-100% - 5px));
        }

        .hide-left {
            transform: translateX(-100%);
        }

        .right {
            float: right;
        }

        #playback-contols {
            grid-column: 4 / 7;
        }

        .editor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .editor {
            display: flex;
            font-family: monospace;
            flex-grow: 1;
            tab-size: 4;
        }

        .line-numbers {
            text-align: end;
            background: lightgray;
            resize: none;
            overflow: hidden;
            font-variant-numeric: tabular-nums;
        }

        .shader-program-editor {
            display: grid;
            grid-template-columns: max-content 1fr;
        }

        .shader-program-editor .update {
            grid-column: 1 / -1;
        }

        .shader-program-editor .uniforms {
            grid-column: 1 / -1;
        }

        .view {
            background: lightgray;
        }

        .view-selection {
            text-align: center;
        }

        .view-selection li {
            list-style: none;
            color: blue;
        }

        .main {
            flex-grow: 1;
            resize: none;
        }

        #input {
            width: 100%;
            height: 100%;
            overflow: auto;
            grid-column: 1 / -1;
            flex-grow: 1;
            resize: none;
            font-family: monospace;
            /*white-space: nowrap;*/
        }

        .new-heading {
            display: inline-block;
            min-width: 1em;
        }

        .clock-view {
            position: relative;
            overflow: hidden;
            height: 100%;
            max-width: 100%;
        }

        .full-canvas {
            position: relative;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background: black;
        }

        .detail-view {
            height: 100%;
            width: 100%;
            padding: 0.25rem;
        }

        .internal {
            font-style: italic;
        }

        .diagram-view {
            position: relative;
            overflow: hidden;
            height: 100%;
            max-width: 100%;
        }

        .diagram {
            position: relative;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        .gl-view {
            position: relative;
            overflow: hidden;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .gl-view .texture {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
        }

        .svg-view {
            width: 100%;
            height: 100%
        }

        .svg-view .tree {
            display: none;
        }

        #top-view-container {
            position: relative;
            overflow: hidden;
        }

        #top-view {
            width: 100%;
            height: 100%;
        }

        .structure-tree {
            overflow: auto;
        }

        .search-controls {
            display: flex;
        }

        .search {
            border-radius: 50px;
            flex-grow: 1;
            outline: none;
        }

        .detail {
            position: relative;
            overflow: auto;
        }


        .calendar-view h2 {
            position: relative;
            margin-top: 0.5rem;
            padding: 0 2rem;
            text-align: center;
        }

        .calendar-view .previous-month {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .calendar-view .next-month {
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
        }

        .calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: 2em;
            justify-items: center;
            overflow: hidden;
            border-radius: 0.3em;
            background: white;
            margin: 0.2em;
            align-items: center;
            font-size: 80%;
        }

        .calendar-day {
            padding: 0.3em 0.3em 1em;
            border-radius: 0.3em;
            position: relative;
            top: 1px;
            left: 1px;
            width: calc(100% - 4px);
            height: calc(100% - 4px);
            text-align: center;
        }

        .calendar-day-weekend {
            background: lightgray;
        }

        .calendar-day-shade {
            color: gray;
        }


        .vector-sliders {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
        }

        .group {
            position: relative;
            border-left: 1px solid gray;
            border-top-left-radius: 0.5em;
            border-bottom-left-radius: 0.5em;

            border: 1px solid gray;
            border-radius: 0.5em;
            margin: 0 1px;

            transition: max-height 0.3s ease-in;
        }

        .expand {
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
            transition: max-height 0.3s ease-in;
            max-height: 1.2em;
            overflow: hidden;
        }

        .shader-controls {
            display: flex;
        }

        .shader-name {
            flex-grow: 1;
        }

        .content {
            white-space: nowrap;
            max-height: 1.2em;
            transition: max-height 0.3s ease-in;
            overflow: hidden;
        }

        .range {
            font-style: italic;
            color: blue;
        }

        .control-node {
            font-style: italic;
            color: blue;
        }

        .range-expanded {
            font-style: italic;
            color: lightgray;
        }

        .collapse {
            max-height: 0;
            /*border: none;*/
        }

        .entry {
            padding-left: 1.1em;
        }

        .entry-content {
            padding-left: 1.1em;
        }

        .selected {
            background-color: yellow;
            fill: yellow !important;
        }

        .media-button {
            padding: 0;
            margin: 0;
            background: none;
            border: none;
            font-size: 150%;
        }

        #external-names {
            grid-column: 1 / -1;
            grid-row: 4;
            overflow: auto;
            padding: 0.5rem;
        }

        .header {
            background-color: lightgray;
            font-weight: bold;
            position: sticky;
            padding: 0.25rem;
            text-align: center;
        }

        .cell {
            background-color: white;
            padding: 0.25rem;
            width: 100%;
        }

        .attributes,
        .uniforms {
            display: grid;
            grid-gap: 1px;
        }

        .attributes {
            grid-template-columns: repeat(3, 1fr);
        }

        .uniforms {
            grid-template-columns: repeat(4, 1fr);
        }

        .settings {
            z-index: 10;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            /*            height: 100%; */
            background: lightgray;
            display: grid;
            grid-template-columns: max-content 1fr;
            box-shadow: 0px 3px 5px #333;
            transition: transform 0.3s ease-in-out;
            grid-gap: 3px;
            padding: 0.5em;
        }

        .settings label {
            text-align: right;
        }

        .hidden {
            display: none !important;
        }

        .hide {
            max-height: 0;
            overflow: hidden;
        }

        #search-button {
            width: 100px;
            height: 50px;
        }

        #search-button svg {
            width: 25px;
            height: 25px;
        }

        .svg-icon {
            width: 16px;
            height: 16px;
        }
    </style>
</head>

<body>
    <div id="overlay"></div>
    <datalist id="shader-object-list"></datalist>
    <datalist id="shader-program-list"></datalist>
    <template id="frame-template">
        <div class="frame"></div>
    </template>

    <template id="editor-template">
        <div class="view editor-container">
            <div>
                <button class="comment">Comment</button>
                <button class="uncomment">Uncomment</button>
                <button class="unindent">&larr;</button>
                <button class="indent">&rarr;</button>
                <button class="unit-break" title="Insert unit break">\u1f</button>
                <button class="record-break" title="Insert record break">\u1e</button>
                <button class="group-break" title="Insert group break">\u1d</button>
                <input class="spell-check" type="checkbox" />
            </div>
            <div class="editor">
                <textarea class="line-numbers"></textarea>
                <textarea class="main" wrap="off" spellcheck="false" autocapitalize="off"></textarea>
            </div>
            <div class="settings hide-up">
                <label>Shader:</label>
                <input class="shader-name" type="text" placeholder="Shader Name" list="shader-object-list" />
            </div>
        </div>
    </template>

    <template id="shader-program-editor-template">
        <div class="view shader-program-editor">
            <label>View: </label>
            <select class="gl-view-selection"></select>
            <label>Name: </label>
            <input class="program-name" type="text" list="shader-programs /">
            <label>Vertex Shader:</label>
            <select class="vertex-shader"></select>
            <label>Fragment Shader:</label>
            <select class="fragment-shader"></select>
            <button class="update">Update</button>
            <div class="uniforms"></div>
        </div>
    </template>

    <template id="tree-view-template">
        <div class="view tree-view">
            <div class="search-controls">
                <input class="search" type="text" />
            </div>
            <div class="tree"></div>
            <div class="settings hide-up">
                <label>Case Sensitive: </label>
                <input class="case-sensitive" title="Case Sensitive" type="checkbox" />
                <label>Regular Expression: </label>
                <input class="regular-expression" title="Regular Expression" type="checkbox" checked />
            </div>
        </div>
    </template>

    <template id="grid-tree-view-template">
        <div class="view grid-tree-view">
            <!--div class="search-controls">
                <input class="search" type="text" />
                <input class="case-sensitive" title="Case Sensitive" type="checkbox" />
                <input class="regular-expression" title="Regular Expression" type="checkbox" checked />
            </div-->
            <div class="tree"></div>
            <div class="settings hide-up"></div>
        </div>
    </template>

    <template id="shader-controls-template">
        <div class="view shader-controls">
            <input class="shader-name" placeholder="Shader Name" list="shader-list">
            <button class="build-shader">Build</button>
        </div>
    </template>

    <template id="diagram-view-template">
        <div class="view diagram-view">
            <canvas class="diagram" tabindex="1"></canvas>
            <div class="settings hide-up">
            </div>
    </template>

    <template id="gl-view-template">
        <div class="view gl-view">
            <div id="light-direction" class="vector-sliders">
                <input class="light-x light-position" type="range" min="-100" max="100" value="-75">
                <input class="light-y light-position" type="range" min="-100" max="100" value="-90">
                <input class="light-z light-position" type="range" min="-100" max="100">
            </div>
            <canvas class="scene" tabindex="1"></canvas>
            <div class="settings hide-up">
                <label for="split">Split</label><input class="split" type="checkbox">
                <label for="move">Move</label><input class="move" type="checkbox">
                <button class="reset" style="margin:0;padding:0;">
                    <svg id="upright-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M18 1 L16 9 L21 11 M20 7 L16 9" stroke="gray" fill="none" />
                        <path d="M12 4 L12 12 L20 12" stroke="black" fill="none" />
                        <circle cx="12" cy="12" r="3" stroke="black" fill="none" />
                    </svg>
                </button>
                <button class="upright">
                    <svg id="upright-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M12 21 L21 6" stroke="lightgray" fill="none" />
                        <path d="M12 21 L12 3 M21 6 A18 18 0 0 0 12 3 L15 1.5 L14.5 5 L12 3" stroke="black"
                            fill="none" />
                    </svg>
                </button>
                <label for="depth-test">Depth Test</label><input class="depth-test" type="checkbox" checked>
                <label for="min-level">Min Level</label><input class="min-level" type="number" value="0">
                <label for="levels">Levels</label><input class="levels" type="number" value="0">
                <label for="far">Far limit</label><input class="far" type="number" value=10000>
                <label for="step-size">Step Size</label><input class="step-size" type="number" value=1>
            </div>
            <canvas class="texture"></canvas>
        </div>
    </template>

    <template id="svg-view-template">
        <div class="view svg-view">
            <div>
                <svg class="svg" viewBox="0 0 1024 1024" width="1024" height="1024"></svg>
            </div>
            <div class="settings hide-up">
                <label>Nodes: </label><input class="root-nodes" type="text" value="svg" />
                <label>Filter: </label><input class="filter" type="text" />
                <label>Context: </label><select class="context-selection"></select>
                <label class="tree">Layout: </label><select class="layout tree">
                    <option value="grid">Grid</option>
                    <!--option value="timeline">Timeline</option-->
                    <option value="horizontal">Horizontal Tree</option>
                    <option value="vertical">Vertical Tree</option>
                    <option value="leftToRight">Left to Right</option>
                </select>
                <label class="tree">Connector Style: </label><select class="connector-style tree">
                    <option value="rectilinear">Rectilinear</option>
                    <option value="straight">Straight</option>
                    <option value="curved">Curved</option>
                    <option value="rounded">Rounded</option>
                </select>
                <label class="tree">Max Horizontal Nodes: </label><input class="max-horizontal-nodes tree" type="number"
                    value="5" />
                <label class="tree">Scroll to current: </label><input class="scroll-to-current tree" type="checkbox"
                    checked />
            </div>
        </div>
    </template>

    <template id="table-view-template">
        <div class="view table-view">
            <div class="search-controls">
                <input placeholder="search" class="search" type="text">
                <button class="case-sensitive">aA</button>
                <button class="regular-expression-seach">.*</button>
            </div>
            <div style="flex-grow:1;overflow:auto">
                <table>
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="settings hide-up">
                <label>Headings: </label><select class="headings-list" multiple="true"></select>
                <label>Hide Empty Rows: </label><input class="hide-empty-rows" type="checkbox" />
            </div>
        </div>
    </template>

    <template id="detail-view-template">
        <div class="view detail-view">
            <h2 class="title"></h2>
            <div class="detail"></div>
            <div class="settings hide-up">
                <label>Update: </label><input class="auto-update" type="checkbox" checked>
                <label>Context: </label><select class="context-selection"></select>
            </div>
        </div>
    </template>

    <template id="clock-view-template">
        <div class="view clock-view">
            <canvas class="full-canvas">Argh, no canvas how old is this browser?</canvas>
            <div class="settings hide-up">
                <label>Update: </label><input class="auto-update" type="checkbox" checked>
                <label>Context: </label><select class="context-selection"></select>
            </div>
        </div>
    </template>

    <template id="calendar-view-template">
        <div class="view calendar-view">

            <h2 class="month">
                <button class="previous-month">&lt;</button>
                <span class="month-label"></span>
                <button class="next-month">&gt;</button>
            </h2>
            <div class="calendar"></div>

            <div class="settings hide-up">
                <label>Update: </label><input class="auto-update" type="checkbox" checked>
                <label>Context: </label><select class="context-selection"></select>
            </div>
        </div>
    </template>

    <div class="layout">
        <div class="controls">
            <div class="main-controls">
                <datalist id="files"></datalist>
                <input id="filename" list="files" placeholder="Name" value="New Scene" />
                <button id="load">&#x1F4C2;</button>
                <button id="save">
                    <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M1 19 L1 23 L23 23 L23 19 M12 3 L12 19" stroke="black" fill="none" />
                        <path d="M12 19 L8 13 L16 13 Z" stroke="black" fill="black" />
                    </svg>
                </button>
                <button id="export-frame">
                    <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M1 19 L1 23 L23 23 L23 19 M12 6 L12 19 M5 3 h14 v10 h-14 Z" stroke="black"
                            fill="none" />
                        <path d="M12 20 L8 15 L16 15 Z" stroke="black" fill="black" />
                    </svg>
                </button>
                <button id="save-layout">&#x1F4BE;</button>
                <button id="view-settings">
                    <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="4" stroke="black" fill="none" />
                        <path
                            d="M12 19 L13.366 18.865 L15.827 21.239 L17.556 20.315 L16.950 16.950 L17.820 15.889 L21.239 15.827 L21.808 13.951 L19 12 L18.865 10.634 L21.239 8.173 L20.315 6.444 L16.950 7.050 L15.889 6.180 L15.827 2.761 L13.951 2.192 L12 5 L10.634 5.135 L8.173 2.761 L6.444 3.685 L7.050 7.050 L6.180 8.111 L2.761 8.173 L2.192 10.049 L5 12 L5.135 13.366 L2.761 15.827 L3.685 17.556 L7.050 16.950 L8.111 17.820 L8.173 21.239 L10.049 21.808 L12 19"
                            stroke="black" fill="none" />
                    </svg>
                </button>

                <div id="playback-controls" style="display:none">
                    <button id="start" class="media-button">&#x23ee;</button>
                    <button id="rewind" class="media-button">&#x23ea;</button>
                    <button id="play" class="media-button">&#x23ef;</button>
                    <button id="forward" class="media-button">&#x23e9;</button>
                    <button id="end" class="media-button">&#x23ed;</button>
                </div>
                <input id="interactive-update" type="checkbox" checked />
                <select id="add-view-selection"></select>
                <button id="toggle-secondary-controls">&#9776;</button>
                <button id="toggle-sidebar">Sidebar</button>
            </div>
            <div id="secondary-controls" class="hide-left">
                <!--button id="toggle-tabbed-layout">
                <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                    <path d="M0 10 L4 6 L10 6 L14 10 L24 10 L24 24 L0 24L 0 10 M12 8 L14 6 L18 6 L22 10"
                            stroke="black" fill="none"/>
                </svg>
            </button-->
                <button id="toggle-tabbed-layout">
                    <svg id="search-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M14 14 L24 14 L24 24 L14 24 L14 14 M12 24 L0 24 L0 0 L24 0 L24 12" stroke="black"
                            fill="none" />
                    </svg>
                </button>
                <button id="fullscreen">
                    <svg id="vertical-split-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path d="M0 4 L0 0 L4 0 M20 0 L24 0 L 24 4 M24 20 L24 24 L20 24 M4 24 L0 24 L0 20"
                            stroke="black" fill="none" />
                    </svg>
                </button>
                <button id="add-column">
                    <svg id="vertical-split-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path
                            d="M0 6 L8 6 L8 22 L0 22L0 6 M8 6 L16 6 L16 22 L8 22 M16 0 L24 0 L24 16 L16 16 L16 0 M20 11 L20 18 L22 18 L20 20 L18 18 L20 18"
                            stroke="black" fill="none" />
                    </svg>
                </button>
                <button id="add-row">
                    <svg id="vertical-split-icon" class="svg-icon" viewBox="0 0 24 24">
                        <path
                            d="M6 0 L6 8 L22 8 L22 0 L6 0 M6 8 L6 16 L22 16 L22 8 M0 16 L0 24 L16 24 L16 16 L0 16 M11 20 L18 20 L18 22 L20 20 L18 18 L18 20"
                            stroke="black" fill="none" />
                    </svg>
                </button>

                <button id="save-png">PNG</button>
                <button id="close-current-frame">&#10006;</button>

                <select id="view-type-selection"></select>
                <button id="hide-menu">&ShortLeftArrow;</button>
            </div>
        </div>
        <div class="layout-main">
            <div class="sidebar hide-right"></div>
        </div>

    </div>

    <script>
        const EpochDate = new Date("2018-04-04");

        const Holidays = [
            { date: "2018-01-01", event: "New Year's Day" },
            { date: "2018-01-02", event: "Christmas Shutdown" },
            { date: "2018-01-26", event: "Australia Day" },
            { date: "2018-01-12", event: "" },
            { date: "2018-01-30", event: "" },
            { date: "2018-03-02", event: "Easter" },
            { date: "2018-04-25", event: "Anzac Day" },
            { date: "2018-06-11", event: "Queen's Birthday" },
            { date: "2018-10-01", event: "Labour Day" },
            { date: "2018-12-24", event: "Christmas Shutdown" },
            { date: "2018-12-25", event: "Christmas Day" },
            { date: "2018-12-26", event: "Boxing Day" },
            { date: "2018-12-27", event: "Christmas Shutdown" },
            { date: "2018-12-28", event: "Christmas Shutdown" },
            { date: "2018-12-31", event: "Christmas Shutdown" },

            { date: "2019-01-01", event: "New Year's Day" },
            { date: "2019-01-02", event: "Christmas Shutdown" },
            { date: "2019-03-11", event: "Adelaide Cup Day" },
            { date: "2019-03-19", event: "Easter Friday" },
            { date: "2019-03-22", event: "Easter Monday" },
            { date: "2019-04-25", event: "Anzac Day" },
            { date: "2019-06-10", event: "Queen's Birthday" },
            { date: "2019-10-07", event: "Labour Day" },
            { date: "2019-12-23", event: "Christmas Shutdown" },
            { date: "2019-12-24", event: "Christmas Shutdown" },
            { date: "2019-12-25", event: "Christmas Day" },
            { date: "2019-12-26", event: "Boxing Day" },
            { date: "2019-12-27", event: "Christmas Shutdown" },
            { date: "2019-12-30", event: "Christmas Shutdown" },
            { date: "2019-12-31", event: "Christmas Shutdown" },

            { date: "2020-01-01", event: "New Year's Day" },
            { date: "2020-01-02", event: "Christmas Shutdown" },
            { date: "2020-01-03", event: "Christmas Shutdown" },
            { date: "2020-01-27", event: "Australia Day (Observed)" },
            { date: "2020-03-09", event: "Adelaide Cup Day" },
            { date: "2020-03-10", event: "Easter Friday" },
            { date: "2020-03-13", event: "Easter Monday" },
            { date: "2020-06-08", event: "Queen's Birthday" },
            { date: "2020-10-05", event: "Labour Day" },
            { date: "2020-12-23", event: "Christmas Shutdown" },
            { date: "2020-12-24", event: "Christmas Shutdown" },
            { date: "2020-12-25", event: "Christmas Day" },
            { date: "2020-12-28", event: "Christmas Shutdown" },
            { date: "2020-12-29", event: "Christmas Shutdown" },
            { date: "2020-12-30", event: "Christmas Shutdown" },
            { date: "2020-12-31", event: "Christmas Shutdown" },

            { date: "2021-01-01", event: "New Year's Day" },
            { date: "2021-01-26", event: "Australia Day" },
            { date: "2021-03-08", event: "Adelaide Cup Day" },
            { date: "2021-03-02", event: "Easter Friday" },
            { date: "2021-03-05", event: "Easter Monday" },
            { date: "2021-04-26", event: "Anzac Day" },
            { date: "2021-06-14", event: "Queen's Birthday" },
            { date: "2021-10-04", event: "Labour Day" },
            { date: "2021-12-23", event: "Christmas Shutdown" },
            { date: "2021-12-24", event: "Christmas Shutdown" },
            { date: "2021-12-27", event: "Christmas Shutdown" },
            { date: "2021-12-28", event: "Christmas Shutdown" },
            { date: "2021-12-29", event: "Christmas Shutdown" },
            { date: "2021-12-30", event: "Christmas Shutdown" },
            { date: "2021-12-31", event: "Christmas Shutdown" },

            { date: "2022-01-03", event: "Christmas Shutdown" },
            { date: "2022-01-26", event: "Australia Day" },
            { date: "2022-03-14", event: "Adelaide Cup Day" },
            { date: "2022-03-15", event: "Easter Friday" },
            { date: "2022-03-18", event: "Easter Monday" },
            { date: "2022-04-25", event: "Anzac Day" },
            { date: "2022-06-13", event: "Queen's Birthday" },
            { date: "2022-10-03", event: "Labour Day" },
            { date: "2022-12-26", event: "Boxing Day" },
            { date: "2022-12-27", event: "Christmas Shutdown" },
            { date: "2022-12-28", event: "Christmas Shutdown" },
            { date: "2022-12-29", event: "Christmas Shutdown" },
            { date: "2022-12-30", event: "Christmas Shutdown" },

            { date: "2023-01-02", event: "New Year's Day (Observed)" },
            { date: "2023-01-26", event: "Australia Day" },
            { date: "2023-03-13", event: "Adelaide Cup Day" },
            { date: "2023-03-07", event: "Easter Friday" },
            { date: "2023-03-10", event: "Easter Monday" },
            { date: "2023-06-12", event: "Queen's Birthday" },
            { date: "2023-10-02", event: "Labour Day" },
            { date: "2023-12-21", event: "BAE Christmas Shutdown" },
            { date: "2023-12-22", event: "BAE Christmas Shutdown" },
            { date: "2023-12-25", event: "Christmas Day" },
            { date: "2023-12-26", event: "Boxing Day" },
            { date: "2023-12-27", event: "Christmas Shutdown" },
            { date: "2023-12-28", event: "Christmas Shutdown" },
            { date: "2023-12-29", event: "Christmas Shutdown" },

            { date: "2024-01-01", event: "New Year's Day" },
            { date: "2024-01-02", event: "Christmas Shutdown" },
            { date: "2024-03-11", event: "Adelaide Cup Day" },
            { date: "2024-03-29", event: "Easter Friday" },
            { date: "2024-03-01", event: "Easter Monday" },
            { date: "2024-04-25", event: "Anzac Day" },
            { date: "2024-06-10", event: "Queen's Birthday" },
            { date: "2024-10-07", event: "Labour Day" },
            { date: "2024-12-23", event: "Christmas Shutdown" },
            { date: "2024-12-24", event: "Christmas Shutdown" },
            { date: "2024-12-25", event: "Christmas Day" },
            { date: "2024-12-26", event: "Boxing Day" },
            { date: "2024-12-27", event: "Christmas Shutdown" },
            { date: "2024-12-30", event: "Christmas Shutdown" },
            { date: "2024-12-31", event: "Christmas Shutdown" },

            { date: "2025-01-01", event: "New Year's Day" },
            { date: "2025-01-02", event: "Christmas Shutdown" },
            { date: "2025-01-03", event: "Christmas Shutdown" },
            { date: "2025-01-27", event: "Australia Day (Observed)" },
            { date: "2025-03-10", event: "Adelaide Cup Day" },
            { date: "2025-03-18", event: "Easter Friday" },
            { date: "2025-03-21", event: "Easter Monday" },
            { date: "2025-04-25", event: "Anzac Day" },
            { date: "2025-10-06", event: "Labour Day" },
            { date: "2025-12-22", event: "Christmas Shutdown" },
            { date: "2025-12-23", event: "Christmas Shutdown" },
            { date: "2025-12-25", event: "Christmas Day" },
            { date: "2025-12-26", event: "Boxing Day" },
            { date: "2025-12-29", event: "Christmas Shutdown" },
            { date: "2025-12-30", event: "Christmas Shutdown" },
            { date: "2025-12-31", event: "Christmas Shutdown" },

            { date: "2026-01-01", event: "New Year's Day" },
            { date: "2026-01-02", event: "Christmas Shutdown" },
            { date: "2026-01-26", event: "Australia Day" },
            { date: "2026-03-09", event: "Adelaide Cup Day" },
            { date: "2026-03-03", event: "Easter Friday" },
            { date: "2026-03-06", event: "Easter Monday" },
            { date: "2026-06-08", event: "Queen's Birthday" },
            { date: "2026-10-05", event: "Labour Day" },
            { date: "2026-12-23", event: "Christmas Shutdown" },
            { date: "2026-12-24", event: "Christmas Shutdown" },
            { date: "2026-12-25", event: "Christmas Day" },
            { date: "2026-12-28", event: "Christmas Shutdown" },
            { date: "2026-12-29", event: "Christmas Shutdown" },
            { date: "2026-12-30", event: "Christmas Shutdown" },
            { date: "2026-12-31", event: "Christmas Shutdown" },

            { date: "2027-01-01", event: "New Year's Day" },
            { date: "2027-01-26", event: "Australia Day" },
            { date: "2027-03-12", event: "Adelaide Cup Day" },
            { date: "2027-03-26", event: "Easter Friday" },
            { date: "2027-03-29", event: "Easter Monday" },
            { date: "2027-06-14", event: "Queen's Birthday" },
            { date: "2027-10-04", event: "Labour Day" },
            { date: "2027-12-23", event: "Christmas Shutdown" },
            { date: "2027-12-24", event: "Christmas Shutdown" },
            { date: "2027-12-27", event: "Christmas Shutdown" },
            { date: "2027-12-28", event: "Christmas Shutdown" },
            { date: "2027-12-29", event: "Christmas Shutdown" },
            { date: "2027-12-30", event: "Christmas Shutdown" },
            { date: "2027-12-31", event: "Christmas Shutdown" },

            { date: "2028-01-03", event: "New Year's Day (Observed)" },
            { date: "2028-01-26", event: "Australia Day" },
            { date: "2028-03-13", event: "Adelaide Cup Day" },
            { date: "2028-03-14", event: "Easter Friday" },
            { date: "2028-03-17", event: "Easter Monday" },
            { date: "2028-04-25", event: "Anzac Day" },
            { date: "2028-06-12", event: "Queen's Birthday" },
            { date: "2028-10-02", event: "Labour Day" },
            { date: "2028-12-25", event: "Christmas Day" },
            { date: "2028-12-26", event: "Boxing Day" },
            { date: "2028-12-27", event: "Christmas Shutdown" },
            { date: "2028-12-28", event: "Christmas Shutdown" },
            { date: "2028-12-29", event: "Christmas Shutdown" },

            { date: "2029-01-01", event: "New Year's Day" },
            { date: "2029-01-02", event: "Christmas Shutdown" },
            { date: "2029-01-26", event: "Australia Day" },
            { date: "2029-03-12", event: "Adelaide Cup Day" },
            { date: "2029-03-30", event: "Easter Friday" },
            { date: "2029-03-02", event: "Easter Monday" },
            { date: "2029-04-25", event: "Anzac Day" },
            { date: "2029-06-11", event: "Queen's Birthday" },
            { date: "2029-10-01", event: "Labour Day" },
            { date: "2029-12-24", event: "Christmas Shutdown" },
            { date: "2029-12-25", event: "Christmas Day" },
            { date: "2029-12-26", event: "Boxing Day" },
            { date: "2029-12-27", event: "Christmas Shutdown" },
            { date: "2029-12-28", event: "Christmas Shutdown" },
            { date: "2029-12-31", event: "Christmas Shutdown" },

            { date: "2030-01-01", event: "New Year's Day" },
            { date: "2030-01-28", event: "Australia Day (Observed)" },
            { date: "2030-03-11", event: "Adelaide Cup Day" },
            { date: "2030-03-19", event: "Easter Friday" },
            { date: "2030-03-22", event: "Easter Monday" },
            { date: "2030-04-25", event: "Anzac Day" },
            { date: "2030-06-10", event: "Queen's Birthday" },
            { date: "2030-10-07", event: "Labour Day" },
            { date: "2030-12-23", event: "Christmas Shutdown" },
            { date: "2030-12-24", event: "Christmas Shutdown" },
            { date: "2030-12-25", event: "Christmas Day" },
            { date: "2030-12-26", event: "Boxing Day" },
            { date: "2030-12-27", event: "Christmas Shutdown" },
            { date: "2030-12-30", event: "Christmas Shutdown" },
            { date: "2030-12-31", event: "Christmas Shutdown" },

            { date: "2031-01-01", event: "New Year's Day" },
            { date: "2031-01-27", event: "Australia Day (Observed)" },
            { date: "2031-03-10", event: "Adelaide Cup Day" },
            { date: "2031-03-11", event: "Easter Friday" },
            { date: "2031-03-14", event: "Easter Monday" },
            { date: "2031-04-25", event: "Anzac Day" },
            { date: "2031-06-09", event: "Queen's Birthday" },
            { date: "2031-10-06", event: "Labour Day" },
            { date: "2031-12-22", event: "Christmas Shutdown" },
            { date: "2031-12-23", event: "Christmas Shutdown" },
            { date: "2031-12-24", event: "Christmas Shutdown" },
            { date: "2031-12-25", event: "Christmas Day" },
            { date: "2031-12-26", event: "Boxing Day" },
            { date: "2031-12-29", event: "Christmas Shutdown" },
            { date: "2031-12-30", event: "Christmas Shutdown" },
            { date: "2031-12-31", event: "Christmas Shutdown" },

            { date: "2032-01-01", event: "New Year's Day" },
            { date: "2032-01-26", event: "Australia Day" },
            { date: "2032-03-26", event: "Easter Friday" },
            { date: "2032-03-29", event: "Easter Monday" },
            { date: "2032-06-14", event: "Queen's Birthday" },
            { date: "2032-10-04", event: "Labour Day" },
            { date: "2032-12-23", event: "Christmas Shutdown" },
            { date: "2032-12-24", event: "Christmas Shutdown" },
            { date: "2032-12-27", event: "Christmas Shutdown" },
            { date: "2032-12-28", event: "Christmas Shutdown" },
            { date: "2032-12-29", event: "Christmas Shutdown" },
            { date: "2032-12-30", event: "Christmas Shutdown" },
            { date: "2032-12-31", event: "Christmas Shutdown" },
        ].reduce((holidays, holiday) => {
            holidays[dayNumber(new Date(holiday.date))] = holiday.event;
            return holidays;
        }, {});


        /**
         * Convert a date to a day number
         */
        function dayNumber(date) {
            date = new Date(`${date.getFullYear()}-${((date.getMonth() + 1) + '').padStart(2, '0')}-${(date.getDate() + '').padStart(2, '0')}`);
            return (date.getTime() - EpochDate.getTime()) / (24 * 60 * 60 * 1000)
        }

        /**
         * Return true if the date is a working day, ie. not weekend or holiday
         */
        function isWorkingDay(date) {
            return (date.getDay() !== 0) && (date.getDay() !== 6) && (Holidays[dayNumber(date)] === undefined);
        }

        /**
         * Return the number of working dates between who dates.
         */
        function workingDays(start, end) {
            let sign = 1;
            if (start.getTime() > end.getTime()) {
                [start, end] = [end, start];
                sign = -1;
            }
            const date = new Date(start);
            let count = 0;
            while (date.getTime() < end.getTime()) {
                if (isWorkingDay(date)) {
                    count += 1;
                }
                date.setDate(date.getDate() + 1);
            }
            return sign * count;
        }

        function getCalendarDays(start, workingDays) {
            let offset = 1;
            if (workingDays < 0) {
                offset = -1;
                workingDays = - workingDays;
            }
            const date = new Date(start);
            --workingDays;  // The Start / end day is included in the count
            while (workingDays > 0) {
                date.setDate(date.getDate() + offset);
                if (isWorkingDay(date)) {
                    --workingDays;
                }
            }
            return date;
        }

        function offsetDate(date, workingDays) {
            let offset = 1;
            if (workingDays < 0) {
                offset = -1;
                workingDays = - workingDays;
            }

            while (workingDays > 0) {
                date.setDate(date.getDate() + offset);
                if (isWorkingDay(date)) {
                    --workingDays;
                }
            }
            return date;
        }

        /**
         * Clear the hours, minutes, seconds and milliseconds.
         */
        function quantiseDate(date, hours = 0) {
            date.setHours(hours);
            date.setMinutes(0);
            date.setSeconds(0);
            date.setMilliseconds(0);
            return date;
        }

        /**
         * return a quantised date.
         */
        function quantisedDate(date, hours = 0) {
            date = new Date(date)
            date.setHours(hours);
            date.setMinutes(0);
            date.setSeconds(0);
            date.setMilliseconds(0);
            return date;
        }

        /**
         *
         */
        addEventListener('load', function (e) {
            main();
        });

        /**
         * Display a warning.
         */
        function warn(str) {
            console.log(str);
        }

        /**
         * Display a warning.
         */
        function error(str) {
            console.log(str);
        }

        /**
         * Display the text in overlay div.
         */
        function report(text, sep) {
            if (sep) {
                document.getElementById('overlay').innerText += sep + text;
            } else {
                document.getElementById('overlay').innerText = text;
            }
        }

        /**
         * Converts an HSL colour value to RGB. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSL_colour_space.
         * Assumes h, s, and l are contained in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         *
         * @param   {number}  h       The hue
         * @param   {number}  s       The saturation
         * @param   {number}  l       The lightness
         * @return  {Array}           The RGB representation
         */
        function hslToRgb(h, s, l) {
            var r, g, b;

            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                var hue2rgb = function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        /**
         * Utility function to support downloading generated content.
         */
        function download(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Export frame
         */
        function exportFrame() {
            if (Core.currentFrame) {
                const svg = Core.currentFrame.querySelector('svg');
                if (svg) {
                    const text = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
${svg.parentElement.innerHTML}`;
                    download(svg.parentElement.innerHTML, 'image.svg');
                } else {
                    const canvas = Core.currentFrame.querySelector('canvas');
                    if (canvas) {
                        savePNG(canvas);
                    }
                }
            }
        }


        function downloadCanvasAsImage(canvas) {
            const downloadLink = document.createElement('a');
            downloadLink.setAttribute('download', 'CanvasAsImage.png');
            canvas.toBlob(function (blob) {
                const url = URL.createObjectURL(blob);
                downloadLink.setAttribute('href', url);
                downloadLink.click();
            });
        }
        /**
         * Save a canvas as png
         */
        function savePNG(canvas) {
            const data = canvas.toDataURL('image/png');
            //.replace(/^data:image\/[^;]*/, 'data:application/octet-stream');
            //.replace(/^data:image\/[^;]*/, 'data:application/octet-stream;headers=Content-Disposition%3A%20attachment%3B%20filename=canvas.png');

            // Create an anchor, and set the href value to our data URL
            const link = document.createElement('a');
            link.href = data;

            // This is the name of our downloaded file
            link.download = "download-this-canvas";

            // Click the download button, causing a download, and then remove it
            link.click();
            link.remove();
        }

        /**
         * Get a string representation of the current window configuration.
         */
        function getLayout() {
            const node = document.querySelector('.layout-main');
            const lines = [];
            const content = (node, level = 0) => {
                const indent = ''.padStart(level * 2, ' ');
                for (const child of node.children) {
                    if (child.classList.contains('layout-row')) {
                        lines.push(`${indent}row;${getRowSizes(child).join(',')}`);
                        content(child, level + 1);
                    } else if (child.classList.contains('layout-column')) {
                        lines.push(`${indent}column;${getColumnSizes(child).join(',')}`);
                        content(child, level + 1);
                    } else if (child.classList.contains('frame')) {
                        const viewNode = child.querySelector('.view');
                        const view = Core.views.find((view) => view.node === viewNode);
                        lines.push(`${indent}view;${view.getSettingsString()}`);
                    }
                }
            }
            content(node);
            const sidebar = document.querySelector('.sidebar');
            if (sidebar.children.length > 0) {
                lines.push(`sidebar`);
                const indent = '  ';
                for (const child of sidebar.children) {
                    const viewNode = child.querySelector('.view');
                    const view = Core.views.find((view) => view.node === viewNode);
                    lines.push(`${indent}view;${view.getSettingsString()}`);
                }
            }
            return lines.join('\n');
        }

        /**
         * Set the window layout based on the given defintion string.
         */
        function restoreLayout(definition) {
            // Clear current views
            Core.views = [];
            const records = definition.split(/\r?\n|\u{1e}/u);
            const roots = [];
            const stack = [];

            const layout = document.querySelector('.layout-main');
            const rootNode = layout.querySelector('.root-frame');
            if (rootNode) {
                layout.querySelector('.root-frame').remove();
            }

            const processRecord = (record) => {
                const units = record.definition.split(/;|\u{1f}/u)
                let item;
                if (units[0] === 'view') {
                    const viewClass = Views.find((view) => view.cls.name === units[1]);
                    const settings = units.slice(3).reduce((settings, unit) => {
                        if (unit.includes('=')) {
                            const [name, ...value] = unit.split('=');
                            settings[name.trim()] = value.join('=').trim();
                        }
                        return settings;
                    }, {});
                    const view = new viewClass.cls()
                    view.applySettings(settings);
                    item = uiControls.newFrame(view);
                } else if (units[0] === 'row') {
                    item = new FrameContainer(...record.children);
                    const sizes = units[1].split(',').map((str) => `${str}fr`);
                    item.node.style.gridTemplateColumns = sizes.join(' min-content ');
                } else if (units[0] === 'column') {
                    item = new FrameContainer(...record.children);
                    item.column();
                    const sizes = units[1].split(',').map((str) => `${str}fr`);
                    item.node.style.gridTemplateRows = sizes.join(' min-content ');
                } else if (units[0] === 'sidebar') {
                    item = document.querySelector('.sidebar');
                    record.children.forEach((child) => item.append(child));
                }
                if (stack.length) {
                    stack[0].data.children.push(item);
                } else {
                    roots.push(item);
                    if (units[0] === 'view') {
                        layout.append(item);
                        item.classList.add('root-frame');
                    } else if ((units[0] === 'column') || (units[0] === 'row')) {
                        layout.append(item.node);
                        item.node.classList.add('root-frame');
                    }
                }
            }

            records.forEach((record) => {
                const trimmed = record.trim();
                if (!(record === '' || record.startsWith('#'))) {
                    const level = record.length - record.trimStart().length;
                    while (stack.length && stack[0].level >= level) {
                        processRecord(stack.shift().data);
                    }
                    stack.unshift({ level, data: { children: [], definition: trimmed, }, });
                }
            });

            while (stack.length) {
                processRecord(stack.shift().data);
            }
        }

        /**
         * Get sizes in a row container as a proportion of total sizes.
         */
        function getRowSizes(node) {
            const style = window.getComputedStyle(node);
            if (style.gridTemplateColumns) {
                const sizes = style.gridTemplateColumns.split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                const total = sizes.reduce((sum, size) => sum + size, 0);
                return sizes.map((size) => size / total);
            }
        }

        /**
         * Get sizes in a column container as a proportion of total sizes.
         */
        function getColumnSizes(node) {
            const style = window.getComputedStyle(node);
            if (style.gridTemplateRows) {
                const sizes = style.gridTemplateRows.split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                const total = sizes.reduce((sum, size) => sum + size, 0);
                return sizes.map((size) => size / total);
            }
        }

        class FrameContainer {
            static all = [];
            constructor(...content) {
                this.node = document.createElement('div');
                this.node.classList.add('layout-row');
                this.bar = this.node.classList.contains('layout-row') ? uiControls.newVerticalBar : uiControls.newHorizontalBar;
                this.content = [];
                this.style = window.getComputedStyle(this.node);
                if (content.length) {
                    this.setContent(...content);
                }
                FrameContainer.all.push(this);
            }
            row() {
                if (this.node.classList.contains('layout-row')) {
                    return;
                }
                this.node.classList.add('layout-row');
                this.node.classList.remove('layout-column');

                this.bar = uiControls.newVerticalBar;

                for (const node of this.node.querySelectorAll(':scope > .horizontal-bar')) {
                    node.replaceWith(uiControls.newVerticalBar());
                }

                const content = Array.from(this.node.children).filter((s, i) => (i % 2) === 0);
                const style = window.getComputedStyle(this.node);

                if (style.gridTemplateRows) {
                    const sizes = style.gridTemplateRows.split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                    const total = sizes.reduce((sum, size) => sum + size, 0);
                    this.node.style.gridTemplateColumns = sizes.map((size) => `${size / total}fr`).join(' min-content ');
                    this.node.style.gridTemplateRows = '1fr';
                } else {
                    this.node.style.gridTemplateColumns = content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateRows = '1fr';
                }
            }
            column() {
                if (!this.node.classList.contains('layout-row')) {
                    return;
                }
                this.node.classList.add('layout-column');
                this.node.classList.remove('layout-row');

                this.bar = uiControls.newHorizontalBar;

                for (const node of this.node.querySelectorAll(':scope > .vertical-bar')) {
                    node.replaceWith(uiControls.newHorizontalBar());
                }

                const content = Array.from(this.node.children).filter((s, i) => (i % 2) === 0);
                const style = window.getComputedStyle(this.node);

                if (style.gridTemplateColumns) {
                    const sizes = style.gridTemplateColumns.split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                    const total = sizes.reduce((sum, size) => sum + size, 0);
                    this.node.style.gridTemplateRows = sizes.map((size) => `${size / total}fr`).join(' min-content ');
                    this.node.style.gridTemplateColumns = '1fr';
                } else {
                    this.node.style.gridTemplateRows = content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateColumns = '1fr';
                }
            }
            setContent(...content) {
                this.content = content;
                content.forEach((frame, index) => {
                    this.node.append(frame.node || frame);
                    if (index < this.content.length - 1) {
                        this.node.append(this.bar());
                    }
                });
                if (this.node.classList.contains('layout-row')) {
                    this.node.style.gridTemplateColumns = this.content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateRows = '1fr';
                } else {
                    this.node.style.gridTemplateRows = this.content.map((item) => '1fr').join(' min-content ');
                    this.node.style.gridTemplateColumns = '1fr';
                }
            }
            insert(view, bar) {
                const container = bar.parentElement;
                const gridTemplate = container.classList.contains('layout-row') ? 'gridTemplateColumns' : 'gridTemplateRows';
                const content = Array.from(container.children);
                const style = window.getComputedStyle(container);
                const sizes = style[gridTemplate].split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);

                const index = (1 + content.indexOf(bar)) / 2;
                const total = sizes.reduce((sum, size) => sum + size, 0);
                const newSize = sizes.map((size) => `${size / total}fr`);
                newSize.splice(index, 0, `${1 / sizes.length}fr`);

                if (container.classList.contains('layout-row')) {
                    container.insertBefore(uiControls.newVerticalBar(), bar);
                } else {
                    container.insertBefore(uiControls.newHorizontalBar(), bar);
                }
                container.insertBefore(view, bar);
                container.style[gridTemplate] = newSize.join(' min-content ');
            }
            split(newFrame, existing, after) {
                const currentContainer = existing.parentElement;
                const container = new FrameContainer();
                if (currentContainer.classList.contains('layout-row')) {
                    container.column();
                }
                existing.replaceWith(container.node);
                if (after) {
                    container.setContent(existing, newFrame);
                } else {
                    container.setContent(newFrame, existing);
                }
            }
            remove(frame) {
                const content = Array.from(this.node.children);
                const heights = this.style.gridTemplateRows.split(' ').map((height) => parseFloat(height));
                const index = content.indexOf(frame.node);
                if (index === 0) {
                    frame.node.nextSibling.remove();
                    frame.node.remove();
                    heights.splice(index, 2);
                } else if (index > 0) {
                    frame.node.previousSibling.remove();
                    frame.node.remove();
                    heights.splice(index - 1, 2);
                }
                if (heights.length > 1) {
                    const sizes = heights.map((height, index) =>
                        (index % 2) ? 'min-content' : `${height}fr`);
                    this.node.style.gridTemplateRows = sizes.join(' ');
                } else {
                    const other = this.content.find((other) => other != frame);
                    this.node.replaceWith(other.node);
                    other.container = this.container;
                    if (this.container) {
                        this.container.content = this.container.content.map((frame) => frame === this ? other : frame);
                    }
                }
                const pos = FrameContainer.all.indexOf(this);
                if (pos > -1) {
                    FrameContainer.all.splice(pos, 1);
                }
            }
        }

        /**
         * Create nodes from a template
         */
        class Templated {
            constructor(templateName) {
                const template = document.getElementById(templateName);
                this.node = template.content.firstElementChild.cloneNode(true);
            }
            getNodes(map) {
                this.nodes = {};
                Object.entries(map).forEach(([name, selector]) => {
                    this.nodes[name] = this.node.querySelector(selector);
                    if (!this.nodes[name]) {
                        warn(`Warning: selector ${selector} not found in template for ${this.constructor.name}`);
                    }
                });
            }
        }

        /**
         * Process the nodes based on the roots and filters.
         */
        function process(action, roots, filter) {
            const fullName = (node) => {
                const path = [node];
                while (node[symbols.container]) {
                    node = node[symbols.container];
                    path.unshift(node);
                }
                return path;
            }
            if (roots) {
                roots = roots.split(/;/).map((str) => str.trim())
                    .flatMap((name) => Core.find((node) => node.name === name || fullName(node).join('.') === name) || []);
            } else {
                roots = Core.structure;
            }

            if (filter) {
                const test = filter.split(/( AND | OR | && | \|\| |\(|\))/)
                    .map((item) => item.trim())
                    .map((test) => {
                        if (test === 'AND' || test === '&&') {
                            return '&&';
                        } else if (test === 'OR' || test === '||') {
                            return '||';
                        } else if (test === '(' || test === ')') {
                            return test;
                        } else if (test.startsWith('$')) {
                            return test.replace(/^\$/, 'node');
                        } else if (test.includes('=')) {
                            const [attr, value] = test.split('=');
                            return `node[${attr}] === ${value}`;
                        } else {
                            return `node[${test}] !== undefined`;
                        }
                    }).join(' ');
                filter = new Function('node', `return ${test};`);
            } else {
                filter = (node) => true;
            }

            const walk = (node) => {
                action(node);
                node[symbols.content].filter(filter).forEach((node) => walk(node));
            }
            roots.forEach((node) => walk(node));
        }

        /**
         * View component
         */
        class View extends Templated {
            constructor(templateName, settingsMap) {
                super(templateName);
                if (settingsMap) {
                    this.getSettingsNodes(settingsMap);
                }
                Core.views.push(this);
                const settings = this.node.querySelector('.settings');
                if (settings) {
                    this.node.addEventListener('click', (event) =>
                        settings.contains(event.target) ? '' : settings.classList.add('hide-up'));
                }
            }
            getSettingsNodes(settingsMap) {
                this.settings = {};
                Object.entries(settingsMap).forEach(([name, selector]) => {
                    this.settings[name] = this.node.querySelector(selector);
                    if (!this.settings[name]) {
                        warn(`Warning: selector ${selector} not found in template for ${this.constructor.name}`);
                    }
                });
            }
            getSettingsString() {
                let settings = '';
                if (this.settings) {
                    settings = Object.entries(this.settings).map(([name, node]) => {
                        if (node.type === 'checkbox') {
                            return `${name}=${Boolean(node.checked)}`;
                        }
                        return `${name}=${node.value}`;
                    }).join(';');
                }
                return `${this.constructor.name};title=${this.title};${settings}`;
            }
            applySettings(settings) {
                if (this.settings) {
                    Object.entries(settings).forEach(([control, value]) => {
                        if (this.settings[control].type === 'checkbox') {
                            this.settings[control].checked = value === 'true';
                        } else {
                            this.settings[control].value = value;
                        }
                    });
                }
            }
            toggleSettings() {
                const settings = this.node.querySelector('.settings');
                if (settings) {
                    settings.classList.toggle('hide-up');
                }
            }
            update(time) {

            }
            remove() {
                Core.views = Core.views.filter((view) => view !== this);
            }
        }

        /**
        * Editor component
        */
        class Editor extends View {
            constructor(title = '', config = {}, settingsMap) {
                super('editor-template', settingsMap);
                this.config = config;
                this.lineNumbers = this.node.querySelector('.line-numbers');
                this.main = this.node.querySelector('.main');

                this.main.addEventListener('scroll', (event) =>
                    this.lineNumbers.scrollTop = this.main.scrollTop);

                this.main.addEventListener('input', (event) => this.updateLineNumbers());
                this.title = title;

                this.node.querySelector('.comment').addEventListener('click',
                    (event) => {
                        this.comment();
                        this.main.focus();
                    });
                this.node.querySelector('.uncomment').addEventListener('click',
                    (event) => {
                        this.uncomment();
                        this.main.focus();
                    });
                this.node.querySelector('.indent').addEventListener('click',
                    (event) => {
                        this.indent();
                        this.main.focus();
                    });
                this.node.querySelector('.unindent').addEventListener('click',
                    (event) => {
                        this.unindent();
                        this.main.focus();
                    });
                this.main.addEventListener('keydown', (event) => {
                    if (event.key === 'Tab') {
                        event.preventDefault();
                        if (this.main.selectionStart === this.main.selectionEnd) {
                            const cursor = this.main.selectionStart;
                            this.main.value = this.main.value.slice(0, cursor) + '\t' +
                                this.main.value.slice(cursor);
                            this.main.selectionEnd = this.main.selectionStart = cursor + 1;
                        } else {
                            if (event.shiftKey) {
                                this.unindent();
                            } else {
                                this.indent();
                            }
                        }
                    }
                    if (event.key === 'Enter' && event.shiftKey) {
                        event.preventDefault();
                        const text = this.main.value;
                        const start = this.main.selectionStart;
                        const end = this.main.selectionEnd;
                        const expr = text.slice(start, end);
                        if (expr) {
                            try {
                                const result = new Function(`return ${expr}`)();
                                this.main.value = text.slice(0, start) + result + text.slice(end);
                                this.main.selectionStart = start;
                                this.main.selectionEnd = start + (result + '').length;
                            } catch (err) {
                                error(err.toString());
                            }
                        }
                    }
                });
                this.updateLineNumbers();
            }
            updateLineNumbers() {
                const count = this.main.value.split(/\n/g).length;
                this.lineNumbers.value = '';
                const numbers = Array(count).fill(0).map((e, i) => i + 1);
                this.lineNumbers.value = numbers.join('\r\n');
                this.lineNumbers.cols = 1 + (count + '').length;
            }
            get value() {
                return this.main.value;
            }
            set value(text) {
                this.main.value = text;
                this.updateLineNumbers();
            }
            modifySelection(modify) {
                const text = this.value;
                const lines = text.split(/\r?\n/);
                const start = this.main.selectionStart;
                const end = this.main.selectionEnd;
                const firstLine = text.slice(0, start).split(/\n/).length - 1;
                const lastLine = text.slice(0, end).split(/\n/).length;

                lines.splice(firstLine, lastLine - firstLine, ...lines.slice(firstLine, lastLine).map(modify));

                this.value = lines.join('\r\n');
                this.main.selectionStart = start + 2;
                this.main.selectionEnd = end + (lastLine - firstLine) * 2;

            }
            /**
             * Add a comment marker to the start of each line of the selected text
             */
            comment() {
                const comment = this.config.comment || '#';
                this.modifySelection((line) => `${comment} ${line}`);
            }
            /**
             * Remove comment from the selected text
             */
            uncomment() {
                this.modifySelection((line) => line.replace(/^(?<indent>\s*)(#|\/\/) ?/, '$<indent>'));
            }
            /**
             * Indent the selected text
             */
            indent() {
                const indent = this.config.indent || '    ';
                this.modifySelection((line) => `${indent}${line}`);
            }
            /**
             * Remove indent from the selected text
             */
            unindent() {
                this.modifySelection((line) =>
                    line.charAt(0) === '\t' ? line.slice(1) : line.replace(/^ {1,4}/, ''));
            }
        }

        /**
         * Specialisation of Editor for editing the structure
         */
        class StructureEditor extends Editor {
            constructor(title, configuration) {
                super(title, configuration);
                this.value = Core.source;
                this.main.addEventListener('change', (event) => {
                    Core.source = this.value;
                });

                this.main.addEventListener('input', (event) => {
                    try {
                        localStorage.setItem('current_source', this.value);
                    } catch (err) {
                        error(err);
                    }

                    if (document.getElementById('interactive-update').checked) {
                        Core.source = this.value;
                    }
                    updateLineNumbers(this.main, this.lineNumbers);
                });
                const spellcheck = this.node.querySelector('.spell-check');
                spellcheck.addEventListener('change', (event) => {
                    this.main.spellcheck = spellcheck.checked;
                    this.main.focus();
                });
            }
            set source(source) {
                this.value = source;
            }
            set currentNode(node) {
                // Show the source node.
                if (!(document.activeElement === this.main) && node && node[symbols.source]) {
                    const lines = this.value.split(/\r?\n/);
                    const position = this.main.scrollHeight * (node[symbols.source][0].lineNumber - 1) / lines.length;
                    this.main.focus();
                    this.main.scrollTo(0, position);
                    const start = lines.slice(0, node[symbols.source][0].lineNumber - 1).reduce((total, line) => total + line.length + 1, 0);
                    this.main.selectionStart = start;
                    this.main.selectionEnd = start + lines[node[symbols.source][0].lineNumber - 1].length;
                }
            }
        }

        /**
         * Specialisation of Editor for editing shaders
         */
        class ShaderEditor extends Editor {
            static settingsMap = {
                name: '.shader-name',
            }
            constructor(title, configuration) {
                super(title, { comment: '//' }, ShaderEditor.settingsMap);
                this.settings.name.addEventListener('change', (event) => {
                    const name = this.settings.name.value;
                    this.shader = shaderObjects.find((shader) => shader.name === name);
                    this.value = this.shader.source;
                });
            }
        }

        function glTypeName(gl, type) {
            const types = [];
            types[gl.FLOAT] = 'gl.FLOAT';
            types[gl.FLOAT_VEC2] = 'gl.FLOAT_VEC2';
            types[gl.FLOAT_VEC3] = 'gl.FLOAT_VEC3';
            types[gl.FLOAT_VEC4] = 'gl.FLOAT_VEC4';
            types[gl.INT] = 'gl.INT';
            types[gl.INT_VEC2] = 'gl.INT_VEC2';
            types[gl.INT_VEC3] = 'gl.INT_VEC3';
            types[gl.INT_VEC4] = 'gl.INT_VEC4';
            types[gl.BOOL] = 'gl.BOOL';
            types[gl.BOOL_VEC2] = 'gl.BOOL_VEC2';
            types[gl.BOOL_VEC3] = 'gl.BOOL_VEC3';
            types[gl.BOOL_VEC4] = 'gl.BOOL_VEC4';
            types[gl.FLOAT_MAT2] = 'gl.FLOAT_MAT2';
            types[gl.FLOAT_MAT3] = 'gl.FLOAT_MAT3';
            types[gl.FLOAT_MAT4] = 'gl.FLOAT_MAT4';
            types[gl.SAMPLER_2D] = 'gl.SAMPLER_2D';
            types[gl.SAMPLER_CUBE] = 'gl.SAMPLER_CUBE';
            return types[type];

            /*
            When using a WebGL 2 context, the following values are possible additionally:
            gl.UNSIGNED_INT
            gl.UNSIGNED_INT_VEC2
            gl.UNSIGNED_INT_VEC3
            gl.UNSIGNED_INT_VEC4
            gl.FLOAT_MAT2x3
            gl.FLOAT_MAT2x4
            gl.FLOAT_MAT3x2
            gl.FLOAT_MAT3x4
            gl.FLOAT_MAT4x2
            gl.FLOAT_MAT4x3
            gl.SAMPLER_3D
            gl.SAMPLER_2D_SHADOW
            gl.SAMPLER_2D_ARRAY
            gl.SAMPLER_2D_ARRAY_SHADOW
            gl.SAMPLER_CUBE_SHADOW
            gl.INT_SAMPLER_2D
            gl.INT_SAMPLER_3D
            gl.INT_SAMPLER_CUBE
            gl.INT_SAMPLER_2D_ARRAY
            gl.UNSIGNED_INT_SAMPLER_2D
            gl.UNSIGNED_INT_SAMPLER_3D
            gl.UNSIGNED_INT_SAMPLER_CUBE
            gl.UNSIGNED_INT_SAMPLER_2D_ARRAY
            */
        }


        /**
         * Specialisation of Editor for editing shaders
         */
        class ProgramEditor extends View {
            static nodeMap = {
                name: '.program-name',
                viewSelection: '.gl-view-selection',
                vertexShader: '.vertex-shader',
                fragmentShader: '.fragment-shader',
                update: '.update',
                uniforms: '.uniforms',
            }
            constructor(title, configuration) {
                super('shader-program-editor-template');
                this.uniforms = {};

                this.getNodes(ProgramEditor.nodeMap);

                this.setOptions();
                this.nodes.vertexShader.addEventListener('change', (event) =>
                    this.vertexShader = shaderObjects.find((shader) =>
                        shader.name === this.nodes.vertexShader.value && shader.type === 'vertex'));

                this.nodes.fragmentShader.addEventListener('change', (event) =>
                    this.fragmentShader = shaderObjects.find((shader) =>
                        shader.name === this.nodes.fragmentShader.value && shader.type === 'fragment'));

                this.nodes.update.addEventListener('click', (event) =>
                    this.updateUniforms());

                this.updateViewSelection();
                this.view = Core.views.find((view) => view.constructor.name === 'GLView');
            }
            updateViewSelection() {
                const views = Core.views.filter((view) => view.constructor.name === 'GLView');
                views.forEach((view, index) => {
                    const option = document.createElement('option');
                    option.innerText = view.title || `GL View ${index + 1}`;
                    option.value = index;
                    this.nodes.viewSelection.append(option);
                });
                this.nodes.viewSelection.addEventListener('change', (event) =>
                    this.view = views[this.nodes.viewSelection.value]);
            }
            setOptions() {
                shaderObjects.forEach((shader) => {
                    const option = document.createElement('option');
                    option.innerText = shader.title || shader.name;
                    option.value = shader.name;
                    if (shader.type === 'vertex') {
                        this.nodes.vertexShader.append(option);
                    } else {
                        this.nodes.fragmentShader.append(option);
                    }
                });
                this.vertexShader = shaderObjects.find((shader) => shader.type === 'vertex');
                this.fragmentShader = shaderObjects.find((shader) => shader.type === 'fragment');
            }
            updateUniforms() {
                if (this.view && this.vertexShader && this.fragmentShader) {
                    const context = this.view.context;
                    this.program = initialiseShaders(context, this.vertexShader.source, this.fragmentShader.source);
                    const numUniforms = context.getProgramParameter(this.program, context.ACTIVE_UNIFORMS);
                    this.nodes.uniforms.innerHTML = `
                    <table>
                      <thead>
                        <tr>
                          <th rowspan="2">Name</th>
                          <th rowspan="2">Type</th>
                          <th colspan="3">Mapping</th>
                        </tr>
                        <tr><th>Scene</th><th>Node</th><th>Shape</th></tr>
                      </thead>
                      <tbody></tbody>
                    </table>`;
                    const table = this.nodes.uniforms.querySelector('table');
                    const body = this.nodes.uniforms.querySelector('tbody');
                    const makeInputCell = (name, type) => {
                        const cell = document.createElement('td');
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.setAttribute('list', `${type}-parameters`);
                        input.value = this.uniforms[name][type] || '';
                        input.addEventListener('input', (event) =>
                            this.uniforms[name][type] = input.value);
                        cell.append(input);
                        return cell;
                    };

                    for (let i = 0; i < numUniforms; ++i) {
                        const row = document.createElement('tr');
                        const info = context.getActiveUniform(this.program, i);
                        this.uniforms[info.name] = this.uniforms[info.name] || {};
                        row.innerHTML = `<td>${info.name}</td><td>${glTypeName(context, info.type)}</td>`;
                        let cell = document.createElement('cell');
                        const scene = document.createElement('input');
                        row.append(makeInputCell(info.name, 'scene'));
                        row.append(makeInputCell(info.name, 'node'));
                        row.append(makeInputCell(info.name, 'shape'));
                        body.append(row);
                    }
                }
            }
        }


        /**
         * Split text into lines based on the given width
         */
        function fitText(text, width, measure, split = /(\s+)/) {
            const lines = [];
            const parts = text.split(/(\s+)/).filter((i) => i);
            if (width < measure('W')) {
                return [text.trim()];
            }
            let count;
            while (parts.length) {
                count = 2;
                while ((count <= parts.length) && (measure(parts.slice(0, count)) < width)) {
                    ++count;
                }
                --count;
                if ((count === 1) && (measure(parts[0]) > length) && (split !== '')) {
                    lines.push(...fitText(parts[0], width, measure, ''));
                    parts.shift();
                } else {
                    lines.push(parts.splice(0, count).join('').trim());
                }
            }
            return lines.filter((line) => line.trim());
        }


        /**
         * Diagram class
         */
        class DiagramView extends View {
            static settingsMap = {

            }
            constructor() {
                super('diagram-view-template');
                this.title = 'Diagram';
                this.transform = [1, 0, 0, 1, 0, 0];
                this.canvas = this.node.querySelector('.diagram');
                this.context = this.canvas.getContext('2d');
                this.context.setTransform(1, 0, 0, 1, 0, 0);
                this.content = [];
                this.addControls();
                this.structure = Core.structure;
            }
            set structure(structure) {
                this.content = [];
                const actions = {
                    rect: (contxt, [x, y, w, h]) => (context) => context.strokeRect(x, y, w, h),
                    path: (context, d) => {
                        const path = new Path2D(d);
                        return (context) => context.stroke(path);
                    },
                    text: (context, [text, x, y, width, lineHeight]) => {
                        let lines;

                        if (width) {
                            lines = fitText(text, width, (text) => context.measureText(text).width);
                            lineHeight = lineHeight || Math.max(...lines.map((line) => {
                                const metrics = context.measureText(text);
                                return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            }));
                        } else {
                            lines = [text];
                            context.fillText(text, x || 0, y || 0);
                        }
                        return (context) => {
                            let tx = x || 0;
                            let ty = y || 0;
                            lines.forEach((line) => {
                                context.fillText(line, tx, ty);
                                ty += lineHeight;
                            });
                        }
                    },
                    pie: (context, [radius, sort], nodes) => {
                        if (radius && nodes.length) {
                            nodes = nodes.filter((node) => node[symbols.value]);
                            const total = nodes.reduce((sum, node) => sum += node[symbols.value] || 0, 0);
                            let angle = -Math.PI / 2;
                            if (sort) {
                                nodes.sort((a, b) => b[symbols.value] - a[symbols.value]);
                            }
                            const segments = nodes.map((node) => {
                                const span = 2 * node[symbols.value] * Math.PI / total;
                                const path = new Path2D();
                                path.moveTo(0, 0);
                                path.arc(0, 0, radius, angle, angle + span);
                                path.lineTo(0, 0);
                                angle += span;
                                return {
                                    path, fill: `hsl(${angle}rad 50% 50%)`, label: node.name,
                                }
                            });
                            const lineHeight = Math.max(...segments.map((segment) => {
                                const metrics = context.measureText(segment.label);
                                return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            }));
                            return (context) => {
                                let y = lineHeight - radius;
                                segments.forEach((segment) => {
                                    context.fillStyle = segment.fill;
                                    context.fill(segment.path);
                                    context.stroke(segment.path);
                                    context.fillText(segment.label, 5 + radius, y);
                                    y += lineHeight;
                                });
                            };
                        }
                    },
                    xy: (context, [width, height, sort, xOrigin, yOrigin], nodes) => {
                        width = validateNumber(width, 100);
                        height = validateNumber(height, 100);
                        if (nodes.length) {
                            nodes = nodes.filter((node) => (node.x !== undefined) && (node.y !== undefined));
                            const xMin = xOrigin === '*' ? Math.min(...nodes.map((node) => node.x)) : (xOrigin || 0);
                            const xMax = Math.max(...nodes.map((node) => node.x));
                            const yMin = yOrigin === '*' ? Math.min(...nodes.map((node) => node.y)) : (yOrigin || 0);
                            const yMax = Math.max(...nodes.map((node) => node.y));

                            if (sort) {
                                nodes.sort((a, b) => a.x - b.x);
                            }
                            const points = nodes.map((node) => ({
                                label: name,
                                source: node,
                                x: width * (node.x - xMin) / (xMax - xMin),
                                y: height * (1 - ((node.y - yMin) / (yMax - yMin))),
                            }));

                            return (context) => {
                                context.strokeStyle = 'black';
                                context.beginPath();
                                context.moveTo(0, 0);
                                context.lineTo(0, height);
                                context.lineTo(width, height);
                                context.stroke();
                                context.strokeStyle = 'red';
                                if (points.length) {
                                    context.beginPath();
                                    context.moveTo(points[0].x, points[0].y);
                                    points.forEach((point) => context.lineTo(point.x, point.y));
                                    context.stroke();
                                }
                            };
                        }
                    },
                    line: (context, [width, height, sort], nodes) => {
                        if (width, height) {
                            const blockWidth = width / nodes.length;
                            nodes = nodes.filter((node) => node[symbols.value]);
                            const max = Math.max(...nodes.map((node) => node[symbols.value]));
                            if (sort) {
                                nodes.sort((a, b) => b[symbols.value] - a[symbols.value]);
                            }
                            const points = nodes.map((node, i) => ({
                                fill: `hsl(${2 * Math.PI * i / nodes.length}rad 50% 50%)`,
                                label: name,
                                x: (i + 0.5) * blockWidth, y: height * (1 - node[symbols.value] / max),
                                width: blockWidth, height: height * node[symbols.value] / max,
                            }));
                            return (context) => {
                                context.strokeStyle = 'red';
                                context.beginPath();
                                context.moveTo(points[0].x, points[0].y);
                                points.forEach((point) => context.lineTo(point.x, point.y));
                                context.stroke();
                            };
                        }
                    },
                    histogram: (context, [width, height, sort], nodes) => {
                        if (width, height) {
                            const blockWidth = width / nodes.length;
                            nodes = nodes.filter((node) => node[symbols.value]);
                            const max = Math.max(...nodes.map((node) => node[symbols.value]));
                            if (sort) {
                                nodes.sort((a, b) => b[symbols.value] - a[symbols.value]);
                            }
                            const blocks = nodes.map((node, i) => ({
                                fill: `hsl(${2 * Math.PI * i / nodes.length}rad 50% 50%)`,
                                label: node.name,
                                x: i * blockWidth, y: height * (1 - node[symbols.value] / max),
                                width: blockWidth, height: height * node[symbols.value] / max,
                            }));
                            const lineHeight = Math.max(...blocks.map((block) => {
                                const metrics = context.measureText(block.label);
                                return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            }));
                            return (context) => {
                                context.textAlign = "end";
                                context.textBaseline = "middle";
                                blocks.forEach((block) => {
                                    context.fillStyle = block.fill;
                                    context.fillRect(block.x, block.y, block.width, block.height);
                                    context.strokeRect(block.x, block.y, block.width, block.height);
                                    context.rotate(-Math.PI / 2);
                                    context.fillText(block.label, -height - lineHeight / 2, block.x + block.width / 2);
                                    context.rotate(Math.PI / 2);
                                });
                            };
                        }
                    },
                }
                const stateChange = {
                    stoke: (colour) => (context) => context.strokeStyle = colour,
                    fill: (colour) => (context) => context.fillStyle = colour,
                    font: (font) => (context) => context.font = font,
                }
                const stack = [this];
                const processNode = (node) => {
                    let childParser = processNode;
                    let finalisation;
                    const children = [];
                    let pop = false;
                    if (node[symbols.views] && node[symbols.views]['diagram']) {
                        const item = {
                            actions: [],
                            content: [],
                        };
                        stack[0].content.push(item);
                        stack.unshift(item);
                        pop = true;
                        Object.entries(node[symbols.views]['diagram']).forEach(([key, value]) => {
                            value = value || [];
                            if (actions[key]) {
                                const action = actions[key](this.context, [value].flatMap((v) => v), node[symbols.content]);
                                if (action) {
                                    item.actions.push(action);
                                }
                            } else if (stateChange[key]) {
                                const change = stateChange[key](value);
                                if (change) {
                                    change(this.context);
                                    item.actions.unshift(change);
                                }
                            } else if (key === 'position' && Array.isArray(value)) {
                                item.transform = [1, 0, 0, 1, ...value];
                            } else if (key === 'transform') {
                                item.transform = [...value];
                            }
                        });
                    }
                    if (node[symbols.content]) {
                        node[symbols.content].forEach((node) => processNode(node));
                    }
                    if (pop) {
                        stack.shift();
                    }
                }
                structure.forEach((node) => processNode(node));
            }
            addControls() {
                const last = {};
                let action;
                const drag = (event, x, y) => {
                    const dx = x - last.x;
                    const dy = y - last.y;

                    this.context.transform(1, 0, 0, 1, dx, dy);

                    last.x = x;
                    last.y = y;
                };
                const transform = (event, x, y) => {
                    const c = this.context.getTransform();
                    const m = [c.a, c.b, c.e, c.c, c.d, c.f, 0, 0, 1];
                    const t = c.inverse();
                    const inverse = [t.a, t.b, t.e, t.c, t.d, t.f, 0, 0, 1];

                    const box = this.canvas.getBoundingClientRect();

                    if (event.touches.length === 2) {
                        const p1 = { x: last.x - box.x, y: last.y - box.y };
                        const p2 = { x: last.second.x - box.x, y: last.second.y - box.y };
                        const q1 = { x: event.touches[0].clientX - box.x, y: event.touches[0].clientY - box.y };
                        const q2 = { x: event.touches[1].clientX - box.x, y: event.touches[1].clientY - box.y };

                        const v1 = { x: p2.x - p1.x, y: p2.y - p1.y };
                        const v2 = { x: q2.x - q1.x, y: q2.y - q1.y };

                        const l2 = v1.x * v1.x + v1.y * v1.y;
                        const scaledCosAngle = (v2.x * v1.x + v1.y * v2.y) / l2;
                        const scaledSinAngle = (v1.x * v2.y - v1.y * v2.x) / l2;
                        const tx = (v1.x * (q1.x * p2.x - p1.x * q2.x) + v1.y * (q1.x * p2.y - q2.x * p1.y) + v2.y * (p2.x * p1.y - p1.x * p2.y)) / l2;
                        const ty = (v2.x * (p1.x * p2.y - p2.x * p1.y) + v1.y * (q1.y * p2.y - q2.y * p1.y) + v1.x * (q1.y * p2.x - q2.y * p1.x)) / l2;

                        const transform = matrixMultiply3x3([
                            scaledCosAngle, scaledSinAngle, tx,
                            -scaledSinAngle, scaledCosAngle, ty,
                            0, 0, 1], last.transform);

                        this.context.setTransform(
                            transform[0], transform[1], transform[3], transform[4], transform[2], transform[5]);
                    }
                };
                this.canvas.addEventListener('touchstart', (event) => {
                    last.x = event.touches[0].clientX;
                    last.y = event.touches[0].clientY;
                    const before = this.context.getTransform();
                    last.transform = [
                        before.a, before.b, before.e,
                        before.c, before.d, before.f,
                        0, 0, 1];

                    if (event.touches.length === 1) {
                        action = drag;
                    } else if (event.touches.length === 2) {
                        event.preventDefault();
                        last.second = {
                            x: event.touches[1].clientX,
                            y: event.touches[1].clientY,
                        };
                        action = transform;
                    }
                });

                this.canvas.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    if (action) {
                        action(event, event.touches[0].clientX, event.touches[0].clientY);
                    }
                });

                this.canvas.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    action = null;
                });

                this.canvas.addEventListener('mousedown', (event) => {
                    event.preventDefault();
                    last.x = event.clientX;
                    last.y = event.clientY;
                    action = drag;
                });

                this.canvas.addEventListener('mousemove', (event) => {
                    event.preventDefault();
                    if (action) {
                        action(event, event.clientX, event.clientY);
                    }
                });

                this.canvas.addEventListener('mouseup', (event) => {
                    event.preventDefault();
                    action = null;
                });

                this.canvas.addEventListener('wheel', (event) => {
                    const delta = Math.pow(2, event.deltaY / 1000);
                    const transform = this.context.getTransform();
                    transform.a *= delta;
                    transform.b *= delta;
                    transform.c *= delta;
                    transform.d *= delta;
                    this.context.setTransform(
                        transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
                });

                this.canvas.addEventListener('keydown', (event) => {
                    report(event.key);
                    event.preventDefault();
                    const scale = event.ctrlKey ? 0.1 : 1;
                    if (event.key === 'u') {
                        view.camera.up = [0, 1, 0];
                    }
                    if (event.key === 'ArrowUp') {
                    }
                    if (event.key === 'ArrowDown') {
                    }
                    if (event.key === 'ArrowLeft') {
                    }
                    if (event.key === 'ArrowRight') {
                    }
                });
            }
            update(time) {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;

                if (this.canvas.width != width || this.canvas.height != height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }

                this.context.save();
                this.context.setTransform(1, 0, 0, 1, 0, 0);
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.context.restore();

                this.context.fillStyle = 'black';
                this.context.strokeStyle = 'black';

                const draw = (node) => {
                    if (node.transform && node.transform.length === 6) {
                        this.context.save();
                        this.context.transform(...node.transform);
                    }
                    node.actions.forEach((action) => action(this.context));
                    node.content.forEach((item) => draw(item));
                    if (node.transform) {
                        this.context.restore();
                    }
                }
                this.content.forEach((item) => draw(item));
            }
        }

        /**
         * GLView component
         */
        class GLView extends View {
            static settingsMap = {
                split: '.split',
                move: '.move',
                reset: '.reset',
                upright: '.upright',
                depthTest: '.depth-test',
                minLevel: '.min-level',
                levels: '.levels',
                far: '.far',
                stepSize: '.step-size',
            };
            constructor(title = '3D Scene', camera, shaders = defaultShaders) {
                super('gl-view-template', GLView.settingsMap);
                // Add to the DOM so that safari can get context
                document.body.append(this.node);
                this.canvas = this.node.querySelector('.scene');
                this.textureCanvas = this.node.querySelector('.texture');

                this.shapes = [];
                this.textures = [];
                this.points = [];
                this.lines = [];
                this.graph = [];
                this.nodes = [];
                this.overlays = [];
                this.events = [];
                this.activeEvents = [];
                this.lightPosition = [-75, -90, 0];
                this.data = {
                    vertex: [],
                    indices: [],
                };
                this.gl = this.context;
                if (this.gl.getSupportedExtensions().indexOf('EXT_frag_depth')) {
                    this.gl.getExtension('EXT_frag_depth');
                };

                this.textureContext = this.textureCanvas.getContext('2d');
                this.textureCanvas.width = 500;
                this.textureCanvas.height = 1500;
                this.textureContext.width = 500;
                this.textureContext.height = 1500;
                this.nextLine = 0;

                this.title = title;
                //this.camera = camera || new Camera([14.638, -0.074, 27.731], [6.762, 1.357, 7.673], [0, 1, 0]);
                this.camera = camera || new Camera([0, 55000, 40000], [0, 0, 10000], [0, 1, 0]);
                this.background = [1, 1, 1, 1];
                this.setShaders(shaders);

                const lightX = this.node.querySelector('.light-x');
                const lightY = this.node.querySelector('.light-y');
                const lightZ = this.node.querySelector('.light-z');

                lightX.value = -75;
                lightY.value = -90;
                lightZ.value = 0;

                lightX.addEventListener('input', (event) =>
                    this.lightPosition[0] = lightX.value);
                lightY.addEventListener('input', (event) =>
                    this.lightPosition[1] = lightY.value);
                lightZ.addEventListener('input', (event) =>
                    this.lightPosition[2] = lightZ.value);

                addControls(this.canvas, this);

                this.vertexBuffer = this.context.createBuffer();
                this.indexBuffer = this.context.createBuffer();

                this.settings.reset.addEventListener('click', () => {
                    this.camera.reset();
                    this.canvas.focus();
                    document.body.style.backgroundColour = 'pink';
                });

                this.settings.upright.addEventListener('click', () => {
                    this.camera.up = [0, 1, 0];
                    updateCamera(this.camera.getString());
                    this.canvas.focus();
                });
                this.structure = Core.structure;
            }
            get context() {
                return this.canvas.getContext('webgl');
            }
            setShaders(shaders) {
                this.shaders = shaders.reduce((shaders, definition) => {
                    shaders[definition.name] = makeShader(definition, this.context);
                    return shaders;
                }, {});
                glErrors(this.context, `${this.title} setShaders`);
            }
            get structure() {
                return this._structure || [];
            }
            set structure(structure = []) {
                this._structure = structure;
                this.textures.forEach((texture) => this.context.deleteTexture(texture.texture));
                this.textTexture = null;
                this.textures = [];
                this.textureContext.clearRect(0, 0, this.textureCanvas.width, this.textureCanvas.height);
                this.nextLine = 0;
                getGraph(this._structure, this);
            }
            set currentNode(node) {
                this._structure = node ? [node] : Core.structure;
                this.textures.forEach((texture) => this.context.deleteTexture(texture.texture));
                this.textTexture = null;
                this.textures = [];
                this.textureContext.clearRect(0, 0, this.textureCanvas.width, this.textureCanvas.height);
                this.nextLine = 0;
                getGraph(this._structure, this);
            }
            addText(text, colour = 'black', font = '24px sans-serif') {
                const width = this.textureCanvas.width;
                const height = this.textureCanvas.height;
                /*
                this.textureContext.fillStyle = 'purple';
                this.textureContext.fillRect(0, 0, width, height);
                */
                this.textureContext.fillStyle = colour;
                this.textureContext.font = font;
                this.textureContext.textBaseline = 'hanging';
                this.textureContext.fillText(text, 0, this.nextLine);
                this.copyTexture(this.textureCanvas);
                const metrics = this.textureContext.measureText(text);
                const pos = this.nextLine;
                this.nextLine += metrics.fontBoundingBoxDescent - metrics.fontBoundingBoxAscent;

                return [{ x: 0, y: (pos + metrics.fontBoundingBoxDescent - metrics.fontBoundingBoxAscent) / height },
                { x: metrics.width / width, y: pos / height },
                metrics.width / (metrics.fontBoundingBoxDescent - metrics.fontBoundingBoxAscent)];
            }
            /**
             * Initialise a texture and copy an image from the specified canvas.
             * When the image finished loading copy it into the texture.
             */
            copyTexture(source) {
                const gl = this.context;
                this.textTexture = this.textTexture ?? gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.textTexture);

                const internalFormat = gl.RGBA;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;

                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, srcFormat, srcType, source);

                // WebGL1 has different requirements for power of 2 images
                // vs non power of 2 images so check if the image is a
                // power of 2 in both dimensions.
                if (isPowerOf2(source.width) && isPowerOf2(source.height)) {
                    // Yes, it's a power of 2. Generate mips.
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    // No, it's not a power of 2. Turn of mips and set
                    // wrapping to clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
                glErrors(gl, 'Load Texture');
            }
            updateBuffers(data) {
                const gl = this.context;

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertex), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data.indices), gl.STATIC_DRAW);
                glErrors(this.context, `${this.title} updateBuffers`);
            }
            /**
             * Initialize a texture and load an image.
             * When the image finished loading copy it into the texture.
             */
            loadTexture(url) {
                const gl = this.context;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                // Because images have to be downloaded over the internet
                // they might take a moment until they are ready.
                // Until then put a single pixel in the texture so we can
                // use it immediately. When the image has finished downloading
                // we'll update the texture with the contents of the image.
                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    level,
                    internalFormat,
                    width,
                    height,
                    border,
                    srcFormat,
                    srcType,
                    pixel,
                );

                const image = new Image();
                image.onload = () => {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(
                        gl.TEXTURE_2D,
                        level,
                        internalFormat,
                        srcFormat,
                        srcType,
                        image,
                    );

                    // WebGL1 has different requirements for power of 2 images
                    // vs. non power of 2 images so check if the image is a
                    // power of 2 in both dimensions.
                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                        // Yes, it's a power of 2. Generate mips.
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        // No, it's not a power of 2. Turn off mips and set
                        // wrapping to clamp to edge
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    }
                };
                image.src = url;

                return texture;
            }

            /**
             * Add a texture to the library
             */
            getTexture(url) {
                const current = this.textures.find((texture) => texture.url === url);
                if (!current) {
                    this.textures.push({ url, texture: this.loadTexture(url) });
                }
                return current;
            }

            /**
             * 
             */
            bindTextures() {
                this.context.activeTexture(this.context.TEXTURE0);
                this.context.bindTexture(this.context.TEXTURE_2D, this.textTexture);
                this.textures.forEach((texture, index) => {
                    // Tell WebGL we want to affect texture unit 0
                    this.context.activeTexture(this.context.TEXTURE1 + index);

                    // Bind the texture to texture unit 0
                    this.context.bindTexture(this.context.TEXTURE_2D, texture.texture);

                    // Tell the shader we bound the texture to texture unit 0
                    //gl.uniform1i(programInfo.uniformLocations.uSampler, index);
                });
            }
            focus() {
                this.canvas.focus();
            }
            updateSize() {
                // Lookup the size the browser is displaying the canvas in CSS pixels.
                const box = this.canvas.getBoundingClientRect();

                const width = box.width;
                const height = box.height;

                // Check if the canvas is not the same size.
                const resize = this.canvas.width !== width || this.canvas.height !== height;

                if (resize) {
                    // Make the canvas the same size
                    this.canvas.width = width;
                    this.canvas.height = height;

                    this.context.viewport(0, 0, width, height);
                }

                return resize;
            }
            initialiseShader(shader, projectionMatrix) {
                const context = this.context;
                const numComponents = 3;
                const type = context.FLOAT;    // the data in the buffer is 32bit floats
                const normalize = false;  // don't normalize
                const stride = 4 * (3 + 3 + 2);
                /*
                    (shader.attribLocations.vertexNormal ? 3 : 0) +
                    (shader.attribLocations.vertexTexture ? 2 : 0) + 
                    (shader.attribLocations.offset ? 2 : 0));         // how many bytes to get from one set of values to the next
                // 0 = use type and numComponents above
                //*/

                const offset = 0;         // how many bytes inside the buffer to start from
                context.useProgram(shader.program);
                context.bindBuffer(context.ARRAY_BUFFER, this.vertexBuffer);

                context.vertexAttribPointer(
                    shader.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                context.enableVertexAttribArray(shader.attribLocations.vertexPosition);

                if (shader.attribLocations.vertexNormal) {
                    context.vertexAttribPointer(
                        shader.attribLocations.vertexNormal,
                        numComponents,
                        type,
                        true,  // normalise normals
                        stride,
                        4 * 3);
                    context.enableVertexAttribArray(shader.attribLocations.vertexNormal);
                }

                if (shader.attribLocations.vertexTexture) {
                    context.vertexAttribPointer(
                        shader.attribLocations.vertexTexture,
                        2,     // numcomponents
                        type,
                        normalize,
                        stride,
                        4 * (3 + 3));
                    context.enableVertexAttribArray(shader.attribLocations.vertexTexture);
                }
                if (shader.attribLocations.offset) {
                    context.vertexAttribPointer(
                        shader.attribLocations.offset,
                        2,     // numcomponents
                        type,
                        normalize,
                        stride,
                        4 * (3 + 3 + 2));
                    context.enableVertexAttribArray(shader.attribLocations.offset);
                }

                shader.setSceneData(this);

                glErrors(this.context, `${this.title} initialiseShaders`);
            }
            update(time) {
                const gl = this.context;
                this.updateSize();

                this.modelViewMatrix = this.camera.viewMatrix();

                glErrors(gl, `${this.title} update 1`);
                // Create a perspective matrix, a special matrix that is
                // used to simulate the distortion of perspective in a camera.
                // Our field of view is 45 degrees, with a width/height
                // ratio that matches the display size of the canvas
                const fieldOfView = 45;   // in degrees
                const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                const zNear = 0.1;
                const zFar = parseFloat(this.settings.far.value);
                const projectionMatrix = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, -(zFar+zNear)/(zFar-zNear),
                0, 0, 0, 1,
            ];//perspective(fieldOfView, aspect, zNear, zFar);
                this.projectionMatrix = projectionMatrix;

                this.graph.forEach((node) => node.update(this, identityMatrix(), node, time));

                this.updateBuffers(this.data);

                glErrors(gl, `${this.title} update 2`);

                Object.values(this.shaders).forEach((shader) =>
                    this.initialiseShader(shader, projectionMatrix));

                glErrors(gl, `${this.title} update 2.5`);
                this.bindTextures();
                glErrors(gl, `${this.title} update 3`);
                gl.enable(gl.BLEND)
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                // Set clear colour to black, fully opaque
                gl.clearColor(...this.background);
                // Clear the colour buffer with specified clear colour

                glErrors(gl, `${this.title} update 4`);

                gl.clearDepth(1.0);                 // Clear everything
                if (this.settings.depthTest.checked) {
                    gl.enable(gl.DEPTH_TEST);           // Enable depth testing
                } else {
                    gl.disable(gl.DEPTH_TEST);           // Enable depth testing
                    this.graph.sort((a, b) => a.z - b.z);
                }
                gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
                glErrors(gl, `${this.title} update 5`);
                // Clear the canvas before we start drawing on it.

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                if (this.settings.split.checked) {
                    drawScene2(this, gl, this.structure, this.shaders, time);
                } else {
                    drawScene(this, gl, this.structure, time);
                }
                glErrors(gl, `${this.title} update 6`);

                if (this.overlays) {
                    this.overlays.forEach((overlay) => overlay.updateOverlay(projectionMatrix));
                }
                if (this.savePNG) {
                    savePNG(this.canvas);
                    this.savePNG = false;
                }
                glErrors(gl, `${this.title} update end`);
            }
        }

        /**
         * SVGView component
         */
        class SVGView extends View {
            static ns = 'http://www.w3.org/2000/svg';
            static namedArributes = Symbol('named attributes');
            static settingsMap = {
                rootNodes: '.root-nodes',
                filter: '.filter',
                context: '.context-selection',
                layout: '.layout',
                connectorStyle: '.connector-style',
                maxHorizontalNodes: '.max-horizontal-nodes',
                scrollToCurrent: '.scroll-to-current',
            }
            constructor(structure, title) {
                super('svg-view-template', SVGView.settingsMap);
                this.svg = this.node.querySelector('svg');
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
                this.title = title || 'SVG Diagram';
                this.structure = structure || Core.structure;
                this.addControls();
            }
            make(type, attributes, content, classes) {
                const element = document.createElementNS(SVGView.ns, type);
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);
                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                //this.node.appendChild(element);
                if (content) {
                    element.append(content);
                    //element.innerHTML = content;
                }
                if (classes) {
                    element.classList.add(...classes)
                }
                return element;
            }
            add(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.appendChild(element);
                return element;
            }
            addUnder(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.insertBefore(element, parent.firstElementChild);
                return element;
            }
            updateElement(element, attributes) {
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);

                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                return element
            }
            set contexts(contexts) {
                this.settings.context.innerHTML =
                    '<option value="" selected>None</option>';
                if (contexts) {
                    contexts.forEach((context) => {
                        const option = document.createElement('option');
                        option.innerText = context;
                        option.value = context;
                        this.settings.context.append(option);
                    });
                }
            }
            set structure(structure) {
                this.svg.innerHTML = '';
                this._structure = structure;
                this.render();
            }
            render() {
                // Use a handler to extract data from specified view
                const view = this.settings.view;

                const handler = {
                    get(target, prop, receiver) {
                        if (target[symbols.views][view]) {
                            if (target[symbols.views][view][prop] !== undefined) {
                                return target[symbols.views][view][prop];
                            }
                        }
                        return original[prop];
                    },
                };

                // Generate SVG nodes from structure
                const makeSVG = (node) => {
                    if (this._structure.includes(node)) {
                        return;
                    }
                    this.add(node.name, this.svg, node, node[symbols.content], []);
                    if (view) {
                        node = new Proxy(node, handler);
                    }
                };
                process(makeSVG, this.settings.rootNodes.value, this.settings.filter.value);
                const extents = {
                    left: 0,
                    top: 0,
                    right: 100,
                    bottom: 100,
                }
                this.svg.setAttribute('viewBox', `${extents.left} ${extents.top} ${extents.right} ${extents.bottom}`);
                this.svg.setAttribute('width', `${extents.right - extents.left}`);
                this.svg.setAttribute('height', `${extents.bottom - extents.top}`);

                this.svg.style.width = `${extents.right - extents.left}px`;
                this.svg.style.height = `${extents.bottom - extents.top}px`;
            }
            addControls() {
                const last = {};
                let action;
                const drag = (event, x, y) => {
                    const dx = x - last.x;
                    const dy = y - last.y;

                    const m = new DOMMatrix([1, 0, 0, 1, dx, dy]);
                    const t = m.multiply(initialMatrix);
                    const attrs = {
                        transform: `matrix(${t.a}, ${t.b}, ${t.c}, ${t.d}, ${t.e}, ${t.f})`,
                    };
                    this.updateElement(this.context, attrs);
                };
                let initialMatrix;
                const transform = (event, x, y) => {

                    const box = this.svg.getBoundingClientRect();

                    if (event.touches.length === 2) {
                        const p1 = { x: last.x - box.x, y: last.y - box.y };
                        const p2 = { x: last.second.x - box.x, y: last.second.y - box.y };
                        const q1 = { x: event.touches[0].clientX - box.x, y: event.touches[0].clientY - box.y };
                        const q2 = { x: event.touches[1].clientX - box.x, y: event.touches[1].clientY - box.y };

                        const v1 = { x: p2.x - p1.x, y: p2.y - p1.y };
                        const v2 = { x: q2.x - q1.x, y: q2.y - q1.y };

                        const l2 = v1.x * v1.x + v1.y * v1.y;
                        const scaledCosAngle = (v2.x * v1.x + v1.y * v2.y) / l2;
                        const scaledSinAngle = (v1.x * v2.y - v1.y * v2.x) / l2;
                        const tx = (v1.x * (q1.x * p2.x - p1.x * q2.x) + v1.y * (q1.x * p2.y - q2.x * p1.y) + v2.y * (p2.x * p1.y - p1.x * p2.y)) / l2;
                        const ty = (v2.x * (p1.x * p2.y - p2.x * p1.y) + v1.y * (q1.y * p2.y - q2.y * p1.y) + v1.x * (q1.y * p2.x - q2.y * p1.x)) / l2;

                        const m = new DOMMatrix([scaledCosAngle, scaledSinAngle, -scaledSinAngle, scaledCosAngle, tx, ty]);
                        const t = m.multiply(initialMatrix);
                        const attrs = {
                            transform: `matrix(${t.a}, ${t.b}, ${t.c}, ${t.d}, ${t.e}, ${t.f})`,
                        };
                        this.updateElement(this.context, attrs);
                    }
                };
                this.svg.addEventListener('touchstart', (event) => {
                    initialMatrix = this.context.getCTM();
                    last.x = event.touches[0].clientX;
                    last.y = event.touches[0].clientY;
                    const before = this.svg.getCTM();
                    last.transform = [
                        before.a, before.b, before.e,
                        before.c, before.d, before.f,
                        0, 0, 1];

                    if (event.touches.length === 1) {
                        action = drag;
                    } else if (event.touches.length === 2) {
                        event.preventDefault();
                        last.second = {
                            x: event.touches[1].clientX,
                            y: event.touches[1].clientY,
                        };
                        action = transform;
                    }
                });

                this.svg.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    if (action) {
                        action(event, event.touches[0].clientX, event.touches[0].clientY);
                    }
                });

                this.svg.addEventListener('touchend', (event) => {
                    action = null;
                });

                this.svg.addEventListener('mousedown', (event) => {
                    event.preventDefault();
                    initialMatrix = this.context.getCTM();
                    last.x = event.clientX;
                    last.y = event.clientY;
                    action = drag;
                });

                this.svg.addEventListener('mousemove', (event) => {
                    event.preventDefault();
                    if (action) {
                        action(event, event.clientX, event.clientY);
                    }
                });

                this.svg.addEventListener('mouseup', (event) => {
                    event.preventDefault();
                    action = null;
                });

                this.svg.addEventListener('wheel', (event) => {
                    if (event.ctrlKey) {
                        event.preventDefault();
                        // Determine the scaling factor
                        const delta = Math.pow(2, -event.deltaY / 1000);

                        // Get the point under the mouse
                        const point = new DOMPoint(event.clientX, event.clientY);
                        const initial = this.context.getCTM();
                        const origin = point.matrixTransform(initial.inverse().multiply(this.svg.getScreenCTM().inverse()));

                        const offset = initial.translate(origin.x, origin.y);
                        const scaled = offset.scale(delta);
                        const matrix = scaled.translate(-origin.x, -origin.y);

                        const attrs = {
                            transform: `matrix(${matrix.a}, ${matrix.b}, ${matrix.c}, ${matrix.d}, ${matrix.e}, ${matrix.f})`,
                        };
                        this.updateElement(this.context, attrs);
                    }
                });

                this.svg.addEventListener('keydown', (event) => {
                    report(event.key);
                    event.preventDefault();
                    const scale = event.ctrlKey ? 0.1 : 1;
                    if (event.key === 'u') {
                        view.camera.up = [0, 1, 0];
                    }
                    if (event.key === 'ArrowUp') {
                    }
                    if (event.key === 'ArrowDown') {
                    }
                    if (event.key === 'ArrowLeft') {
                    }
                    if (event.key === 'ArrowRight') {
                    }
                });
            }
        }

        /**
         * Get the SVG shape for a node.
         */
        function getSVGShape(node, view) {
            if (node) {
                const shapes = [SVGRect, SVGActivity, SVGMilestone, SVGStar, SVGText, SVGTimeline, SVGNetwork, SVGCircle, SVGEllipse, SVGParallelogram, SVGTrapezoid, SVGDiamond, SVGLink, SVG, SVGPie, SVGPlot, SVGChart, SVGHistogram, SVGNone];
                const shapeName = ((node[symbols.views][view.title]?.shape ?? node.shape) + '').toLowerCase();
                const layout = ((node[symbols.views][view.title]?.layout ?? node.layout) + '').toLowerCase();
                const shapeType = shapes.find((shape) => shape.name === shapeName) ?? (layout === 'grid' ? SVGText : SVGRect);
                return shapeType.make(view, node);
            }
            return new SVGNone(view);
        }

        /**
         * SVG Tree Diagram node types
         */
        class SVGShape {
            static clipCount = 0;
            static make(view, node) {
                return new this(view, node);
            }
            constructor(view, node) {
                this.view = view;
                this.node = node;
                this.fill = this.getData('fill') ?? 'white';
                this.stroke = this.getData('line') ?? 'black';
                this.leftEdge = [];
                this.rightEdge = [];
                this.x = 0;
                this.y = 0;
                this.box = { x: null, y: null };
                this.layout = this.getData('layout');
            }
            getData(property) {
                return this.node[symbols.views]?.[this.view.title]?.[property] ?? this.node?.[property];
            }
            viewData(property) {
                return this.node[symbols.viewData].get(this.view)?.[property];
            }
            get width() {
                return validateNumber(this.getData('width'), 100);
            }
            get height() {
                return validateNumber(this.getData('height'), 60);
            }
            get fontSize() {
                return validateNumber(this.getData('font size'), 10);
            }
            get lineHeight() {
                return this.fontSize * (validateNumber(this.getData('line spacing'), 1.4));
            }
            addContainer(parent) {
                const groupStyle = this.getData('group style');
                this.container = this.view.add('g', parent, typeof groupStyle === 'object' ? groupStyle : {});
                this.viewData('svgNodes').push(this.container);
                if (this.getData('layout') === 'grid') {
                    this.containerRect = this.view.add('rect', this.container);
                    this.containerRect.addEventListener('click', (event) => clickNode(this.node, event));
                    this.containerRect.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                    this.viewData('svgNodes').push(this.containerRect);
                }
                if (this.getData('title property')) {
                    const title = this.getData(this.getData('title property'));
                    if (title) {
                        this.view.add('title', this.container, {}, title);
                    }
                }
                return this.container;
            }
            drawContainer() {
                const attrs = {
                    x: 0,
                    y: 0,
                    width: this.box.width,
                    height: this.box.height,
                    stroke: this.stroke,
                    fill: this.fill,
                };
                const svgElement = this.view.updateElement(this.containerRect, attrs);
            }
            textOrigin() {
                const textAlignment = this.getData('text align') ?? 'middle';
                const verticalAlignment = this.getData('text vertical align') ?? 'middle';
                const origin = { x: this.x + this.width / 2, anchor: 'middle', y: this.y + this.height / 2, baseline: 'middle' };

                if (textAlignment === 'left') {
                    origin.x = this.x;
                    origin.anchor = 'start';
                } else if (textAlignment === 'outside left') {
                    origin.x = this.x;
                    origin.anchor = 'end';
                    origin.outside = true;
                } else if (textAlignment === 'right') {
                    origin.x = this.x + this.width;
                    origin.anchor = 'end';
                } else if (textAlignment === 'outside right') {
                    origin.x = this.x + this.width;
                    origin.anchor = 'start';
                    origin.outside = true;
                }
                if (verticalAlignment === 'top') {
                    origin.y = this.y;
                    origin.baseline = 'hanging';
                } else if (verticalAlignment === 'over') {
                    origin.y = this.y;
                    origin.baseline = 'auto';
                    origin.outside = true;
                } else if (verticalAlignment === 'bottom') {
                    origin.y = this.y + this.height;
                    origin.baseline = 'auto';
                } else if (verticalAlignment === 'under') {
                    origin.y = this.y + this.height;
                    origin.baseline = 'hanging';
                    origin.outside = true;
                }
                return origin;
            }
            addText(maxWidth) {
                const origin = this.textOrigin();

                maxWidth = maxWidth || this.width;
                const textAttrs = {
                    x: origin.x,
                    'font-size': `${this.fontSize}pt`,
                    'font-family': this.getData('font') ?? 'sans-serif',
                    'text-anchor': origin.anchor,
                    'dominant-baseline': origin.baseline,
                    fill: this.getData('text') ?? 'black',
                };

                if (0 && maxWidth) {
                    textAttrs.textLength = maxWidth;
                    textAttrs.lengthAdjust = 'spacingAndGlyphs';
                }

                const href = this.getData('href');
                const container = href ? this.view.add('a', this.container, { href }) : this.container;
                if (href) {
                    textAttrs.fill = this.getData('text') ?? 'blue';
                    textAttrs['text-decoration'] = 'underline';
                }

                const getLength = (text) => {
                    const node = this.view.add('text', this.container, textAttrs, text);
                    const length = node.getComputedTextLength();
                    node.remove();
                    return length;
                };

                const textWidth = this.getData('textWidth') ?? (maxWidth > (this.fontSize * 3) ? maxWidth : 60);
                const lines = fitText(this.view.configuration.nodeText(this.node) ?? '', textWidth, getLength);

                textAttrs.y = origin.y - (lines.length - 1) * this.lineHeight / 2;

                if (!origin.outside && maxWidth && this.height) {
                    const clipRect = this.view.make('rect', { x: this.x, y: this.y, width: this.width, height: this.height });
                    this.view.add('clipPath', container, { id: `clip${SVGShape.clipCount}` }, clipRect);
                    textAttrs['clip-path'] = `url(#clip${SVGShape.clipCount})`;
                }
                ++SVGShape.clipCount;

                const text = this.view.add('text', container, textAttrs)

                lines.forEach((line) => {
                    this.view.add('tspan', text, { x: origin.x, y: textAttrs.y }, line);
                    textAttrs.y += this.lineHeight;
                });
                return text;
            }
            drawLabel(text, x, y, colour='black', opacity=1, background='white', anchor='middle') {
                const back = this.view.add('rect', this.container, {
                    x, y: y - this.lineHeight / 2, height: this.lineHeight,
                    rx: this.lineHeight / 2,
                    stroke: colour, 'stroke-opacity': opacity,
                    fill: background, 'fill-opacity': opacity,
                });
                const tx = anchor === 'start' ? x + this.lineHeight * 0.4 : anchor === 'end' ? x - this.lineHeight * 0.4 : x;
                const textElement = this.view.add('text', this.container, {
                    x: tx, y,
                    'text-anchor': anchor, 'dominant-baseline': 'middle',
                    fill: colour, 'fill-opacity': opacity,
                    'font-family': this.getData('font') ?? 'sans-serif', 'font-size': `${this.fontSize * 0.8}pt`
                }, text);
                const width = textElement.getComputedTextLength() + 0.8 * this.lineHeight;
                const bx = anchor === 'start' ? label.x : anchor === 'end' ? x - width : x - width / 2;
                this.view.updateElement(back, { x: bx, width, });
                return [textElement, background];
            }
            merge(edge1, edge2, cmp) {
                const lerp = (line, point) => line[0].x + (line[1].x - line[0].x) *
                    (point.y - line[0].y) / (line[1].y - line[0].y);

                const result = [];
                let index1 = 0;
                let index2 = 0;
                let last = 0;
                while ((index1 < edge1.length) && (index2 < edge2.length)) {
                    while (edge1[index1] && edge2[index2] && edge1[index1].y === edge2[index2].y) {
                        if (cmp(edge2[index2].x, edge1[index1].x)) {
                            if (last) {
                                result.push(edge1[index1]);
                            }
                            result.push(edge2[index2]);
                            last = 0;
                        } else {
                            if (!last) {
                                result.push(edge2[index2]);
                            }
                            result.push(edge1[index1]);
                            last = 1;
                        }
                        ++index1;
                        ++index2;
                    }
                    while (edge1[index1] && edge2[index2] && edge1[index1].y < edge2[index2].y) {
                        if (index2 > 0) {
                            const x = lerp([edge2[index2 - 1], edge2[index2]], edge1[index1]);
                            if (cmp(edge1[index1].x, x)) {
                                if (!last) {
                                    result.push({ x, y: edge1[index1].y });
                                }
                                result.push(edge1[index1]);
                                last = 1;
                                if (index1 === edge1.length - 1) {
                                    result.push({ x, y: edge1[index1].y });
                                    last = 0;
                                }
                            }
                        } else {
                            result.push(edge1[index1]);
                            last = 1;
                        }
                        ++index1;
                    }
                    while (edge1[index1] && edge2[index2] && edge2[index2].y < edge1[index1].y) {
                        if (index1 > 0) {
                            const x = lerp([edge1[index1 - 1], edge1[index1]], edge2[index2]);
                            if (cmp(edge2[index2].x, x)) {
                                if (last) {
                                    result.push({ x, y: edge2[index2].y });
                                }
                                result.push(edge2[index2]);
                                last = 0;
                                if (index2 === edge2.length - 1) {
                                    result.push({ x, y: edge2[index2].y });
                                    last = 1;
                                }
                            }
                        } else {
                            result.push(edge2[index2]);
                            last = 0;
                        }
                        ++index2;
                    }
                }
                result.push(...edge1.slice(index1));
                result.push(...edge2.slice(index2));
                return result;
            }
            mergeEdges(shape) {
                const leftEdge = shape.leftEdge.map((point) =>
                    ({ x: parseFloat(point.x + shape.box.x), y: parseFloat(point.y + shape.box.y) }));
                const rightEdge = shape.rightEdge.map((point) =>
                    ({ x: parseFloat(point.x + shape.box.x), y: parseFloat(point.y + shape.box.y) }));

                this.leftEdge = this.merge(this.leftEdge, leftEdge, (a, b) => a < b);
                this.rightEdge = this.merge(this.rightEdge, rightEdge, (a, b) => a > b);
            }
            drawTreeLines(shapes, style) {
                style = this.getData('connector style') ?? style;
                const attrs = {
                    fill: 'none', stroke: this.getData('line') ?? 'black', d: '',
                }
                if (this.layout === 'grid') {
                    this.x = (this.box.width - this.width) / 2;
                    this.y = this.view.configuration.rowGap;
                    this.leftEdge = this.merge(this.leftEdge, [{ x: 0, y: 0 }, { x: 0, y: this.box.height }], (a, b) => a < b);
                    this.rightEdge = this.merge(this.leftEdge, [
                        { x: this.box.width, y: 0 }, { x: this.box.width, y: this.box.height }], (a, b) => a > b);
                } else if (this.layout === 'leftToRight') {

                } else if (this.layout === 'vertical') {
                    this.x = 0;
                    this.y = 0;
                    const l = Math.max(...shapes.map((shape) => shape.box.y + shape.y + shape.height / 2));

                    const end = Math.max(...shapes.map((shape) => shape.box.y + shape.y + shape.height));

                    this.leftEdge = this.merge(this.leftEdge, [
                        { x: this.x, y: this.y },
                        { x: this.x, y: this.y + this.height },
                        { x: this.x + this.view.configuration.columnGap, y: this.y + this.height },
                        { x: this.x + this.view.configuration.columnGap, y: end }], (a, b) => a < b);
                    this.rightEdge = this.merge(this.rightEdge, [
                        { x: this.x + this.width, y: this.y },
                        { x: this.x + this.width, y: this.y + this.height },
                        { x: this.x + this.view.configuration.columnGap, y: this.y + this.height },
                        { x: this.x + this.view.configuration.columnGap, y: end }], (a, b) => a > b);

                    if (style === 'straight') {
                        const x1 = this.x + this.view.configuration.columnGap;
                        const y1 = this.y + this.height;
                        shapes.forEach((shape) => {
                            const x = shape.box.x + shape.x;
                            const y = shape.box.y + shape.y + shape.height / 2;
                            attrs.d += ` M ${x1} ${y1} L${x} ${y}`;
                        });
                    } else if (style === 'rectilinear') {
                        attrs.d = `M ${this.view.configuration.columnGap} ${this.height} V${l}`;

                        shapes.forEach((shape) => {
                            const y = shape.box.y + shape.y + shape.height / 2;
                            const x = shape.box.x + shape.x;
                            attrs.d += ` M ${this.view.configuration.columnGap} ${y} H${x}`;
                        });
                    } else if (style === 'curved') {
                        shapes.forEach((shape) => {
                            const x1 = this.x + this.view.configuration.columnGap;
                            const y1 = this.y + this.height;
                            const x2 = shape.box.x + shape.x + shape.width / 2;
                            const y2 = shape.box.y + shape.y;
                            attrs.d += ` M ${x1} ${y1} C${x1} ${y2} ${x2} ${y1} ${x2} ${y2}`;
                        });
                    } else {
                        const row = this.view.configuration.rowGap;
                        attrs.d = `M ${this.view.configuration.columnGap} ${this.height} V${l - row}`;
                        shapes.forEach((shape) => {
                            const x1 = this.x + this.view.configuration.columnGap;
                            const y = shape.box.y + shape.y + shape.height / 2;
                            const x2 = shape.box.x + shape.x;
                            const y2 = shape.box.y + shape.y + shape.height / 2;

                            const dx = x1 > x2 ? -Math.min(this.view.configuration.columnGap, (x1 - x2) / 2) : Math.min(this.view.configuration.columnGap, (x2 - x1) / 2);

                            attrs.d += ` M${x1} ${y - row}`;
                            attrs.d += ` Q${x1} ${y} ${x1 + row} ${y} H${x2}`;
                        });
                    }
                } else {
                    this.x = (this.box.width - this.width) / 2;
                    this.y = 0;
                    const x1 = Math.min(...shapes.map((shape) => shape.box.x + shape.x + shape.width / 2));
                    const x2 = Math.max(...shapes.map((shape) => shape.box.x + shape.x + shape.width / 2));

                    const first = shapes.reduce((first, shape) =>
                        (first.box.x < shape.box.x) ? first : shape, shapes[0]);
                    const last = shapes.reduce((last, shape) =>
                        ((last.box.x + last.box.width) > (shape.box.x + shape.box.width)) ? last : shape, shapes[0]);

                    this.leftEdge = this.merge(this.leftEdge, [
                        { x: this.x, y: this.y },
                        { x: this.x, y: this.height },
                        { x: this.x + this.width / 2, y: this.y + this.height },
                        { x: this.x + this.width / 2, y: this.y + this.height + this.view.configuration.rowGap },
                        { x: first.box.x + first.x + first.width / 2, y: this.y + this.height + this.view.configuration.rowGap },
                        { x: first.box.x + first.x + first.width / 2, y: first.box.y + first.y }], (a, b) => a < b);
                    this.rightEdge = this.merge(this.rightEdge, [
                        { x: this.x + this.width, y: this.y },
                        { x: this.x + this.width, y: this.height },
                        { x: this.x + this.width / 2, y: this.y + this.height },
                        { x: this.x + this.width / 2, y: this.y + this.height + this.view.configuration.rowGap },
                        { x: last.box.x + last.x + last.width / 2, y: this.y + this.height + this.view.configuration.rowGap },
                        { x: last.box.x + last.x + last.width / 2, y: last.box.y + last.y }], (a, b) => a > b);

                    if (style === 'straight') {
                        shapes.forEach((shape) => {
                            const x = shape.box.x + shape.x + shape.width / 2;
                            const y = shape.box.y + shape.y;
                            attrs.d += ` M ${this.x + this.width / 2} ${this.y + this.height} L${x} ${y}`;
                        });
                    } else if (style === 'rectilinear') {
                        attrs.d = `M ${this.x + this.width / 2} ${this.y + this.height} v${this.view.configuration.rowGap}`;
                        attrs.d += ` M ${x1} ${this.height + this.view.configuration.rowGap} h${x2 - x1}`;
                        shapes.forEach((shape) => {
                            const x = shape.box.x + shape.x + shape.width / 2;
                            const y = shape.box.y + shape.y;
                            attrs.d += ` M ${x} ${this.y + this.height + this.view.configuration.rowGap} V${y}`;
                        });
                    } else if (style === 'curved') {
                        shapes.forEach((shape) => {
                            const x1 = this.x + this.width / 2;
                            const y1 = this.y + this.height;
                            const x2 = shape.box.x + shape.x + shape.width / 2;
                            const y2 = shape.box.y + shape.y;
                            attrs.d += ` M ${x1} ${y1} C${x1} ${y2} ${x2} ${y1} ${x2} ${y2}`;
                        });
                    } else {
                        const row = this.view.configuration.rowGap;
                        shapes.forEach((shape) => {
                            const x1 = this.x + this.width / 2;
                            const y1 = this.y + this.height;
                            const x2 = shape.box.x + shape.x + shape.width / 2;
                            const y2 = shape.box.y + shape.y;

                            const dx = x1 > x2 ? -Math.min(this.view.configuration.columnGap, (x1 - x2) / 2) : Math.min(this.view.configuration.columnGap, (x2 - x1) / 2);

                            attrs.d += `M${x1} ${y1} `;
                            attrs.d += `Q${x1} ${y1 + row} ${x1 + dx} ${y1 + row} H${x2 - dx}`;
                            attrs.d += `Q${x2} ${y1 + row} ${x2} ${y2} V${y2}`;
                        });
                    }
                }
                if (shapes.length > 0) {
                    this.view.add('path', this.container, attrs);
                }
            }
            linePoint(points, position) {
                const segments = points.length - 1;
                position = Math.abs(position) % segments;
                const segment = Math.floor(position);
                const d = position - segment;

                const x1 = points[segment].x;
                const y1 = points[segment].y;

                const x2 = points[segment + 1].x;
                const y2 = points[segment + 1].y;

                return { x: x1 + d * (x2 - x1), y: y1 + d * (y2 - y1) };
            }

            connectionPoint(position) {
                return { x: this.x, y: this.y };
            }
        }

        class SVGRect extends SVGShape {
            static name = 'rect';

            constructor(view, node) {
                super(view, node);
            }
            draw() {
                const attrs = {
                    x: this.x,
                    y: this.y,
                    width: this.width, height: this.height,
                    fill: this.fill, stroke: this.stroke,
                    rx: 5,
                };
                Object.assign(attrs, this.getData('style') || {});
                const svgElement = this.view.add('rect', this.container, attrs);
                this.addText();
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                if (this.getData('button 1') && this.getData(this.getData('button 1')) !== undefined) {
                    this.drawLabel(this.getData(this.getData('button 1')), this.x + this.width, this.y);
                }
                if (this.getData('button 2') && this.getData(this.getData('button 2')) !== undefined) {
                    this.drawLabel(this.getData(this.getData('button 2')), this.x + this.width, this.y + this.height);
                }
                if (this.getData('button 3') && this.getData(this.getData('button 3')) !== undefined) {
                    this.drawLabel(this.getData(this.getData('button 3')), this.x, this.y + this.height);
                }
                if (this.getData('button 4') && this.getData(this.getData('button 4')) !== undefined) {
                    this.drawLabel(this.getData(this.getData('button 4')), this.x, this.y);
                }
                this.viewData('svgNodes').push(svgElement);
            }
            connectionPoint(position) {
                let x = this.x, y = this.y;
                let w = this.width, h = this.height;

                if (this.getData('layout') === 'grid') {
                    x = y = 0;
                    w = this.box.width;
                    h = this.box.height;
                }

                const points = [{ x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h }, { x: x, y: y }];

                return this.linePoint(points, position);
            }
        }


        class SVGActivity extends SVGShape {
            static name = 'activity';

            constructor(view, node) {
                super(view, node);
            }
            draw() {
                if (this.getData('show latest')) {
                    const viewData = this.node[symbols.viewData].get(this.view);
                    const attrs = {
                        x: (this.getData('lateStart').getTime() - this.getData('start').getTime()) * viewData.scale,
                        y: this.y,
                        width: (this.getData('lateFinish').getTime() - this.getData('lateStart').getTime()) * viewData.scale,
                        height: this.height,
                        fill: this.fill, 'fill-opacity': 0.5, stroke: this.stroke, 'stroke-opacity': 0.5,
                        rx: 5,
                    };
                    const svgElement = this.view.add('rect', this.container, attrs);
                }
                const attrs = {
                    x: this.x,
                    y: this.y,
                    width: this.width, height: this.height,
                    fill: this.fill, stroke: this.stroke,
                    rx: 5,
                };

                Object.assign(attrs, this.getData('style') || {});
                const svgElement = this.view.add('rect', this.container, attrs);

                if (this.getData('show dates') && (this.width > (5 * this.lineHeight))) {
                    this.addText(this.width - this.lineHeight * 2);
                    const path = {
                        fill: 'none', stroke: this.stroke,
                        d: `M${this.x + this.lineHeight} ${this.y} v${this.height} M${this.x + this.width - this.lineHeight} ${this.y} v${this.height}`,
                    }
                    this.view.add('path', this.container, path);
                    const start = {
                        x: 0, y: 0,
                        'font-size': `${this.fontSize * 0.8}pt`,
                        'font-family': this.getData('font') ?? 'sans-serif',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'middle',
                        fill: this.getData('text') ?? 'black',
                        transform: `rotate(-90) translate(${-this.y - this.height / 2} ${this.x + this.lineHeight / 2})`,
                    }
                    this.view.add('text', this.container, start, this.getData('earlyStart').toLocaleDateString());
                    const end = {
                        x: 0, y: 0,
                        'font-size': `${this.fontSize * 0.8}pt`,
                        'font-family': this.getData('font') ?? 'sans-serif',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'middle',
                        fill: this.getData('text') ?? 'black',
                        transform: `rotate(-90) translate(${-this.y - this.height / 2} ${this.x + this.width - this.lineHeight / 2})`,
                    }
                    const finish = getCalendarDays(this.getData('earlyStart'), this.getData('duration'));
                    this.view.add('text', this.container, end, `${finish.toLocaleDateString()}`);
                } else {
                    this.addText(this.width);
                    /*
                                        const label = {
                                            x: 0, y: 0,
                                            'font-size': `${this.fontSize}pt`,
                                            'font-family': this.getData('font') ?? 'sans-serif',
                                            'text-anchor': 'end',
                                            'dominant-baseline': 'middle',
                                            fill: this.getData('text') ?? 'black',
                                            transform: `rotate(-90) translate(${-this.y - this.height} ${this.x + this.lineHeight / 2})`,
                                        }
                                        const text = this.view.add('text', this.container, label, this.view.configuration.nodeText(this.node) ?? '');
                    
                                        const path = {
                                            fill: 'none', stroke: this.stroke,
                                            d: `M${this.x} ${this.y + this.height / 2} V${this.height + text.getComputedTextLength()}`,
                                        }
                                        this.view.add('path', this.container, path);
                                        */
                }

                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);
            }
            connectionPoint(position) {
                let x = this.x, y = this.y;
                let w = this.width, h = this.height;

                if (this.getData('layout') === 'grid') {
                    x = y = 0;
                    w = this.box.width;
                    h = this.box.height;
                }

                const points = [{ x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h }, { x: x, y: y }];

                return this.linePoint(points, position);
            }
        }

        class SVGPackage extends SVGShape {
            static name = 'package';

            constructor(view, node) {
                super(view, node);
            }
            draw() {
                const attrs = {
                    x: this.x,
                    y: this.y,
                    width: this.width, height: this.height,
                    fill: this.fill, stroke: this.stroke,
                    rx: 5,
                };
                Object.assign(attrs, this.getData('style') || {});
                const svgElement = this.view.add('rect', this.container, attrs);

                if (this.width > (5 * this.lineHeight)) {
                    this.addText(this.width - this.lineHeight * 2);
                    const path = {
                        fill: 'none', stroke: this.stroke,
                        d: `M${this.x + this.lineHeight} ${this.y} v${this.height} M${this.x + this.width - this.lineHeight} ${this.y} v${this.height}`,
                    }
                    this.view.add('path', this.container, path);
                    const start = {
                        x: 0, y: 0,
                        'font-size': `${this.fontSize * 0.8}pt`,
                        'font-family': this.getData('font') ?? 'sans-serif',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'middle',
                        fill: this.getData('text') ?? 'black',
                        transform: `rotate(-90) translate(${-this.y - this.height / 2} ${this.x + this.lineHeight / 2})`,
                    }
                    this.view.add('text', this.container, start, this.getData('earlyStart').toLocaleDateString());
                    const end = {
                        x: 0, y: 0,
                        'font-size': `${this.fontSize * 0.8}pt`,
                        'font-family': this.getData('font') ?? 'sans-serif',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'middle',
                        fill: this.getData('text') ?? 'black',
                        transform: `rotate(-90) translate(${-this.y - this.height / 2} ${this.x + this.width - this.lineHeight / 2})`,
                    }
                    const finish = getCalendarDays(this.getData('earlyStart'), this.getData('duration'));
                    this.view.add('text', this.container, end, finish.toLocaleDateString());
                } else {
                    this.addText(this.width);
                    /*
                                        const label = {
                                            x: 0, y: 0,
                                            'font-size': `${this.fontSize}pt`,
                                            'font-family': this.getData('font') ?? 'sans-serif',
                                            'text-anchor': 'end',
                                            'dominant-baseline': 'middle',
                                            fill: this.getData('text') ?? 'black',
                                            transform: `rotate(-90) translate(${-this.y - this.height} ${this.x + this.lineHeight / 2})`,
                                        }
                                        const text = this.view.add('text', this.container, label, this.view.configuration.nodeText(this.node) ?? '');
                    
                                        const path = {
                                            fill: 'none', stroke: this.stroke,
                                            d: `M${this.x} ${this.y + this.height / 2} V${this.height + text.getComputedTextLength()}`,
                                        }
                                        this.view.add('path', this.container, path);
                                        */
                }

                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);
            }
            connectionPoint(position) {
                let x = this.x, y = this.y;
                let w = this.width, h = this.height;

                if (this.getData('layout') === 'grid') {
                    x = y = 0;
                    w = this.box.width;
                    h = this.box.height;
                }

                const points = [{ x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h }, { x: x, y: y }];

                return this.linePoint(points, position);
            }
        }

        class SVGText extends SVGShape {
            static name = 'rect';

            constructor(view, node) {
                super(view, node);
            }
            get width() {
                return this.box.width ?? validateNumber(this.getData('width'), 100);
            }
            get height() {
                return validateNumber(this.getData('height'), this.lineHeight * 1.5);
            }
            draw() {
                this.addText();
            }
            connectionPoint(position) {
                let x = this.x, y = this.y;
                let w = this.width, h = this.height;

                if (this.getData('layout') === 'grid') {
                    x = y = 0;
                    w = this.box.width;
                    h = this.box.height;
                }

                const points = [{ x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h }, { x: x, y: y }];

                return this.linePoint(points, position);
            }
        }

        class SVGTimeline extends SVGShape {
            static name = 'timeline';

            constructor(view, node) {
                super(view, node);
                this.nodes = [];
                const addNode = (node) => {
                    const proxy = makeProxy(node, this.view.title);
                    if (proxy.inputs) {
                        this.nodes.push(proxy);
                    }
                    node[symbols.content].forEach(addNode);
                }
                this.node[symbols.content].forEach(addNode);
            }
            get width() {
                return this.box.width ?? validateNumber(this.getData('width'), 100);
            }
            get height() {
                const lines = Math.max(0, ...this.nodes.map((node) =>
                    Math.max((node.inputs || []).filter((input) => input.links.length === 0).length,
                        (node.outputs || []).filter((output) => output.links.length === 0).length)));

                return Math.max(100, ...this.nodes.map((node, i) => {
                    const box = node[symbols.viewData]?.get(this.view)?.shape?.box;
                    if (box) {
                        return box.y + box.height;
                    }
                    return 0;
                })) + lines * this.lineHeight;// + this.view.configuration.rowGap;
            }
            draw() {
                const proxy = makeProxy(this.node, this.view.title);
                const start = this.getData('start');
                if (!start) {
                    return;
                }
                quantiseDate(start);
                const finish = this.getData('finish');
                const scale = validateNumber(proxy.scale, 10) / (24 * 60 * 60 * 1000);
                const x = (date) => (date.getTime() - start.getTime()) * scale;

                const footer = this.lineHeight * Math.max(0, ...this.nodes.map((node) =>
                    Math.max((node.inputs || []).filter((input) => input.links.length === 0).length,
                        (node.outputs || []).filter((output) => output.links.length === 0 && !output.autoGenerated).length)));

                const update = (date) => date.setDate(date.getDate() + 1);
                const width = (2 * 24 * 60 * 60 * 1000) * scale;
                const date = new Date(start);
                quantiseDate(date);

                const attrs = { fill: 'none', stroke: 'gray', d: '' };
                while (date < finish) {
                    attrs.d += `M${x(date)} ${0} V${this.height - footer}`;
                    if (date.getDay() === 6) {
                        const attrs = { fill: 'rgb(200 200 200)', 'fill-opacity': 0.5, stroke: 'none', x: x(date), y: 0, width, height: this.height - footer };
                        this.view.addUnder('rect', this.container, attrs);
                    }
                    update(date);
                }
                this.view.addUnder('path', this.container, attrs);
                const now = {
                    d: `M${x(new Date())} 0 V${this.height - footer}`, fill: 'none', stroke: 'red', 'stroke-width': 2, 'stroke-dasharray': 4,
                };
                this.view.add('path', this.container, now);

                date.setTime(start.getTime());
                date.setDate(1);
                quantiseDate(date);

                while (date < finish) {
                    const startDate = (date > start) ? date : start;
                    const x1 = x(startDate);
                    const end = new Date(date);
                    end.setMonth(end.getMonth() + 1);
                    const endDate = (end < finish) ? end : finish;
                    const x2 = x(endDate);
                    const attrs = { fill: 'white', stroke: 'black', x: x1, y: 0, width: x2 - x1, height: this.lineHeight, }
                    const rect = this.view.add('rect', this.container, attrs);
                    this.view.add('title', rect, {}, `${date.toLocaleDateString()} ${end.toLocaleDateString()}`);
                    const textAttrs = {
                        fill: 'black', stroke: 'none', x: (x1 + x2) / 2, y: this.lineHeight / 2,
                        'font-size': `${this.fontSize * 0.8}pt`,
                        'font-family': this.getData('font') ?? 'sans-serif',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'middle',
                    }
                    this.view.add('text', this.container, textAttrs, date.toLocaleDateString('en-AU', { year: 'numeric', month: 'long', }));
                    date.setMonth(date.getMonth() + 1);
                }

                //this.addText();
                if (proxy['show burndown']) {
                    const burndowns = [proxy['show burndown']].flatMap((i) => i);
                    const nodes = this.view.configuration.nodeContent(this.node).filter((node) => getDuration(node));

                    const start = new Date(Math.min(...nodes.map((node) => node[symbols.views][this.view.title].start.getTime())));
                    const finish = new Date(Math.max(...nodes.map((node) => node[symbols.views][this.view.title].finish.getTime())));

                    const attrs = {
                        fill: 'none', stroke: 'black', 'stroke-width': 1,
                        d: `M${x(start)} ${2 * this.view.configuration.rowGap} v${this.height - footer - 2 * this.view.configuration.rowGap} H${x(finish)}`,
                    };
                    this.view.add('path', this.container, attrs);
                    let v = 0;
                    const text = {
                        fill: 'black', stroke: 'none', x: x(start), 'text-anchor': 'end', 'dominant-baseline': 'middle',
                        'font-size': `${this.fontSize * 0.8}pt`, 'font-family': this.getData('font') ?? 'sans-serif',
                    };
                    attrs.stroke = 'gray';
                    attrs.d = '';
                    while (v <= 100) {
                        text.y = this.height - footer - (v / 100) * (this.height - footer - 2 * this.view.configuration.rowGap);
                        this.view.add('text', this.container, text, `${v.toFixed(1)}%`);
                        attrs.d += `M${x(start)} ${text.y} H${x(finish)}`;
                        v += 10;
                    }
                    this.view.add('path', this.container, attrs);

                    burndowns.forEach((burndown) => {
                        let total = 0;
                        const points = nodes.flatMap((node) => {
                            const data = node[symbols.views][this.view.title];
                            let rate = 0;
                            if (Array.isArray(node[burndown])) {
                                const sum = node[burndown].reduce((sum, node) => sum + (node.value || 0), 0);
                                total += sum;
                                rate = sum / ((data.finish.getTime() - data.start.getTime()) * scale);
                            } else {
                                total += node[burndown]?.value ?? 0;
                                rate = (node[burndown]?.value ?? 0) / ((data.finish.getTime() - data.start.getTime()) * scale);
                            }
                            return [
                                { x: x(data.start), rate: -rate, },
                                { x: x(data.finish), rate: rate, }
                            ];
                        });
                        points.sort((a, b) => a.x - b.x);
                        const y = (value) => this.height - footer - (value / total) * (this.height - footer - 2 * this.view.configuration.rowGap);
                        const attrs = { fill: 'none', stroke: 'red', 'stroke-width': 1.5, d: `M${points[0].x} ${y(total)}` };
                        let currentX = 0;
                        let rate = 0;
                        let value = total;
                        points.forEach((point) => {
                            const deltaX = point.x - currentX;
                            currentX = point.x;
                            value += rate * deltaX;
                            rate += point.rate;
                            attrs.d += ` L${point.x} ${y(value)}`;
                        });
                        this.view.add('path', this.container, attrs);
                    });
                }
            }
            drawTreeLines(shapes, style) {
                const proxy = makeProxy(this.node, this.view.title);
                const start = this.getData('start');
                quantiseDate(start);
                const scale = validateNumber(proxy.scale, 10) / (24 * 60 * 60 * 1000);
                const x = (date) => (date.getTime() - start.getTime()) * scale;
                const opacity = this.getData('link opacity');
                const labels = [];

                const drawLabel = (label) => {
                    const back = this.view.add('rect', this.container, {
                        x: label.x, y: label.y - this.lineHeight / 2, height: this.lineHeight,
                        rx: this.lineHeight / 2,
                        stroke: label.colour, 'stroke-opacity': opacity ?? 1,
                        fill: 'white', 'fill-opacity': opacity ?? 1,
                    });
                    const tx = label.anchor === 'start' ? label.x + this.lineHeight * 0.4 : label.anchor === 'end' ? label.x - this.lineHeight * 0.4 : label.x;
                    const text = this.view.add('text', this.container, {
                        x: tx, y: label.y,
                        'text-anchor': label.anchor ?? 'middle', 'dominant-baseline': 'middle',
                        fill: label.colour, 'fill-opacity': opacity ?? 1,
                        'font-family': this.getData('font') ?? 'sans-serif', 'font-size': `${this.fontSize * 0.8}pt`
                    }, label.text);
                    const width = text.getComputedTextLength() + 0.8 * this.lineHeight;
                    const x = label.anchor === 'start' ? label.x : label.anchor === 'end' ? label.x - width : label.x - width / 2;
                    this.view.updateElement(back, { x, width, });
                };

                this.nodes.forEach((node) => {
                    const totalInputs = node.inputs.length + 1;
                    const totalOutputs = node.outputs.filter((output) => output.links.length || !output.autoGenerated).length + 1;
                    const unresolved = node.inputs.filter((input) => input.links.length === 0);
                    const unused = node.outputs.filter((output) => output.links.length === 0 && !output.autoGenerated);
                    const links = node.inputs.flatMap((input) => input.links);

                    links.forEach((link) => {
                        const attrs = { fill: 'none', stroke: 'green', d: '', 'stroke-opacity': opacity ?? 0.8, 'fill-opacity': opacity ?? 0.8, };
                        if (link.float < 1) {
                            attrs.stroke = 'red';
                            attrs['stroke-opacity'] = opacity ?? 1;
                        } else if (link.float < 5) {
                            attrs.stroke = 'orange';
                        }
                        const from = link.from.node[symbols.views][this.view.title];
                        const shape = link.from.node[symbols.viewData].get(this.view).shape;
                        const start = {
                            y: shape.y + shape.box.y + shape.height *
                                (link.from.node[symbols.views][this.view.title].outputs.indexOf(link.from) + 1) /
                                (link.from.node[symbols.views][this.view.title].outputs.length + 1),
                        };

                        let date = from.start;
                        if (link.from.date) {
                            date = link.from.date;
                            start.y = shape.y + shape.box.y + shape.box.height;
                        } else if (link.from.event === 'finish') {
                            date = from.finish;
                        }
                        /*
                        if (link.from.lag) {
                            if (link.from.lag.endsWith('%')) {
                                const percent = parseFloat(link.from.lag);
                                date.setTime(date.getTime() +
                                    (from.finish.getTime() - from.start.getTime()) * percent / 100);
                            } else {
                                const lag = parseInt(link.from.lag);
                                offsetDate(date, lag);
                            }
                        }
                        */

                        start.x = x(date);

                        const to = link.to.node[symbols.views][this.view.title];
                        const toDate = (link.to.event === 'start') ? to.start : to.finish;
                        /*
                        if (link.to.lag) {
                            const lag = parseInt(link.to.lag);
                            offsetDate(toDate, lag);
                        }
                        */
                        const toShape = link.to.node[symbols.viewData].get(this.view).shape;
                        const end = { x: x(toDate), y: toShape.y + toShape.box.y + toShape.height * (node.inputs.indexOf(link.to) + 1) / totalInputs, };
                        const mid = (start.x + end.x) / 2;

                        const offset = Math.abs((start.y < end.y + toShape.height) && (start.y + shape.height > end.y)) ? 0 : 50;

                        if (link.from.date) {
                            attrs.d = `M${start.x} ${start.y} C${start.x} ${start.y + 50} ${mid} ${end.y} ${end.x - 5} ${end.y}`;
                        } else {
                            attrs.d = `M${start.x} ${start.y} C${start.x + offset} ${start.y} ${end.x - offset} ${end.y} ${end.x - 5} ${end.y}`;
                        }
                        this.view.add('path', this.container, attrs);
                        attrs.fill = attrs.stroke;
                        attrs.d = `M${end.x} ${end.y} l-5 -2 v4 Z`;
                        this.view.add('path', this.container, attrs);
                        
                        if (this.getData('show labels')) {
                            labels.push({
                                text: link.from.name, x: (start.x + end.x) / 2, y: (start.y + end.y) / 2, colour: attrs.stroke,
                            });
                        }

                    });

                    let y = this.height - this.view.configuration.rowGap - this.lineHeight;
                    unresolved.forEach((input, i) => {
                        const y = this.height - this.view.configuration.rowGap + (i - unresolved.length) * this.lineHeight;
                        const attrs = { fill: 'none', stroke: 'red', d: '', 'stroke-opacity': opacity ?? 0.5, 'fill-opacity': opacity ?? 0.5, };
                        const to = node[symbols.views][this.view.title];
                        const toDate = (input.event === 'start') ? to.start : to.finish;
                        if (input.lag) {
                            const lag = parseInt(input.lag);
                            offsetDate(toDate, lag);
                        }
                        const toShape = input.node[symbols.viewData].get(this.view).shape;
                        const end = {
                            x: x(toDate), y: toShape.y + toShape.box.y + toShape.height *
                                (node.inputs.indexOf(input) + 1) / totalInputs,
                        };
                        const start = { x: end.x - 100, y };
                        const mid = (start.x + end.x) / 2;

                        attrs.d = `M${start.x} ${start.y} C${mid} ${start.y} ${mid} ${end.y} ${end.x - 5} ${end.y}`;
                        this.view.add('path', this.container, attrs);
                        attrs.fill = attrs.stroke;
                        attrs.d = `M${end.x} ${end.y} l-5 -2 v4 Z`;
                        this.view.add('path', this.container, attrs);

                        labels.push({x: start.x, y, anchor: 'end', text: input.name, colour: 'red', });
                    });

                    y = this.height - this.view.configuration.rowGap - this.lineHeight;
                    unused.forEach((output) => {
                        const attrs = { fill: 'none', stroke: 'orange', d: '', 'stroke-opacity': opacity ?? 0.5, 'fill-opacity': opacity ?? 0.5, };
                        const from = output.node[symbols.views][this.view.title];
                        const shape = output.node[symbols.viewData].get(this.view).shape;
                        const start = { y: shape.y + shape.box.y + shape.height * (output.node[symbols.views][this.view.title].outputs.indexOf(output) + 1) / totalOutputs, };

                        let date = from.start;
                        if (output.date) {
                            date = output.date;
                            start.y = shape.y + shape.box.y + shape.box.height;
                        } else if (output.event === 'finish') {
                            date = from.finish;
                        }
                        if (output.lag) {
                            if (output.lag.endsWith('%')) {
                                const percent = parseFloat(output.lag);
                                date.setTime(date.getTime() +
                                    (from.finish.getTime() - from.start.getTime()) * percent / 100);
                            } else {
                                const lag = parseInt(output.lag);
                                offsetDate(date, lag);
                            }
                        }

                        start.x = x(date);

                        const end = { x: start.x + 100, y, };
                        const mid = (start.x + end.x) / 2;

                        if (output.date) {
                            attrs.d = `M${start.x} ${start.y} C${start.x} ${start.y + 20} ${mid} ${end.y} ${end.x} ${end.y}`;
                        } else {
                            attrs.d = `M${start.x} ${start.y} C${start.x + 50} ${start.y} ${end.x - 50} ${end.y} ${end.x} ${end.y}`;
                        }
                        this.view.add('path', this.container, attrs);
                        labels.push({x: end.x, y, anchor: 'start', text: output.name, colour: 'orange', });
                        y -= this.lineHeight;
                    });
                });
                labels.forEach(drawLabel);
            }
            connectionPoint(position) {
                const x = 0
                const y = 0;
                const w = this.box.width;
                const h = this.box.height;

                const points = [{ x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h }, { x: x, y: y }];

                return this.linePoint(points, position);
            }
        }

        class SVGNetwork extends SVGShape {
            static name = 'network';

            constructor(view, node) {
                super(view, node);
                this.nodes = [];
                const addNode = (node) => {
                    const proxy = makeProxy(node, this.view.title);
                    if (proxy.inputs) {
                        this.nodes.push(proxy);
                    }
                    node[symbols.content].forEach(addNode);
                }
                this.node[symbols.content].forEach(addNode);
            }
            get width() {
                return this.box.width ?? validateNumber(this.getData('width'), 100);
            }
            get height() {
                const lines = Math.max(0, ...this.nodes.map((node) =>
                    Math.max((node.inputs || []).filter((input) => input.links.length === 0).length,
                        (node.outputs || []).filter((output) => output.links.length === 0).length)));

                return Math.max(100, ...this.nodes.map((node, i) => {
                    const box = node[symbols.viewData]?.get(this.view)?.shape?.box;
                    if (box) {
                        return box.y + box.height;
                    }
                    return 0;
                })) + lines * this.lineHeight + this.view.configuration.rowGap * 2;
            }
            draw() {
                const proxy = makeProxy(this.node, this.view.title);

                const footer = Math.max(0, ...this.nodes.map((node) =>
                    Math.max((node.inputs || []).filter((input) => input.links.length === 0).length,
                        (node.outputs || []).filter((output) => output.links.length === 0).length)));
            }
            drawTreeLines(shapes, style) {
                const proxy = makeProxy(this.node, this.view.title);
                const labels = [];
                const opacity = this.getData('link opacity');
                const get = (node, parameter) => node?.[symbols.views][this.view]?.[parameter] ?? node?.[parameter];

                const drawLabel = (label) => {
                    const back = this.view.add('rect', this.container, {
                        x: label.x, y: label.y - this.lineHeight / 2, height: this.lineHeight,
                        rx: this.lineHeight / 2,
                        stroke: label.colour, 'stroke-opacity': label.opacity,
                        fill: 'white', 'fill-opacity': label.opacity,
                    });
                    const tx = label.anchor === 'start' ? label.x + this.lineHeight * 0.4 : label.anchor === 'end' ? label.x - this.lineHeight * 0.4 : label.x;
                    const text = this.view.add('text', this.container, {
                        x: tx, y: label.y,
                        'text-anchor': label.anchor ?? 'middle', 'dominant-baseline': 'middle',
                        fill: label.colour, 'fill-opacity': label.opacity,
                        'font-family': this.getData('font') ?? 'sans-serif', 'font-size': `${this.fontSize * 0.8}pt`
                    }, label.text);
                    const width = text.getComputedTextLength() + 1.2 * this.lineHeight;
                    const x = label.anchor === 'start' ? label.x : label.anchor === 'end' ? label.x - width : label.x - width / 2;
                    this.view.updateElement(back, { x, width, });
                };

                this.nodes.forEach((node) => {
                    const totalInputs = node.inputs.length + 1;
                    const totalOutputs = node.outputs.filter((output) => output.links.length || !output.autoGenerated).length + 1;
                    const unresolved = node.inputs.filter((input) => input.links.length === 0);
                    const unused = node.outputs.filter((output) => output.links.length === 0 && !output.autoGenerated);
                    const links = node.inputs.flatMap((input) => input.links);
                    
                    links.forEach((link, i) => {
                        const totalOutputs = link.from.node[symbols.views][this.view.title].outputs.filter((output) => output.links.length || !output.autoGenerated).length + 1;
                        const linkNode = Core.find((node) => node.name === `${link.from.node.name}->${link.to.node.name}(${link.name})`) ?? Core.find((node) => node.name === link.name);
                        const linkOpacity = get(linkNode, 'opacity') ?? opacity ?? 0.8;
                        const attrs = { fill: 'none', stroke: get(linkNode, 'colour') ?? 'black', d: '', 'stroke-opacity': linkOpacity, 'fill-opacity': linkOpacity, };
                        const shape = link.from.node[symbols.viewData].get(this.view).shape;
                        const start = { x: shape.box.x + shape.x + shape.width, y: shape.y + shape.box.y + shape.height * (link.from.node[symbols.views][this.view.title].outputs.indexOf(link.from) + 1) / totalOutputs, };

                        const toShape = link.to.node[symbols.viewData].get(this.view).shape;
                        const end = { x: toShape.box.x + toShape.x, y: toShape.y + toShape.box.y + toShape.height * (i + 1) / totalInputs, };
                        const mid = {
                            x: get(linkNode, 'x') ?? (start.x + end.x) / 2,
                            y: get(linkNode, 'y') ?? (start.y + end.y) / 2,
                        };

                        if (get(linkNode, 'points')) {
                            attrs.d = `M${start.x} ${start.y} `;
                            attrs.d += get(linkNode, 'points').map((point) => `L${point.x} ${point.y}`).join(' ');
                            attrs.d += ` L${end.x} ${end.y}`;
                        } else if (get(linkNode, 'curve')) {
                            const d = {x: (start.x - end.x + 100) / 4,  y: (start.y - end.y) / 4};
                            attrs.d = `M${start.x} ${start.y} C${start.x + 50} ${start.y} ${mid.x + d.x} ${mid.y + d.y} ${mid.x} ${mid.y} C${mid.x - d.x} ${mid.y - d.y} ${end.x - 50} ${end.y} ${end.x - 5} ${end.y}`;
                        } else {
                            attrs.d = `M${start.x} ${start.y} H${(start.x + end.x) / 2} V${end.y} L${end.x} ${end.y}`;
                        }


                        this.view.add('path', this.container, attrs);
                        attrs.fill = attrs.stroke;
                        attrs.d = `M${end.x} ${end.y} l-5 -2 v4 Z`;
                        this.view.add('path', this.container, attrs);

                        if (this.getData('show labels')) {
                            labels.push({
                                text: link.from.name, x: mid.x, y: mid.y, colour: attrs.stroke, opacity: linkOpacity,
                            });
                        }
                    });

                    unresolved.forEach((input, i) => {
                        const y = this.height + (i - unresolved.length) * this.lineHeight;
                        const linkNode = Core.find((node) => node.name === `->${input.node.name}(${input.name})`);
                        const linkOpacity = get(linkNode, 'opacity') ?? opacity ?? 0.8;
                        const attrs = { fill: 'none', stroke: get(linkNode, 'colour') ?? 'red', d: '', 'stroke-opacity': opacity ?? 0.5, 'fill-opacity': opacity ?? 0.5, };
                        const toShape = input.node[symbols.viewData].get(this.view).shape;
                        const end = {
                            x: toShape.box.x + toShape.x, y: toShape.y + toShape.box.y + toShape.height *
                                (node[symbols.views][this.view.title].inputs.indexOf(input) + 1) /
                                (node[symbols.views][this.view.title].inputs.length + 1),
                        };
                        const cy = (end.y > this.height / 2) ? y : this.height - y;
                        const start = {
                            x: get(linkNode, 'x') ?? end.x - 60,
                            y: get(linkNode, 'y') ?? cy
                        };

                        if (get(linkNode, 'points')) {
                            attrs.d = `M${start.x} ${start.y} `;
                            attrs.d += get(linkNode, 'points').map((point) => `L${point.x} ${point.y}`).join(' ');
                            attrs.d += ` L${end.x} ${end.y}`;
                        } else if (get(linkNode, 'curve')) {
                            attrs.d = `M${start.x} ${start.y} C${start.x + 50} ${start.y} ${end.x - 50} ${end.y} ${end.x} ${end.y}`;
                        } else {
                            attrs.d = `M${start.x} ${start.y} H${(start.x + end.x) / 2} V${end.y} L${end.x} ${end.y}`;
                        }
                        this.view.add('path', this.container, attrs);
                        attrs.fill = attrs.stroke;
                        attrs.d = `M${end.x} ${end.y} l-5 -2 v4 Z`;
                        this.view.add('path', this.container, attrs);

                        labels.push({ text: input.name, x: start.x, y: cy, colour: 'red', anchor: 'end', opacity: linkOpacity, });
                    });

                    unused.forEach((output, i) => {
                        const y = this.height + (i - unresolved.length) * this.lineHeight;
                        const linkNode = Core.find((node) => node.name === `${output.node.name}->(${output.name})`);
                        const linkOpacity = get(linkNode, 'opacity') ?? opacity ?? 0.8;
                        const attrs = { fill: 'none', stroke: get(linkNode, 'colour') ?? 'orange', d: '', 'stroke-opacity': opacity ?? 0.5, 'fill-opacity': opacity ?? 0.5, };
                        const shape = node[symbols.viewData].get(this.view).shape;
                        const start = {
                            x: shape.box.x + shape.x + shape.width,
                            y: shape.y + shape.box.y + shape.height * (node[symbols.views][this.view.title].outputs.indexOf(output) + 1) / totalOutputs,
                        };

                        const end = {
                            x: get(linkNode, 'x') ?? start.x + 60, 
                            y: get(linkNode, 'y') ?? y,
                        };
                        const mid = (start.x + end.x) / 2;

                        attrs.d = `M${start.x} ${start.y} C${start.x + 50} ${start.y} ${end.x - 50} ${end.y} ${end.x} ${end.y}`;
                        this.view.add('path', this.container, attrs);
                        attrs.fill = attrs.stroke;
                        attrs.d = `M${end.x} ${end.y} l-5 -2 v4 Z`;
                        this.view.add('path', this.container, attrs);

                        labels.push({ text: output.name, x: end.x, y, colour: 'orange', anchor: 'start', opacity: linkOpacity, });
                    });
                });
                labels.forEach(drawLabel);
            }
            connectionPoint(position) {
                const x = 0
                const y = 0;
                const w = this.box.width;
                const h = this.box.height;

                const points = [{ x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h }, { x: x, y: y }];

                return this.linePoint(points, position);
            }
        }

        class SVGCircle extends SVGShape {
            static name = 'circle';

            constructor(view, node) {
                super(view, node);
            }

            draw() {
                const attrs = {
                    cx: this.cx,
                    cy: this.cy,
                    r: this.radius,
                    fill: this.fill, stroke: this.stroke,
                };
                const svgElement = this.view.add('circle', this.container, attrs);
                this.addText();
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);
            }
            get cx() {
                return this.x + this.width / 2;
            }
            get cy() {
                return this.y + this.height / 2;
            }
            get radius() {
                return validateNumber(this.getData('radius'), this.width / 2);
            }
            connectionPoint(position) {
                const angle = Math.PI * (position - 0.5) / 2;
                return {
                    x: this.cx + this.radius * Math.sin(angle),
                    y: this.cy - this.radius * Math.cos(angle),
                };
            }
        }

        class SVGEllipse extends SVGShape {
            static name = 'ellipse';

            constructor(view, node) {
                super(view, node);
            }
            draw() {
                const attrs = {
                    cx: this.cx,
                    cy: this.cy,
                    rx: this.xRadius, ry: this.yRadius,
                    fill: this.fill, stroke: this.stroke,
                };
                const svgElement = this.view.add('ellipse', this.container, attrs);
                this.addText();
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);
            }
            get cx() {
                return this.x + this.width / 2;
            }
            get cy() {
                return this.y + this.height / 2;
            }
            get xRadius() {
                return validateNumber(this.getData('x radius'), this.width / 2);
            }
            get yRadius() {
                return validateNumber(this.getData('y radius'), this.height / 2);
            }
            connectionPoint(position) {
                const angle = Math.PI * (position - 0.5) / 2;
                return {
                    x: this.cx + this.xRadius * Math.sin(angle),
                    y: this.cy - this.yRadius * Math.cos(angle),
                };
            }

        }

        class SVGDiamond extends SVGShape {
            static name = 'diamond';

            constructor(view, node) {
                super(view, node);
            }

            draw() {
                const x1 = this.x;
                const y1 = this.y;
                const x2 = this.x + this.width / 2;
                const y2 = this.y + this.height / 2;
                const x3 = this.x + this.width;
                const y3 = this.y + this.height;
                const attrs = {
                    d: `M${x1} ${y2} L${x2} ${y1} L${x3} ${y2} L${x2} ${y3} Z`,
                    fill: this.fill, stroke: this.stroke,
                };
                const svgElement = this.view.add('path', this.container, attrs);
                this.addText();
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);

            }
            connectionPoint(position) {
                const x1 = this.viewData('x');
                const y1 = this.viewData('y');
                const x2 = this.viewData('x') + this.viewData('width') / 2;
                const y2 = this.viewData('y') + this.viewData('height') / 2;
                const x3 = this.viewData('x') + this.viewData('width');
                const y3 = this.viewData('y') + this.viewData('height');
                const points = [{ x: x1, y: y2 }, { x: x2, y: y1 }, { x: x3, y: y2 }, { x: x2, y: y3 }, { x: x1, y: y2 }];
                return this.linePoint(points, position + 0.5);
            }
        }

        class SVGMilestone extends SVGShape {
            static name = 'milestone';

            constructor(view, node) {
                super(view, node);
            }
            draw() {
                const x1 = this.x - this.height / 2;
                const y1 = this.y;
                const x2 = this.x;
                const y2 = this.y + this.height / 2;
                const x3 = this.x + this.height / 2;
                const y3 = this.y + this.height;
                const attrs = {
                    d: `M${x1} ${y2} L${x2} ${y1} L${x3} ${y2} L${x2} ${y3} Z`,
                    fill: this.fill, stroke: this.stroke,
                };
                const backgroundAttrs = {
                    x: x2, y: y1 - 2, height: Math.max(this.height, this.lineHeight) + 2, width: 10, rx: this.height / 2,
                    fill: this.fill, stroke: 'none',
                };
                const background = this.view.add('rect', this.container, backgroundAttrs);
                const svgElement = this.view.add('path', this.container, attrs);
                const text = this.addText();
                backgroundAttrs.width = text.getComputedTextLength() + this.width + 2;
                this.view.updateElement(background, backgroundAttrs);
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);
                this.box.width = text.getComputedTextLength() + this.width * 2;
            }
            connectionPoint(position) {
                const x1 = this.viewData('x');
                const y1 = this.viewData('y');
                const x2 = this.viewData('x') + this.viewData('width') / 2;
                const y2 = this.viewData('y') + this.viewData('height') / 2;
                const x3 = this.viewData('x') + this.viewData('width');
                const y3 = this.viewData('y') + this.viewData('height');
                const points = [{ x: x1, y: y2 }, { x: x2, y: y1 }, { x: x3, y: y2 }, { x: x2, y: y3 }, { x: x1, y: y2 }];
                return this.linePoint(points, position + 0.5);
            }
        }

        class SVGStar extends SVGShape {
            static name = 'star';

            constructor(view, node) {
                super(view, node);
            }
            draw() {
                const x1 = this.x - this.height / 2;
                const y1 = this.y;
                const x2 = this.x;
                const y2 = this.y + this.height / 2;
                const x3 = this.x + this.height / 2;
                const y3 = this.y + this.height;
                const attrs = {
                    d: '',
                    fill: this.fill, stroke: this.stroke,
                };
                const points = 5;
                for (let i = 0; i < (points * 2); ++i) {
                    const radius = i % 2 ? (this.height / 2) : (this.height / 5);
                    const angle = Math.PI * i / points;
                    const x = this.x + this.height / 2 + radius * Math.sin(angle);
                    const y = this.y + this.height / 2 + radius * Math.cos(angle);
                    if (i === 0) {
                        attrs.d += `M${x} ${y}`;
                    } else {
                        attrs.d += `L${x} ${y}`;
                    }
                }
                attrs.d += 'Z';
                const backgroundAttrs = {
                    x: x2, y: y1 - 2, height: Math.max(this.height, this.lineHeight) + 2, width: 10, rx: this.height / 2,
                    fill: this.fill, stroke: 'none',
                };
                //const background = this.view.add('rect', this.container, backgroundAttrs);
                const svgElement = this.view.add('path', this.container, attrs);
                const text = this.addText();
                //backgroundAttrs.width = text.getComputedTextLength() + this.width + 2;
                //this.view.updateElement(background, backgroundAttrs);
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);
                this.box.width = text.getComputedTextLength() + this.width * 2;
            }
            connectionPoint(position) {
                const x1 = this.viewData('x');
                const y1 = this.viewData('y');
                const x2 = this.viewData('x') + this.viewData('width') / 2;
                const y2 = this.viewData('y') + this.viewData('height') / 2;
                const x3 = this.viewData('x') + this.viewData('width');
                const y3 = this.viewData('y') + this.viewData('height');
                const points = [{ x: x1, y: y2 }, { x: x2, y: y1 }, { x: x3, y: y2 }, { x: x2, y: y3 }, { x: x1, y: y2 }];
                return this.linePoint(points, position + 0.5);
            }
        }


        class SVGParallelogram extends SVGShape {
            static name = 'parallelogram';

            constructor(view, node) {
                super(view, node);
            }

            draw(container, node) {
                const x1 = this.x;
                const x2 = this.x + (validateNumber(this.getData('offset'), 10));
                const x3 = this.x + this.width;
                const x4 = this.x + this.width - (validateNumber(this.getData('offset'), 10));
                const y1 = this.y;
                const y2 = this.y + this.height;
                const attrs = {
                    d: `M${x2} ${y1} L${x3} ${y1} L${x4} ${y2} L${x1} ${y2} Z`,
                    fill: this.fill, stroke: this.stroke,
                };
                const svgElement = this.view.add('path', this.container, attrs);
                this.addText();
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);

            }
            connectionPoint(position) {
                const x1 = this.x;
                const x2 = this.x + (validateNumber(this.getData('offset'), 10));
                const x3 = this.x + this.width;
                const x4 = this.x + this.width - (validateNumber(this.getData('offset'), 10));
                const y1 = this.y;
                const y2 = this.y + this.height;
                const points = [{ x: x2, y: y1 }, { x: x3, y: y1 }, { x: x4, y: y2 }, { x: x1, y: y2 }, { x: x2, y: y1 }];
                return this.linePoint(points, position);
            }
        }

        class SVGTrapezoid extends SVGShape {
            static name = 'trapezoid';

            constructor(view, node) {
                super(view, node);
            }

            draw() {
                const x1 = this.x;
                const x2 = this.x + (validateNumber(this.getData('offset'), 10));
                const x3 = this.x + this.width;
                const x4 = this.x + this.width - (validateNumber(this.getData('offset'), 10));
                const y1 = this.y;
                const y2 = this.y + this.height;
                const attrs = {
                    d: `M${x2} ${y1} L${x4} ${y1} L${x3} ${y2} L${x1} ${y2} Z`,
                    fill: this.fill, stroke: this.stroke,
                };
                const svgElement = this.view.add('path', this.container, attrs);
                this.addText();
                svgElement.addEventListener('click', (event) => clickNode(this.node, event));
                svgElement.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(svgElement);
            }
            connectionPoint(position) {
                const x1 = this.x;
                const x2 = this.x + (validateNumber(this.getData('offset'), 10));
                const x3 = this.x + this.width;
                const x4 = this.x + this.width - (validateNumber(this.getData('offset'), 10));
                const y1 = this.y;
                const y2 = this.y + this.height;
                const points = [{ x: x2, y: y1 }, { x: x4, y: y1 }, { x: x3, y: y2 }, { x: x1, y: y2 }, { x: x2, y: y1 }];
                return this.linePoint(points, position);
            }
        }

        class SVGPie extends SVGShape {
            static name = 'pie chart';

            constructor(view, node) {
                super(view, node);
            }
            get width() {
                return 2 * (validateNumber(this.getData('radius'), 50));
            }
            get height() {
                return 2 * (validateNumber(this.getData('radius'), 50));
            }
            draw() {
                const group = this.view.add('g', this.container);

                const controls = {
                    countAll: this.getData('count all'),
                    count: this.getData('count'),
                    data: this.getData('data') ?? 'value',
                }

                const values = {};
                if (controls.countAll) {
                    const stack = [...this.node[symbols.content]];
                    const nodes = [];
                    while (stack.length) {
                        const node = stack.shift();
                        stack.push(...node[symbols.content]);
                    }
                    nodes.forEach((node) => {
                        const value = node[controls.countAll];
                        values[value] = validateNumber(values[value], 0);
                        values[value] += 1;
                    });
                } else if (controls.count) {
                    const nodes = this.node[symbols.content];
                    nodes.forEach((node) => {
                        const value = node[controls.count];
                        values[value] = validateNumber(values[value], 0);
                        values[value] += 1;
                    });
                } else {
                    const nodes = this.node[symbols.content];
                    nodes.forEach((node) => {
                        const value = node.name;
                        values[value] = validateNumber(values[value], 0);
                        values[value] += node[controls.data];
                    });
                }

                const r = validateNumber(this.getData('radius'), 50);
                const keys = Object.keys(values);

                if (keys.length) {
                    const total = keys.reduce((sum, key) => sum += values[key] || 0, 0);
                    let angle = -Math.PI / 2;
                    if (this.getData('sort')) {
                        key.sort((a, b) => values[key] - values[key]);
                    }
                    const attrs = { stroke: this.getData('line') ?? 'black' };
                    keys.forEach((key) => {
                        attrs.fill = `hsl(${angle}rad 50% 50%)`;
                        const span = 2 * values[key] * Math.PI / total;
                        const x1 = r * (1 + Math.sin(angle));
                        const y1 = r * (1 + Math.cos(angle));
                        const x2 = r * (1 + Math.sin(angle + span));
                        const y2 = r * (1 + Math.cos(angle + span));

                        attrs.d = `M ${x1} ${y1} A${r} ${r} 0 ${span > Math.PI ? 1 : 0} 0 ${x2} ${y2} L${r} ${r} Z`;
                        angle += span;

                        this.view.add('path', group, attrs);
                    });
                }
                this.addText();
                group.addEventListener('click', (event) => clickNode(this.node, event));
                group.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(group);
            }
        }

        class SVGPlot extends SVGShape {
            static name = 'xy plot';

            constructor(view, node) {
                super(view, node);
            }

            draw() {
                const group = this.view.add('g', this.container);

                const xProperty = this.getData('x data') ?? 'x';
                const yProperty = this.getData('y data') ?? 'y';

                const nodes = this.node[symbols.content].filter((node) =>
                    (node[xProperty] !== undefined) && (node[xProperty] !== undefined));

                const width = validateNumber(this.getData('width'), 100);
                const height = validateNumber(this.getData('height'), 100);
                const xOrigin = validateNumber(this.getData('x origin'), 0);
                const yOrigin = validateNumber(this.getData('y origin'), 0);
                if (nodes.length) {
                    const xMin = xOrigin === '*' ? Math.min(...nodes.map((node) => node[xProperty])) : (xOrigin || 0);
                    const xMax = Math.max(...nodes.map((node) => node[xProperty]));
                    const yMin = yOrigin === '*' ? Math.min(...nodes.map((node) => node[yProperty])) : (yOrigin || 0);
                    const yMax = Math.max(...nodes.map((node) => node[yProperty]));

                    if (this.getData('sort')) {
                        nodes.sort((a, b) => a[sort] - b[sort]);
                    }

                    const lineAttrs = {
                        fill: 'none', stroke: this.getData('line') ?? 'black', d: '',
                    }
                    const points = nodes.map((node, i) => {
                        const x = width * (node[xProperty] - xMin) / (xMax - xMin);
                        const y = height * (1 - ((node[yProperty] - yMin) / (yMax - yMin)));
                        lineAttrs.d += (i ? 'L' : 'M') + `${x} ${y}`;
                    });
                    this.view.add('path', group, lineAttrs);
                }
                this.addText();
                group.addEventListener('click', (event) => clickNode(this.node, event));
                group.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(group);
            }
        }

        class SVGChart extends SVGShape {
            static name = 'line chart';

            constructor(view, node) {
                super(view, node);
            }

            draw() {
                const group = this.view.add('g', this.container);

                const property = this.getData('data') ?? 'value';
                const nodes = this.node[symbols.content].filter((node) => node[property] !== undefined);

                const width = validateNumber(this.getData('width'), 100);
                const height = validateNumber(this.getData('height'), 60);
                const blockWidth = width / nodes.length;

                const max = Math.max(...nodes.map((node) => node[property]));
                if (this.getData('sort')) {
                    nodes.sort((a, b) => b[sort] - a[sort]);
                }

                const lineAttrs = {
                    fill: 'none', stroke: this.getData('line') ?? 'black', d: '',
                }
                const points = nodes.map((node, i) =>
                    lineAttrs.d += (i ? 'L' : 'M') + `${(i + 0.5) * blockWidth} ${height * (1 - node[property] / max)}`);

                this.view.add('path', group, lineAttrs);
                this.addText();
                group.addEventListener('click', (event) => clickNode(this.node, event));
                group.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(group);
            }
        }

        class SVGHistogram extends SVGShape {
            static name = 'histogram';

            constructor(view, node) {
                super(view, node);
                console.log('histogram constructor');
            }

            draw() {
                const property = this.getData('data') ?? 'value';
                const group = this.view.add('g', this.container);

                const width = validateNumber(this.getData('width'), 100);
                const height = validateNumber(this.getData('height'), 60);
                const nodes = this.node[symbols.content].filter((node) => node[property] !== undefined);
                const blockWidth = width / nodes.length;
                const max = Math.max(...nodes.map((node) => node[property]));

                if (this.getData('sort')) {
                    nodes.sort((a, b) => b[property] - a[property]);
                }
                const labelAttrs = {
                    textAlign: 'end',
                    baseline: 'middle',
                };
                const stroke = this.getData('line') ?? 'black';
                const xOrigin = this.getData('x');
                nodes.forEach((node, i) => {
                    const attrs = {
                        fill: `hsl(${2 * Math.PI * i / nodes.length}rad 50% 50%)`, stroke,
                        x: i * blockWidth, y: height * (1 - node[property] / max),
                        width: blockWidth, height: height * node[property] / max,
                    };

                    this.view.add('rect', group, attrs);
                });
                this.addText();
                group.addEventListener('click', (event) => clickNode(this.node, event));
                group.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
                this.viewData('svgNodes').push(group);
            }
        }

        class SVGLink extends SVGShape {
            static name = 'link';

            constructor(view, node) {
                super(view, node);
                this.label = this.getData(this.getData('label property'));
            }
            addArrow(attrs, point, direction, size) {
                const radius = size / 2;
                const angle = Math.PI * (-direction) / 2;
                const x1 = size * Math.sin(angle);
                const y1 = size * Math.cos(angle);
                const x2 = size * Math.sin(angle + Math.PI / 2);
                const y2 = size * Math.cos(angle + Math.PI / 2);

                attrs.d += `M${point.x - x1 + x2 / 3} ${point.y - y1 + y2 / 3} l${x1 - x2 / 3} ${y1 - y2 / 3} l${-x1 - x2 / 3} ${-y1 - y2 / 3} l${2 * x2 / 3} ${2 * y2 / 3}`;
            }
            addArrow2(attrs, point, direction, size) {
                const radius = size / 2;
                const angle = Math.PI * (2 - direction) / 2;
                const x1 = size * Math.sin(angle);
                const y1 = size * Math.cos(angle);
                const x2 = size * Math.sin(angle + Math.PI / 2);
                const y2 = size * Math.cos(angle + Math.PI / 2);

                attrs.d += `M${point.x + x2 / 3} ${point.y + y2 / 3} l${x1 - x2 / 3} ${y1 - y2 / 3} l${-x1 - x2 / 3} ${-y1 - y2 / 3} l${2 * x2 / 3} ${2 * y2 / 3}`;
            }
            addBox(attrs, point, direction, size) {
                const points = 4;
                const step = Math.PI * 2 / points;
                const offset = step / 2;
                const radius = size / 2;
                const angle = Math.PI * (2 - direction) / 2;
                const cx = point.x + radius * Math.cos(offset) * Math.sin(angle);
                const cy = point.y + radius * Math.cos(offset) * Math.cos(angle);
                const x = cx + radius * Math.sin(angle + Math.PI + offset);
                const y = cy + radius * Math.cos(angle + Math.PI + offset);
                attrs.d += ` M${x} ${y}`;
                for (let i = 0; i < points; ++i) {
                    const x = cx + radius * Math.sin(angle + Math.PI + offset + (i + 1) * step);
                    const y = cy + radius * Math.cos(angle + Math.PI + offset + (i + 1) * step);
                    attrs.d += ` L${x} ${y}`;
                }
            }
            addBox2(attrs, point, direction, size) {
                const points = 4;
                const step = Math.PI * 2 / points;
                const offset = step / 2;
                const radius = size / 2;
                const angle = Math.PI * (2 - direction) / 2;
                const x = point.x + radius * Math.sin(angle + offset - step);
                const y = point.y + radius * Math.cos(angle + offset - step);
                attrs.d += ` M${x} ${y}`;
                for (let i = 0; i < points; ++i) {
                    const x = point.x + radius * Math.sin(angle + offset + i * step);
                    const y = point.y + radius * Math.cos(angle + offset + i * step);
                    attrs.d += ` L${x} ${y}`;
                }
            }
            addDiamond(attrs, point, direction, size) {
                const points = 4;
                const step = Math.PI * 2 / points;
                const offset = step / 2;
                const radius = size / 2;
                const angle = Math.PI * (2 - direction) / 2;
                const cx = point.x + radius * Math.sin(angle);
                const cy = point.y + radius * Math.cos(angle);
                const x = cx + radius * Math.sin(angle + Math.PI);
                const y = cy + radius * Math.cos(angle + Math.PI);
                attrs.d += ` M${x} ${y}`;
                for (let i = 0; i < points; ++i) {
                    const x = cx + radius * Math.sin(angle + Math.PI + (i + 1) * step);
                    const y = cy + radius * Math.cos(angle + Math.PI + (i + 1) * step);
                    attrs.d += ` L${x} ${y}`;
                }
            }
            addDiamond2(attrs, point, direction, size) {
                const points = 4;
                const step = Math.PI * 2 / points;
                const offset = step / 2;
                const radius = size / 2;
                const angle = Math.PI * (2 - direction) / 2;
                const x = point.x + radius * Math.sin(angle - step);
                const y = point.y + radius * Math.cos(angle - step);
                attrs.d += ` M${x} ${y}`;
                for (let i = 0; i < points; ++i) {
                    const x = point.x + radius * Math.sin(angle + i * step);
                    const y = point.y + radius * Math.cos(angle + i * step);
                    attrs.d += ` L${x} ${y}`;
                }
            }
            addCircle(attrs, point, direction, size) {
                const radius = size / 2;
                const radius2 = size / 200;
                const angle = Math.PI * (3 - direction) / 2;
                const x1 = point.x + radius2 * Math.sin(angle);
                const y1 = point.y + radius2 * Math.cos(angle);
                const x2 = point.x + radius2 * Math.sin(angle + Math.PI);
                const y2 = point.y + radius2 * Math.cos(angle + Math.PI);
                attrs.d += ` M${x1} ${y1} A${radius} ${radius} 0 1 1 ${x2} ${y2}`;
            }
            addCircle2(attrs, point, direction, size) {
                const radius = size / 2;
                const angle = Math.PI * (2 - direction) / 2;
                const x1 = point.x + radius * Math.sin(angle);
                const y1 = point.y + radius * Math.cos(angle);
                const x2 = point.x + radius * Math.sin(angle + Math.PI / 100);
                const y2 = point.y + radius * Math.cos(angle + Math.PI / 100);
                attrs.d += ` M${x1} ${y1} A${radius} ${radius} 0 1 1 ${x2} ${y2}`;
            }
            addSemiCircle(attrs, point, direction, size) {
                const radius = size / 2;
                const angle = Math.PI * (3 - direction) / 2;
                const x1 = point.x + radius * Math.sin(angle);
                const y1 = point.y + radius * Math.cos(angle);
                const x2 = point.x + radius * Math.sin(angle + Math.PI);
                const y2 = point.y + radius * Math.cos(angle + Math.PI);
                attrs.d += ` M${x1} ${y1} A${radius} ${radius} 0 1 1 ${x2} ${y2}`;
            }
            draw() {
                const startNode = this.getData('start');
                const endNode = this.getData('end');
                if (startNode && endNode && (startNode !== endNode) && startNode[symbols.source] && endNode[symbols.source]) {
                    const getData = (node) => node[symbols.viewData].get(this.view);
                    const startAncestors = getAncestors(startNode);
                    const endAncestors = getAncestors(endNode);
                    let index = 0;
                    while (startAncestors[index] === endAncestors[index]) {
                        ++index;
                    }
                    const start = getData(startNode).shape.connectionPoint(validateNumber(this.getData('start position'), 2.5));
                    const end = getData(endNode).shape.connectionPoint(validateNumber(this.getData('end position'), 0.5));
                    const attrs = { d: '', fill: 'none', stroke: this.stroke };
                    let commonAncestor = this.view.context;
                    if (index > 0) {
                        let startIndex = index;
                        while (startIndex < startAncestors.length) {
                            start.x += getData(startAncestors[startIndex])?.shape.box?.x ?? 0;
                            start.y += getData(startAncestors[startIndex])?.shape.box?.y ?? 0;
                            ++startIndex;
                        }
                        let endIndex = index;
                        while (endIndex < endAncestors.length) {
                            end.x += getData(endAncestors[endIndex])?.shape.box?.x ?? 0;
                            end.y += getData(endAncestors[endIndex])?.shape.box?.y ?? 0;
                            ++endIndex;
                        }
                        commonAncestor = getData(startAncestors[index - 1])?.svgNodes[0] ?? this.view.context;
                    } else {
                        start.x += this.view.configuration.columnGap;
                        start.y += this.view.configuration.rowGap;
                        end.x += this.view.configuration.columnGap;
                        end.y += this.view.configuration.rowGap;

                        startAncestors.forEach((ancestor) => {
                            start.x += getData(ancestor)?.shape.box?.x ?? 0;
                            start.y += getData(ancestor)?.shape.box?.y ?? 0;
                        });
                        endAncestors.forEach((ancestor) => {
                            end.x += getData(ancestor)?.shape.box?.x ?? 0;
                            end.y += getData(ancestor)?.shape.box?.y ?? 0;
                        });
                    }
                    const group = this.view.add('g', commonAncestor);
                    const startDirection = Math.floor(Math.abs(validateNumber(this.getData('start position'), 2.5))) % 4;
                    const endDirection = Math.floor(Math.abs(validateNumber(this.getData('end position'), 0.5))) % 4;
                    const sd = {
                        x: (startDirection % 2) * (2 - startDirection),
                        y: (1 - (startDirection % 2)) * (startDirection - 1),
                    };
                    const ed = {
                        x: (endDirection % 2) * (2 - endDirection),
                        y: (1 - (endDirection % 2)) * (endDirection - 1),
                    };

                    attrs.d = `M${start.x} ${start.y}`;
                    const path = this.getData('path');
                    if (path) {
                        const points = path.reduce((list, point, index) => {
                            if (index % 2) {
                                list[(index - 1) / 2][1] = point;
                            } else {
                                list.push([point]);
                            }
                            return list;
                        }, []);
                        let direction = Math.abs(sd.x);
                        attrs.d += points.map((point) =>
                            sd.x ? `H${point[0]} V${point[1]}` : `V${point[1]} H${point[0]}`).join(' ');
                        attrs.d += ed.x ? ` V${end.y} ` : ` H${end.x} `;
                    } else {
                        if (startDirection === endDirection) {
                            if (startDirection === 0) {
                                attrs.d += `V${Math.min(start.y, end.y) - 50} H${end.x}`;
                            } else if (startDirection === 1) {
                                attrs.d += `H${Math.max(start.x, end.x) + 50} V${end.y}`;
                            } else if (startDirection === 2) {
                                attrs.d += `V${Math.min(start.y, end.y) + 50} H${end.x}`;
                            } else {
                                attrs.d += `H${Math.min(start.x, end.x) - 50} V${end.y}`;
                            }
                        } else {
                            if ((startDirection + endDirection) % 2) {
                                if (sd.x) {
                                    if ((end.x - start.x) * sd.x) {
                                        attrs.d += `H${end.x}`;
                                    } else {

                                    }
                                } else {
                                    if ((end.y - start.y) * sd.y) {
                                        attrs.d += `V${end.y}`;
                                    } else {

                                    }
                                }
                            } else {
                                if (sd.x) {
                                    if ((end.x - start.x) * sd.x) {
                                        attrs.d += `H${(start.x + end.x) / 2} V${end.y}`;
                                    } else {

                                    }
                                } else {
                                    if ((end.y - start.y) * sd.y) {
                                        attrs.d += `V${(start.y + end.y) / 2} H${end.x}`;
                                    } else {

                                    }
                                }
                            }
                        }
                    }
                    attrs.d += `L${end.x} ${end.y}`;
                    const endStyles = {
                        arrow: this.addArrow,
                        arrow2: this.addArrow2,
                        box: this.addBox,
                        box2: this.addBox2,
                        diamond: this.addDiamond,
                        diamond2: this.addDiamond2,
                        circle: this.addCircle,
                        circle2: this.addCircle2,
                        'semi-circle': this.addSemiCircle,
                    };
                    const startStyle = endStyles[this.getData('start style')];
                    if (startStyle) {
                        const endAttrs = Object.assign({}, attrs, { d: '' });
                        endAttrs.fill = this.getData('start colour') ?? this.getData('line') ?? 'black';
                        startStyle(endAttrs, start, startDirection, validateNumber(this.getData('start size'), 10));
                        this.view.add('path', commonAncestor, endAttrs);
                    }
                    const endStyle = endStyles[this.getData('end style')];
                    if (endStyle) {
                        const endAttrs = Object.assign({}, attrs, { d: '' });
                        endAttrs.fill = this.getData('end colour') ?? this.getData('line') ?? 'black';
                        endStyle(endAttrs, end, endDirection, validateNumber(this.getData('end size'), 10));
                        this.view.add('path', commonAncestor, endAttrs);
                    }
                    if (this.label) {
                        const attrs = {
                            x: 0, y: 0, width: 10, height: this.lineHeight * 1.4, rx: this.lineHeight / 2, ry: this.lineHeight / 2,
                            fill: 'white', stroke: this.stroke
                        };
                        const background = this.view.add('rect', commonAncestor, attrs);
                        let x, y;

                        const pts = (this.getData('path') ?? []).reduce((points, point, index) => {
                            if (index % 2) {
                                points[points.length - 1].y = point;
                            } else {
                                points.push({ x: point });
                            }
                            return points;
                        }, []);
                        const points = [];

                        points.unshift(start);
                        pts.forEach((point, i) =>
                            sd.x ? points.push({ x: point.x, y: points[points.length - 1].y }, point) :
                                points.push({ x: points[points.length - 1].x, y: point.y }, point));
                        ed.x ? points.push({ x: points[points.length - 1].x, y: end.y }) :
                            points.push({ x: end.x, y: points[points.length - 1].y });
                        points.push(end);

                        const lengths = [];
                        points.forEach((p, i) =>
                            i ? lengths.push(Math.hypot(p.x - points[i - 1].x, p.y - points[i - 1].y)) : '');
                        const total = lengths.reduce((sum, length) => sum + length, 0);
                        let i = 0;
                        let dist = 0;
                        while (dist < total / 2) {
                            if (dist + lengths[i] > total / 2) {
                                const p = (total / 2 - dist) / lengths[i];
                                x = points[i].x + p * (points[i + 1].x - points[i].x);
                                y = points[i].y + p * (points[i + 1].y - points[i].y);
                            }
                            dist += lengths[i];
                            ++i;
                        }

                        if (this.getData('tx')) {
                            x = this.getData('ty');
                        }
                        if (this.getData('ty')) {
                            y = this.getData('ty');
                        }
                        const textAttrs = {
                            x, y, fill: this.stroke, 'text-anchor': 'middle', 'dominant-baseline': 'middle',
                        }
                        const text = this.view.add('text', commonAncestor, textAttrs, this.label);
                        const length = text.getComputedTextLength();
                        attrs.width = length + this.lineHeight / 2;
                        attrs.x = x - attrs.width / 2;
                        attrs.y = y - this.lineHeight * 0.7;
                        this.view.updateElement(background, attrs);
                        if (this.getData('title property')) {
                            this.view.add('title', background, {}, this.getData(this.getData('title property')) ?? '');
                        }
                    }

                    /*
                    const control = (start, position) => {
                        const direction = Math.floor(Math.abs(position)) % 4;
                        if (direction === 0) {
                            return { x: start.x, y: start.y - 50 };
                        } else if (direction === 1) {
                            return { x: start.x + 50, y: start.y };
                        } else if (direction === 2) {
                            return { x: start.x, y: start.y + 50 };
                        }
                        return { x: start.x - 50, y: start.y };
                    }
                    const c1 = control(start, this.getData('start position') ?? 2.5);
                    const c2 = control(end, this.getData('end position') ?? 0.5);
                    
                    //attrs.d = `M${start.x} ${start.y} L${end.x} ${end.y}`;
                    attrs.d = `M${start.x} ${start.y} C${c1.x} ${c1.y} ${c2.x} ${c2.y} ${end.x} ${end.y}`;
                    */
                    this.view.add('path', group, attrs);
                }
            }
        }

        class SVG extends SVGShape {
            static name = 'svg';

            constructor(view, node) {
                super(view, node);
            }

            draw() {
                const source = this.getData('source');
                const nodes = this.viewData('svgNodes');

                const container = this.view.add('g', this.container, { transform: `translate(${shape.x}, ${shape.y})` });
                nodes.push(container);
                if (source && source[symbols.content]) {
                    source[symbols.content].forEach((child) =>
                        nodes.push(this.view.add(child.name, container, child, child[symbols.content])));
                } else {
                    this.node[symbols.content].forEach((child) =>
                        nodes.push(this.view.add(child.name, container, child, child[symbols.content])));
                }
                container.addEventListener('click', (event) => clickNode(this.node, event));
                container.addEventListener('dblclick', (event) => this.view.dblClickNode(this.node, event));
            }
        }
        class SVGNone extends SVGShape {
            static name = 'none';

            constructor(view, node) {
                super(view, node);
            }
            get width() {
                return 0;
            }
            get height() {
                return 0;
            }

            draw() { }
            drawTreeLines() { }
        }

        /**
         * Get the start time / date of a node in milliseconds from epoch
         */
        function getStart(node, view) {
            const getProperty = (property) =>
                node[property] ?? node[symbols.views]?.[view.title]?.[property] ?? node[symbols.viewData].get(view)?.[property];
            const setStart = getProperty('start') ?? getProperty('earlyStart');
            if (setStart?.getTime) {
                return setStart.getTime();
            }
            const finish = getProperty('finish');
            const duration = getProperty('duration');
            if ((finish?.getTime) && (duration !== undefined)) {
                return finish.getTime() - duration * 24 * 60 * 60 * 1000;
            }
        }

        /**
         * Get the finish time / date of a node in milliseconds from epoch
         */
        function getFinish(node, view) {
            const proxy = makeProxy(node, view.title);
            const finish = proxy.finish;
            if (finish) {
                return finish.getTime();
            }
            /*

            const getProperty = (property) =>
                node[property] ?? node[symbols.views]?.[view.title]?.[property] ?? node[symbols.viewData].get(view)?.[property];
            const setStart = getProperty('start') ?? getProperty('earlyStart');
            if (setStart?.getTime) {
                return setStart.getTime();
            }
            const finish = getProperty('finish');
            const duration = getProperty('duration');
            if ((finish?.getTime) && (duration !== undefined)) {
                return finish.getTime() - duration * 24 * 60 * 60 * 1000;
            }*/
        }

        /**
         * Get the duration of a node in milliseconds
         */
        function getDuration(node, view) {
            const getProperty = (property) =>
                node[property] ?? node[symbols.views]?.[view?.title]?.[property] ?? node[symbols.viewData].get(view)?.[property];
            const setDuration = getProperty('duration');
            if (!isNaN(setDuration)) {
                return setDuration * 24 * 60 * 60 * 1000;
            }

            const start = getProperty('start');
            const finish = getProperty('finish');

            if ((start?.getTime) && (finish?.getTime)) {
                return finish.getTime() - start.getTime();
            }
        }

        /**
         * SVG representation of the tree
         */
        class SVGTreeDiagram extends SVGView {
            static defaults = {
                topMargin: 10,
                leftMargin: 10,
                rightMargin: 10,
                bottomMargin: 10,
                columnGap: 10,
                rowGap: 10,
                nodeContent(node) {
                    return [...node[symbols.content]];
                },
                nodeText(node) {
                    return node.name;
                },
            }
            constructor(title = 'Tree Diagram', structure, configuration = {}) {
                super(structure, title);
                for (const node of this.node.querySelectorAll('.tree')) {
                    node.classList.remove('tree');
                }
                this.vertical = true;
                document.body.append(this.node); // Temporarily add node to DOM so text measurement works
                this.configuration = Object.assign({}, SVGTreeDiagram.defaults, configuration);
                this.structure = structure || Core.structure;
                this.settings.layout.addEventListener('change', (event) => this.redraw());
                this.settings.connectorStyle.addEventListener('change', (event) => this.redraw());
                this.settings.maxHorizontalNodes.addEventListener('change', (event) => this.redraw());
            }
            redraw() {
                const matrix = this.context?.getCTM();

                this.svg.innerHTML = '';
                this.defs = this.add('defs', this.svg);

                this.render();
                if (matrix) {
                    const attrs = {
                        transform: `matrix(${matrix.a}, ${matrix.b}, ${matrix.c}, ${matrix.d}, ${matrix.e}, ${matrix.f})`,
                    };
                    this.updateElement(this.context, attrs);
                }
            }
            set structure(structure) {
                if (this.configuration) {
                    this._structure = structure;
                    this.redraw();
                }
            }
            set selectedNodes(selection) {
                // Set the roots as the selected nodes that are not descendants of other selected nodes
                const roots = [];
                selection.forEach((node) => {
                    const ancestors = getAncestors(node).slice(0, -1);
                    if (!ancestors.some((ancestor) => selection.includes(ancestor))) {
                        roots.push(node);
                    }
                })
                this.structure = roots;
            }
            set currentNode(node) {
                for (const svgNode of this.node.querySelectorAll('.selected')) {
                    svgNode.classList.remove('selected');
                }
                const data = node[symbols.viewData].get(this);
                if (data) {
                    data.svgNodes.forEach((node) => node.classList.add('selected'));
                }

                if (this.settings.scrollToCurrent.checked) {
                    const element = node[symbols.viewData]?.get(this)?.svgNodes[0];
                    if (element) {
                        const matrix = element.getCTM();
                        const box = element.getBBox();
                        const origin = new DOMPoint(box.x, box.y);
                        const position = origin.matrixTransform(matrix);
                        this.node.scroll({ left: position.x - 10, top: position.y - 10, behavior: 'smooth' });
                    }
                }
            }
            dblClickNode(node, event) {
                const expanded = node[symbols.viewData].get(this).expanded === false;

                const apply = (node) => {
                    node[symbols.viewData].get(this).expanded = expanded;
                    node[symbols.content].forEach(apply);
                }

                if (event.ctrlKey) {
                    apply(node);
                } else {
                    node[symbols.viewData].get(this).expanded = expanded;
                }
                this.redraw();
            }
            render() {
                this.context = this.add('g', this.svg);

                const getValue = (node, property) => node[symbols.views]?.[this.title]?.[property] ?? node[property];
                const lerp = (line, point) => line[0].x + (line[1].x - line[0].x) *
                    (point.y - line[0].y) / (line[1].y - line[0].y);

                const getOffset = (right, left) => {
                    let offset = 0;

                    if (right.length === 0) {
                        return 0;
                    }

                    let index1 = 0;
                    let index2 = 0;

                    while ((index1 < left.length) && (index2 < right.length)) {
                        if (left[index1].y < right[index2].y) {
                            if (index2) {
                                offset = Math.max(offset, lerp([right[index2 - 1], right[index2]], left[index1]) - left[index1].x);
                            }
                            ++index1;
                        } else if (right[index2].y < left[index1].y) {
                            if (index1) {
                                offset = Math.max(offset, right[index2].x - lerp([left[index1 - 1], left[index1]], right[index2]));
                            }
                            ++index2;
                        } else {
                            offset = Math.max(offset, right[index2].x - left[index1].x);
                            ++index2;
                            ++index1;
                        }
                    }

                    if (offset === -Infinity) {
                        return 0;
                    }
                    return offset + this.configuration.columnGap;
                };

                const root = {
                    [symbols.viewData]: new Map(),
                    [symbols.views]: { [this.title]: { layout: this.settings.layout.value, shape: 'none' } },
                    [symbols.content]: this._structure,
                }
                root[symbols.viewData].set(this, { nextY: this.configuration.rowGap, rowHeight: 0, height: 0, rightEdge: [] });

                const getData = (node) => node[symbols.viewData].get(this);

                SVGShape.clipCount = 0;
                const addNode = (node, parent) => {
                    const shape = getSVGShape(node, this);
                    const data = node[symbols.viewData].get(this);
                    if (data) {
                        data.shape = shape;
                        data.svgNodes = [];
                    } else {
                        node[symbols.viewData].set(this, { shape, svgNodes: [] });
                    }

                    const nodes = this.configuration.nodeContent(node).filter((node) => getValue(node, 'shape') !== 'hidden');
                    const proxy = makeProxy(node, this.title);

                    const container = shape.addContainer(parent);

                    if (getValue(node, 'closed') || (nodes.length === 0) || (getData(node).expanded === false)) {
                        shape.box.width = shape.width;
                        shape.box.height = shape.height;
                        shape.leftEdge = [{ x: 0, y: 0 }, { x: 0, y: shape.height }];
                        shape.rightEdge = [{ x: shape.width, y: 0 }, { x: shape.width, y: shape.height }];
                    } else if (shape.constructor.name === 'timeline') {
                        const nodes = [];
                        const spread = proxy.spread;
                        const stack = [...this.configuration.nodeContent(node)];
                        while (stack.length) {
                            const node = stack.shift();
                            if (getStart(node, this) && (getDuration(node, this) !== undefined)) {
                                nodes.push(node);
                            }
                            const children = [...this.configuration.nodeContent(node)];
                            stack.push(...children);
                        }
                        if (proxy['critical first']) {
                            nodes.sort((a, b) => a[symbols.views][this.title].float - b[symbols.views][this.title].float);
                        }
                        nodes.sort((a, b) => getStart(a, this) - getStart(b, this));
                        const scale = validateNumber(proxy.scale, 10) / (24 * 60 * 60 * 1000);
                        const now = new Date();
                        const start = proxy.start;
                        quantiseDate(start);
                        const x = (time) => (time - start.getTime()) * scale;
                        const positioned = [];

                        nodes.forEach((node) => {
                            const proxy = makeProxy(node, this.title);
                            const duration = (node[symbols.views][this.title].finish.getTime() - node[symbols.views][this.title].start.getTime());
                            const shape = getSVGShape(node, this);

                            const data = node[symbols.viewData].get(this);
                            if (data) {
                                data.shape = shape;
                                data.svgNodes = [];
                            } else {
                                node[symbols.viewData].set(this, { shape, svgNodes: [] });
                            }

                            shape.addContainer(container);

                            const box = shape.box;

                            if (proxy.y !== undefined) {
                                box.y = proxy.y + this.configuration.rowGap;
                                positioned.push(box);
                            }

                            shape.x = 0;
                            shape.y = 0;
                            box.height = shape.height ?? 60;

                            if (duration) {
                                node[symbols.views][this.title] = node[symbols.views][this.title] || {};
                                node[symbols.views][this.title].width = duration * scale;
                                box.width = duration * scale;
                                box.x = x(getStart(node, this));
                            } else {
                                if (node[symbols.content].length) {
                                    const nodes = node[symbols.content];
                                    const start = Math.min(...nodes.map((node) => getStart(node, this)));
                                    const finish = Math.max(...nodes.map((node) => getFinish(node, this)));
                                    box.x = x(start);
                                    box.width = x(finish) - x(start);
                                } else {
                                    box.width = shape.width + 100;
                                    const time = getStart(node, this);
                                    box.x = x(proxy.start.getTime());
                                }
                            }
                        });

                        const placeNode = (node, y=0) => {
                            const proxy = makeProxy(node, this.title);

                            const data = node[symbols.viewData].get(this);
                            data.scale = scale;
                            const box = data.shape.box;
                            //box.height = data.shape.height;
                            if (!positioned.includes(box)) {
                                box.y = y || 2 * this.configuration.rowGap;
                                //box.y = 2 * this.configuration.rowGap;

                                const overlapped = positioned.filter((existing) =>
                                    ((box.x + box.width) > existing.x) && (box.x < (existing.x + existing.width)));
                                overlapped.sort((a, b) => a.y - b.y);
                                if (spread) {
                                    box.y = Math.max(box.y, ...overlapped.map((box) => box.y + box.height));
                                } else {
                                    while (overlapped.filter((existing) => (box.y <= (existing.y + existing.height))
                                        && ((box.y + box.height) >= existing.y)).length) {
                                        box.y = Math.max(...overlapped.filter((existing) => (box.y <= (existing.y + existing.height))
                                            && ((box.y + box.height) >= existing.y)).map((existing) => existing.y + existing.height)) + this.configuration.rowGap;
                                    }
                                }
                                positioned.push(box);

                                data.shape.draw();
                                this.updateElement(data.shape.container, { transform: `translate(${box.x}, ${box.y})`, });
                                const links = node[symbols.views][this.title]?.outputs.flatMap((output) => output.links)
                                    .filter((link) => link.from.event === 'finish' && link.to && link.to !== node);
                                links.forEach((link) => placeNode(link.to.node, box.y));
                            } else {
                                data.shape.draw();
                                this.updateElement(data.shape.container, { transform: `translate(${box.x}, ${box.y})`, });
                            }

                            shape.box.width = Math.max((shape.box.width || 0), box.x + box.width + this.configuration.columnGap * 2);
                            shape.box.height = Math.max((shape.box.height || 0), box.y + box.height + this.configuration.rowGap * 2);
                        };
                        nodes.forEach(placeNode, 0);
                        shape.x = this.configuration.columnGap;
                        shape.y = this.configuration.rowGap;
                        shape.box.x = this.configuration.columnGap;
                        shape.box.y = this.configuration.rowGap;
                        shape.drawTreeLines(this.settings.connectorStyle.value);
                    } else if (shape.constructor.name === 'network') {
                        const nodes = [];
                        const spread = proxy.spread;
                        const stack = [...this.configuration.nodeContent(node)];
                        while (stack.length) {
                            const node = stack.shift();
                            if (getStart(node, this) && (getDuration(node, this) !== undefined)) {
                                nodes.push(node);
                            }
                            const children = [...this.configuration.nodeContent(node)];
                            stack.push(...children);
                        }
                        if (proxy['critical first']) {
                            nodes.sort((a, b) => a[symbols.views][this.title].float - b[symbols.views][this.title].float);
                        }
                        nodes.sort((a, b) => getStart(a, this) - getStart(b, this));
                        const positioned = [];

                        nodes.forEach((node) => {
                            const proxy = makeProxy(node, this.title);
                            const duration = (node[symbols.views][this.title].finish.getTime() - node[symbols.views][this.title].start.getTime());
                            const shape = getSVGShape(node, this);

                            const data = node[symbols.viewData].get(this);
                            if (data) {
                                data.shape = shape;
                                data.svgNodes = [];
                            } else {
                                node[symbols.viewData].set(this, { shape, svgNodes: [] });
                            }

                            shape.addContainer(container);
                            const box = shape.box;
                            if (proxy.x !== undefined) {
                                box.x = proxy.x;
                            }
                            if (proxy.y !== undefined) {
                                box.y = proxy.y + this.configuration.rowGap;
                                positioned.push(box);
                            }

                            shape.x = 0;
                            shape.y = 0;

                            if (duration) {
                                node[symbols.views][this.title] = node[symbols.views][this.title] || {};
                                box.width = proxy.width ?? 100;
                            } else {
                                if (node[symbols.content].length) {
                                    const nodes = node[symbols.content];
                                    const start = Math.min(...nodes.map((node) => getStart(node, this)));
                                    const finish = Math.max(...nodes.map((node) => getFinish(node, this)));
                                } else {
                                    const time = getStart(node, this);
                                }
                                box.width = proxy.width + 200;
                            }
                            node[symbols.views][this.title].width = proxy.width ?? 100;
                            //box.width = proxy.width ?? 100;
                            box.height = proxy.height ?? 60;
                        });

                        const spacing = proxy.spacing ?? 50;
                        const groups = [];

                        const getX = (node) => {
                            const shape = node[symbols.viewData].get(this).shape;
                            if (!shape.box.x) {
                                const inputs = node[symbols.views][this.title].inputs.flatMap((input) => input.links);
                                if (inputs.length) {
                                    shape.box.x = Math.max(...inputs.map((link) => getX(link.from.node) + link.from.node[symbols.viewData].get(this).shape.width)) + spacing;
                                } else {
                                    shape.box.x = 0;
                                }
                            }
                            return shape.box.x;
                        }
                        nodes.forEach(getX);

                        nodes.sort((a, b) => a[symbols.viewData].get(this).shape.box.x - b[symbols.viewData].get(this).shape.box.x);
                        const orderedNodes = [];//nodes.filter((node) => node[symbols.views][this.title].priority);
                        const orderNode = (node) => {
                            if (!orderedNodes.includes(node)) {
                                orderedNodes.push(node);
                                node[symbols.views][this.title].priority = node[symbols.views][this.title].priority ?? Infinity;
                                const outLinks = node[symbols.views][this.title]?.outputs.flatMap((output) => output.links)
                                    .filter((link) => link.to && link.to !== node);
                                outLinks.forEach((link) => orderNode(link.to.node));
                                const inLinks = node[symbols.views][this.title]?.inputs.flatMap((input) => input.links)
                                    .filter((link) => link.from && link.from !== node);
                                inLinks.forEach((link) => orderNode(link.from.node));
                            }
                        };
                        nodes.forEach((node) => orderNode(node));
                        orderedNodes.sort((a, b) => a[symbols.views][this.title].priority - b[symbols.views][this.title].priority);

                        orderedNodes.forEach((node) => {
                            const data = node[symbols.viewData].get(this);
                            const box = data.shape.box;
                            const matches = groups.filter((group) => ((box.x + box.width) > group.min) && (box.x < group.max));
                            if (matches.length === 0) {
                                groups.push({ min: box.x, max: box.x + box.width, nodes: [{ node, box }], });
                            } else if (matches.length === 1) {
                                matches[0].min = Math.min(matches[0].min, box.x);
                                matches[0].max = Math.max(matches[0].max, box.x + box.width);
                                matches[0].nodes.push({ node, box });
                            } else {
                                matches[0].min = Math.min(...matches.map((match) => match.min), box.x);
                                matches[0].max = Math.max(...matches.map((match) => match.max), box.x + box.width);
                                matches[0].nodes.push(...matches.slice(1).flatMap((match) => match.nodes), { node, box });
                                matches.slice(1).forEach((match) =>
                                    groups.splice(groups.indexOf(match), 1));
                            }
                        });

                        groups.forEach((group) => {
                            //group.height = group.nodes.reduce((sum, node) => sum + node.box.height, 0) + group.nodes.length * this.configuration.rowGap;
                            group.height = Math.max(...group.nodes.map((node) => node.box.y + node.box.height));
                        });
                        const maxHeight = Math.max(...groups.map((group) => group.height));
                        groups.forEach((group) => {
                            let y = (maxHeight - group.height) / 2;
                            group.nodes.forEach((node) => {
                                node.box.y = node.box.y || y;
                                const data = node.node[symbols.viewData].get(this);
                                data.shape.draw();
                                this.updateElement(data.shape.container, { transform: `translate(${node.box.x}, ${node.box.y})`, });
                                y = node.box.y + node.box.height + this.configuration.rowGap;
                            });
                        });
                        shape.box.width = Math.max(...groups.map((group) => group.max)) + this.configuration.columnGap * 2;
                        shape.box.height = shape.height;
                        
                        /*
                                                const placeNode = (node, y) => {
                                                    const data = node[symbols.viewData].get(this);
                                                    const box = data.shape.box;
                                                    box.height = data.shape.height;
                                                    if (!positioned.includes(box)) {
                        
                                                        box.y = y || 2 * this.configuration.rowGap;
                                                        const overlapped = positioned.filter((existing) =>
                                                            ((box.x + box.width) > existing.x) && (box.x < (existing.x + existing.width)));
                                                        overlapped.sort((a, b) => a.y - b.y);
                                                        if (spread) {
                                                            box.y = Math.max(box.y, ...overlapped.map((box) => box.y + box.height));
                                                        }
                                                        while (overlapped.length && ((overlapped[0].y + overlapped[0].height) < box.y)) {
                                                            overlapped.shift();
                                                        }
                                                        while (overlapped.length && (box.y <= (overlapped[0].y + overlapped[0].height))
                                                            && ((box.y + box.height) >= overlapped[0].y)) {
                                                            box.y = overlapped[0].y + overlapped[0].height + this.configuration.rowGap;
                                                            while (overlapped.length && (overlapped[0].y + overlapped[0].height) < box.y) {
                                                                overlapped.shift();
                                                            }
                                                        }
                                                        positioned.push(box);
                        
                                                        data.shape.draw();
                                                        this.updateElement(data.shape.container, { transform: `translate(${box.x}, ${box.y})`, });
                                                        const links = node[symbols.views][this.title]?.outputs.flatMap((output) => output.links)
                                                            .filter((link) => link.from.event === 'finish' && link.to && link.to !== node);
                                                        links.forEach((link) => placeNode(link.to.node, box.y));
                                                    } else {
                                                        data.shape.draw();
                                                        this.updateElement(data.shape.container, { transform: `translate(${box.x}, ${box.y})`, });
                                                    }
                        
                                                    shape.box.width = Math.max((shape.box.width || 0), box.x + box.width + this.configuration.columnGap * 2);
                                                    shape.box.height = Math.max((shape.box.height || 0), box.y + box.height + this.configuration.rowGap * 2);
                                                };
                                                nodes.forEach(placeNode);
                                                */
                        shape.x = this.configuration.columnGap;
                        shape.y = this.configuration.rowGap;
                        shape.box.x = this.configuration.columnGap;
                        shape.box.y = this.configuration.rowGap;
                        shape.drawTreeLines(this.settings.connectorStyle.value);

                    } else {
                        let nextX = 0;
                        let nextY = shape.height + this.configuration.rowGap;
                        let rowHeight = 0;
                        const childShapes = nodes.map((child, index) => {
                            const childShape = addNode(child, container);

                            if (shape.layout === 'grid') {
                                const columns = Math.ceil(Math.sqrt(nodes.length));

                                childShape.box.x = getValue(child, 'x') ?? (nextX + this.configuration.columnGap);
                                childShape.box.y = getValue(child, 'y') ?? (nextY + this.configuration.rowGap);

                                nextX += childShape.box.width + this.configuration.columnGap;
                                rowHeight = Math.max(rowHeight, childShape.box.height);

                                if ((index % columns) === (columns - 1)) {
                                    nextX = 0;
                                    nextY += rowHeight + this.configuration.rowGap;
                                    rowHeight = 0;
                                }
                            } else if (shape.layout === 'leftToRight') {
                                childShape.box.x = 0;
                                childShape.box.y = nextY;
                                nextY += childShape.box.height + this.configuration.rowGap;
                            } else if (shape.layout === 'vertical') {
                                childShape.box.x = 2 * this.configuration.columnGap;
                                childShape.box.y = nextY;
                                nextY += childShape.box.height + this.configuration.rowGap;
                            } else {
                                childShape.box.y = nextY + this.configuration.rowGap;
                                const offset = getOffset(shape.rightEdge, childShape.leftEdge.map((point) =>
                                    ({ x: point.x + childShape.box.x, y: point.y + childShape.box.y })));
                                childShape.box.x = offset;
                            }
                            shape.mergeEdges(childShape);
                            return childShape;
                        });

                        const width = Math.max(...childShapes.map((shape) => shape.box.x + shape.box.width));
                        const height = Math.max(...childShapes.map((shape) => shape.box.y + shape.box.height));
                        const offset = { x: 0, y: 0 };

                        if (shape.layout === undefined && (width < shape.width)) {
                            offset.x = (shape.width - width) / 2;
                        }

                        childShapes.forEach((childShape) => {
                            childShape.box.x += offset.x;
                            childShape.box.y += offset.y;
                            const attrs = { transform: `translate(${childShape.box.x}, ${childShape.box.y})`, };
                            this.updateElement(childShape.container, attrs);
                            shape.mergeEdges(childShape);
                        });

                        shape.box.width = Math.max(shape.width, width);
                        shape.box.height = Math.max(shape.height, height);

                        if (getValue(node, 'layout') === 'grid') {
                            shape.box.width += this.configuration.columnGap;
                            shape.box.height += this.configuration.rowGap;
                        }
                        shape.drawTreeLines(childShapes, this.settings.connectorStyle.value);
                    }
                    if (getValue(node, 'layout') === 'grid') {
                        shape.drawContainer();
                    }

                    shape.draw();
                    if ((getData(node).expanded === false) && nodes.length) {
                        const attrs = { fill: 'white', stroke: 'black', d: '', };
                        attrs.d = `M${shape.width - 21} ${shape.height - 5} H${shape.width - 5} `
                        attrs.d += `A5 5 0 0 1 ${shape.width} ${shape.height} `;
                        attrs.d += `A5 5 0 0 1 ${shape.width - 5} ${shape.height + 5}`;
                        attrs.d += `H${shape.width - 21} A5 5 0 0 1 ${shape.width - 26} ${shape.height} `;
                        attrs.d += `A5 5 0 0 1 ${shape.width - 21} ${shape.height - 5}`,

                            this.add('path', shape.container, attrs);

                        const dotAttrs = { fill: 'black', stroke: 'black', r: 2.5, cx: shape.width - 21, cy: shape.height };
                        this.add('circle', shape.container, dotAttrs);
                        dotAttrs.cx = shape.width - 13;
                        this.add('circle', shape.container, dotAttrs);
                        dotAttrs.cx = shape.width - 5;
                        this.add('circle', shape.container, dotAttrs);
                    }
                    /*
                    {
                        const attrs = {
                            fill: 'none', stroke: 'red',
                        }
                        attrs.d = shape.leftEdge.map((point, i) => `${i ? 'L' :' M'} ${point.x} ${point.y}`);
                        this.add('path', shape.container, attrs);
                    }
                    {
                        const attrs = {
                            fill: 'none', stroke: `hsl(${360 * Math.random()}deg 100% 50%`,
                        }
                        attrs.d = shape.rightEdge.map((point, i) => `${i ? 'L' :' M'} ${point.x} ${point.y}`);
                        this.add('path', shape.container, attrs);
                    }*/

                    return shape;
                }

                const shape = addNode(root, this.context);

                const groupAttrs = {
                    transform: `translate(${this.configuration.leftMargin}, ${this.configuration.topMargin})`,
                };
                this.updateElement(shape.container, groupAttrs);


                const extents = {
                    top: 0,
                    left: 0,
                    right: this.configuration.leftMargin + shape.box.width + this.configuration.rightMargin,
                    bottom: this.configuration.topMargin + shape.box.height + this.configuration.bottomMargin,
                };

                this.svg.setAttribute('viewBox', `${extents.left} ${extents.top} ${extents.right} ${extents.bottom}`);
                this.svg.setAttribute('width', `${extents.right - extents.left}`);
                this.svg.setAttribute('height', `${extents.bottom - extents.top}`);

                this.svg.style.width = `${extents.right - extents.left}px`;
                this.svg.style.height = `${extents.bottom - extents.top}px`;
            }
        }

        /**
         * Display a table view for the selected data
         */
        class TableView extends View {
            static settingsMap = {
                headings: '.headings-list',
                hideEmpty: '.hide-empty-rows',
            }
            static defaults = {};
            constructor(roots, configuration) {
                super('table-view-template', TableView.settingsMap);

                this.configuration = Object.assign({}, TableView.defaults, configuration);
                this.roots = roots || Core.structure;
                this.title = 'Table View';
                this.head = this.node.querySelector('thead');
                this.body = this.node.querySelector('tbody');
                this.getNodes();
                this.getHeadings();
                this.render();
                this.settings.headings.addEventListener('change', (event) => this.render());
                this.settings.hideEmpty.addEventListener('change', (event) => this.render());
            }
            getNodes() {
                this.nodes = [];
                this.fields = new Set();
                const stack = [...this.roots];
                while (stack.length) {
                    const node = stack.shift();
                    this.nodes.push(node);
                    const next = node[symbols.content];
                    stack.unshift(...next);
                    Object.keys(node).forEach((key) => this.fields.add(key));
                }
            }
            getHeadings() {
                this.headings = Array.from(this.fields);
                this.headings.forEach((heading, index) => {
                    const option = document.createElement('option');
                    option.innerText = heading;
                    option.value = heading;
                    option.selected = true;
                    this.settings.headings.append(option);
                });
            }
            render() {
                this.head.innerHTML = '';
                this.body.innerHTML = '';
                const row = document.createElement('tr');
                row.classList.add('heading-row');
                this.head.append(row);
                const headings = Array.from(this.settings.headings.options)
                    .filter((option) => option.selected)
                    .map((option) => option.value);
                headings.forEach((heading, index) => {
                    const cell = document.createElement('th');
                    cell.innerText = heading;
                    cell.classList.add(`column-${index}`);
                    cell.draggable = true;
                    cell.addEventListener('dragstart', (event) => {
                        event.dataTransfer.setData('text/heading-index', index);
                        event.dataTransfer.setData('text/plain', heading);
                        for (const node of this.node.querySelectorAll(`.column-${index}`)) {
                            node.classList.add('dragging');
                        }
                        this.headings.splice(index, 1);
                    });
                    cell.addEventListener('dragend', (event) => this.render());
                    cell.addEventListener('dragover', (event) => event.preventDefault());
                    cell.addEventListener('drop', (event) => {
                        event.preventDefault();
                        const draggedIndex = parseInt(event.dataTransfer.getData('text/heading-index'));
                        for (const node of this.body.querySelectorAll(`column-${draggedIndex}`)) {
                            node.classList.remove('dragging');
                        }
                        const draggedHeading = event.dataTransfer.getData('text/plain');
                        this.headings.splice(index, 0, draggedHeading);
                    });
                    row.append(cell);
                });
                this.nodes.forEach((node, rowIndex) => {
                    const row = document.createElement('tr');
                    let show = !this.settings.hideEmpty.checked;
                    headings.forEach((heading, index) => {
                        const cell = document.createElement('td');
                        cell.innerText = node[heading] !== undefined ? node[heading] : '';
                        if (index > 0) {
                            show = show || (node[heading] !== undefined);
                        }
                        cell.classList.add(`column-${index}`, `row-${rowIndex}`);
                        if (node[heading] === undefined) {
                            cell.classList.add('undefined');
                        }
                        cell.addEventListener('dragover', (event) => event.preventDefault());
                        cell.addEventListener('drop', (event) => {
                            event.preventDefault();
                            const draggedIndex = parseInt(event.dataTransfer.getData('text/heading-index'));
                            for (const node of this.body.querySelectorAll(`column-${draggedIndex}`)) {
                                node.classList.remove('dragging');
                            }
                            const draggedHeading = event.dataTransfer.getData('text/plain');
                            this.headings.splice(index, 0, draggedHeading);
                        });
                        cell.addEventListener('click', (event) => clickNode(node, event));
                        row.append(cell);
                    });
                    if (show) {
                        this.body.append(row);
                    }
                });
            }
        }

        /**
         * Process a click on a node
         */
        function clickNode(node, event) {
            // Ignore non-source nodes, i.e. view generated nodes
            if (node[symbols.source]) {
                if (event.shiftKey) {
                    Core.selectionToggle(node);
                } else {
                    Core.currentNode = node;
                }
            }
        }

        /**
         * Process a click on a node
         */
        function dblClickNode(node, event) {
            if (event.shiftKey) {
            } else {
            }
        }

        /**
         * Node in a tree View
         */
        class TreeViewNode {
            constructor(item, tree, container) {
                this.item = item;
                this.container = container;
                this.tree = tree;
                this.node = document.createElement('div');
                this.expander = document.createElement('span');
                this.node.append(this.expander);
                this.expander.classList.add('expander');
                this.labelNode = document.createElement('span');
                this.labelNode.innerText = this.label;
                if (this.title) {
                    this.labelNode.title = this.title;
                }
                this.node.append(this.labelNode);
                this.contentNode = document.createElement('div');
                this.node.append(this.contentNode);
                this.contentNode.classList.add('branch-content');
                this.contentNode.classList.remove('hide');
                this.structure = false;

                this.expander.addEventListener('click', (event) => this.toggle(event.ctrlKey));
                this.expander.innerHTML = this.indicator;

                if (tree.config.actions) {
                    Object.entries(tree.config.actions).forEach(([event, action]) =>
                        this.labelNode.addEventListener(event, (event) =>
                            action(event, this)));
                }
            }
            expand(recursive) {
                const content = this.content;
                this.contentNode.innerHTML = '';
                this.contentNode.classList.remove('hide');
                this.nodes = content.map((item) => {
                    const node = this.content.find((existing) => existing.item === item) ||
                        new TreeViewNode(item, this.tree, this);
                    this.contentNode.append(node.node);
                    if (recursive) {
                        node.expand(recursive);
                    }
                    return node;
                });
                this.structure = true;
                this.expander.innerHTML = this.indicator;
            }
            collapse(recursive) {
                this.contentNode.classList.add('hide');
                if (recursive) {
                    this.content.forEach((item) => node.collapse(recursive));
                }
                this.structure = false;
                this.expander.innerHTML = this.indicator;
            }
            toggle(recursive) {
                if (this.structure) {
                    this.collapse(recursive);
                } else {
                    this.expand(recursive);
                }
            }
            get indicator() {
                if (this.content.length > 0) {
                    return this.structure ? '&#9661' : '&#9655';
                }
                return '';
            }
            get label() {
                if (this.tree.config.getLabel) {
                    return this.tree.config.getLabel(this);
                }
                return this.item.name;
            }
            get title() {
                if (this.tree.config.getTitle) {
                    return this.tree.config.getTitle(this);
                }
            }
            get content() {
                if (this.tree.config.getContent) {
                    return this.tree.config.getContent(this.item);
                }
                return this.item.content || [];
            }
        }

        /**
         * Class for managing tree views
         */
        class TreeView extends View {
            static settingsMap = {
                caseSensitive: '.case-sensitive',
                regularExpression: '.regular-expression',
            }
            static defaults = {
                getContent(node) { return node[symbols.content] },
                getLabel(node) { return node.item[symbols.name] || node.item.name },
                getTitle(node) { return node.item[symbols.description] || node.item[symbols.name] || node.item.name },
                actions: {
                    'click': (event, node) => Core.currentNode = node.item,
                }
            }
            constructor(content, title = 'Tree', config = {}) {
                super('tree-view-template', TreeView.settingsMap);
                this.main = this.node.querySelector('.tree');
                this.title = title;

                this.config = Object.assign({}, TreeView.defaults, config);
                this.searchStack = [];
                this.path = [];
                this.structure = content || Core.structure;

                const search = this.node.querySelector('.search');
                search.addEventListener('input', (event) => this.incrementalSearch());
                search.addEventListener('change', (event) => this.search());
                this.resetSearch();
            }
            set structure(structure) {
                this.main.innerHTML = '';
                this.content = structure;
                this.nodes = this.content.map((item) => {
                    const node = new TreeViewNode(item, this);
                    this.main.append(node.node);
                    return node;
                });
                this.resetSearch();
            }
            set currentNode(node) {
                const allNodes = [];
                const stack = [...this.nodes];
                while (stack.length) {
                    const next = stack.shift();
                    allNodes.push(next);
                    next.labelNode.classList.remove('selected');
                    stack.unshift(...(next.nodes || []));
                }

                const treeNode = allNodes.find((treeNode) => treeNode.item === node);
                if (treeNode) {
                    treeNode.labelNode.classList.add('selected');
                    treeNode.node.scrollIntoView();
                }
            }
            expand(path) {
                let nodes = this.nodes;
                let node;
                path.forEach((item) => {
                    node = nodes.find((node) => node.item === item);
                    node.expand();
                    nodes = node.nodes;
                });
                if (node) {
                    Core.currentNode = node.item;
                }
            }
            resetSearch() {
                this.searchStack.length = 0;
                this.path = [];
                this.first = true;
                this.stack = [...this.content];
            }
            search() {
                const search = this.node.querySelector('.search');

                if (search.value) {
                    const caseSensitive = this.settings.caseSensitive.checked;
                    const regularExpression = this.settings.regularExpression.checked;
                    const flags = caseSensitive ? '' : 'i';
                    const pattern = new RegExp(search.value, flags);

                    const content = this.config.getContent || ((item) => item.content);
                    const test = (node) => this.config.test ? this.config.test(node, pattern) : pattern.test(node.name);

                    while (this.stack.length) {
                        const item = this.stack.shift();
                        if (item) {
                            this.path.push(item);
                            if (test(item)) {
                                break;
                            }
                            this.stack.unshift(...content(item), null);
                        } else {
                            this.path.pop();
                        }
                    }

                    if (this.path.length) {
                        this.expand(this.path);
                    }
                } else {
                    this.resetSearch();
                }
            }
            incrementalSearch() {

            }
        }

        /**
         * Display a tree table for the selected data, allowing expansion of nodes.
         */
        class TreeTableView extends View {
            static settingsMap = {
                headings: '.headings-list',
                hideEmpty: '.hide-empty-rows',
            }
            static defaults = {};
            constructor(roots, configuration) {
                super('table-view-template', TreeTableView.settingsMap);

                this.configuration = Object.assign({}, TreeTableView.defaults, configuration);
                this.roots = roots || Core.structure;
                this.title = 'Table View';
                this.head = this.node.querySelector('thead');
                this.body = this.node.querySelector('tbody');
                this.getNodes();
                this.getHeadings();
                this.render();
                this.settings.headings.addEventListener('change', (event) => this.render());
                this.settings.hideEmpty.addEventListener('change', (event) => this.render());
                this.state = {};
                this.searchState = { stack: this.roots.map((node) => ({ node, path: [] })), visited: new Set() };

                const search = this.node.querySelector('.search');
                search.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        this.search();
                    }
                });
                this.caseSensitive = this.node.querySelector('.case-sensitive');
                this.caseSensitive.addEventListener('click', (event) => {
                    this.caseSensitive.classList.toggle('on');
                    search.focus();
                });
                this.regExp = this.node.querySelector('.regular-expression-seach');
                this.regExp.addEventListener('click', (event) => {
                    this.regExp.classList.toggle('on');
                    search.focus();
                });
            }
            set structure(structure = []) {
                this.roots = structure;
                this.restoreState();
                this.getNodes();
                this.getHeadings();
                this.render();
                this.searchState.stack = this.roots.map((node) => ({ node, path: [] }));
                this.searchState.visited.clear();
            }
            search() {
                const str = this.node.querySelector('.search').value;
                if (str === '') {
                    this.searchState.stack = this.roots.map((node) => ({ node, path: [] }));
                    this.searchState.visited.clear();
                    this.body.scrollTo(0, 0);
                }
                const caseSensitive = this.caseSensitive.classList.contains('on');
                const regEx = this.regExp.classList.contains('on');

                let pattern;
                if (regEx) {
                    try {
                        pattern = new RegExp(str, caseSensitive ? '' : 'i');
                    } catch (err) {
                        warn(err.tostring());
                    }
                }
                const test = pattern ? (node) => pattern.test(node.name) :
                    (caseSensitive ? (node) => node.name.includes(str) :
                        (node) => node.name.toLowerCase().includes(str.toLowerCase()));

                const stack = [...this.searchState.stack];
                const visited = new Set(this.searchState.visited);
                while (stack.length) {
                    const searchNode = stack.shift();
                    visited.add(searchNode.node);
                    if (test(searchNode.node)) {
                        searchNode.path.forEach((node) => {
                            if (node[symbols.viewData].get(this) === undefined) {
                                node[symbols.viewData].set(this, {});
                            }
                            node[symbols.viewData].get(this).expanded = true;
                        });
                        this.render(searchNode.node);
                        this.searchState = { stack, visited };
                        break;
                    }
                    const unvisited = this.getContent(searchNode.node).filter((node) => !visited.has(node));
                    stack.unshift(
                        ...unvisited.map((node) => ({ node, path: [...searchNode.path, searchNode.node] })));
                }
            }
            set currentNode(node) {
                const stack = [...this.roots.map((node) => ({ node, path: [] }))];
                const visited = new Set();
                while (stack.length) {
                    const searchNode = stack.shift();
                    visited.add(searchNode.node);
                    if (searchNode.node === node) {
                        searchNode.path.forEach((node) => {
                            if (node[symbols.viewData].get(this) === undefined) {
                                node[symbols.viewData].set(this, {});
                            }
                            node[symbols.viewData].get(this).expanded = true;
                        });
                        this.render(node);
                        break;
                    }
                    const unvisited = this.getContent(searchNode.node).filter((node) => !visited.has(node));
                    stack.unshift(...unvisited.map((node) => ({ node, path: [...searchNode.path, searchNode.node] })));
                }
            }
            restoreState() {
                Object.entries(this.state).forEach(([path, state]) => {
                    const node = findNodes(path)[0];
                    if (node) {
                        node[symbols.viewData].set(this, state);
                    }
                });
            }
            getNodes() {
                this.nodes = [];
                this.fields = new Set();
                const stack = [...this.roots];
                while (stack.length) {
                    const node = stack.shift();
                    this.nodes.push(node);
                    const data = node[symbols.viewData].get(this);
                    if (data?.expanded) {
                        stack.unshift(...this.getContent(node));
                    }
                    Object.keys(node).forEach((key) => this.fields.add(key));
                }
            }
            getHeadings() {
                this.settings.headings.innerHTML = '';
                this.headings = Array.from(this.fields);
                this.headings.forEach((heading, index) => {
                    const option = document.createElement('option');
                    option.innerText = heading;
                    option.value = heading;
                    option.selected = true;
                    this.settings.headings.append(option);
                });
            }
            getContent(node) {
                const property = (node[symbols.views]?.[this.title]?.['content property']) ?? symbols.content;
                return node[property];
            }
            render(showNode) {
                this.head.innerHTML = '';
                this.body.innerHTML = '';
                const row = document.createElement('tr');
                row.classList.add('heading-row');
                this.head.append(row);
                const headings = Array.from(this.settings.headings.options)
                    .filter((option) => option.selected)
                    .map((option) => option.value);
                headings.forEach((heading, index) => {
                    const cell = document.createElement('th');
                    cell.innerText = heading;
                    cell.classList.add(`column-${index}`);
                    cell.draggable = true;
                    cell.addEventListener('dragstart', (event) => {
                        event.dataTransfer.setData('text/heading-index', index);
                        event.dataTransfer.setData('text/plain', heading);
                        for (const node of this.node.querySelectorAll(`.column-${index}`)) {
                            node.classList.add('dragging');
                        }
                        this.headings.splice(index, 1);
                    });
                    cell.addEventListener('dragend', (event) => this.render());
                    cell.addEventListener('dragover', (event) => event.preventDefault());
                    cell.addEventListener('drop', (event) => {
                        event.preventDefault();
                        const draggedIndex = parseInt(event.dataTransfer.getData('text/heading-index'));
                        for (const node of this.body.querySelectorAll(`column-${draggedIndex}`)) {
                            node.classList.remove('dragging');
                        }
                        const draggedHeading = event.dataTransfer.getData('text/plain');
                        this.headings.splice(index, 0, draggedHeading);
                    });
                    row.append(cell);
                });
                const newHeading = document.createElement('span');
                newHeading.contentEditable = true;
                newHeading.classList.add('new-heading');
                const cell = document.createElement('th');
                cell.append(newHeading);
                row.append(cell);
                newHeading.addEventListener('keypress', (event) => {
                    report(event.key);
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        this.fields.add(newHeading.innerText);
                        this.getHeadings();
                        this.render();
                    }
                });

                const toggle = (node) => {
                    const data = node[symbols.viewData].get(this) || {};
                    data.expanded = !data.expanded;
                    node[symbols.viewData].set(this, data);
                    this.state[fullName(node)] = data;
                    this.getNodes();
                    this.getHeadings();
                    this.render();
                }

                const stack = [...this.roots];
                let rowIndex = 0;
                const addRow = (node, level = 0) => {
                    this.nodes.push(node);
                    const data = node[symbols.viewData].get(this);
                    const content = this.getContent(node);
                    const expandable = content.length > 0;
                    if (data?.expanded) {
                        stack.unshift(...content);
                    }
                    const row = document.createElement('tr');
                    let show = !this.settings.hideEmpty.checked;
                    const viewHeading = (node, heading) => {
                        const view = Object.keys(node[symbols.views]).find((key) => node[symbols.views][key][heading]);
                        if (view) {
                            const item = node[symbols.views][view][heading];
                            if (item.toLocaleDateString) {
                                return `::${view}.${item.toLocaleDateString()}`;
                            }
                            return `::${view}.${item}`;
                        }
                    }
                    headings.forEach((heading, index) => {
                        const cell = document.createElement('td');
                        if (index > 0) {
                            show = show || (node[heading] !== undefined);
                        } else {
                            const expander = document.createElement('span');
                            expander.classList.add('expander');
                            if (expandable) {
                                expander.innerHTML = data?.expanded ? '&#9661' : '&#9655';
                            }
                            expander.addEventListener('click', (event) => toggle(node, event));
                            cell.style.paddingLeft = `${level}em`;
                            cell.style.whiteSpace = 'nowrap';
                            cell.append(expander);
                            if (showNode === node) {
                                setTimeout(() => cell.scrollIntoView({ behavior: 'smooth', block: 'center' }), 0);
                            }
                        }
                        const content = node[heading] ?? viewHeading(node, heading) ?? '';
                        if (content.startsWith && content.startsWith('http://')) {
                            const link = document.createElement('a');
                            link.href = link.innerText = content;
                            cell.append(link);
                        } else if (content.toLocaleDateString) {
                            cell.append(content.toLocaleDateString());
                        } else if (Array.isArray(content)) {
                            cell.append('[list]');
                            cell.title = content.join('\n');
                        } else {
                            cell.append(content);
                        }
                        cell.classList.add(`column-${index}`, `row-${rowIndex}`);
                        if (node[heading] === undefined) {
                            cell.classList.add('undefined');
                        }
                        cell.addEventListener('dragover', (event) => event.preventDefault());
                        cell.addEventListener('drop', (event) => {
                            event.preventDefault();
                            const draggedIndex = parseInt(event.dataTransfer.getData('text/heading-index'));
                            for (const node of this.body.querySelectorAll(`column-${draggedIndex}`)) {
                                node.classList.remove('dragging');
                            }
                            const draggedHeading = event.dataTransfer.getData('text/plain');
                            this.headings.splice(index, 0, draggedHeading);
                        });
                        cell.addEventListener('click', (event) => clickNode(node, event));
                        row.append(cell);
                    });
                    if (show) {
                        this.body.append(row);
                        ++rowIndex;
                        if (data?.expanded) {
                            this.getContent(node).forEach((node) => addRow(node, level + 1));
                        }
                    }
                }
                this.roots.forEach((node) => addRow(node));
            }
        }




        /**
         * View selection component used for empty frames
         */
        class DetailView extends View {
            static settingsMap = {
                update: '.auto-update',
                context: '.context-selection',
            }
            constructor() {
                super('detail-view-template', DetailView.settingsMap);

                this.contexts = Core.contexts;
                this.title = 'Detail View';
                this.detail = this.node.querySelector('.detail');
                this.settings.context.addEventListener('change', (event) => this.render());
            }
            set currentNode(node) {
                this._currentNode = node;
                if (this.settings.update.checked) {
                    this.render();
                }
            }
            set contexts(contexts) {
                this.settings.context.innerHTML =
                    '<option value="" selected>None</option>';
                if (contexts) {
                    contexts.forEach((context) => {
                        const option = document.createElement('option');
                        option.innerText = context;
                        option.value = context;
                        this.settings.context.append(option);
                    });
                }
            }
            render() {
                if (this._currentNode) {
                    this.node.querySelector('.title').innerText = this._currentNode.name;
                    this.detail.innerHTML = '';
                    Object.entries(this._currentNode).map(([key, value]) =>
                        this.detail.append(showEntry(key, value)));
                    Object.entries(this._currentNode[symbols.views]).map(([key, value]) =>
                        this.detail.append(showEntry(key, value)));
                    if (this.settings.context.value) {
                        const view = this._currentNode[symbols.views][this.settings.context.value];
                        if (view) {
                            Object.entries(view).map(([key, value]) =>
                                this.detail.append(showEntry(key, value)));
                        }
                    }
                    if (this._currentNode[symbols.values].length) {
                        this.detail.append(showEntry('Values', this._currentNode[symbols.values], true));
                    }
                }
            }
        }

        function flatten(structure) {
            const list = [];
            if (structure) {
                const stack = [...structure];
                while (stack.length > 0) {
                    const node = stack.shift();
                    list.push(node);
                    if (node[symbols.content].length) {
                        stack.unshift(...node[symbols.content]);
                    }
                }
            }

            return list;
        }


        /**
         * View component for calendar display
         */
        class ClockView extends View {
            static settingsMap = {
                update: '.auto-update',
                context: '.context-selection',
            }
            constructor(date) {
                super('clock-view-template', ClockView.settingsMap);
                this.canvas = this.node.querySelector('canvas');
                this.context = this.canvas.getContext('2d');
                this.title = 'Local Time';
                this.last = new Date();
            }
            update(time) {
                const current = new Date();
                const width = this.canvas.clientWidth / 2;
                const height = this.canvas.clientHeight / 2;

                if (this.canvas.width !== this.canvas.clientWidth ||
                    this.canvas.height !== this.canvas.clientHeight) {
                    this.canvas.width = this.canvas.clientWidth;
                    this.canvas.height = this.canvas.clientHeight;
                    this.render(current);
                    this.last = current;
                } else if (current.toLocaleTimeString() !== this.last.toLocaleTimeString() || this.constant) {
                    this.render(current);
                    this.last = current;
                }
            }
            render(time) {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const width = this.canvas.clientWidth / 2;
                const height = this.canvas.clientHeight / 2;

                const hours = Math.PI * (time.getHours() % 12) / 6;
                const minutes = Math.PI * time.getMinutes() / 30;
                const seconds = Math.PI * time.getSeconds() / 30;

                const s = Math.min(width, height);

                this.context.strokeStyle = 'white';
                this.context.beginPath();
                for (let i = 0; i < 60; ++i) {
                    const a = Math.PI * i / 30;
                    const inner = s * ((i % 5) ? 0.98 : 0.9);
                    this.context.moveTo(width + s * Math.sin(a), height + s * Math.cos(a));
                    this.context.lineTo(width + inner * Math.sin(a), height + inner * Math.cos(a));
                }
                this.context.stroke();

                this.context.fillStyle = 'gray';
                this.context.font = `bold ${s / 5}px monospace`;
                this.context.textBaseline = 'hanging';
                this.context.textAlign = 'center';
                this.context.fillText(time.toLocaleTimeString(), width, height);
                this.context.fillText(time.toLocaleDateString(), width, height + s / 4);

                this.context.strokeStyle = 'white';
                this.context.lineWidth = 3;
                this.context.beginPath();
                this.context.moveTo(width, height);
                this.context.lineTo(width + s * 0.6 * Math.sin(hours), height - s * 0.6 * Math.cos(hours));
                this.context.stroke();

                this.context.lineWidth = 2;
                this.context.beginPath();
                this.context.moveTo(width, height);
                this.context.lineTo(width + s * 0.8 * Math.sin(minutes), height - s * 0.8 * Math.cos(minutes));
                this.context.stroke();

                this.context.lineWidth = 1;
                this.context.beginPath();
                this.context.moveTo(width, height);
                this.context.lineTo(width + s * 0.9 * Math.sin(seconds), height - s * 0.9 * Math.cos(seconds));
                this.context.stroke();
            }
        }

        /**
         * View component for calendar display
         */
        class CalendarView extends View {
            static settingsMap = {
                update: '.auto-update',
                context: '.context-selection',
            }
            constructor(date) {
                super('calendar-view-template', CalendarView.settingsMap);
                this.title = 'Calendar';
                this.calendarNode = this.node.querySelector('.calendar');
                this.monthLabel = this.node.querySelector('.month-label');
                this.next = this.node.querySelector('.next-month');
                this.previous = this.node.querySelector('.previous-month');
                const dayNameDate = new Date();
                dayNameDate.setDate(dayNameDate.getDate() - dayNameDate.getDay() + 1);
                for (let i = 0; i < 7; ++i) {
                    const dayNode = document.createElement('span');
                    dayNode.innerHTML = dayNameDate.toLocaleDateString('en-AU', { weekday: 'short' });
                    dayNode.classList.add('calendar-day-name');
                    this.calendarNode.append(dayNode);
                    dayNameDate.setDate(dayNameDate.getDate() + 1);
                }
                this.date = date || new Date();
                this.contexts = Core.contexts;
                this._structure = Core.structure;
                this.settings.context.addEventListener('change', (event) => this.render());
                this.render();
                this.previous.addEventListener('click', (event) => this.previousMonth());
                this.next.addEventListener('click', (event) => this.nextMonth());
            }
            previousMonth() {
                this.date.setMonth(this.date.getMonth() - 1);
                this.render();
            }
            nextMonth() {
                this.date.setMonth(this.date.getMonth() + 1);
                this.render();
            }
            set currentNode(node) {
                this._currentNode = node;
                if (this.settings.update.checked) {
                    this.render();
                }
            }
            set structure(structure) {
                this._structure = structure;
                this.render();
            }
            render() {
                const start = (node) => {
                    const date = node.start || node.date;
                    if (!(date instanceof Date)) {
                        return;
                    }
                    quantiseDate(date);
                    return date;
                }
                const end = (node) => {
                    const date = node.end && (node.end instanceof Date) ? node.end : start(node);
                    if (!(date instanceof Date)) {
                        return s;
                    }
                    quantiseDate(date);
                    date.setTime(date.getTime() - 1);
                    return date;
                }

                const nodes = flatten(this._structure).filter((node) => start(node)?.getMonth &&
                    ((start(node).getMonth() - this.date.getMonth()) <= 1) &&
                    ((this.date.getMonth() - start(node).getMonth()) >= -1));
                for (const node of this.calendarNode.querySelectorAll('.calendar-day')) {
                    node.remove();
                }
                const year = this.date.getFullYear() === (new Date).getFullYear() ? '' : ` ${this.date.getFullYear()}`;
                this.monthLabel.innerHTML = this.date.toLocaleDateString('en-AU', { month: 'long' }) + year;
                const day = new Date(this.date.getTime());
                day.setDate(1);
                const dayOfWeek = (day.getDay() + 6) % 7;
                day.setDate(1 - dayOfWeek);

                const nextMonth = new Date(day);
                nextMonth.setMonth(nextMonth.getMonth() + 1);
                while ((day.getTime() < nextMonth.getTime()) || (day.getDay() !== 1)) {
                    const dayNode = document.createElement('div');
                    dayNode.innerHTML = day.getDate();
                    dayNode.classList.add('calendar-day');
                    if ((day.getDay() > 0) && (day.getDay() < 6)) {
                        dayNode.classList.add('calendar-day-weekday');
                    } else {
                        dayNode.classList.add('calendar-day-weekend');
                    }
                    if (day.getMonth() !== this.date.getMonth()) {
                        dayNode.classList.add('calendar-day-shade');
                    }
                    const dayNodes = nodes.find((node) => (start(node) <= day) && (end(node) >= day));
                    if (dayNodes) {
                        dayNode.style.backgroundColor = 'pink';
                    }
                    this.calendarNode.append(dayNode);
                    day.setDate(day.getDate() + 1);
                }
            }
        }

        const Views = [
            { group: 'Utiltiy', name: 'Calendar View', cls: CalendarView, },
            { group: 'Utiltiy', name: 'Clock View', cls: ClockView, },
            { group: 'Diagrams', name: '3D View', cls: GLView, },
            { group: 'Data', name: 'Detail View', cls: DetailView, },
            { group: 'Diagrams', name: 'Diagram', cls: DiagramView, },
            { group: 'Editors', name: 'Editor', cls: Editor, },
            { group: 'Shaders', name: 'Shader Editor', cls: ShaderEditor, },
            { group: 'Shaders', name: 'Shader Program Editor', cls: ProgramEditor, },
            { group: 'Editors', name: 'Structure Editor', cls: StructureEditor, },
            { group: 'Diagrams', name: 'SVG Diagram', cls: SVGView, },
            { group: 'Data', name: 'Table', cls: TableView, },
            { group: 'Diagrams', name: 'Tree Diagram', cls: SVGTreeDiagram, },
            { group: 'Data', name: 'Tree View', cls: TreeView, },
            { group: 'Data', name: 'Tree Table View', cls: TreeTableView, },
        ];
        const addAllViews = () => {
            Views.forEach((view) => uiControls.newSidebarFrame(view.make()));
        }

        /**
         * Extract group data from match data.
         */
        function getGroupData(listDefinition) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*\|\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(listDefinition);
            const list = [];
            if (!isNaN(count)) {
                for (let i = 1; i <= count; ++i) {
                    list.push(i);
                }
            } else {
                list.push(...listDefinition.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return item.trim();
                }));
            }
            return list;
        }

        /**
         * Return the given value if it is a number, or the 'other' value if not.
         */
        function validateNumber(value, other) {
            if (isNaN(value)) {
                return other;
            }
            return value;
        }

        /**
         * Return the given value if it is a date, or the 'other' value if not.
         */
        function validateDateStr(str, other = '') {
            const date = new Date(str);
            if (isNaN(date)) {
                const today = new Date();
                const dates = {
                    today,
                    yesterday: new Date(today.getTime() - 24 * 60 * 60 * 1000),
                    tomorrow: new Date(today.getTime() + 24 * 60 * 60 * 1000),
                    'last week': new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000),
                    'next week': new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000),
                };

                return dates[other.toLowerCase()] && other;
            }
            return date;
        }

        /*
         * Symbols used to provide attributes of the nodes that are independent of user attributes.
         */
        const symbols = {
            names: Symbol('names'),
            title: Symbol('title'),
            source: Symbol('source'),
            content: Symbol('content'),
            container: Symbol('container'),
            value: Symbol('value'),
            values: Symbol('values'),
            links: Symbol('links'),
            views: Symbol('views'),
            viewData: Symbol('view data'),
            name: Symbol('name'),
            fullName: Symbol('fullName'),
        };


        /**
         * Return an array of the ancestors of a node, including the node itself
         */
        function getAncestors(node) {
            const ancestors = [node];
            while (ancestors[0][symbols.container]) {
                ancestors.unshift(ancestors[0][symbols.container]);
            }
            return ancestors;
        }

        /**
         * Return the full name of a node
         */
        function fullName(node, sep = '.') {
            const viewName = (node) => {
                const view = Object.keys(node[symbols.views]).find((key) => node[symbols.views][key].name);
                if (view) {
                    return `::${view}.${node[symbols.views][view].name}`;
                }
            }
            return getAncestors(node).map((node) =>
                node[symbols.names][0] ?? viewName(node) ?? '').join(sep);
        }

        /**
         * find a node based on it's name / path
         */
        function findNodes(path) {
            const allNodes = flatten(Core.structure);
            const nodes = allNodes.filter((node) => node.name === path);
            if (nodes.length > 0) {
                return nodes;
            } else {
                const pathList = path.split(/[-\/\.]/);
                if (pathList.length > 1) {
                    const first = pathList.shift();
                    let matches = allNodes.filter((node) => node.name === first);
                    while (pathList.length && matches.length) {
                        const name = pathList.shift();
                        matches = matches.flatMap((node) =>
                            node[symbols.content].filter((node) => node.name === name));
                    }
                    return matches;
                }
            }
            return [];
        }

        /**
         * Classes of the nodes in the template structure.
         */
        class MetaNode {
            constructor(value, level, lineNumber) {
                this.value = value;
                this.level = level;
                this.lineNumber = lineNumber;
                this.content = [];
            }
            makeNode(context) {
                const node = {
                    [symbols.source]: [this],
                    [symbols.container]: context.ancestors[0],
                    [symbols.content]: [],
                    [symbols.links]: {},
                    [symbols.value]: '',
                    [symbols.values]: [],
                    [symbols.views]: {},
                    [symbols.viewData]: new Map(),
                    [symbols.names]: [],
                    [symbols.name]() { return this[symbols.names][0] },
                };
                this.startScope(context, node);
                this.parseValue(context, node);
                context.ancestors.unshift(node);
                node[symbols.content].push(...this.content.flatMap((node) => node.expand(context)));
                context.ancestors.shift();
                this.endScope(context);
                return node;
            }
            startScope(context, node) {
                const scope = {
                    node,
                    values: {},
                    modifiers: [],
                    finalisation: [],
                    defaults: [],
                };
                scope.propagate = Object.assign({}, context.scope[0].propagate);
                context.scope.unshift(scope);
                return scope;
            }
            endScope(context) {
                const scope = context.scope.shift();
                scope.finalisation.forEach((finaliser) => finaliser(context));
            }
            parseValue(context, node, newNode = true) {
                node[symbols.source].push(this);
                context.parse(node, this.value, newNode);

                if (newNode) {
                    context.nodeList.push(node);
                    if (context.scope.length < 3) {
                        context.rootNodes.push(node);
                    }
                }
                node[symbols.value] += `${this.value};`;
            }
        }

        /**
         * Append values to the current node
         */
        class ContinuationNode extends MetaNode {
            static pattern = /^\&(?<value>.+)$/;
            static match(value) {
                return ContinuationNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ContinuationNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                this.parseValue(context, context.ancestors[0], false);
                return this.content.flatMap((node) => node.expand(context));
            }
        }

        /**
         * Set a variable for use in processing following nodes
         */
        class VariableNode extends MetaNode {
            static pattern = /^\$(?<value>.+)$/;
            static match(value) {
                return VariableNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(VariableNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const values = {};
                context.parse(values, this.value);
                const content = this.content.flatMap((node) => node.expand(context));
                if (content.length) {
                    Object.entries(values).forEach(([key, value]) => {
                        const data = content.filter((node) => key in node).map((node) => node[key]);
                        if (value === 'join') {
                            values[key] = data.join(' ');
                        } else if (value === 'sum') {
                            values[key] = data.reduce((sum, value) => sum + value, 0);
                        } else {
                            values[key] = data;
                        }
                    });
                    /*
                    const collapse = (node, key) =>
                        node[symbols.content].reduce((sum, node) => sum + collapse(node, key), node[key] || '');
                    Object.entries(values).forEach(([key, value]) =>
                        values[key] = content.reduce((sum, node) => sum + collapse(node, key), value));
                        */
                }
                Object.assign(context.scope[0].values, values);
                return [];
            }
        }

        /**
         * Extend the given node
         */
        class ExtensionNode extends MetaNode {
            static pattern = /^\*(?<value>.+)$/;
            static match(value) {
                return ExtensionNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ExtensionNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                // Check for template node
                const templateMatch = this.value.match(/ \[(?<definition>[^\[\]]+)\]$/);
                const values = [];
                let value;
                const defaults = `${context.scope.flatMap((scope) => scope.defaults).join(';')}`;

                if (templateMatch) {
                    const list = getGroupData(templateMatch.groups.definition);
                    const rawValue = `${this.value.replace(/ \[[^\[\]]+\]$/, '')};${defaults}`;
                    list.forEach((item, index) => {
                        context.scope[0].values[''] = context.scope[0].values['_'] = item;
                        context.scope[0].values['_n'] = index;
                        value = rawValue;
                        context.modifiers.forEach((modifier) => value = modifier.apply(value));
                        values.push(context.resolve(value));
                    });
                } else {
                    value = `${this.value};${defaults}`;
                    context.modifiers.forEach((modifier) => value = modifier.apply(value));
                    values.push(context.resolve(value));
                }

                values.forEach((value) => {
                    this.value = value;
                    const name = value.split(/[\t\|;]/)[0].trim();

                    let referencedNode;
                    let level = 0;
                    const indexed = name.match(/^(?<name>[^\[]+)\[(?<index>[^\]]+)\]$/);

                    if (indexed) {
                        const name = indexed.groups.name;
                        const index = parseInt(indexed.groups.index);

                        referencedNode = getReference(context, name)[index];
                    } else {
                        referencedNode = getReference(context, name)[0];
                    }

                    // If the name is found add the data otherwise return a new node
                    if (referencedNode) {
                        this.parseValue(context, referencedNode, false);
                    } else {
                        warn(`NO MATCH for ${name}`);
                    }
                });
                return [];//super.makeNode(context);
            }
        }


        class GeneratorNode extends MetaNode {
            static pattern = /^\+(?<value>.+)$/;
            static match(value) {
                return GeneratorNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(GeneratorNode.pattern);
                this.value = match.groups.value;
            }
            select(rules, context) {
                const nodes = rules.startsWith('*') ? context.nodeList : context.rootNodes;
                rules = rules.replace(/^\*/, '');
                rules = rules.split(/,/).flatMap((rule) => {
                    const match = rule.match(/(?<name>[^=><]+)(?<test>[=\/><])(?<values>.*)/);
                    if (!match) {
                        return (node) => node.name === rule;
                    }
                    const name = match.groups.name;
                    const test = match.groups.test;
                    const values = match.groups.values.split(',').map((v) => numberOrString(v));
                    switch (test) {
                        case '=':
                            return (node) => values.includes(node[name]);
                        case '/':
                            const patterns = values.map((value) => new RegExp(value));
                            return (node) => patterns.some((pattern) => pattern.test(node[name]));
                        case '<':
                            return (node) => values.some((value) => value > node[name]);
                        case '>':
                            return (node) => values.some((value) => value < node[name]);
                    }
                    return [];
                });
                return nodes.filter((node) => rules.some((rule) => rule(node)));
            }
            map(context, node, mapping) {
                const newNode = {
                    [symbols.source]: [node[symbols.source][0], this],
                    [symbols.container]: context.ancestors[0],
                    [symbols.content]: [],
                    [symbols.links]: {},
                    [symbols.value]: '',
                    [symbols.values]: [],
                    [symbols.views]: {},
                    [symbols.viewData]: new Map(),
                    [symbols.name]: '',
                };
                if (mapping.values.length > 0) {
                    mapping.values.forEach(([to, from]) => newNode[to] = from(node));
                } else {
                    Object.assign(newNode, node);
                }
                return newNode;
            }
            expand(context) {
                // ToDo: allow for templated generator
                const [selector, ...values] = this.value.split(/;/);
                const nodes = this.select(selector, context);
                const mapping = {
                    options: values.filter((value) => !value.includes('=')).map((value) => value.trim().toLowerCase()),
                    values: values.filter((value) => value.includes('=')).map((value) => {
                        const [to, from] = value.split('=');
                        return [to.trim(), (node) => node[from.trim()]];
                    }),
                };
                const expanded = mapping.options.includes('content') ? nodes.flatMap((node) => node[symbols.content]) : nodes;
                if (mapping.options.includes('flatten')) {
                    const flat = (node) => [node, ...node[symbols.content].flatMap((node) => flat(node))];
                    expanded.splice(0, expanded.length, ...structure.flatMap((node) => flat(node)));
                }
                if (mapping.options.includes('count')) {
                    const values = {};
                    if (mapping.values.length === 0) {
                        expanded.forEach((node) =>
                            Object.values(node).forEach((value) => {
                                values[value] = values[value] || [];
                                values[value].push(node);
                            }));
                    } else {
                        expanded.forEach((node) =>
                            mapping.values.forEach(([to, from]) => {
                                const value = from(node);
                                values[value] = values[value] || [];
                                values[value].push(node);
                            }));
                    }
                    return Object.entries(values).map(([key, nodes]) => ({
                        [symbols.source]: nodes.map((node) => node[symbols.source][0]),
                        [symbols.container]: context.ancestors[0],
                        [symbols.content]: [],
                        [symbols.links]: {},
                        [symbols.value]: nodes.length,
                        [symbols.values]: [],
                        [symbols.views]: {},
                        [symbols.viewData]: new Map(),
                        [symbols.name]: '',
                        name: key,
                        value: nodes.length,
                    }));
                }
                if (mapping.options.includes('transpose')) {
                    const keys = {};
                    expanded.forEach((node) =>
                        Object.keys(node).forEach((key) => {
                            if (key !== 'name') {
                                keys[key] = keys[key] || { name: key, [symbols.source]: node[symbols.source] };
                                keys[key][node.name] = node[key];
                            }
                        }));
                    return Object.values(keys).map((node) => this.map(context, node, mapping));
                }
                if (!mapping.values.find((map) => map[0] === 'name')) {
                    mapping.values.push(['name', (node) => `(${node.name})`]);
                }
                return expanded.flatMap((node) => this.map(context, node, mapping));
            }
        }

        /**
         * Node in which all content consists of JSON definition
         */
        class JSONNode extends MetaNode {
            static pattern = /^!JSON(?<value>.+)$/;
            static match(value) {
                return JSONNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
            }
            expand(context) {
                // consolidate the content of this node
                const getContent = (str, node) =>
                    str + `${node.value}\n${this.content.reduce(getContent, '')}`;
                const content = this.content.reduce(getContent, '');
                try {
                    return JSON.parse(content);
                } catch (err) {
                    context.warning(`Failed to parse the JSON at line ${this.lineNumber}`);
                }
                return [];
            }
        }

        /**
         * Calculate schedule data for a set of nodes
         */
        function schedule(nodes, context, data) {
            const view = context.views[context.views.length - 1] || 'schedule';
            const get = (node, property) => node[symbols.views][view]?.[property] ?? node[property];
            const first = new Date(Math.min(...nodes.map((node) => get(node, 'start')).filter((start) => start)));
            const start = !isNaN(first) ? first : (data.start ?? new Date());

            quantiseDate(start);
            const inputs = [];
            const links = [];

            const getDuration = (node) =>
                (node[symbols.views.duration] ?? node.duration ?? 0);

            const sources = [];
            const sinks = [];

            // link inputs to outputs based on names
            nodes.forEach((node) => {
                const proxy = makeProxy(node, view);
                const inputList = [proxy.inputs ?? []].flatMap((i) => i).filter((i) => i);
                const outputList = [proxy.outputs ?? []].flatMap((i) => i).filter((i) => i);

                node[symbols.views][view] = node[symbols.views][view] || {};
                node[symbols.views][view].inputs = inputList.map((input) => {
                    const parts = input.split(':');
                    const to = {
                        node,
                        name: parts[0],
                        event: parts[1] ?? 'start',
                        lag: parts[2] ?? 0,
                        links: [],
                    }
                    const from = sources.find((link) => link.name === to.name && (link.from?.node !== node));
                    if (from) {
                        const link = { name: to.name, from, to };
                        from.links.push(link);
                        to.links.push(link);
                    }

                    return to;
                });

                node[symbols.views][view].outputs = outputList.map((output) => {
                    const parts = output.split(':');
                    const date = new Date(parts[1]);
                    const from = {
                        node,
                        name: parts[0],
                        event: parts[1] ?? 'finish',
                        lag: parts[2] ?? 0,
                        date: isNaN(date) ? undefined : date,
                        links: [],
                    };
                    const inputs = sinks.filter((link) => link.name === parts[0] && (link.to !== node) && (link.from === undefined));
                    inputs.forEach((to) => {
                        const link = { name: parts[0], from, to };
                        from.links.push(link);
                        to.links.push(link);
                    });
                    return from;
                });

                node[symbols.views][view].outputs.push(
                    { node, name: `${node.name} started`, event: 'start', lag: 0, links: [], autoGenerated: true, },
                    { node, name: `${node.name} finished`, event: 'finished', lag: 0, links: [], autoGenerated: true, });

                sinks.push(...node[symbols.views][view].inputs);
                sources.push(...node[symbols.views][view].outputs);

                if (getDuration(node) === 0) {
                    if (0 && node[symbols.content].length) {
                        node[symbols.views][view].shape = 'package';
                        node[symbols.views][view]['text align'] = 'middle';
                        node[symbols.views][view]['text vertical align'] = 'above';
                    } else {
                        node[symbols.views][view].shape = node[symbols.views][view].shape || node.shape || 'milestone';
                        node[symbols.views][view].width = node[symbols.views][view].width || node.width || 60;
                        node[symbols.views][view].height = node[symbols.views][view].height || node.height || 60;
                        node[symbols.views][view].textWidth = 0;
                        //node[symbols.views][view]['text align'] = 'outside right';
                    }
                } else {
                    node[symbols.views][view].shape = 'activity';
                }
            });

            const getEarliest = (link) => {
                let outputLag = 0;
                if (link.from.date) {
                    return new Date(link.from.date.getTime());
                }
                if (link.from.lag.endsWith && link.from.lag.endsWith('%')) {
                    outputLag = Math.ceil(getDuration(link.from.node) * parseFloat(link.from.lag) / 100);
                } else {
                    outputLag = link.from.lag;
                }
                const totalLag = outputLag + parseFloat(link.to.lag);
                if (link.from.event === 'start') {
                    return offsetDate(new Date(getEarlyStart(link.from.node)), totalLag);
                } else {
                    return offsetDate(new Date(getEarlyFinish(link.from.node)), totalLag);
                }
            }

            const getEarliestStart = (link) => {
                const date = getEarliest(link);
                if (link.to.event === 'finish') {
                    offsetDate(date, 1 - getDuration(link.to.node));
                } else if (getDuration(link.to.node) && link.to.event === 'start' &&
                           (link.from.date || link.from.event === 'finish')) {
                    offsetDate(date, 1);
                }
                return date;
            }

            const getEarlyStart = (node) => {
                const proxy = makeProxy(node, view);

                if (!proxy.earlyStart) {
                    const nodeStart = proxy.start;
                    const inputs = proxy.inputs.flatMap((input) => input.links);
                    if (nodeStart?.getTime) {
                        proxy.earlyStart = new Date(nodeStart);
                    } else if (inputs.length) {
                        proxy.earlyStart = new Date(Math.max(...inputs.filter((link) => link.from).map((link) => getEarliestStart(link).getTime())));
                    } else {
                        proxy.earlyStart = start;
                    }
                }
                quantiseDate(proxy.earlyStart, 8);
                return proxy.earlyStart;
            }

            const getEarlyFinish = (node) => {
                if (node[symbols.views][view].finish) {
                    return node[symbols.views][view].finish;
                }
                const finish = getCalendarDays(getEarlyStart(node), node[symbols.views]?.[view]?.duration ?? node.duration ?? 0);
                quantiseDate(finish, 17);
                return finish;
            };

            // Set any nodes that have a set date
            nodes.forEach((node) => {
                if (node[symbols.views][view].start) {
                    node[symbols.views][view].earlyStart = quantisedDate(node[symbols.views][view].start, 8);
                    node[symbols.views][view].earlyFinish = getEarlyFinish(node);
                }
                if (node[symbols.views][view].finish) {
                    node[symbols.views][view].lateFinish = quantisedDate(node[symbols.views][view].finish, 17);
                    node[symbols.views][view].lateStart = getCalendarDays(node[symbols.views][view].finish, node[symbols.views]?.[view]?.duration ?? -node.duration ?? 0);
                    quantiseDate(node[symbols.views][view].lateStart, 8);
                }
            });

            nodes.forEach((node) => {
                if (getDuration(node) === 0) {
                    const date = getEarlyStart(node);
                    quantiseDate(date, 12);
                    node[symbols.views][view].start = date;
                    node[symbols.views][view].finish = date;
                } else {
                    node[symbols.views][view].start = getEarlyStart(node);
                    node[symbols.views][view].finish = getEarlyFinish(node);
                }
            });
            nodes.sort((a, b) => getEarlyFinish(a) - getEarlyFinish(b));
            const reversed = nodes.toReversed();
            const finish = new Date(Math.max(data.finish ?? 0, getEarlyFinish(reversed[0])));

            const getLatest = (link) => {
                const inputLag = (link.to.lag ?? 0) * 24 * 60 * 60 * 1000;

                if (link.from.date) {
                    return link.from.date.getTime() - inputLag;
                }
                if (link.to.event === 'start') {
                    return getLateStart(link.to.node).getTime() - inputLag;
                }
                return getLateFinish(link.to.node).getTime() - inputLag;
            }

            const getLateFinish = (node) => {
                const proxy = makeProxy(node, view);
                let lateFinish = getEarlyFinish(reversed[0]);
                const outputs = proxy.outputs.flatMap((output) => output.links);
                if (proxy.lateFinish) {
                    lateFinish = proxy.lateFinish;
                } else if (outputs.length) {
                    lateFinish = new Date(Math.min(...outputs.map((link) => {
                        const time = getLatest(link);

                        const outputLag = (link.from.lag ?? 0) * 24 * 60 * 60 * 1000;
                        if (link.from.date) {
                            const lateStart = new Date(link.from.date.getTime() - outputLag);
                            return getCalendarDays(lateStart, node[symbols.views]?.[view]?.duration ?? node.duration ?? 0);
                        }
                        if (link.from.event === 'start') {
                            const lateStart = new Date(time - outputLag);
                            return getCalendarDays(lateStart, node[symbols.views]?.[view]?.duration ?? node.duration ?? 0);
                        }
                        const date = new Date(time - outputLag);
                        if (getDuration(link.to.node) && link.to.event === 'start' && (link.from.date || link.from.event === 'finish')) {
                            offsetDate(date, -1);
                        }
                        return date;
                    })));
                }
                quantiseDate(lateFinish, 17);
                return lateFinish;
            }

            const getLateStart = (node) => {
                const finish = quantisedDate(getLateFinish(node), 8);
                return getCalendarDays(finish, -(node[symbols.views]?.[view]?.duration ?? node.duration ?? 0));
            };

            const getLinkFloat = (link) => {
                if (link.float === undefined) {
                    link.float = workingDays(quantisedDate(getEarliestStart(link)), quantisedDate(link.to.node[symbols.views][view].start));
                }
                return link.float;
            };

            const getFloat = (node) => {
                if (node[symbols.views][view].float === undefined) {
                    const dependents = node[symbols.views][view].outputs.flatMap((output) => output.links);
                    if (dependents.length) {
                        node[symbols.views][view].float = Math.min(...dependents.map((link) => getLinkFloat(link) + getFloat(link.to.node)));
                    } else {
                        node[symbols.views][view].float = 0;//workingDays(node[symbols.views][view].finish, quantisedDate(finish));
                    }
                }
                return node[symbols.views][view].float;
            };

            reversed.forEach((node) => {
                if (getDuration(node) === 0) {
                    const date = getLateFinish(node);
                    quantiseDate(date, 12);
                    node[symbols.views][view].lateStart = date;
                    node[symbols.views][view].lateFinish = date;
                } else {
                    node[symbols.views][view].lateFinish = getLateFinish(node);
                    node[symbols.views][view].lateStart = getLateStart(node);
                }
                getFloat(node);
            });

            const offset =
                nodes[0][symbols.views][view].start = new Date(Math.min(...nodes.map((getEarlyStart))) - 7 * 24 * 60 * 60 * 1000);
            nodes[0][symbols.views][view].finish = finish;
            nodes[0][symbols.views][view].finish.setDate(finish.getDate() + 2);
            nodes[0][symbols.views][view].duration = dayNumber(finish) - dayNumber(nodes[0][symbols.views][view].earlyStart);
            //nodes[0][symbols.views][view].shape = 'timeline';
        }

        /**
         * Restructure child data based on rules in patent
         */
        function restructure(nodes, context) {

        }


        /**
         * Update all nodes matching the pattern defined by the node content
         */
        class UpdateNode extends MetaNode {
            static pattern = /^\~(?<value>.+)$/;
            static match(value) {
                return UpdateNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(UpdateNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                // Generate a temporary node
                this.value = `${this.value};${context.scope.flatMap((scope) => scope.defaults).join(';')}`;
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const nodeListLength = context.nodeList.length;
                const testNode = this.makeNode(context);
                context.nodeList.length = nodeListLength;

                let nodes = [];
                let func;
                if (testNode.name) {
                    const functions = [schedule, restructure];
                    const pattern = `(?<function>${functions.map((func) => func.name).join('|')})\((?<name>.*)\)$`;
                    const modify = testNode.name.match(new RegExp(pattern));
                    if (modify) {
                        func = functions.find((func) => func.name === modify.groups.function);
                        testNode.name = modify.groups.name.slice(1, -1);
                    }
                    if (testNode.name.startsWith('/') && testNode.name.endsWith('/')) {
                        nodes = context.nodeList.filter((node) => node !== testNode);
                        try {
                            const pattern = new RegExp(testNode.name.slice(1, -1));
                            nodes = nodes.filter((node) => pattern.test(node.name));
                        } catch (err) {
                            warn(`Invalid regular expression ${testNode.name.slice(1, -1)} on line ${this.line}`);
                        }
                    }
                    if (testNode.name.startsWith('...')) {
                        const node = context.nodeList.find((node) => node.name === testNode.name.slice(3));
                        if (node) {
                            nodes.push(...getAncestors(node));
                        }
                    }
                    if (testNode.name.endsWith('...')) {
                        const node = context.nodeList.find((node) => node.name === testNode.name.slice(0, -3));
                        const descendants = (nodes) => nodes.flatMap((node) => [node, ...descendants(node[symbols.content])]);
                        if (node) {
                            nodes.push(...descendants([node]));
                            //Object.assign(testNode, node);
                        }
                    }
                }
                const tests = [];
                Object.entries(testNode).forEach(([key, value]) => {
                    if (key.startsWith('*')) {
                        tests.push((node) => node[key.replace(/^\*/, '')] === value);
                    }
                });

                context.views.forEach((view) => {
                    const viewData = testNode[symbols.views][view] ?? {};
                    Object.entries(viewData).forEach(([key, value]) => {
                        if (key.startsWith('*')) {
                            tests.push((node) => node[symbols.views][view]?.[key.replace(/^\*/, '')] === value);
                        }
                    });
                });

                nodes = nodes.filter((node) => tests.every((test) => test(node)));

                if (nodes.length) {
                    if (func) {
                        return func(nodes, context, testNode) ?? [];
                    }
                    if (context.views.length) {
                        context.views.forEach((view) => {
                            const update = Object.entries(testNode[symbols.views][view])
                                .filter(([key, value]) => !(key.startsWith('*') || key === 'name'))
                                .reduce((obj, [key, value]) => {
                                    obj[key] = value;
                                    return obj;
                                }, {});

                            nodes.forEach((node) => {
                                node[symbols.views][view] = node[symbols.views][view] || { [symbols.values]: [] };
                                Object.assign(node[symbols.views][view], update);
                            });
                        });
                    } else {
                        const valueKeys = Object.keys(testNode).filter((key) => !key.startsWith('*') && key !== 'name');
                        nodes.forEach((node) => {
                            valueKeys.forEach((key) => node[key] = testNode[key]);
                        });
                    }
                    nodes.forEach((node) => {
                        this.startScope(context, node);
                        node[symbols.content].push(...this.content.flatMap((node) => node.expand(context)));
                        this.endScope(context);
                    })
                    return [];
                }
                return [];// testNode;
            }
        }

        class DefaultNode extends MetaNode {
            static pattern = /^\!(?<value>.+)$/;
            static match(value) {
                return DefaultNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(DefaultNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                if (this.content.length) {
                    this.startScope(context);
                    context.scope[0].defaults.push(this.value);
                    const content = this.content.flatMap((node) => node.expand(context));
                    this.endScope(context);
                    return content;
                }
                context.scope[0].defaults.push(this.value);
                return this.content.flatMap((node) => node.expand(context));
            }
        }

        class DocumentationNode extends MetaNode {
            static pattern = /^(?<name>[-a-zA-Z0-9 _]+):$/;
            static match(value) {
                return DocumentationNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(DocumentationNode.pattern);
                this.name = match.groups.name;
            }
            expand(context) {
                if (this.content.length) {
                    this.startScope(context);
                    const content = this.content.flatMap((node) => node.expand(context));
                    this.endScope(context);
                    const lines = [];
                    let lastLine = content[0][symbols.source][0].lineNumber;
                    const level = content[0][symbols.source][0].level;
                    const addNode = (node) => {
                        lastLine += 1;
                        while (lastLine < node[symbols.source][0].lineNumber) {
                            lines.push('\n');
                            lastLine += 1;
                        }
                        const padding = ''.padStart(node[symbols.source][0].level - level, ' ');

                        lines.push(`${padding}${node.name}\n`);
                        node[symbols.content].forEach(addNode);
                        lastLine = node[symbols.source][0].lineNumber;
                    }
                    content.forEach(addNode);
                    context.scope[0].node[this.name] = lines.join('');
                }
                return [];
            }
        }
        
        class ViewNode extends MetaNode {
            static pattern = /^::(?<value>.+)$/;
            static match(value) {
                return ViewNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ViewNode.pattern);
                this.value = match.groups.value;
            }
            expand(context) {
                context.views.push(this.value);
                super.startScope(context);
                const content = this.content.flatMap((node) => node.expand(context));
                super.endScope(context);
                context.views.pop();
                return content;
            }
        }

        class GroupNode extends MetaNode {
            static pattern = /^\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
            static match(content) {
                const pattern = /^\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\[(?<list>[^\]]+)\]\s*(?<name>\S.*)?/;
                const match = value.match(pattern);
                this.list = match.groups.list;
                this.name = match.groups.name || '';
            }
            expand(context) {
                // Process the elements of the value based on the context
                context.modifiers.forEach((modifier) => {
                    this.list = modifier.apply(this.list);
                    this.name = modifier.apply(this.name);
                });
                this.group = getGroupData(this.list);
                this.name = (this.name || '').trim();
                const content = this.group.flatMap((item, index) => {
                    context.scope[0].values[this.name] = item;
                    context.scope[0].values[`${this.name}_n`] = index;
                    return this.content.flatMap((node) => node.expand(context));
                });
                return content;
            }
        }

        class TemplateNode extends MetaNode {
            static match(content) {
                const pattern = /^(?<value>\S.*)\[(?<list>[^\]]+)\]\s*$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^(?<value>\S.*)\[(?<list>[^\]]+)\]\s*$/;
                const match = value.match(pattern);

                this.value = match.groups.value;
                this.list = match.groups.list;
            }
            expand(context) {
                // Process the elements of the value based on the context
                this.value = `${this.value};${context.scope.flatMap((scope) => scope.defaults).join(';')}`;
                context.modifiers.forEach((modifier) => {
                    this.list = modifier.apply(this.list);
                    this.value = modifier.apply(this.value);
                });

                this.group = getGroupData(this.list);
                this.name = (this.name || '').trim();
                const content = this.group.flatMap((item, index) => {
                    context.scope[0].values[this.name || '_'] = item;
                    context.scope[0].values[''] = item;
                    context.scope[0].values[`${this.name}_n`] = index;
                    return super.makeNode(context);
                });
                return content;
            }
        }

        /**
         * Create a duplicate tree based on the defintion of the referenced node.
         * <parameter=value>
         */
        class ReferenceNode extends MetaNode {
            static pattern = /^<(?<parameter>[^=]+)=(?<value>[^>]+)>$/;
            static match(content) {
                return ReferenceNode.pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const match = value.match(ReferenceNode.pattern);

                this.parameter = match.groups.parameter;
                this.value = match.groups.value;
            }
            expand(context) {
                // Process the elements of the value based on the context
                context.modifiers.forEach((modifier) => {
                    this.parameter = modifier.apply(this.parameter.trim());
                    this.value = modifier.apply(this.value.trim());
                });

                const refNode = context.nodeList.find((node) => node[this.parameters] === this.value);
                if (refNode) {
                    return refNode.source.expand(context);
                }
                context.warnings.push(`Unresolved reference ${this.parameter} = ${this.value} on line: $(this.lineNumber}`);

                return this.makeNode(context);
            }
        }

        /**
         * Add the contents if the condition is true
         */
        class ConditionalNode extends MetaNode {
            static match(content) {
                const pattern = /^\?\[(?<expr>[^\]]+)\]\s*(?<content>.*)/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
                const pattern = /^\?\[(?<expr>[^\]]+)\]\s*(?<value>.*)/;
                const match = value.match(pattern);

                this.value = match.groups.value;
                this.expr = match.groups.expr;
            }
            expand(context) {
                context.modifiers.forEach((modifier) => {
                    this.expr = modifier.apply(this.expr);
                    this.value = modifier.apply(this.value);
                });

                const expr = `return ${context.resolve(this.expr)}`;
                try {
                    const variables = context.scope.toReversed().reduce((values, scope) =>
                        Object.assign(values, scope.values), {});
                    const names = Object.keys(variables).map((name) => name ? name : '_');
                    const values = Object.values(variables);
                    const func = new Function(...names, expr);
                    if (func(...values)) {
                        return this.content.flatMap((node) => node.expand(context));
                    }
                } catch (err) {
                    warn(`Invalid expression on line ${this.lineNumber} (${expr})`);
                }
                // Return an empty list on test failure or exception;
                return [];
            }
        }

        /**
         * Replace matching content prior to processing
         */
        class PatternNode extends MetaNode {
            static pattern = /^!\/(?<pattern>[^\/]+)\/(?<flags>[ig])?\s*->\s*(?<replacement>.+)$/;
            static match(content) {
                return this.pattern.test(content);
            }
            constructor(value, level, lineNumber, context) {
                super(value, level, lineNumber);

                const match = value.match(PatternNode.pattern);

                this.replacement = match.groups.replacement.trim();
                try {
                    this.expression = new RegExp(match.groups.pattern, match.groups.flags);
                } catch (err) {
                    warn(`Parsing ${match.groups.pattern} failed!`);
                }
            }
            preprocess(node) {
                node.value = node.value.replace(this.expression, this.replacement);
            }
            expand(context) {
                return this.content.flatMap((node) => node.expand(context));
            }
        }

        /**
         * Replace node with content of file.
         */
        class ImportNode extends MetaNode {
            static cache = {};
            static pattern = /^--<(?<url>[^>]+)>--\s*/;
            static match(content) {
                return this.pattern.test(content);
            }
            static clearCache() {
                ImportNode.cache = {};
            }
            constructor(value, level, lineNumber, context) {
                super(value, level, lineNumber);

                const match = value.match(ImportNode.pattern);

                this.url = match.groups.url.trim();
            }
            expand(context) {
                if (ImportNode.cache[this.url] === undefined) {
                    ImportNode.cache[this.url] = '';
                    fetch(this.url).then((response) => {
                        response.text().then((text) => {
                            ImportNode.cache[this.url] = text;
                            Core.parse();
                        });
                    });
                }
                const structure = getStructure(ImportNode.cache[this.url]);
                return expand(structure, valueParser);//this.content.flatMap((node) => node.expand(context));
            }
        }

        /**
         * Replace pattern in following nodes with given string.
         */
        class ParsedPatternNode extends MetaNode {
            static pattern = /^\/(?<pattern>[^\/]+)\/(?<flags>[ig])?\s*->\s*(?<replacement>.+)$/;
            static match(content) {
                return ParsedPatternNode.pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const match = value.match(ParsedPatternNode.pattern);

                this.pattern = match.groups.pattern;
                this.flags = match.groups.flags;
                this.replacement = match.groups.replacement.trim();
            }
            expand(context) {
                try {
                    this.expr = new RegExp(this.pattern, this.flags);
                    this.apply = (value) => value.replace(this.expr, this.replacement);
                } catch (err) {
                    error(`Invalid Regular expression on line ${lineNumber}`);
                    this.apply = (value) => value;
                }
                context.modifiers.unshift(this);
                const content = this.content.flatMap((node) => node.expand(context));
                context.modifiers.shift();
                return content;
            }
        }

        /**
         * Use format to define following nodes
         */
        class FormatNode extends MetaNode {
            static match(content) {
                const pattern = /^\$(?<format>(<[^>]+>[^<]+)*(<[^>]+>))\s*;?\s*$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const pattern = /^\$(?<format>(<[^>]+>[^<]+)*(<[^>]+>))\s*;?\s*$/;
                const match = value.match(pattern);
            }
            apply(value) {

            }
            expand(context) {
                const content = this.content.flatMap((node) => node.expand(context));
                return content;
            }
        }

        class TableNode extends MetaNode {
            static pattern = /^\|(?<headings>[^\t;\|]+([\t;\|][^\t;\|]+)*)\|?$/;
            static match(value) {
                return TableNode.pattern.test(value);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);

                const match = value.match(TableNode.pattern);
                this.headings = match.groups.headings.split(/[\t;\|]/g);
            }
            apply(context, node, namedValues, unnamed, references) {
                const nodes = context.views.length ? context.views.map((view) => {
                    node[symbols.views][view] = node[symbols.views][view] || { [symbols.values]: [] };
                    return node[symbols.views][view];
                }) : [node];

                this.headings.forEach((heading, index) => {
                    nodes.forEach((node) => {
                        const value = unnamed.shift();

                        if (value !== undefined) {
                            heading = heading.trim();
                            // Use the heading ending with '*' as the name of the object
                            if (heading.endsWith('*')) {
                                node.name = node[symbols.values][index];
                                heading = heading.replace(/\*\s*$/, '');
                            }
                            if ((value + '').trim().startsWith('^')) {
                                const referenced = value.length > 1 ? value.slice(1) : heading;
                                Object.defineProperty(node, heading, {
                                    enumerable: true,
                                    get() {
                                        let container = this[symbols.container];
                                        while (container && container[referenced] === undefined) {
                                            container = container[symbols.container];
                                        }
                                        if (container) {
                                            return container[referenced];
                                        }
                                        return value;
                                    }
                                });
                            } else {
                                namedValues[heading] = value;
                            }
                        }
                    });
                });
            }
            expand(context) {
                context.parsers.unshift(this);
                const content = this.content.flatMap((node) => node.expand(context));
                context.parsers.shift(this);
                return content;
            }
        }

        class PathNode extends MetaNode {
            static match(content) {
                const pattern = /^[\./].+$/;
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
            }
            expand(context) {

                this.value = `${this.value};${context.scope.flatMap((scope) => scope.defaults).join(';')}`;
                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                const path = this.value.split(/[\t;\|]/, 1)[0].split(/[\./]/g).slice(1);
                this.value = this.value.replace(/^[^\t;\|]+[\t;\|]/, '');

                const node = super.makeNode(context);
                node[symbols.values].unshift(path.join());

                if (path.length) {
                    const containerID = path.slice(0, -1).join();
                    const scope = context.ancestors.find((node) => node[symbols.values][0] === containerID)
                    const container = scope ? scope :
                        context.nodeList.find((node) =>
                            node[symbols.values][0] === containerID);
                    if (container) {
                        container[symbols.content].push(node);
                        return [];
                    }
                }
                return node;
            }
        }

        class PlainNode extends MetaNode {
            static match(content) {
                const pattern = /^.*$/;   // Match anything not already matched
                return pattern.test(content);
            }
            constructor(value, level, lineNumber) {
                super(value, level, lineNumber);
            }
            expand(context) {
                this.value = `${this.value};${context.scope.flatMap((scope) => scope.defaults).join(';')}`;

                context.modifiers.forEach((modifier) => {
                    this.value = modifier.apply(this.value);
                });
                return super.makeNode(context);
            }
        }

        /**
         * convert string definition to structure
         */
        function getStructure(definition) {
            const lines = definition.split(/\r?\n/);
            const structure = [];
            const stack = [];
            const names = {};

            // The structure is determined by indentation, level, or 'path' style.
            // When using indentation a tab is equivelent to 4 spaces.
            // Level is indicated by > at the start of a line followed by integer
            // at start of line.
            // Path is indicated by optional whitespace followed by a '.'
            // separated path, including a leading and trailling '.'.

            let lineNumber = 0;
            for (const line of lines) {
                ++lineNumber;
                if (/^\s*(#|$)/.test(line)) {
                    continue;
                }

                // Level can be determined by indentaion or numerically
                // Convert a leading integer into that number of spaces
                let level = 0;
                let levelCount = '';
                let offset = 0;
                let i = 0;
                const lineStructure = /^(?<indent>\s*[\^_]?\s*([0-9]+\s+)?)(?<value>.*)$/
                const match = line.match(lineStructure);
                const indent = match.groups.indent || ''; //line.replace(/(\s*([0-9]+\s+)?)(.*)/, '$1');
                for (let i = 0; i < indent.length; ++i) {
                    const c = indent[i];
                    if (/[0-9]/.test(c)) {
                        levelCount += c;
                    } else if (c === '^' && stack.length) {
                        offset = stack[0].level;
                    } else if (c === '_') {
                        offset = 0;
                    } else if (c === '\t') {
                        level += 4 - (level % 4);
                    } else {
                        level += 1;
                    }
                }
                level += offset;
                if (levelCount) {
                    level += parseInt(levelCount);
                }

                while (stack.length && stack[0].level >= level) {
                    stack.shift();
                }

                const value = match.groups.value;

                const node = {
                    value, lineNumber, level, content: [],
                }
                if (stack[0]) {
                    stack[0].content.push(node);
                } else {
                    structure.push(node)
                }
                stack.unshift(node);
            }
            return structure;
        }

        /**
         *
         */
        function numberOrString(input) {
            const num = Number(input);
            if (isNaN(num)) {
                const date = new Date(input);
                if (/^[0-9]{1,4}[-\/ ]([0-9]{1,2}|[a-zA-Z]{2,})[-\/ ][0-9]{1,4}$/.test(input) && !isNaN(date.getTime())) {
                    return date;
                }
                return input.trim();
            }
            return num;
        }

        /**
         *
         */
        function setProperty(obj, name, input) {
            if (input.trim().startsWith('=')) {
                const expr = input.trim().slice(1);
                try {
                    const func = new Function(`
                    try {
                        return ${expr};
                    } catch (err) {
                        return 0;
                    }`);
                    Object.defineProperty(obj, name, {
                        enumerable: true,
                        get: func,
                    });
                } catch (err) {
                    error(err);
                    obj[name] = input;
                }
            } else {
                obj[name] = numberOrString(input);
            }
        }

        const funcs = {
            sum: (list) => list.reduce((t, i) => t + i, 0),
            mean: (list) => list.reduce((t, i) => t + i, 0) / list.length,
            median: (list) => {
                list.sort((a, b) => a - b);
                if (list.length % 2) {
                    return list[(list.length - 1) / 2];
                }
                return (list[(list.length / 2) - 1] + list[list.length / 2]) / 2;
            },
            mode: (list) => {
                list.sort((a, b) => a - b);
                let max = 0;
                let mode;
                let last = undefined;
                let count = 0;
                list.forEach((value) => {
                    if (value === last) {
                        count += 1;
                    } else {
                        count = 0;
                    }
                    if (count > max) {
                        mode = value;
                        max = count;
                    }
                    last = value;
                });
                return mode;
            },
            concat: (list) => list.join(),
        };

        function getReference(context, name) {
            const nodes = context.nodeList.filter((node) => node[symbols.names].includes(name));
            if (nodes.length > 0) {
                return nodes;
            } else {
                const path = name.split(/[-\/\.]/);
                path.shift();
                if (path.length > 1) {
                    const first = path.shift();
                    let matches = context.nodeList.filter((node) => node[symbols.names].includes(first));
                    let last = [];
                    let index = 0;
                    while ((index < path.length) && matches.length) {
                        last = matches;
                        matches = matches.flatMap((node) =>
                            node[symbols.content].filter((node) => node[symbols.names].includes(path[index])));
                        ++index;
                    }
                    if (matches.length > 0) {
                        return matches;
                    }
                    matches = last;

                    --index;
                    while ((index < path.length) && matches.length) {
                        matches = last.flatMap((node) => node[path[index]] ?? []);
                        ++index;
                    }
                    --index;
                    return matches;
                }
            }
            return [];
        }




        /**
         * Generate a node parameters from the value string and context
         */
        function valueParser(node, value, context, newNode) {
            if (value) {
                const nodes = context.views.length ? context.views.map((view) => {
                    node[symbols.views][view] = node[symbols.views][view] || { [symbols.values]: [] };
                    return node[symbols.views][view];
                }) : [node];

                const namedValues = {};
                const unnamed = [];
                const references = [];

                const getReference = (name) => {
                    const nodes = context.nodeList.filter((node) => node[symbols.names].includes(name));
                    if (nodes.length > 0) {
                        return nodes;
                    } else {
                        const path = name.split(/[-\/\.]/);
                        path.shift();
                        if (path.length > 1) {
                            const first = path.shift();
                            let matches = context.nodeList.filter((node) => node[symbols.names].includes(first));
                            let last = [];
                            let index = 0;
                            while ((index < path.length) && matches.length) {
                                last = matches;
                                matches = matches.flatMap((node) =>
                                    node[symbols.content].filter((node) => node[symbols.names].includes(path[index])));
                                ++index;
                            }
                            if (matches.length > 0) {
                                return matches;
                            }
                            matches = last;

                            --index;
                            while ((index < path.length) && matches.length) {
                                matches = last.flatMap((node) => node[path[index]] ?? []);
                                ++index;
                            }
                            --index;
                            namedValues[path[index]] = matches[0];
                        }
                    }
                }

                const data = value.split(/[\|\t;\u{1f}]/gu);
                data.forEach((item) => {
                    item = item.trim();
                    if (item.includes('=')) {
                        const [nameDef, ...valueArr] = item.split(/=/);
                        const name = nameDef.replace(/^\\/, '').replace(/\\$/, '').trim();
                        const value = valueArr.join('=').trim();
                        if (nameDef.endsWith('\\')) {
                            context.scope[0].propagate[name] = value;
                        }
                        namedValues[name] = value;
                    } else if (item.startsWith('&')) {  // mix in values from reference
                        const nodes = getReference(item.replace(/^&\s*/, ''));
                        if (nodes) {
                            references.push(...nodes);
                        } else {
                            unnamed.push(item);
                        }
                    } else if (item.startsWith('@')) {  // add reference to named node(s)
                        const nodes = getReference(item.replace(/^@\s*/, ''));
                        unnamed.push(nodes === undefined ? item : (nodes.length === 1 ? nodes[0] : nodes));
                    } else if (item.startsWith('^')) {  // gel value from ancestor
                        const name = item.slice(1).trim();
                        const value = context.scope.find((scope) => scope.node[name] !== undefined);
                        if (value) {
                            namedValues[name] = value.node[name];
                        } else {
                            unnamed.push(name);
                        }
                    } else if (item.startsWith('~')) {  // Alternative name
                        node[symbols.names].push(item.slice(1).trim());
                    } else {
                        unnamed.push(item);
                    }
                });

                context.parsers.forEach((parser) => parser.apply(context, node, namedValues, unnamed, references));

                if (value.includes('LOG')) {
                    console.log(references);
                }
                const getView = (name) =>
                    name.startsWith('::') ?
                        name.slice(2).split('.').map((item) => item.trim()) : [null, name];

                const linkMatch = data[0].match(/(?<start>.+)->(?<end>.+)/);
                if (linkMatch) {
                    const start = getReference(linkMatch.groups.start.trim());
                    const end = getReference(linkMatch.groups.end.trim());
                    if (start && end) {
                        namedValues.start = namedValues.start ?? start[0];
                        namedValues.end = namedValues.end ?? end[0];
                        namedValues.shape = namedValues.link ?? 'link';
                    }
                }

                nodes.forEach((targetNode) => {
                    if (newNode) {
                        node.name = data[0].trim();
                        node[symbols.names].push(data[0].trim());
                    }

                    references.reverse();
                    const values = Object.assign({}, context.scope[0].propagate, ...references, namedValues);

                    Object.entries(values).forEach(([name, value]) => {
                        const [view, partName] = getView(name);
                        let node = targetNode;
                        if (view && targetNode[symbols.views]) {
                            targetNode[symbols.views][view] = targetNode[symbols.views][view] ?? { [symbols.values]: [] };
                            node = targetNode[symbols.views][view];
                            name = partName;
                        }
                        if (value?.[symbols.source]) {
                            node[name] = value;
                        } else {
                            value = value + '';
                            if (value.includes('...')) {
                                const descendants = (nodes) => nodes.flatMap((node) => [node, ...descendants(node[symbols.content])]);
                                context.scope[0].finalisation.push((context) => {
                                    const values = node[symbols.content].map((node) => node[name]);
                                    node[name] = numberOrString(value.replace(/([^\(]+)\s*\(\s*(\.\.\.\.?)\s*\)/, (match, func, elements) => {
                                        const action = funcs[func.trim()];
                                        if (action) {
                                            const defined = (value) => value !== undefined;
                                            if (elements === '...') {
                                                return action(node[symbols.content].map((node) => node[name]).filter(defined));
                                            } else {
                                                return action(descendants(node[symbols.content]).map((node) => node[name]).filter(defined));
                                            }
                                        }
                                        return match;
                                    }));
                                    if (value.trim() === '...') {
                                        node[name] = node[symbols.content].map((node) => node[name]);
                                    } else if (value.trim() === '....') {
                                        node[name] = descendants(node[symbols.content]).map((node) => node[name]);
                                    }
                                });
                            } else if (value.trim() === '') {
                                node[name] = null;
                            } else if (/^"[^"]+"$/.test(value)) {
                                node[name] = value.replace(/^"([^"]+)"$/, '$1');
                            } else if (value.startsWith('^')) {
                                const referenced = value.length > 1 ? value.slice(1) : name;
                                let container = context.container.find((container) => container[referenced] !== undefined);
                                if (container) {
                                    node[name] = container[referenced];
                                } else {
                                    node[name] = value;
                                }
                            } else if (value.includes(',')) {
                                node[name] = [];
                                value.split(/,/g).forEach((val, index) => {
                                    val = val.trim();
                                    const nodes = getReference(val.slice(1).trim());
                                    if (nodes === undefined) {
                                        setProperty(node[name], index, val);
                                    } else {
                                        node[name][index] = (nodes.length === 1 ? nodes[0] : nodes);
                                    }
                                });
                            } else if (value.startsWith('@')) {
                                const nodes = getReference(value.slice(1).trim());
                                node[name] = nodes === undefined ? value : (nodes.length === 1 ? nodes[0] : nodes);
                            } else {
                                setProperty(node, name, value);
                            }
                        }
                    });

                    unnamed.forEach((item) => {
                        let value = item
                        if (item[symbols.source]) {

                        } else if (/^"[^"]+"$/.test(item)) {

                        } else if (item.includes(',')) {
                            value = item.split(/,/g).map((val) => numberOrString(val));
                        } else if (Array.isArray(item)) {
                            value = item.map((each) => node[symbols.values].push(each));
                        } else {
                            value = node[symbols.values].push(numberOrString(item));
                        }
                        node[symbols.values].push(value);
                    });

                    if (newNode) {
                        node.name = data[0].trim();
                    }
                });
            }
        }

        /**
         * Expand the structure
         */
        function expand(structure, parser) {
            const context = {
                nodeTypes: [
                    ImportNode,
                    PatternNode,
                    ContinuationNode,
                    VariableNode,
                    DefaultNode,
                    DocumentationNode,
                    ViewNode,
                    ExtensionNode,
                    GeneratorNode,
                    UpdateNode,
                    ConditionalNode,
                    GroupNode,
                    TemplateNode,
                    ReferenceNode,
                    ParsedPatternNode,
                    FormatNode,
                    TableNode,
                    PathNode,
                    PlainNode],
                scope: [{ node: { [symbols.values]: [], [symbols.content]: [] }, values: {}, modifiers: [], propagate: {}, defaults: [] }],
                ancestors: [],
                names: {},
                rootNodes: [],
                nodeList: [],
                modifiers: [],
                parsers: [],
                views: [],
                warnings: [],
                resolve(value) {
                    if (value) {
                        // Convert any variables in the string to the values in the context.
                        const variables = context.scope.toReversed().reduce((values, scope) =>
                            Object.assign(values, scope.node, scope.values), {});
                        const nodes = context.scope.map((scope) => scope.node).filter((node) => node);
                        let resolved = true;
                        value = value.replace(/<([^>]*)>/g, (match, name) => {
                            name = name.trim();
                            if (variables[name] !== undefined) {
                                return variables[name];
                            }
                            if (name.startsWith('::')) {
                                const view = name.slice(2).split('.', 1)[0].trim();
                                const variable = name.slice(view.length + 3).trim();
                                const node = nodes.find((node) => node[symbols.views]?.[view]?.[variable]);
                                if (node) {
                                    return node[symbols.views][view][variable];
                                }
                            }
                            resolved = false;
                            return `<${name}>`;
                        });
                        //value = value.replace(/\{([^:\}]+)(:0+)?\}(?<loop>\[[^\]]+\]([^\s;\t\|]+))?/g, (match, expr, format, loop, loopVar) => {
                        if (resolved) {
                            value = value.replace(/\{([^\+][^\}]*)\}(?<loop>\[[^\]]+\]([^\s;\t\|]+))?/g,
                                (match, expr, loop, loopVar) => {
                                    let result = match;
                                    const names = Object.keys(variables).map((name) => name ? name : '_');
                                    const values = Object.values(variables);
                                    if (loop) {
                                        const list = getGroupData(loop.replace(/\[([^\]]+)\][^\s;\t\|]+/, '$1'));
                                        names.push(loopVar);
                                        try {
                                            const func = new Function(...names, `return ${expr}`);
                                            result = list.reduce((ans, value) => ans + func(...values, value), '');
                                        } catch (err) {
                                            console.log(`Info: expression ${expr} unresolved`);
                                        }
                                    } else {
                                        try {
                                            result = new Function(...names, `return ${expr}`)(...values);
                                        } catch (err) {
                                            error(variables);
                                            error(err.name);
                                            error(err.message);
                                            error(`Info: expression ${expr} unresolved`);
                                        }
                                    }
                                    /*
                                    if (format) {
                                        result = (result + '').pad(format.length - 1, format[1]);
                                    }
                                    */
                                    return result;
                                });
                        }
                        return value;
                    }
                },
                parse(node, value, newNode) {
                    return parser(node, this.resolve(value), this, newNode);
                },
            };

            // Determine node type based on content
            const definitionScope = [{ modifiers: [] }];
            const define = (node) => {
                const modifiers = definitionScope.flatMap((scope) => scope.modifiers);
                modifiers.forEach((modifier) => modifier.preprocess(node));
                const type = context.nodeTypes.find((type) => type.match(node.value));
                if (type) {
                    const typedNode = new type(node.value, node.level, node.lineNumber);
                    if (typedNode.preprocess) {
                        definitionScope[0].modifiers.push(typedNode);
                    } else {
                        definitionScope.unshift({ modifiers: [] });
                    }
                    typedNode.content = node.content.flatMap((node) => define(node));
                    if (definitionScope.length && !typedNode.preprocess || typedNode.content.length) {
                        definitionScope.shift();
                    }
                    return typedNode;
                }
                return [];
            }
            const defined = structure.flatMap((node) => define(node));

            const expanded = defined.flatMap((node) => node.expand(context));
            return expanded;
        }

        /**
         * Toggle the expansion of a node.
         */
        function toggleExpansion(viewNode, recursive) {
            viewNode.structure = !viewNode.structure;

            const expand = (viewNode) => {
                if (recursive) {
                    viewNode.structure = true;
                }
                viewNode.nodes.forEach((node) => node.classList.remove('collapse'));
                if (viewNode.structure) {
                    viewNode.content.forEach((part) => expand(part));
                } else {
                    viewNode.nodes[1].classList.add('collapse');
                }
            };

            const collapse = (viewNode) => {
                if (recursive) {
                    viewNode.structure = false;
                }
                viewNode.nodes.forEach((node) => node.classList.add('collapse'));
                viewNode.content.forEach((part) => collapse(part));
            };

            if (viewNode.structure) {
                viewNode.content.forEach((part) => expand(part));
                viewNode.nodes[0].innerHTML = '&CircleMinus;';
                viewNode.nodes[1].classList.remove('collapse');
            } else {
                viewNode.content.forEach((part) => collapse(part));
                viewNode.nodes[0].innerHTML = '&CirclePlus;';
                viewNode.nodes[1].classList.add('collapse');
            }
        }

        class GridTreeView extends View {
            static settingsMap = {

            }
            constructor(title = 'GridTree', config = {}, content = []) {
                super('grid-tree-view-template', GridTreeView.settingsMap);
                this.main = this.node.querySelector('.tree');
                this.title = title;

                this.config = config;

                /*
                const search = this.node.querySelector('.search');
                search.addEventListener('input', (event) => this.incrementalSearch());
                search.addEventListener('change', (event) => this.search());

                this.searchStack = [];
                this.path = [];
                */
                this.structure = content;
            }
            set structure(structure) {
                const actions = {
                    click: (event, node) => Core.currentNode = node,
                };
                this.main.innerHTML = '';

                this.nodes = [];

                const flatten = (node, level = 1) => {
                    const viewNode = {
                        node, level
                    };
                    this.nodes.push(viewNode);
                    viewNode.content = node[symbols.content].map((part) => flatten(part, level + 1));
                    return viewNode;
                };

                const tree = structure.map((part) => flatten(part));

                let depth = Math.max(...this.nodes.map((node) => node.level));

                let row = 0;
                const addNode = (viewNode) => {
                    row += 1;
                    let text = viewNode.node.name;
                    viewNode.structure = true;
                    viewNode.row = row;
                    viewNode.nodes = [];

                    const group = document.createElement('div');
                    this.main.appendChild(group);
                    group.style.gridColumn = viewNode.level;
                    const expander = document.createElement('div');
                    expander.classList.add('expand');
                    viewNode.nodes.push(expander);
                    viewNode.nodes.push(group);
                    group.appendChild(expander);
                    const content = document.createElement('div');
                    content.classList.add('content');

                    viewNode.nodes.push(content);
                    content.style.gridColumn = `${viewNode.level + 1}/${depth + 2}`;
                    this.main.appendChild(content);
                    const data = Object.entries(viewNode.node).map(([name, value]) => `${name} = ${value}`).join(', ');
                    content.innerText = `${text}`;// (${data})`;
                    content.title = `${viewNode.node.uniqueName} ${data}`;
                    if (viewNode.node.shape) {
                        content.classList.add('shape');
                    }
                    if (viewNode.node.sceneNode) {
                        content.classList.add('scene-node');
                    }
                    Object.entries(actions).forEach(([event, action]) =>
                        content.addEventListener(event, (event) => action(event, viewNode.node)));

                    if (viewNode.content.length) {
                        group.classList.add('group');
                        expander.innerHTML = '&CircleMinus;';
                        expander.addEventListener('click', (event) => toggleExpansion(viewNode, event.ctrlKey));
                        expander.addEventListener('dblclick', (event) => toggleExpansion(viewNode, true));

                        const startRow = row;
                        viewNode.content.forEach((viewNode) => addNode(viewNode));
                        group.style.gridRow = `${startRow}/${row + 1}`;
                        group.style.background = `hsl(${360 * Math.random()} 50% 50%)`;
                    }
                };

                const columns = `repeat(${depth}, 1em) max-content 1fr`;
                this.main.style.gridTemplateColumns = columns;

                tree.forEach((node) => addNode(node));
            }
            set currentNode(node) {
                for (const domNode of this.node.querySelectorAll('.selected')) {
                    domNode.classList.remove('selected');
                }
                this.nodes.filter((viewNode) => viewNode.node === node)
                    .forEach((viewNode) => viewNode.nodes.forEach((node) => node.classList.add('selected')));
            }
        }

        const namedNodes = {};

        class Transition {
            constructor(node) {
                this.node = node.sceneNode;
            }
            start() { }
            finish() { }
        }

        class Translate extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
                }
                const p = d * d * (3 - 2 * d);
                const v = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    ...v, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...this.value, 1]);
            }
        }

        class Rotate extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
                if (this.value.length < 4) {
                    const start = this.value.length;
                    this.value.length = 4;
                    this.value.fill(0, start);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement,
                        getRotationMatrix(this.value[0], this.value.slice(1)));
                }
                const p = d * d * (3 - 2 * d);
                const angle = this.value[0] * p;
                this.node.movement = matrixMultiply(this.node.movement,
                    getRotationMatrix(angle, this.value.slice(1)));
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform,
                    getRotationMatrix(this.value[0], this.value.slice(1)));
            }
        }

        class Scale extends Transition {
            constructor(node, value) {
                super();
                if (Array.isArray(value)) {
                    this.value = value;
                } else {
                    this.value = Array(3).fill(value);
                }
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.movement = matrixMultiply(this.node.movement, [
                        this.value[0], 0, 0, 0,
                        0, this.value[1], 0, 0,
                        0, 0, this.value[2], 0,
                        0, 0, 0, 1,
                    ]);
                }
                const p = d * d * (3 - 2 * d);
                const s = scaled(this.value, p);
                this.node.movement = matrixMultiply(this.node.movement, [
                    s[0], 0, 0, 0,
                    0, s[1], 0, 0,
                    0, 0, s[2], 0,
                    0, 0, 0, 1,
                ]);
            }
            finish() {
                this.node.transform = matrixMultiply(this.node.transform, [
                    this.value[0], 0, 0, 0,
                    0, this.value[1], 0, 0,
                    0, 0, this.value[2], 0,
                    0, 0, 0, 1,
                ]);
            }
        }

        class ColourChange extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            start() {
                this.intialColour = this.node.colour;
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const v = this.value.forEach((v, i) =>
                    this.intialColour[i] + (v - this.intialColour[i]) * p);
                this.node.colour = v;
            }
        }

        class Fade extends Transition {
            constructor(node, value) {
                super();
                this.value = value;
            }
            start() {
                this.initialAlpha = this.node.colour[3];
            }
            progress(d) {
                if (d < 0) {
                    return;
                }
                if (d > 1) {
                    this.node.colour = value;
                }
                const p = d * d * (3 - 2 * d);
                const f = this.initialAlpha + (this.value - this.initialAlpha) * p;
                this.node.colour[3] = f;
            }
        }

        const nodeTransitions = {
            Translate, Rotate, Scale, ColourChange, Fade,
        };

        /**
         * Make a proxy that accesses view specific parameters then node parameters
         */
        function makeProxy(node, view) {
            const handler = {
                get(target, prop, receiver) {
                    return target[symbols.views]?.[view]?.[prop] ?? node[prop];
                },
                set(target, prop, value) {
                    target[symbols.views][view] = target[symbols.views][view] || {};
                    target[symbols.views][view][prop] = value;
                    return true;
                }
            }
            return new Proxy(node, handler);
        }

        /**
         * Generate scene graph for the given structure
         */
        function getGraph(structure, view) {
            view.data.vertex.length = 0;
            view.data.indices.length = 0;

            let links = 0;

            const types = {
                Box, Text, Ball, Frustum, Cylinder, Cone, Diamond, Tetrahedron, Torus, Prism, Link,
            }
            view.shapes = [];
            const shapes = {};

            const stack = [];
            view.graph = [];
            view.nodes = [];

            function getEvents(node, sceneNode) {
                const eventPattern = /^@(?<trigger>[^,]+)\s*,\s*(?<transition>[^=]+)/
                const triggerPattern = /^(?<time>[^\/]+)\/(?<duration>[^\/]+)/
                return Object.entries(node).map(([item, value]) => {
                    const event = item.match(eventPattern);
                    if (event) {
                        const transition = nodeTransitions[event.groups.transition];
                        const triggerWithDuration = event.groups.trigger.match(triggerPattern);
                        let startTime;
                        let endTime;
                        if (triggerWithDuration) {
                            endTime = numberOrString(triggerWithDuration.groups.time);
                            const duration = numberOrString(triggerWithDuration.groups.duration);
                            startTime = endTime - duration;
                        } else {
                            endTime = numberOrString(event.groups.trigger)
                            startTime = endTime - 1;
                        }
                        if (transition) {
                            return {
                                node: sceneNode,
                                startTime,
                                endTime,
                                transition: new transition(node, value),
                            };
                        }
                    }
                }).filter((i) => i);
            }

            const handler = {};

            const add = (node) => {
                const original = node;
                handler.get = (target, prop, receiver) =>
                    target[symbols.views]?.[view.title]?.[prop] ?? original[prop];
                node = new Proxy(node, handler);
                let index = 0;
                let positionalName = null;
                let position = node.position;

                const shapeName = positionalName || (node.shape ? node.shape.toLowerCase() : 'none');
                const typeName = shapeName.slice(0, 1).toUpperCase() + shapeName.slice(1).toLowerCase();
                report(typeName);

                let shape;
                if (typeName && types[typeName]) {
                    const hash = types[typeName].hash(node);
                    shapes[hash] = shapes[hash] || types[typeName].make(view, node, index, namedNodes);
                    shape = shapes[hash];
                    view.shapes.push(shape);
                }

                let endScope = false;
                if (node.name === 'Camera') {
                    if (node.lookAt && node.lookAt.length === 3) {
                        //camera.lookAt = node.lookAt;
                    }
                    if (position && position.length === 3) {
                        //camera.position = node.position;
                    }
                    if (node.up && node.up.length === 3) {
                        //camera.up = node.up;
                    }
                } else if (node.name === 'Background') {
                    if (node.colour) {
                        background.colour = node.colour;
                    }
                } else if (position && position.length === 3) {
                    position = position.map((v) => isNaN(v) ? 0 : v);
                    const shader = view.shaders[node.shader] || (typeName === 'Text' ? view.shaders['textured2'] : view.shaders['shader4']);
                    const transform = [];
                    if (node.rotation && node.rotation.length === 4) {
                        node.rotation = node.rotation.map((v) => isNaN(v) ? 0 : v);
                        const angle = Math.PI * node.rotation[0] / 180;
                        const axis = normalised([...node.rotation.slice(1)]);
                        const q = new Quaternion(
                            Math.cos(angle / 2),
                            Math.sin(angle / 2) * axis[0],
                            Math.sin(angle / 2) * axis[1],
                            Math.sin(angle / 2) * axis[2]);
                        q.setMatrix(transform);
                        transform[12] = position[0];
                        transform[13] = position[1];
                        transform[14] = position[2];
                    } else {
                        transform.push(
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            ...position, 1);
                    }
                    if (node.scale && !isNaN(node.scale)) {
                        transform[0] *= node.scale;
                        transform[5] *= node.scale;
                        transform[10] *= node.scale;
                    }
                    const parent = node.parent;
                    let colour = node.colour;
                    let ancestor = parent;
                    while (ancestor && !colour) {
                        colour = ancestor.colour;
                        ancestor = ancestor.parent;
                    }

                    if (Array.isArray(colour)) {
                        colour = [1, 0.9, 0.5, 1].map((v, i) => colour[i] != undefined ? colour[i] : v);
                    } else {
                        colour = [1, 0.9, 0.5, 1];
                    }
                    if (Array.isArray(node.specularColour) && node.specularColour.length === 3) {

                    }

                    const sceneNode = addNode(node, transform, shape, shader, colour);
                    if (node.texture) {
                        sceneNode.texture = view.getTexture(texture, scene);
                    }
                    node[symbols.viewData].set(view, sceneNode);
                    namedNodes[node.name] = sceneNode;
                    if (stack.length > 0) {
                        stack[0][symbols.content].push(sceneNode);
                    } else {
                        view.graph.push(sceneNode);
                    }
                    sceneNode.sourceNode = original;
                    stack.unshift(sceneNode);
                    endScope = true;
                }

                if (node[symbols.content].length) {
                    node[symbols.content].forEach((part) => add(part));
                }

                if (endScope) {
                    stack.shift();
                }
            };

            structure.forEach((part) => add(part));
            //view.events.sort((a, b) => (a.startTime) - (b.startTime));

            glErrors(view.gl, '>>> Update Buffers');
        }

        /**
         *
         */
        function associateArray(node, arr, action) {
            let index = 0;
            const update = (index) => {
                return (event, value) => arr[index] = event.target.valueAsNumber;
            }

            for (const input of node.querySelectorAll('input')) {
                input.value = arr[index];
                input.addEventListener('input', update(index));
                index += 1;
            }
        }

        /**
         * Vertex shader program
         */
        const shaderObjects = [
            {
                name: 'vsSource',
                type: 'vertex',
                source: `
attribute vec4 aVertexPosition;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

varying vec4 vPosition;

void main() {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    vPosition = gl_Position;
}
                `,
            },
            {
                name: 'vsSource2',
                type: 'vertex',
                source: `
attribute vec3 aPosition;
attribute vec3 aNormal;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    // Transform vertex position and normal to eye coordinates
    vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
    vPosition = eyePosition.xyz;
    vNormal = normalize(uNormalMatrix * aNormal);

    // Output vertex position in clip coordinates
    gl_Position = uProjectionMatrix * eyePosition;
}
                `,
            },
            {
                name: 'vsSource3',
                type: 'vertex',
                source: `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTextureCoord;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

varying vec3 vPosition;
varying vec3 vNormal;
varying highp vec2 vTextureCoord;

void main() {
    // Transform vertex position and normal to eye coordinates
    vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
    vPosition = eyePosition.xyz;
    vNormal = normalize(uNormalMatrix * aNormal);

    // Output vertex position in clip coordinates
    gl_Position = uProjectionMatrix * eyePosition;
    vTextureCoord = aTextureCoord;
}`,
            },
            {
                name: 'fsSource',
                type: 'fragment',
                source: `
precision mediump float;
varying vec4 vPosition;

uniform vec4 uColour;

void main() {
    gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
    vec4 colour = vPosition * 0.15 + 0.5;
    gl_FragColor = uColour;
}`,
            },
            {
                name: 'fsSource2',
                type: 'fragment',
                source: `
precision mediump float;
varying vec4 vPosition;

uniform vec4 uColour;

void main() {
    vec4 colour = vPosition * 0.5 + 0.5;
    gl_FragColor = colour * uColour;
}`,
            },
            {
                name: 'fsSource3',
                type: 'fragment',
                source: `
precision highp float;

uniform vec3 uLightPosition;
uniform vec4 uAmbientColour;
uniform vec4 uDiffuseColour;
uniform vec3 uSpecularColour;
uniform float uShininess;

varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    // ambient
    vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;

    // Calculate diffuse lighting contribution
    vec3 lightDirection = normalize(uLightPosition - vPosition);
    float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
    vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

    // Calculate specular lighting contribution
    vec3 viewDirection = normalize(-vPosition);
    vec3 reflectionDirection = reflect(-lightDirection, vNormal);
    float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
    vec3 specular = uSpecularColour * specularIntensity;

    // Combine diffuse and specular contributions
    vec3 colour = ambient + diffuse + specular;

    // Output final colour
    gl_FragColor = vec4(colour, uDiffuseColour.a);
}
                `,
            },
            {
                name: 'fsSource4',
                type: 'fragment',
                source: `
precision highp float;

uniform vec3 uLightPosition;
uniform vec4 uAmbientColour;
uniform vec4 uDiffuseColour;
uniform vec3 uSpecularColour;
uniform float uShininess;

varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    // ambient

    // Calculate diffuse lighting contribution
    vec3 lightDirection = normalize(uLightPosition - vPosition);
    float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
    vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

    // Calculate specular lighting contribution
    vec3 viewDirection = normalize(-vPosition);
    vec3 reflectionDirection = reflect(-lightDirection, vNormal);
    float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
    vec3 specular = uSpecularColour * specularIntensity;

    float edge = clamp(1.0 - vNormal.z, 0.0, 1.0);
    vec3 ambient = edge * vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;
    // Combine diffuse and specular contributions
    vec3 colour = ambient + diffuse + specular;

    // Output final colour
    gl_FragColor = vec4(colour, uDiffuseColour.a);
}
                `,
            },
            {
                name: 'fsSource5',
                type: 'fragment',
                source: `
precision highp float;

uniform vec3 uLightPosition;
uniform vec4 uAmbientColour;
uniform vec4 uDiffuseColour;
uniform vec3 uSpecularColour;
uniform float uShininess;

varying vec3 vPosition;
varying vec3 vNormal;

float rand(float co) {
    return fract(sin(co*(91.3458)) * 47453.5453);
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float rand(vec3 co){
    return rand(co.xy+rand(co.z));
}

void main() {
    // ambient
    vec3 ambient = vec3(0.25) * uAmbientColour.rgb;

    // Calculate diffuse lighting contribution
    vec3 lightDirection = normalize(uLightPosition - vPosition);
    float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
    vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

    // Calculate specular lighting contribution
    vec3 viewDirection = normalize(-vPosition);
    vec3 reflectionDirection = reflect(-lightDirection, vNormal);
    float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
    vec3 specular = uSpecularColour * specularIntensity;

    // Combine diffuse and specular contributions
    vec3 colour = ambient + diffuse + specular;

    // Output final colour
    gl_FragColor = vec4(colour, 1.0);
}
                `,
            },
            {
                name: 'fsSource6',
                type: 'fragment',
                source: `
precision mediump float;
varying vec3 vPosition;
varying highp vec2 vTextureCoord;

uniform vec4 uDiffuseColour;
uniform sampler2D uSampler;

void main() {
    gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
    vec4 colour = vec4(vPosition * 0.15 + 0.5, 1);
    gl_FragColor = uDiffuseColour;
    gl_FragColor = texture2D(uSampler, vTextureCoord);
}
                `,
            },
        ];


        const vsSource = `
            attribute vec4 aVertexPosition;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;

            varying vec4 vPosition;

            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vPosition = gl_Position;
            }`;

        /**
         * Vertex shader
         */
        const vsSource2 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
            }`;

        /**
         * Vertex shader
         */
        const vsSource3 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;
            varying highp vec2 vTextureCoord;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * aNormal);

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
                vTextureCoord = aTextureCoord;
            }`;

        /**
         * Vertex shader
         */
        const vsSource4 = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat3 uNormalMatrix;

            varying vec3 vPosition;
            varying vec3 vNormal;
            varying highp vec2 vTextureCoord;

            void main() {
                // Transform vertex position and normal to eye coordinates
                vec4 eyePosition = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = eyePosition.xyz;
                vNormal = normalize(uNormalMatrix * vec3(0.0, 0.0, 1.0));

                // Output vertex position in clip coordinates
                gl_Position = uProjectionMatrix * eyePosition;
                gl_Position.x += aNormal.x * gl_Position.w;
                gl_Position.y += aNormal.y * gl_Position.w;
                vTextureCoord = aTextureCoord;
            }`;

        /**
         *
         */
        const fsSource = `
            precision mediump float;
            varying vec4 vPosition;

            uniform vec4 uColour;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 colour = vPosition * 0.15 + 0.5;
                gl_FragColor = uColour;
            }`;

        /**
         *
         */
        const fsSource2 = `
            precision mediump float;
            varying vec4 vPosition;

            uniform vec4 uColour;

            void main() {
                vec4 colour = vPosition * 0.5 + 0.5;
                gl_FragColor = colour * uColour;
            }`;


        /**
         *
         */
        const fsSource3 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient
                vec3 ambient = vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, uDiffuseColour.a);
            }`;

        /**
         *
         */
        const fsSource4 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                // ambient

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                float edge = clamp(1.0 - vNormal.z, 0.0, 1.0);
                vec3 ambient = edge * vec3(0.25, 0.25, 0.25) * uDiffuseColour.rgb;
                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, uDiffuseColour.a);

            }`;

        /**
         *
         */
        const fsSource5 = `
            // Fragment shader
            precision highp float;

            uniform vec3 uLightPosition;
            uniform vec4 uAmbientColour;
            uniform vec4 uDiffuseColour;
            uniform vec3 uSpecularColour;
            uniform float uShininess;

            varying vec3 vPosition;
            varying vec3 vNormal;

            float rand(float co) {
                return fract(sin(co*(91.3458)) * 47453.5453);
            }

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            float rand(vec3 co){
                return rand(co.xy+rand(co.z));
            }

            void main() {
                // ambient
                vec3 ambient = vec3(0.25) * uAmbientColour.rgb;

                // Calculate diffuse lighting contribution
                vec3 lightDirection = normalize(uLightPosition - vPosition);
                float diffuseIntensity = 0.2 * max(dot(vNormal, lightDirection), 0.0);
                vec3 diffuse = uDiffuseColour.rgb * diffuseIntensity;

                // Calculate specular lighting contribution
                vec3 viewDirection = normalize(-vPosition);
                vec3 reflectionDirection = reflect(-lightDirection, vNormal);
                float specularIntensity = pow(max(dot(reflectionDirection, viewDirection), 0.0), uShininess);
                vec3 specular = uSpecularColour * specularIntensity;

                // Combine diffuse and specular contributions
                vec3 colour = ambient + diffuse + specular;

                // Output final colour
                gl_FragColor = vec4(colour, 1.0);
            }`;

        /**
         *
         */
        const fsSource6 = `
            #extension GL_EXT_frag_depth : enable
        
            precision mediump float;
            varying vec3 vPosition;
            varying highp vec2 vTextureCoord;

            uniform vec4 uDiffuseColour;
            uniform sampler2D uSampler;

            void main() {
                gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);
                vec4 colour = vec4(vPosition * 0.15 + 0.5, 1);
                gl_FragColor = uDiffuseColour;
                gl_FragColor = texture2D(uSampler, vTextureCoord);
                gl_FragDepthEXT = -1.0;
            }`;


        const defaultShaders = [
            {
                name: 'shader1',
                vertex: vsSource, fragment: fsSource,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aVertexPosition' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'colour', uniform: 'uColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                ],
            },
            {
                name: 'shader2',
                vertex: vsSource, fragment: fsSource2,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aVertexPosition' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'colour', uniform: 'uColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                ],
            },
            {
                name: 'shader3',
                vertex: vsSource2, fragment: fsSource3,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aPosition' },
                    { name: 'vertexNormal', attribute: 'aNormal' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', },
                    { name: 'normalMatrix', uniform: 'uNormalMatrix', },
                    { name: 'lightPosition', uniform: 'uLightPosition', },
                    { name: 'ambient', uniform: 'uAmbientColour', },
                    { name: 'colour', uniform: 'uDiffuseColour', },
                    { name: 'specularColour', uniform: 'uSpecularColour', },
                    { name: 'shininess', uniform: 'uShininess', },
                ],
            },
            {
                name: 'shader4',
                vertex: vsSource2, fragment: fsSource4,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aPosition' },
                    { name: 'vertexNormal', attribute: 'aNormal' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix4fv(location, false, value) },
                    { name: 'normalMatrix', uniform: 'uNormalMatrix', }, //, set: (location, value) => scene.gl.uniformMatrix3fv(location, false, value) },

                    { name: 'lightPosition', uniform: 'uLightPosition', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                    { name: 'ambient', uniform: 'uAmbientColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                    { name: 'colour', uniform: 'uDiffuseColour', }, //, set: (location, value) => scene.gl.uniform4fv(location, value) },
                    { name: 'specularColour', uniform: 'uSpecularColour', }, //, set: (location, value) => scene.gl.uniform3fv(location, value) },
                    { name: 'shininess', uniform: 'uShininess', }, //, set: (location, value) => scene.gl.uniform1f(location, value) },
                ],
            },
            {
                name: 'textured',
                vertex: vsSource3, fragment: fsSource6,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aPosition' },
                    { name: 'vertexNormal', attribute: 'aNormal' },
                    { name: 'vertexTexture', attribute: 'aTextureCoord' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', type: 'mat4' },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', type: 'mat4' },
                    { name: 'normalMatrix', uniform: 'uNormalMatrix', type: 'mat3' },

                    { name: 'lightPosition', uniform: 'uLightPosition', type: 'vec3' },
                    { name: 'colour', uniform: 'uDiffuseColour', type: 'vec4' },
                    { name: 'specularColour', uniform: 'uSpecularColour', type: 'vec3' },
                    { name: 'shininess', uniform: 'uShininess', type: 'float' },
                    { name: 'texture', uniform: 'uSampler', type: 'sampler2D' },
                ],
            },
            {
                name: 'textured2',
                vertex: vsSource4, fragment: fsSource6,
                attributes: [
                    { name: 'vertexPosition', attribute: 'aPosition' },
                    { name: 'vertexNormal', attribute: 'aNormal' },
                    { name: 'vertexTexture', attribute: 'aTextureCoord' },
                ],
                uniforms: [
                    { name: 'projectionMatrix', uniform: 'uProjectionMatrix', type: 'mat4' },
                    { name: 'modelViewMatrix', uniform: 'uModelViewMatrix', type: 'mat4' },
                    { name: 'normalMatrix', uniform: 'uNormalMatrix', type: 'mat3' },

                    { name: 'lightPosition', uniform: 'uLightPosition', type: 'vec3' },
                    { name: 'colour', uniform: 'uDiffuseColour', type: 'vec4' },
                    { name: 'specularColour', uniform: 'uSpecularColour', type: 'vec3' },
                    { name: 'shininess', uniform: 'uShininess', type: 'float' },
                    { name: 'texture', uniform: 'uSampler', type: 'sampler2D' },
                ],
            },
        ];

        //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        /**
         *
         */
        function initialiseShaders(gl, vsSource, fsSource) {
            //document.body.style.background = 'purple';

            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            //document.body.style.background = 'green';

            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            //document.body.style.background = 'cyan';

            const shaderProgram = gl.createProgram();
            //document.body.style.background = 'blue';

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        /**
         * creates a shader of the given type, uploads the source and
         * compiles it.
         */
        function loadShader(gl, type, source) {
            //document.body.style.background = 'red';

            const shader = gl.createShader(type);
            //document.body.style.background = 'green';
            report('1844');
            report(shader);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            //document.body.style.background = 'yellow';

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        /**
         * Create the indexes for a strip of quads formed from pairs of triangles.
         */
        function addClosedTriangleStrip(gl, indexBuffer, nQuads, start1, start2, step1 = 2, step2) {
            const offset = indexBuffer.length * 2;
            step2 = step2 || step1;
            start2 = start2 !== undefined ? start2 : start1 + 1;
            for (let i = 0; i < nQuads; ++i) {
                indexBuffer.push(start1 + i * step1);
                indexBuffer.push(start2 + i * step2);
            }
            indexBuffer.push(start1);
            indexBuffer.push(start2);
            const count = 2 + nQuads * 2
            return { mode: gl.TRIANGLE_STRIP, count, offset };
        }

        /**
         *
         */
        function addTriangles(gl, vertex, indexBuffer, points) {
            const offset = indexBuffer.length * 2;
            let index = vertex.length / 8;
            const nTriangles = Math.floor(points.length / 3);
            for (let i = 0; i < nTriangles; ++i) {
                const p0 = points[i * 3].slice(0, 3);
                const p1 = points[i * 3 + 1].slice(0, 3);
                const p2 = points[i * 3 + 2].slice(0, 3);
                const v1 = subtract(p0, p1);//[p0[0] - p1[0], p0[1] - p1[1], p0[2] - p1[2]];
                const v2 = subtract(p1, p2);//[p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];
                const n = normalised((v1, v2));
                vertex.push(...p0.slice(0, 3), ...n, ...points[i * 3].slice(3));
                indexBuffer.push(index++);
                vertex.push(...p1.slice(0, 3), ...n, ...points[i * 3 + 1].slice(3));
                indexBuffer.push(index++);
                vertex.push(...p2.slice(0, 3), ...n, ...points[i * 3 + 2].slice(3));
                indexBuffer.push(index++);
            }

            return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
        }

        /**
         *
         */
        function addClosedTriangleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;

            if (true) {
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(centre);
                    indexBuffer.push(first + i * step);
                    indexBuffer.push(first + ((i + 1) % nTriangles) * step);
                }
                return { mode: gl.TRIANGLES, count: 3 * nTriangles, offset };
            } else {
                indexBuffer.push(centre);
                for (let i = 0; i < nTriangles; ++i) {
                    indexBuffer.push(first + i * step);
                }
                indexBuffer.push(first);
                const count = 2 + nTriangles
                return { mode: gl.TRIANGLE_FAN, count, offset };
            }
        }

        /**
         *
         */
        function addOpenTraingleFan(gl, indexBuffer, nTriangles, centre, first, step = 1) {
            const offset = indexBuffer.length * 2;
            indexBuffer.push(centre);
            for (let i = 0; i <= nTriangles; ++i) {
                indexBuffer.push(first + i * step);
            }
            const count = 2 + nTriangles
            return { mode: gl.TRIANGLE_FAN, count, offset };
        }

        /**
         *
         */
        function addLineLoop(gl, indexBuffer, nSegments, first, step = 1) {
            const offset = indexBuffer.length * 2;
            for (let i = 0; i < nSegments; ++i) {
                indexBuffer.push(first + i * step);
            }
            indexBuffer.push(first);
            const count = 1 + nSegments
            return { mode: gl.LINE_STRIP, count, offset, colour: [0, 0, 0.2, 1.0] };
        }

        function isPowerOf2(value) {
            return (value & (value - 1)) === 0;
        }

        class shape {
            constructor(data) {
                this.depthMask = true;
            }
            updateBuffers(gl) { }
            draw3d(gl, shader) {
                gl.depthMask(this.depthMask);
                this.elements.forEach((shape) => {
                    if (shape.colour) {
                        gl.uniform4fv(shader.colour, shape.colour);
                    }
                    gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                });
                gl.depthMask(true);
            }
        }

        /**
         *
         */
        class Box extends shape {
            static parameters(node) {
                const size = node.size || [1, 1, 1];
                const width = node.width || size[0] || 1;
                const height = node.height || size[1] || size[0] || 1;
                const depth = node.depth || size[2] || size[0] || 1;
                const mapping = node.mapping;
                return [width, height, depth, mapping, node.sides, node.lines];
            }
            static make(view, node, index) {
                return new Box(view, ...Box.parameters(node));
            }
            static hash(node) {
                return `box ${Box.parameters(node)}`;
            }
            constructor(view, width = 1, height = 1, depth = 1, mapping, sides = [1, 1, 1, 1, 1, 1], lines) {
                super();
                const gl = view.context;
                const data = view.data;
                if (!Array.isArray(sides)) {
                    sides = [];
                }
                for (let i = 0; i < 6; ++i) {
                    sides[i] = sides[i] === undefined ? true : sides[i];
                }
                this.width = width;
                this.height = height;
                this.depth = depth;
                const w = width;
                const h = height;
                const d = depth;
                const start = data.vertex.length / 8;

                const addFace = (p1, p2, p3, p4, normal, mapping) => {
                    const start = data.vertex.length / 8;
                    if (mapping !== undefined) {
                        const u1 = (mapping % 4) / 4;
                        const v1 = Math.floor(mapping / 4) / 3;
                        const u2 = ((mapping % 4) + 1) / 4;
                        const v2 = (Math.floor(mapping / 4) + 1) / 3;
                        data.vertex.push(...p1, ...normal, u1, v1);
                        data.vertex.push(...p2, ...normal, u1, v2);
                        data.vertex.push(...p3, ...normal, u2, v1);
                        data.vertex.push(...p4, ...normal, u2, v2);
                    } else {
                        data.vertex.push(...p1, ...normal, 0, 0);
                        data.vertex.push(...p2, ...normal, 0, 1);
                        data.vertex.push(...p3, ...normal, 1, 0);
                        data.vertex.push(...p4, ...normal, 1, 1);
                    }
                    data.indices.push(...[0, 1, 2, 3, 2, 1].map((i) => i + start));
                };
                const indexStart = data.indices.length;
                const points = [
                    [0, 0, 0],
                    [0, h, 0],

                    [w, 0, 0],
                    [w, h, 0],

                    [w, 0, d],
                    [w, h, d],

                    [0, 0, d],
                    [0, h, d],
                ];
                points.forEach((point) => {
                    data.vertex.push(...point, 0, 0, 1, 0, 0);
                });
                data.indices.push(...[
                    0, 2, 4, 6, 0, 1, 3, 5, 7, 1,
                    2, 3, 4, 5, 6, 7,
                ].map((i) => i + start));
                mapping = mapping || Array(6);

                let count = 0;
                if (sides[0]) {
                    addFace(points[0], points[1], points[2], points[3], [0, 0, 1], mapping[0]);
                    count += 6;
                }
                if (sides[1]) {
                    addFace(points[2], points[3], points[4], points[5], [1, 0, 0], mapping[1]);
                    count += 6;
                }
                if (sides[2]) {
                    addFace(points[4], points[5], points[6], points[7], [0, 0, -1], mapping[2]);
                    count += 6;
                }
                if (sides[3]) {
                    addFace(points[6], points[7], points[0], points[1], [-1, 0, 0], mapping[3]);
                    count += 6;
                }
                if (sides[4]) {
                    addFace(points[0], points[2], points[6], points[4], [0, -1, 0], mapping[4]);
                    count += 6;
                }
                if (sides[5]) {
                    addFace(points[1], points[3], points[7], points[5], [0, 1, 0], mapping[5]);
                    count += 6;
                }

                this.elements = [];
                if (count) {
                    this.elements.push({ mode: gl.TRIANGLES, count, offset: (16 + indexStart) * 2 });
                }
                if (lines) {
                    this.elements.push(
                        { mode: gl.LINE_STRIP, count: 10, offset: (indexStart) * 2, colour: [1, 1, 1, 1] },
                        { mode: gl.LINES, count: 6, offset: (10 + indexStart) * 2, colour: [1, 1, 1, 1] });
                }
            }
            intersects(line) {
                const planes = [
                    { point: [this.width / 2, 0, 0], normal: [1, 0, 0] },
                    { point: [-this.width / 2, 0, 0], normal: [-1, 0, 0] },
                    { point: [0, this.height / 2, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height / 2, 0], normal: [0, -1, 0] },
                    { point: [0, 0, this.depth / 2], normal: [0, 0, 1] },
                    { point: [0, 0, -this.depth / 2], normal: [0, 0, -1] },
                ];
                return convexHullIntercept(line, planes);
            }
        }

        /**
         *
         */
        class Text extends shape {
            static parameters(node) {
                const size = node.size || [1, 1];
                const width = node.width || size[0];
                const height = node.height || size[1] || size[0];
                const text = node.text || node.name;
                const colour = node.colour;
                const font = node.font;
                return [width, height, text, colour, font];
            }
            static make(view, node, index) {
                return new Text(view, ...Text.parameters(node));
            }
            static hash(node) {
                return `text ${Text.parameters(node)}`;
            }
            constructor(view, width = 1, height = 1, text, colour, font) {
                super();
                this.depthMask = false;
                const gl = view.context;
                const data = view.data;
                this.uv = view.addText(text, colour, font);
                this.width = height * this.uv[2];
                this.height = height;
                this.text = text;
                const w = height * this.uv[2] / 20;
                const h = height / 20;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                data.vertex.push(0, 0, 0, -w, -h, 1, this.uv[0].x, this.uv[0].y);
                data.vertex.push(0, 0, 0, -w, h, 1, this.uv[0].x, this.uv[1].y);
                data.vertex.push(0, 0, 0, w, -h, 1, this.uv[1].x, this.uv[0].y);
                data.vertex.push(0, 0, 0, w, h, 1, this.uv[1].x, this.uv[1].y);

                data.indices.push(...[0, 1, 2, 1, 3, 2, 0, 1, 3, 2].map((i) => i + start));

                this.elements = [];
                this.elements.push({ mode: gl.TRIANGLES, count: 6, offset: indexStart * 2 },
                    { mode: gl.LINE_STRIP, count: 5, offset: (5 + indexStart) * 2, colour: [1, 1, 1, 1] },);
            }
            intersects(line) {
                return false;
            }
        }

        /**
         *
         */
        class Diamond extends shape {
            static make(view, node, index) {
                return new Diamond(view, node.size);
            }
            static hash(node) {
                return `diamond ${node.size}`;
            }
            constructor(view, size = 1) {
                super();
                const gl = view.context;
                const data = view.data;
                this.size = size;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;
                const points = [
                    [0, 1, 0, 0.125, 0],
                    [1, 0, 0, 0, 0.5],
                    [0, 0, 1, 0.25, 0.5],

                    [0, 1, 0, 0.375, 0],
                    [0, 0, 1, 0.25, 0.5],
                    [-1, 0, 0, 0.5, 0.5],

                    [0, 1, 0, 0.625, 0],
                    [-1, 0, 0, 0.5, 0.5],
                    [0, 0, -1, 0.75, 0.5],

                    [0, 1, 0, 0.875, 0],
                    [0, 0, -1, 0.75, 0.5],
                    [1, 0, 0, 1, 0.5],


                    [0, -1, 0, 0.125, 1],
                    [1, 0, 0, 0, 0.5],
                    [0, 0, 1, 0.25, 0.5],

                    [0, -1, 0, 0.375, 1],
                    [0, 0, 1, 0.25, 0.5],
                    [-1, 0, 0, 0.5, 0.5],

                    [0, -1, 0, 0.625, 1],
                    [-1, 0, 0, 0.5, 0.5],
                    [0, 0, -1, 0.75, 0.5],

                    [0, -1, 0, 0.875, 1],
                    [0, 0, -1, 0.75, 0.5],
                    [1, 0, 0, 1, 0.5],
                ].map((point) => point.map((v, i) => i < 3 ? v * size : v));

                data.indices.push(...[
                    0, 1, 2, 0, 7, 8, 0,
                    12, 13, 14, 12, 17, 18, 12
                ].map((i) => i + start));

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINE_STRIP, count: 7, offset: (24 + indexStart) * 2, colour: [1, 1, 1, 1] },
                    { mode: gl.LINE_STRIP, count: 7, offset: (31 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const points = [
                    [0, this.size, 0,],

                    [-this.size, 0, 0,],
                    [0, 0, -this.size,],
                    [this.size, 0, 0,],
                    [0, 0, this.size,],

                    [0, -this.size, 0,],
                ];

                const planes = [
                    planeFromPoints(points[0], points[2], points[1]),
                    planeFromPoints(points[0], points[3], points[2]),
                    planeFromPoints(points[0], points[4], points[3]),
                    planeFromPoints(points[0], points[1], points[4]),

                    planeFromPoints(points[5], points[1], points[2]),
                    planeFromPoints(points[5], points[2], points[3]),
                    planeFromPoints(points[5], points[3], points[4]),
                    planeFromPoints(points[5], points[4], points[1]),
                ];

                return convexHullIntercept(line, planes);
            }
        }

        /**
         *
         */
        class Ball extends shape {
            static make(view, node, index) {
                const values = node.parameters || [];
                const size = node.size || values[index++] || 2;
                const width = node.width || size[0] || values[index++] || 2;
                const depth = node.depth || size[1] || values[index++] || 2;
                const height = node.height || size[2] || values[index++] || 2;
                const sides = node.sides || values[index++] || 12;
                const strips = node.strips || values[index++] || 12;
                const mode = node.mode || values[index++] || 'solid';

                return new Ball(view, width, depth, height, sides, strips);
            }
            static hash(node) {
                return `ball ${node.size} ${node.height} ${node.depth} ${node.sides} ${node.strips}`;
            }
            constructor(view, width = 2, depth = 0, height = 0, sides = 12, strips = 12) {
                super();
                const gl = view.context;
                const data = view.data;
                depth = depth || width
                height = height || width

                this.width = width / 2;
                this.depth = depth / 2;
                this.height = height / 2;
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                // Create the mesh for the ball
                data.vertex.push(0, height / 2, 0);
                data.vertex.push(0, 1, 0);
                data.vertex.push(0.5, 0);
                data.vertex.push(0, -height / 2, 0);
                data.vertex.push(0, -1, 0);
                data.vertex.push(0.5, 1);
                for (let j = 0; j < strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / strips);
                    for (let i = 0; i < sides; ++i) {
                        const radians = (i * 2) * Math.PI / sides;
                        data.vertex.push(
                            this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians));
                        data.vertex.push(
                            radius * Math.sin(radians), ny, radius * Math.cos(radians));
                        data.vertex.push(i / (sides - 1), j / (strips - 1));
                    }
                }

                const elements = [
                    addClosedTriangleFan(gl, data.indices, sides, start, start + 2),
                    addClosedTriangleFan(gl, data.indices, sides, start + 1, start + 2 + (strips - 2) * sides),
                ];

                for (let j = 0; j < strips - 2; ++j) {
                    elements.push(addClosedTriangleStrip(gl, data.indices, sides, start + 2 + j * sides, start + 2 + (j + 1) * sides, 1, 1));
                }

                this.elements = elements;
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
        }

        /**
         *
         */
        class Torus extends shape {
            static make(view, node, index) {
                const values = node.parameters || [];
                const size = node.size || values[index++] || 2;
                const thickness = node.thickness || values[index++] || 1;
                const sides = node.sides || values[index++] || 12;
                const strips = node.strips || values[index++] || 12;
                const start = node.start || values[index++] || 0;
                const mode = node.mode || values[index++] || 'solid';

                return new Torus(gl, data, size, thickness, sides, strips, start, mode);
            }
            static hash(node) {
                return `torus ${node.size} ${node.thickness} ${node.sides} ${node.strips}`;
            }
            constructor(view, mainRadius = 2, minorRadius = 1, sides = 12, strips = 12, startAngle = 0, mode = 'solid') {
                super();
                const gl = view.context;
                const data = view.data;
                this.sides = sides;
                this.strips = strips;
                const start = data.vertex.length / 8;
                startAngle = startAngle * Math.PI / 180;

                // Create the mesh for the torus
                for (let j = 0; j < sides; ++j) {
                    const dx = Math.cos(2 * j * Math.PI / sides);
                    const dz = Math.sin(2 * j * Math.PI / sides);

                    for (let i = 0; i < strips; ++i) {
                        const angle = startAngle + 2 * i * Math.PI / strips;
                        const x = dx * (mainRadius + minorRadius * Math.sin(angle));
                        const y = minorRadius * Math.cos(angle);
                        const z = dz * (mainRadius + minorRadius * Math.sin(angle));
                        data.vertex.push(x, y, z);
                        data.vertex.push(dx * Math.sin(angle), y, dz * Math.sin(angle));
                        data.vertex.push(j / (sides - 1), i / (strips - 1));
                    }
                }

                this.elements = [];
                if (mode !== 'wireframe') {
                    for (let j = 0; j < sides; ++j) {
                        const start1 = start + j * strips;
                        const start2 = start + ((j + 1) % sides) * strips;
                        this.elements.push(addClosedTriangleStrip(gl, data.indices, strips, start1, start2, 1, 1));
                    }
                }

                if (mode === 'lined' || mode === 'wireframe') {
                    for (let i = 0; i < sides; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, strips, start + i * strips, 1));
                    }
                    for (let i = 0; i < strips; ++i) {
                        this.elements.push(addLineLoop(gl, data.indices, sides, start + i, strips));
                    }
                }
            }
            intersects(line) {
                const planes = [];
                for (let j = 0; j < this.strips - 1; ++j) {
                    const ny = Math.cos((j + 1) * Math.PI / this.strips);
                    const y = this.height * ny;
                    const radius = Math.sin((j + 1) * Math.PI / this.strips);
                    for (let i = 0; i < this.sides; ++i) {
                        const radians = (i * 2 + j) * Math.PI / this.sides;
                        planes.push({
                            point: [this.width * radius * Math.sin(radians), y, this.depth * radius * Math.cos(radians),],
                            normal: [radius * Math.sin(radians), ny, radius * Math.cos(radians),],
                        });
                    }
                }
                return convexHullIntercept(line, planes);
            }
        }

        /**
         *
         */
        class Frustum extends shape {
            static make(view, node, index) {
                return new Frustum(view, node.baseRadius, node.topRadius, node.height, node.sides);
            }
            static hash(node) {
                return `frustum ${node.baseRadius} ${node.topRadius} ${node.height} ${node.sides}`;
            }
            constructor(view, baseRadius = 1, topRadius = 0.5, height = 2, sides = 12) {
                super();
                const gl = view.context;
                const data = view.data;
                height /= 2;
                this.height = height;
                this.baseRadius = baseRadius;
                this.topRadius = topRadius;
                this.sides = sides;

                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                const angle = Math.atan((baseRadius - topRadius) / 2 * height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                for (let i = 0; i < sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / sides;
                    const topRadians = (1 + i * 2) * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(baseRadians), -height, baseRadius * Math.cos(baseRadians),
                        nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),
                        i / (sides - 1), 0.25,
                        topRadius * Math.sin(topRadians), height, topRadius * Math.cos(topRadians),
                        nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),
                        i / (sides - 1), 0.75);
                }

                data.vertex.push(0, -height, 0);
                data.vertex.push(0, -1, 0);
                data.vertex.push(0.5, 0);

                for (let i = 0; i < sides; ++i) {
                    const angle = i * 2 * Math.PI / sides;
                    data.vertex.push(
                        baseRadius * Math.sin(angle), -height, baseRadius * Math.cos(angle),
                        0, -1, 0,
                        i / (sides - 1), 0.25);
                }

                const elements = [
                    addClosedTriangleStrip(gl, data.indices, sides, start),
                    addClosedTriangleFan(gl, data.indices, sides, start + 2 * sides, 1 + start + 2 * sides),
                ];

                if (topRadius > 0) {
                    data.vertex.push(0, height, 0);
                    data.vertex.push(0, 1, 0);
                    data.vertex.push(0.5, 1);

                    for (let i = 0; i < sides; ++i) {
                        const angle = (1 + i * 2) * Math.PI / sides;
                        data.vertex.push(
                            topRadius * Math.sin(angle), height, topRadius * Math.cos(angle),
                            0, 1, 0,
                            i / (sides - 1), 0.75);
                    }
                    elements.push(addClosedTriangleFan(gl, data.indices, sides, 1 + start + 3 * sides, 2 + start + 3 * sides));
                }

                elements.push(
                    Object.assign(addLineLoop(gl, data.indices, sides, 1 + start + 2 * sides), { colour: [1, 1, 1, 1] }));

                if (topRadius > 0) {
                    elements.push(
                        Object.assign(addLineLoop(gl, data.indices, sides, 2 + start + 3 * sides), { colour: [1, 1, 1, 1] }));
                }

                if (sides < 7) {
                    elements.push({ mode: gl.LINE_STRIP, count: sides * 2, offset: indexStart * 2, colour: [1, 1, 1, 1] });
                }
                this.elements = elements;
            }
            intersects(line) {
                const angle = Math.atan((this.baseRadius - this.topRadius) / 2 * this.height);
                const ny = Math.sin(angle);
                const nRadius = Math.cos(angle);

                const planes = [
                    { point: [0, this.height, 0], normal: [0, 1, 0] },
                    { point: [0, -this.height, 0], normal: [0, -1, 0] },
                ];

                for (let i = 0; i < this.sides; ++i) {
                    const baseRadians = i * 2 * Math.PI / this.sides;
                    const topRadians = (1 + i * 2) * Math.PI / this.sides;

                    planes.push({
                        point: [this.baseRadius * Math.sin(baseRadians), -this.height, this.baseRadius * Math.cos(baseRadians),],
                        normal: [nRadius * Math.sin(baseRadians), ny, nRadius * Math.cos(baseRadians),],
                    }, {
                        point: [this.topRadius * Math.sin(topRadians), this.height, this.topRadius * Math.cos(topRadians),],
                        normal: [nRadius * Math.sin(topRadians), ny, nRadius * Math.cos(topRadians),],
                    });
                }

                return convexHullIntercept(line, planes);
            }
        }

        /**
         *
         */
        class Cylinder extends Frustum {
            static make(view, node) {
                var index = 0;
                const values = node[symbols.values] || [];
                const radius = node.radius || values[index++];
                const height = node.height || values[index++];
                const sides = node.sides || values[index++];
                return new Cylinder(view, node.radius, node.height, node.sides);
            }
            static hash(node) {
                return `cylinder ${node.radius} ${node.height} ${node.sides}`;
            }
            constructor(view, radius = 1, height = 2, sides = 12) {
                super(view, radius, radius, height, sides);
            }
        }

        /**
         *
         */
        class Cone extends Frustum {
            static make(view, node) {
                return new Cone(view, node.radius, node.height, node.sides);
            }
            static hash(node) {
                return `cone ${node.radius} ${node.height} ${node.sides}`;
            }
            constructor(view, radius = 1, height = 2, sides = 12) {
                super(view, radius, 0, height, sides);
            }
        }

        /**
         *
         */
        class Tetrahedron extends shape {
            static make(view, node, index) {
                return new Tetrahedron(view, node.size);
            }
            static hash(node) {
                return `tetrahedron ${node.size}`;
            }
            constructor(view, size = 1) {
                super();
                const gl = view.context;
                const data = view.data;
                const start = data.vertex.length / 8;
                this.size = 1;
                const indexStart = data.indices.length;
                const l = Math.cos(30 * Math.PI / 180);
                const points = [
                    [0, 1, 0, 0.25, 0],
                    [0, -0.5, l, 0, 0.5],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],

                    [0, 1, 0, 0.5, 0],
                    [0, -0.5, l, 2 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 1 / 3, 0.5],

                    [0, 1, 0, 0.25, 0],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 2 / 3, 0.5],

                    [0, -0.5, l, 0, 0.5],
                    [l * l, -0.5, -0.5 * l, 1 / 3, 0.5],
                    [-l * l, -0.5, -0.5 * l, 1 / 6, 1],
                ].map((point) => point.map((v, i) => i < 3 ? v * size : v));

                const indices = [0, 1, 1, 2, 2, 0, 3, 0, 3, 1, 3, 2].map((i) => i + start);
                data.indices.push(...indices);

                this.elements = [
                    addTriangles(gl, data.vertex, data.indices, points),
                    { mode: gl.LINES, count: 12, offset: (12 + indexStart) * 2, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
                const l = Math.cos(30 * Math.PI / 180);
                const sides = [
                    [[0, 1, 0],
                    [0, -0.5, l,],
                    [l * l, -0.5, -0.5 * l]],
                    [[0, 1, 0],
                    [-l * l, -0.5, -0.5 * l],
                    [0, -0.5, l],],
                    [[0, 1, 0],
                    [l * l, -0.5, -0.5 * l],
                    [-l * l, -0.5, -0.5 * l]],
                    [[l * l, -0.5, -0.5 * l],
                    [0, -0.5, l,],
                    [-l * l, -0.5, -0.5 * l]],
                ].map((point) => point.map((v) => scaled(v, this.size)));

                const planes = sides.map((side) => planeFromPoints(...side));
                return convexHullIntercept(line, planes);
            }
        }

        /**
          *
          */
        class Prism extends shape {
            static getPoints(node) {
                const points = [];
                if (Array.isArray(node.points)) {
                    for (let i = 0; i < node.points.length; i += 2) {
                        points.push([node.points[i], node.points[i + 1] || 0]);
                    }
                }
                if (Array.isArray(node.path)) {
                    let x = 0;
                    let z = 0;
                    if (points.length > 0) {
                        x = points[points.length - 1][0];
                        z = points[points.length - 1][1];
                    }

                    for (let i = 0; i < node.path.length; i += 2) {
                        x += node.path[i] || 0;
                        z += node.path[i + 1] || 0;
                        points.push([x, z]);
                    }
                }
                return points;
            }
            static make(view, node, index) {
                return new Prism(view, Prism.getPoints(node), node.height, node.smooth, node.sides, node.lines);
            }
            static hash(node) {
                const points = Prism.getPoints(node);
                return `Prism ${points.join(',')} ${node.height} ${node.smooth}, ${node.sides}`;
            }
            constructor(view, points = [[0, 0], [0, 1], [0, -1]], height = 1, smooth, sides = [], lines) {
                super();
                const gl = view.context;
                const data = view.data;
                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;

                this.height = height;
                this.points = points;

                const addFace = (p1, p2, p3, p4, mapping) => {
                    const start = data.vertex.length / 8;
                    const v1 = subtract(p2, p1);
                    const v2 = subtract(p3, p1);
                    const normal = normalised(cross(v1, v2));
                    if (mapping !== undefined) {
                        const u1 = (mapping % 4) / 4;
                        const v1 = Math.floor(mapping / 4) / 3;
                        const u2 = ((mapping % 4) + 1) / 4;
                        const v2 = (Math.floor(mapping / 4) + 1) / 3;
                        data.vertex.push(...p1, ...normal, u1, v1);
                        data.vertex.push(...p2, ...normal, u1, v2);
                        data.vertex.push(...p3, ...normal, u2, v1);
                        data.vertex.push(...p4, ...normal, u2, v2);
                    } else {
                        data.vertex.push(...p1, ...normal, 0, 0);
                        data.vertex.push(...p2, ...normal, 0, 1);
                        data.vertex.push(...p3, ...normal, 1, 0);
                        data.vertex.push(...p4, ...normal, 1, 1);
                    }
                    data.indices.push(...[0, 1, 2, 3, 2, 1].map((i) => i + start));
                };

                const base = (point) => [point[0], 0, point[1]];
                const top = (point) => [point[0], height, point[1]];
                let count = 0;
                points.forEach((point, index) => {
                    const next = points[(index + 1) % points.length];
                    if (sides[index] === undefined || sides[index]) {
                        addFace(base(point), top(point), base(next), top(next));
                        count += 6;
                    }
                });
                this.elements = [];

                const offset = data.indices.length * 2;
                const baseIndex = data.vertex.length / 8;
                data.vertex.push(...points.flatMap((point) => [point[0], 0, point[1], 0, -1, 0, 0, 0]));
                const topIndex = data.vertex.length / 8;
                data.vertex.push(...points.flatMap((point) => [point[0], height, point[1], 0, 1, 0, 0, 0]));

                const det = (u, v) => u[0] * v[1] - u[1] * v[0];

                const winding = (p0, p1, p2) => {
                    const v1 = [p1[0] - p0[0], p1[1] - p0[1]];
                    const v2 = [p2[0] - p1[0], p2[1] - p1[1]];

                    return det(v1, v2) / (Math.hypot(...v1) * Math.hypot(...v2));
                }

                const inside = (p0, d1, d2, point) => {
                    const a = (det(point, d2) - det(p0, d2)) / det(d1, d2);
                    const b = (det(p0, d1) - det(point, d1)) / det(d1, d2);

                    return (a > 0) && (b > 0) && (a + b < 1);;
                }

                const empty = (p0, p1, p2) => {
                    const d1 = [p0[0] - p1[0], p0[1] - p1[1]];
                    const d2 = [p2[0] - p1[0], p2[1] - p1[1]];

                    return !points.some((point) => inside(p1, d1, d2, point));
                }

                const d = [];
                for (let j = 0; j < points.length; ++j) {
                    const i = (j + points.length - 1) % points.length;
                    const k = (j + 1) % points.length;
                    d.push(winding(points[i], points[j], points[k]));
                }

                const sign = d.reduce((sum, d) => sum + d, 0);
                const drawBase = sides[points.length] === undefined || sides[points.length];
                const drawTop = sides[points.length + 1] === undefined || sides[points.length + 1];

                if (drawBase || drawTop) {
                    const remaining = points.map((point, index) => index);
                    let current = 0;
                    let loops = 0;
                    let indices = [];
                    while (remaining.length > 2 && loops < 1000) {
                        const prior = (current + remaining.length - 1) % remaining.length;
                        const next = (current + 1) % remaining.length;
                        const p0 = points[remaining[prior]];
                        const p1 = points[remaining[current]];
                        const p2 = points[remaining[next]];
                        if (winding(p0, p1, p2) * sign > 0 && empty(p0, p1, p2)) {
                            indices.push(remaining[prior], remaining[current], remaining[next]);
                            remaining.splice(current, 1);
                        } else {
                            current = next;
                        }
                        current = current % remaining.length;
                        ++loops;
                    }
                    if (drawBase) {
                        data.indices.push(...indices.map((i) => i + baseIndex));
                        count += indices.length;
                    }
                    if (drawTop) {
                        data.indices.push(...indices.map((i) => i + topIndex));
                        count += indices.length;
                    }
                }
                if (count > 0) {
                    this.elements.push({ mode: gl.TRIANGLES, count, offset: indexStart * 2 });
                }
                if (lines) {
                    this.elements.push(addLineLoop(gl, data.indices, points.length, baseIndex));
                    this.elements.push(addLineLoop(gl, data.indices, points.length, topIndex));
                    {
                        const offset = data.indices.length * 2;
                        for (let i = 0; i < points.length; ++i) {
                            data.indices.push(baseIndex + i, topIndex + i);
                        }
                        this.elements.push({ mode: gl.LINES, count: points.length * 2, offset });
                    }
                }
            }
            get3dPoints() {
                return [
                    ...this.points.map((point) => [point[0], 0, point[1]]),
                    ...this.points.map((point) => [point[0], this.height, point[1]]),
                ];
            }
            getSides() {
                const points = this.getPoints();
                const nPoints = this.points.length;
                const faces = this.points.map((point, i) => [
                    points[i], points[(i + 1) % nPoints],
                    points[nPoints + (i + 1) % nPoints], points[i + nPoints],
                ]);
            }
            intersects(line) {
                return false;
                const planes = this.points.map((point, index) => {
                    const next = this.points[(index + 1) % this.points.length];
                    const v1 = [next[0] - point[0], 0, next[1] - point[1]]
                    const v2 = [0, 1, 0];
                    const normal = normalised(cross(v1, v2));
                    return { point: [point[0], 0, point[1]], normal };
                });
                return convexHullIntercept(line, planes);
            }
        }

        /**
         * Find the first node that matches the name or undefined if no match found
         */
        function findNode(name) {
            return namedNodes[name];
        }

        /**
         * Connection between two nodes
         */
        class Link {
            static links;
            static make(view, node, index, namedNodes) {
                const from = node.from;
                const to = node.to;
                const values = node.points;
                // Ensure points list is valid
                if (Array.isArray(values)) {
                    values.length = 3 * Math.floor(values.length / 3);
                    const points = [];
                    for (let i = 0; i < values.length; i += 3) {
                        points.push([
                            isNaN(values[i]) ? 0 : values[i],
                            isNaN(values[i + 1]) ? 0 : values[i + 1],
                            isNaN(values[i + 2]) ? 0 : values[i + 2],
                        ]);
                    }
                    return new Link(view, from, to, points);
                } else {
                    return new Link(view, from, to);
                }
            }
            static hash(node) {
                return `link ${++this.links}`;
            }
            constructor(view, from, to, points = []) {
                const gl = view.context;
                const data = view.data;
                this.from = from;
                this.to = to;
                this.points = [[0, 0, 0], ...points, [0, 0, 0]];

                const start = data.vertex.length / 8;
                const indexStart = data.indices.length;
                this.pointIndex = data.vertex.length;
                this.pointIndex2 = data.vertex.length + 8 + points.length * 8;

                data.vertex.push(...this.points.flatMap((point) => [...point, 0, 0, -1, 0, 0]));
                const indices = Array(this.points.length).fill(1).map((e, i) => i + start);

                data.indices.push(...indices);

                this.elements = [
                    { mode: gl.LINE_STRIP, count: this.points.length, offset: 2 * indexStart, colour: [1, 1, 1, 1] },
                ];
            }
            intersects(line) {
            }
            updateBuffers(scene, node) {
                this.fromNode = this.fromNode || findNode(this.from) || node.parent;
                this.toNode = this.toNode || findNode(this.to) || node.parent;
                let inverse = identityMatrix();
                if (node.parent) {
                    inverse = invert(node.parent.world);
                }

                if (this.fromNode?.world && this.toNode?.world) {
                    const from = this.fromNode === node.parent ?
                        [0, 0, 0] : transformed(transformed([0, 0, 0], this.fromNode.world), inverse);

                    const to = this.toNode === node.parent ?
                        [0, 0, 0] : transformed(transformed([0, 0, 0], this.toNode.world), inverse);

                    scene.data.vertex[this.pointIndex] = from[0];
                    scene.data.vertex[this.pointIndex + 1] = from[1];
                    scene.data.vertex[this.pointIndex + 2] = from[2];

                    scene.data.vertex[this.pointIndex2] = to[0];
                    scene.data.vertex[this.pointIndex2 + 1] = to[1];
                    scene.data.vertex[this.pointIndex2 + 2] = to[2];
                }
            }
            draw3d(gl, shader) {
                if (this.fromNode && this.toNode) {
                    this.elements.forEach((shape) => {
                        if (shape.colour) {
                            gl.uniform4fv(shader.colour, shape.colour);
                        }
                        gl.drawElements(shape.mode, shape.count, gl.UNSIGNED_SHORT, shape.offset);
                    });
                }
            }
        }

        /**
         * Function to update node data prior to rendering
         */
        function update(scene, origin, time) {
            this.world = matrixMultiply(this.transform, origin);
            if (this.shape) {
                this.shape.updateBuffers(scene, this);
            }
            this[symbols.content].forEach((child) => child.update(scene, this.world, time));
        }

        /**
         *
         */
        function addNode(source, transform, shape, shader, colour = [1, 0, 1, 1]) {

            shininess = source.specular || 1 + 5 * Math.random();

            const node = Object.assign(Object.create({ update }), {
                name: source.name, parent, transform, movement: identityMatrix(),
                shape, shader, colour, shininess, specularColour: source.specularColour, [symbols.content]: [],
            });
            return node;
        }

        /**
         *
         */
        function drawNode(view, gl, origin, node, time, level = 0) {
            const sceneNode = node[symbols.viewData]?.get(view);
            if (sceneNode) {
                sceneNode.world = matrixMultiply(matrixMultiply(sceneNode.transform, sceneNode.movement), origin);
                const transform = matrixMultiply(sceneNode.world, view.modelViewMatrix);
                sceneNode.z = transform[14];

                gl.useProgram(sceneNode.shader.program);
                gl.uniformMatrix4fv(sceneNode.shader.modelViewMatrix, false, transform);
                const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));
                gl.uniformMatrix3fv(sceneNode.shader.normalMatrix, false, normalMatrix);
                sceneNode.shader.setNodeData(gl, sceneNode);
                if (sceneNode.shape && level >= view.minLevel) {
                    sceneNode.shape.draw3d(gl, sceneNode.shader);
                }
                origin = sceneNode.world;
                sceneNode.movement = identityMatrix();
                level += 1;
            }
            node[symbols.content].sort((a, b) => a.z - b.z);
            if ((view.maxLevel === 0) || (level < view.maxLevel)) {
                node[symbols.content].forEach((child) => drawNode(view, gl, origin, child, time));
            }
        }

        /**
         *
         */
        function positionNode(origin, node) {
            node.world = matrixMultiply(node.transform, origin);
            node[symbols.content].forEach((child) => positionNode(node.world, child));
        }

        /**
         *
         */
        function drawNode2(view, gl, node, shader, time) {
            const sceneNode = node[symbols.viewData].get(view);
            if (sceneNode && sceneNode.shader === shader) {
                sceneNode.world = matrixMultiply(matrixMultiply(sceneNode.transform, sceneNode.movement), origin);
                const transform = matrixMultiply(sceneNode.world, scene.modelViewMatrix);
                sceneNode.z = transform[14];

                gl.uniformMatrix4fv(sceneNode.shader.modelViewMatrix, false, transform);
                const normalMatrix = transpose3x3(invert3x3(get3x3(transform)));

                gl.uniformMatrix3fv(sceneNode.shader.normalMatrix, false, normalMatrix);
                sceneNode.shader.setNodeData(gl, sceneNode);
                if (sceneNode.shape) {
                    sceneNode.shape.draw3d(gl, sceneNode.shader);
                }
                sceneNode.movement = identityMatrix();
            }
            node[symbols.content].sort((a, b) => a.z - b.z);
            node[symbols.content].forEach((child) => drawNode2(view, gl, child, shader, time));
        }

        /**
         *
         */
        function drawScene(view, context, graph, time) {
            glErrors(context, 'drawScene start');
            view.minLevel = parseInt(view.settings.minLevel.value);
            const levels = parseInt(view.settings.levels.value);
            view.maxLevel = levels ? (view.minLevel + levels) : 0;
            graph.forEach((node) =>
                drawNode(view, context, identityMatrix(), node, time));
            glErrors(context, 'drawScene end');
        }

        /**
         *
         */
        function drawScene2(view, context, graph, time) {
            const origin = identityMatrix();
            graph.forEach((node) => positionNode(origin, node));

            gl.useProgram(scene.shaders.shader3.program);
            graph.forEach((node) => drawNode2(view, context, node, scene.shaders.shader3, time));
            gl.useProgram(scene.shaders.shader4.program);
            graph.forEach((node) => drawNode2(view, context, node, scene.shaders.shader4, time));
            glErrors(gl, 'drawScene2');
        }

        /**
         *
         */
        function glErrors(gl, context = '') {
            const err = gl.getError();

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                error(context, errors[err]);
                report(errors[err]);
                Core.paused = true;
            }
        }

        /**
         *
         */
        function initialiseShader(context, shader, projectionMatrix) {
            const numComponents = 3;
            const type = context.FLOAT;    // the data in the buffer is 32bit floats
            const normalize = false;  // don't normalize
            const stride = 4 * (3 + 3 + 2);         // how many bytes to get from one set of values to the next
            // 0 = use type and numComponents above
            const offset = 0;         // how many bytes inside the buffer to start from
            context.useProgram(shader.program);
            context.bindBuffer(context.ARRAY_BUFFER, scene.buffers.vertex);

            context.vertexAttribPointer(
                shader.attribLocations.vertexPosition,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            context.enableVertexAttribArray(shader.attribLocations.vertexPosition);

            if (shader.attribLocations.vertexNormal) {
                context.vertexAttribPointer(
                    shader.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    true,  // normalise normals
                    stride,
                    4 * 3);
                context.enableVertexAttribArray(shader.attribLocations.vertexNormal);
            }

            if (shader.attribLocations.vertexTexture) {
                context.vertexAttribPointer(
                    shader.attribLocations.vertexTexture,
                    2,     // numcomponents
                    type,
                    normalize,
                    stride,
                    4 * (3 + 3));
                context.enableVertexAttribArray(shader.attribLocations.vertexTexture);
            }
            //shader.setSceneData(scene);
        }

        /**
         *
         */
        const times = [];
        let last = 0;

        /**
         * Update the Camera position
         */
        function updateCamera(string) {
            //Core.source = Core.source.replace(/^\s*Camera.*/, string);
        }


        /**
         *
         */
        class Camera {
            constructor(position = [0, 0, 1], lookAt = [0, 0, 0], up = [0, 1, 0]) {
                this.initial = { position, lookAt, up };
                this.reset();
            }
            reset() {
                this.position = [...this.initial.position];
                this.lookAt = [...this.initial.lookAt];
                this.up = [...this.initial.up];
            }
            getString() {
                const str = (vector, fixed = 3) => vector.map((element) => element.toFixed(fixed));
                return `Camera;lookAt=${str(this.lookAt)};position=${str(this.position)};up=${str(this.up)}`;
            }
            zAxis() {
                return normalised(subtract(this.lookAt, this.position));
            }
            xAxis() {
                return xaxis = normalised(cross(this.zAxis(), this.up));
            }
            yAxis() {
                const zAxis = normalised(subtract(this.lookAt, this.position));
                const xAxis = normalised(cross(zAxis, this.up));

                return cross(xAxis, zAxis);
            }
            axes() {
                const zAxis = normalised(subtract(this.lookAt, this.position));
                const xAxis = normalised(cross(zAxis, this.up));
                const yAxis = cross(xAxis, zAxis);

                return { xAxis, yAxis, zAxis };
            }
            viewMatrix(eye, at, up) {
                const zaxis = normalised(subtract(this.lookAt, this.position));
                const xaxis = normalised(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);

                negate(zaxis);

                return [
                    xaxis[0], yaxis[0], zaxis[0], 0,
                    xaxis[1], yaxis[1], zaxis[1], 0,
                    xaxis[2], yaxis[2], zaxis[2], 0,
                    -dot(xaxis, this.position), -dot(yaxis, this.position), -dot(zaxis, this.position), 1
                ];
            }
            zoom(distance) {
                const direction = subtract(this.lookAt, this.position);
                const movement = scaled(direction, distance);
                this.position = add(this.position, movement);
                updateCamera(this.getString());
            }
            forward(distance) {
                const zaxis = normalised(subtract(this.lookAt, this.position));
                const movement = scaled(zaxis, distance);
                this.position = add(this.position, movement);
                this.lookAt = add(this.lookAt, movement);
                updateCamera(this.getString());
            }
            rotateX(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                const xaxis = cross(zaxis, this.up);

                const offset = subtract(this.position, this.lookAt);
                rotate(offset, xaxis, angle);
                rotate(this.up, xaxis, angle);

                this.position = add(this.lookAt, offset);
                updateCamera(this.getString());
            }
            rotateY(angle) {
                const offset = subtract(this.position, this.lookAt);
                rotate(offset, this.up, angle);

                this.position = add(this.lookAt, offset);
                updateCamera(this.getString());
            }
            spinY(angle) {
                const offset = subtract(this.lookAt, this.position);
                rotate(offset, [0, 1, 0], angle);
                rotate(this.up, [0, 1, 0], angle);

                this.lookAt = add(this.position, offset);
                updateCamera(this.getString());
            }
            pitch(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                const xaxis = cross(zaxis, this.up);

                rotate(zaxis, xaxis, angle);
                rotate(this.up, xaxis, angle);
                this.lookAt = add(this.position, zaxis);
                updateCamera(this.getString());
            }
            yaw(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                rotate(zaxis, this.up, angle);
                this.lookAt = add(this.position, zaxis);
                updateCamera(this.getString());
            }
            roll(angle) {
                const zaxis = subtract(this.lookAt, this.position);
                rotate(this.up, zaxis, angle);
                updateCamera(this.getString());
            }
            getLine(aspect, x, y, fieldOfView) {
                const fov = fieldOfView * Math.PI / 180;
                const zaxis = normalised(subtract(this.lookAt, this.position));
                const xaxis = normalised(cross(zaxis, this.up));
                const yaxis = cross(xaxis, zaxis);
                const d = 1 / Math.tan(fov / 2);
                const direction = normalised(add(scaled(xaxis, x * aspect), scaled(yaxis, y), scaled(zaxis, d)));

                return { point: this.position, direction };
            }
        }

        /**
         *
         */
        //const camera = new Camera([0, 0, 20], [0, 0, 0], [0, 1, 0]);
        const background = { colour: [0, 0, 0] };

        /**
         *
         */
        let topView;
        let sideView;
        const cameraMove = {};

        /**
         * Start moving camera
         */
        function moveCamera(camera, lookAt, position, up, duration = 1) {
            cameraMove.camera = camera;
            cameraMove.action = 'start';
            cameraMove.lookAt = lookAt || camera.lookAt;
            cameraMove.position = position || camera.position;
            cameraMove.up = up || camera.up;
            cameraMove.duration = duration;
        }

        /**
         *
         */
        function processActiveEvents(time) {
            return;
            //report(`${scene.activeEvents.length} ${time.toFixed(2)}`);
            scene.activeEvents.filter((event) => event.endTime <= time).forEach((event) => event.transition.finish());
            scene.activeEvents = scene.activeEvents.filter((event) => event.endTime > time);
            scene.activeEvents.forEach((event) => {
                const d = (time - event.startTime) / (event.endTime - event.startTime);
                event.transition.progress(d);
            });
        }

        /**
         * Resize the canvas based on the node size
         */
        function updateCanvasSize(view) {
            //return;
            // Lookup the size the browser is displaying the canvas in CSS pixels.
            const width = view.gl.canvas.clientWidth;
            const height = view.gl.canvas.clientHeight;

            // Check if the canvas is not the same size.
            const resize = view.gl.canvas.width !== width || view.gl.canvas.height !== height;

            if (resize) {
                // Make the canvas the same size
                view.gl.canvas.width = width;
                view.gl.canvas.height = height;

                scene.gl.viewport(0, 0, width, height);
            }

            return resize;
        }

        /**
         *
         */
        function render(time = 0) {
            if (Core.paused) {
                return;
            }

            const stateAction = {
                start: () => {
                    state.time = 0;
                    state.nextEvent = 0;
                },
                rewind: () => { },
                play: () => {
                    if (state.mode === 'playing') {
                        state.rate = 1;
                        state.mode = 'paused';
                    } else {
                        state.mode = 'playing';
                    }
                },
                forward: () => { },
                end: () => { },
            }[state.action];
            if (stateAction) {
                stateAction();
            }

            state.action = null;

            if (last) {
                const delta = time - last;
                times.push(delta);
                if (times.length > 5) {
                    times.shift();
                    const total = times.reduce((sum, delta) => sum + delta);
                    const average = 5000 / total;
                }
                if (state.mode === 'playing') {
                    state.time += delta / 1000;
                    while (scene.events[state.nextEvent] && state.time > scene.events[state.nextEvent].startTime) {
                        const event = scene.events[state.nextEvent];
                        event.transition.start();
                        scene.activeEvents.push(event);
                        ++state.nextEvent;
                    }
                }
            }
            processActiveEvents(state.time);
            last = time;
            if (cameraMove.action === 'start') {
                cameraStart = {
                    lookAt: cameraMove.camera.lookAt,
                    position: cameraMove.camera.position,
                    up: cameraMove.camera.up,
                    time: time,
                }
                cameraMove.action = 'move';
            }
            if (cameraMove.action === 'move') {
                const d = (time - cameraStart.time) / (1000 * (cameraMove.duration || 1));
                const s = d * d * (3 - 2 * d);
                cameraMove.camera.lookAt = add(cameraStart.lookAt, scale(subtract(cameraMove.lookAt, cameraStart.lookAt), s));
                cameraMove.camera.position = add(cameraStart.position, scale(subtract(cameraMove.position, cameraStart.position), s));
                cameraMove.camera.up = add(cameraStart.up, scale(subtract(cameraMove.up, cameraStart.up), s));
                if (d > 1) {
                    cameraMove.action = null;
                }
            }

            Core.views.forEach((view) =>
                view.update(time));

            window.requestAnimationFrame(render);
        }

        /**
         *
         */
        function matrixMultiply3x3(a, b) {
            return [
                a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
                a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
                a[0] * b[2] + a[1] * b[5] + a[2] * b[8],

                a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
                a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
                a[3] * b[2] + a[4] * b[5] + a[5] * b[8],

                a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
                a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
                a[6] * b[2] + a[7] * b[5] + a[8] * b[8],
            ];
        }

        /**
         *
         */
        function matrixMultiply(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
            ];
        }

        /**
         *
         */
        function get3x3(input) {
            return [
                input[0], input[1], input[2],
                input[4], input[5], input[6],
                input[8], input[9], input[10]];
        }

        /**
         *
         */
        function transpose3x3(input) {
            return [
                input[0], input[3], input[6],
                input[1], input[4], input[7],
                input[2], input[5], input[8]];
        }

        /**
         *
         */
        function invert3x3(input) {
            const a00 = input[0], a01 = input[1], a02 = input[2];
            const a10 = input[3], a11 = input[4], a12 = input[5];
            const a20 = input[6], a21 = input[7], a22 = input[8];

            const b01 = a22 * a11 - a12 * a21;
            const b11 = -a22 * a10 + a12 * a20;
            const b21 = a21 * a10 - a11 * a20;
            // Calculate the determinant
            const det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return null;
            }
            const idet = 1.0 / det;
            return [
                b01 * idet,
                (-a22 * a01 + a02 * a21) * idet,
                (a12 * a01 - a02 * a11) * idet,
                b11 * idet,
                (a22 * a00 - a02 * a20) * idet,
                (-a12 * a00 + a02 * a10) * idet,
                b21 * idet,
                (-a21 * a00 + a01 * a20) * idet,
                (a11 * a00 - a01 * a10) * idet];
        }

        /**
         *
         */
        function transpose(input) {
            return [
                input[0], input[4], input[8], input[12],
                input[1], input[5], input[9], input[13],
                input[2], input[6], input[10], input[14],
                input[3], input[7], input[11], input[15]];
        }

        /**
         *
         */
        function invert(input) {
            const x0 = input[0];
            const x1 = input[1];
            const x2 = input[2];
            const x3 = input[3];
            const x4 = input[4];
            const x5 = input[5];
            const x6 = input[6];
            const x7 = input[7];
            const x8 = input[8];
            const x9 = input[9];
            const x10 = input[10];
            const x11 = input[11];
            const x12 = input[12];
            const x13 = input[13];
            const x14 = input[14];
            const x15 = input[15];

            const a0 = x0 * x5 - x1 * x4;
            const a1 = x0 * x6 - x2 * x4;
            const a2 = x0 * x7 - x3 * x4;
            const a3 = x1 * x6 - x2 * x5;
            const a4 = x1 * x7 - x3 * x5;
            const a5 = x2 * x7 - x3 * x6;
            const b0 = x8 * x13 - x9 * x12;
            const b1 = x8 * x14 - x10 * x12;
            const b2 = x8 * x15 - x11 * x12;
            const b3 = x9 * x14 - x10 * x13;
            const b4 = x9 * x15 - x11 * x13;
            const b5 = x10 * x15 - x11 * x14;
            const invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

            return [
                (+x5 * b5 - x6 * b4 + x7 * b3) * invdet,
                (-x1 * b5 + x2 * b4 - x3 * b3) * invdet,
                (+x13 * a5 - x14 * a4 + x15 * a3) * invdet,
                (-x9 * a5 + x10 * a4 - x11 * a3) * invdet,
                (-x4 * b5 + x6 * b2 - x7 * b1) * invdet,
                (+x0 * b5 - x2 * b2 + x3 * b1) * invdet,
                (-x12 * a5 + x14 * a2 - x15 * a1) * invdet,
                (+x8 * a5 - x10 * a2 + x11 * a1) * invdet,
                (+x4 * b4 - x5 * b2 + x7 * b0) * invdet,
                (-x0 * b4 + x1 * b2 - x3 * b0) * invdet,
                (+x12 * a4 - x13 * a2 + x15 * a0) * invdet,
                (-x8 * a4 + x9 * a2 - x11 * a0) * invdet,
                (-x4 * b3 + x5 * b1 - x6 * b0) * invdet,
                (+x0 * b3 - x1 * b1 + x2 * b0) * invdet,
                (-x12 * a3 + x13 * a1 - x14 * a0) * invdet,
                (+x8 * a3 - x9 * a1 + x10 * a0) * invdet];
        }

        /**
         * Normalise the input vector
         */
        function normalise(vector) {
            const length = Math.hypot(...vector);
            for (let i = 0; i < vector.length; ++i) {
                vector[i] /= length;
            }
            return vector;
        }

        /**
         * Return a normalised copy of the input vector
         */
        function normalised(vector) {
            const length = Math.hypot(...vector);
            return vector.map((element) => element / length);
        }

        /**
         *
         */
        function dot(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        /**
         *
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0]];
        }

        /**
         *
         */
        function negate(v) {
            v[0] = -v[0];
            v[1] = -v[1];
            v[2] = -v[2];
        }

        /**
         *
         */
        function add(...vectors) {
            return vectors.reduce((sum, v) => [sum[0] + v[0], sum[1] + v[1], sum[2] + v[2]], [0, 0, 0]);
        }

        /**
         *
         */
        function addInPlace(...vectors) {
            const scale = Array.isArray(vectors[vectors.length - 1]) ? 1 : vectors.pop();
            vectors.slice(1).forEach((v) => v.forEach((a, i) => vectors[0][i] += a * scale));
        }

        /**
         *
         */
        function subtract(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        /**
         *
         */
        function scale(v, s) {
            v[0] *= s;
            v[1] *= s;
            v[2] *= s;
            return v;
        }

        /**
         *
         */
        function scaled(v, s) {
            return v.map((e) => e * s);
        }

        /**
         *
         */
        function rotate(v, axis, angle) {
            angle *= Math.PI / 180;
            axis = normalised(axis);

            const s = Math.cos(angle / 2);
            const u = scaled(axis, Math.sin(angle / 2));

            const p1 = scale(cross(v, u), 2 * s);
            const p2 = scaled(v, s * s - dot(u, u));
            const p3 = scaled(u, 2 * dot(v, u));

            [v[0], v[1], v[2]] = add(p1, add(p2, p3));

            return add(p1, add(p2, p3));
        }

        /**
         *
         */
        function transformVector2d(v, matrix) {
            const x = matrix[0] * v[0] + matrix[1] * v[1] + matrix[2];
            const y = matrix[3] * v[0] + matrix[4] * v[1] + matrix[5];
            v[0] = x;
            v[1] = y;
            return v;
        }

        /**
         *
         */
        function matrixVectorMultiply(v, matrix) {
            const x = matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12];
            const y = matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13];
            const z = matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14];
            v[0] = x;
            v[1] = y;
            v[2] = z;
            return v
        }

        /**
         * point transform (apply translation)
         */
        function transformed(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
            ];
        }

        /**
          * point transform (apply translation)
          */
        function transform4(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
                matrix[3] * v[0] + matrix[7] * v[1] + matrix[11] * v[2] + matrix[15],
            ];
        }

        /**
         * Direction transform (ignore translation)
         */
        function transformDirection(v, matrix) {
            return normalised([
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2],
            ]);
        }


        /**
         * Return the plane defined by three points
         */
        function planeFromPoints(p0, p1, p2) {
            const v0 = subtract(p0, p1);
            const v1 = subtract(p0, p2);
            const normal = normalised(cross(v0, v1));
            return { point: p0, normal };
        }

        /**
         * Return an identity matrix
         */
        function identityMatrix() {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }

        /**
         *
         */
        function lookAt(eye, at, up) {
            const zaxis = normalised(subtract(at, eye));
            const xaxis = normalised(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eye), -dot(yaxis, eye), -dot(zaxis, eye), 1
            ];
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zFar + zNear) / (zNear - zFar), -1,
                0, 0, (2 * zFar * zNear) / (zNear - zFar), 1,
            ];
        }


        /**
         * Find the closest point on a line to a given point
         */
        function closestPoint(line, point) {
            // line = lp + d * ld
            // point = p
            // From line to point = p - (lp + d * ld)
            // Closest when (p - (lp + d * ld)).ld = 0
            // dot product is distributive hence
            // (p - (lp + d * ld)).ld = p.ld - lp.ld + d * (ld. ld)
            // d = (lp - p).ld / ld.ld
            const numerator = dot(subtract(line.point - point), line.direction);
            const divisor = dot(line.direction, line.direction);
            return numerator / divisor;
        }

        /**
         * Return the distance between two points
         */
        function distance(point1, point2) {
            return math.hypot(point1[0] - point2[0], point1[1] - point2[1], point1[2] - point2[2]);
        }

        /**
         * Add touch controls to the given node
         */
        function planeIntercept(line, plane) {
            // plane (p - p0).n = 0
            // line p = l + dt
            // (l + dt - p0).n = 0
            // (lx + dxt - p0x)nx + (ly + dyt - p0y)ny + (lz + dzt - p0z)nz = 0
            // t(dx.nx + dy.ny + dz.nz) = nx(p0x-lx) + ny(p0y-ly) + nz(p0z-lz)
            // t = (nx(p0x-lx) + ny(p0y-ly) +nz(p0z-lz)) / (dx.nx + dy.ny + dz.nz)

            const divisor = dot(line.direction, plane.normal);
            if (divisor !== 0) {
                const offset = subtract(plane.point, line.point);
                return dot(offset, plane.normal) / divisor;
            }
        }

        /**
         * Get the point from a line and distance along it
         */
        function getPoint(line, distance) {
            return add(line.point, scaled(line.direction, distance));
        }

        /**
         * Determine the intecep of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalised(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start) {
                return [start, end];
            }
        }

        /**
         * Return the nodes at the screen coordinate 
         */
        function pickNodes(view, x, y) {
            const aspect = view.canvas.width / view.canvas.height;
            const ray = view.camera.getLine(aspect, x, y, 45);
            view.ray = ray;
            view.points.length = 0;
            view.lines.length = 0;
            const hits = view.nodes.filter((node) => {
                if (node.shape) {
                    const inverse = invert(node.world);
                    const point = transformed(ray.point, inverse);
                    const direction = transformDirection(ray.direction, inverse);
                    const points = node.shape.intersects({ point, direction });

                    if (points) {
                        node.hit = points;
                        node.hitPoint = getPoint(ray, points[0]);
                        scene.points.push(getPoint(ray, points[0]), getPoint(ray, points[1]));
                        return true;
                    }
                    if (!event.shiftKey) {
                        node.hit = null;
                    }
                }
            });
            return hits;
        }

        /**
         * Process a 'click' event
         */
        function click(view, x, y) {
            const hits = pickNodes(view, x, y);
            if (hits.length > 0) {
                hits.sort((a, b) => a.hit[0] - b.hit[0]);
                if (!event.altKey) {
                    hits.slice(1).forEach((node) => node.hit = null);
                }
                if (event.ctrlKey) {
                    camera.lookAt = hits[0].world.slice(12, 16);
                    if (hits[0].overlay) {
                        removeOverlay(hits[0]);
                    } else {
                        scene.overlays.push(addOverlay(hits[0]));
                    }
                }
                const lookAt = transformed([0, 0, 0], hits[0].world);
                moveCamera(view.camera, lookAt);

                Core.selectedNodes = hits.map((hit) => hit.sourceNode);
                Core.currentNode = hits[0].sourceNode;
            }
        }

        /**
         * Move a node in screen space
         */
        function dragTo(view, node, x, y) {

            // Get the movement plane
            const normal = view.camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const aspect = view.canvas.width / view.canvas.height;
            const ray = view.camera.getLine(aspect, x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));

            const worldOffset = subtract(point, node.hitPoint);

            view.camera.lookAt = subtract(view.camera.lookAt, worldOffset);
            view.camera.position = subtract(view.camera.position, worldOffset);
        }

        /**
         * Move a node in screen space
         */
        function dragNodeTo(view, node, x, y) {

            // Get the movement plane
            const normal = view.camera.zAxis();
            const plane = { point: node.hitPoint, normal };

            // Find the new location
            const aspect = view.canvas.width / view.canvas.height;
            const ray = view.camera.getLine(x, y, 45);
            const point = getPoint(ray, planeIntercept(ray, plane));


            // Get the origin transform for this node
            const transform = node.parent ? node.parent.world : identityMatrix();
            const inverse = invert(transform);

            const worldOffset = subtract(point, node.hitPoint);
            const offset = [
                inverse[0] * worldOffset[0] + inverse[4] * worldOffset[1] + inverse[8] * worldOffset[2],
                inverse[1] * worldOffset[0] + inverse[5] * worldOffset[1] + inverse[9] * worldOffset[2],
                inverse[2] * worldOffset[0] + inverse[6] * worldOffset[1] + inverse[10] * worldOffset[2],
            ];

            const translate = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ...offset, 1];
            node.transform = matrixMultiply(node.transform, translate);
            node.hitPoint = point;
        }

        /**
         * Move a node in screen space
         */
        function rotateNode(view, node, x, y) {
            const inverse = invert(node.world);

            const zAxis = normalised(subtract(view.camera.lookAt, view.camera.position));
            const xAxis = normalised(cross(zAxis, camera.up));
            const yAxis = normalised(cross(zAxis, xAxis));

            const rotateX = getRotationMatrix(-y, transformDirection(xAxis, inverse));
            const rotateY = getRotationMatrix(x, transformDirection(yAxis, inverse));

            node.transform = matrixMultiply(rotateX, node.transform);
            node.transform = matrixMultiply(rotateY, node.transform);
        }

        /**
         * Add touch controls to the given node
         */
        function addControls(node, view) {
            const start = {};
            let action;
            node.addEventListener('touchstart', (event) => {
                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;

                if (event.touches.length === 1) {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    const hits = pickNodes(view, x, y);
                    if (hits.length > 0) {
                        hits.sort((a, b) => a.hit[0] - b.hit[0]);
                        start.hit = hits[0];
                    } else {
                        start.hit = null;
                    }
                    action = 'click';
                } else if (event.touches.length === 2) {
                    start.second = {
                        x: event.touches[1].clientX,
                        y: event.touches[1].clientY,
                    };
                    action = 'pinch';
                }
                report(action);
            });

            node.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if ((action === 'pinch') && (event.touches.length === 2)) {
                    // Use movement of centre to control rotation
                    const cx = (start.x + start.second.x);
                    const cy = (start.y + start.second.y);
                    const vs = normalise([start.x - start.second.x, start.y - start.second.y]);
                    const vn = normalise([event.touches[0].clientX - event.touches[1].clientX, event.touches[0].clientY - event.touches[1].clientY]);
                    const deltaZ = Math.asin(vs[0] * vn[1] - vs[1] * vn[0]) * 180 / Math.PI;
                    const deltaX = (event.touches[0].clientX + event.touches[1].clientX - cx) / 2;
                    const deltaY = (event.touches[0].clientY + event.touches[1].clientY - cy) / 2;

                    view.camera.rotateY(deltaX);
                    view.camera.rotateX(deltaY);
                    view.camera.roll(deltaZ);

                    const initial = Math.hypot(start.x - start.second.x, start.y - start.second.y);
                    const current = Math.hypot(event.touches[0].clientX - event.touches[1].clientX, event.touches[0].clientY - event.touches[1].clientY);

                    const offset = subtract(view.camera.position, view.camera.lookAt);
                    const scale = current / initial;
                    view.camera.position = add(view.camera.lookAt, scaled(offset, scale));

                    start.second.x = event.touches[1].clientX;
                    start.second.y = event.touches[1].clientY;
                } else if (action) {
                    action = 'drag';
                    const deltaX = event.touches[0].clientX - start.x;
                    const deltaY = event.touches[0].clientY - start.y;

                    if (start.hit) {
                        if (view.settings.move.checked) {
                            rotateNode(view, start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.touches[0].clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.touches[0].clientY) / box.height) + 1;

                            dragTo(view, start.hit, x, y);
                        }
                    } else {
                        if (event.altKey) {
                            view.camera.yaw(deltaX / 10);
                            view.camera.pitch(deltaY / 10);
                        } else {
                            view.camera.rotateY(deltaX);
                            view.camera.rotateX(deltaY);
                        }
                    }
                }
                start.x = event.touches[0].clientX;
                start.y = event.touches[0].clientY;
            });

            node.addEventListener('touchend', (event) => {
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;
                    click(view, x, y);
                } else if (action === 'pinch') {
                    action = null;
                }
                node.focus();
            });

            node.addEventListener('mousedown', (event) => {
                event.preventDefault();
                start.x = event.clientX;
                start.y = event.clientY;

                const box = node.getBoundingClientRect();

                const x = 2 * ((start.x - box.left) / box.width) - 1;
                const y = 2 * ((box.top - start.y) / box.height) + 1;

                const hits = pickNodes(view, x, y);
                if (hits.length > 0) {
                    hits.sort((a, b) => a.hit[0] - b.hit[0]);
                    start.hit = hits[0];
                } else {
                    start.hit = null;
                }
                action = 'click';
            });

            node.addEventListener('mousemove', (event) => {
                event.preventDefault();
                if (action) {
                    action = 'drag';
                    const deltaX = event.clientX - start.x;
                    const deltaY = event.clientY - start.y;

                    if (start.hit) {
                        if (view.settings.move.checked || event.buttons & 4) {
                            rotateNode(view, start.hit, deltaX, deltaY);
                        } else {
                            const box = node.getBoundingClientRect();

                            const x = 2 * ((event.clientX - box.left) / box.width) - 1;
                            const y = 2 * ((box.top - event.clientY) / box.height) + 1;

                            if (event.ctrlKey) {
                                dragNodeTo(view, start.hit, x, y);
                            } else {
                                dragTo(view, start.hit, x, y);
                            }
                        }
                    } else {
                        if (event.altKey) {
                            view.camera.yaw(deltaX / 10);
                            view.camera.pitch(deltaY / 10);
                        } else {
                            view.camera.rotateY(deltaX);
                            view.camera.rotateX(deltaY);
                        }
                    }
                    start.x = event.clientX;
                    start.y = event.clientY;
                }
            });

            node.addEventListener('mouseup', (event) => {
                event.preventDefault();
                if (action === 'click') {
                    const box = node.getBoundingClientRect();

                    const x = 2 * ((start.x - box.left) / box.width) - 1;
                    const y = 2 * ((box.top - start.y) / box.height) + 1;

                    click(view, x, y);
                }
                action = null;
                node.focus();
            });

            node.addEventListener('wheel', (event) => {
                const stepSize = parseFloat(view.settings.stepSize.value);
                const dist = stepSize * (-event.deltaY / 1000);
                view.camera.zoom(dist);
                report(dist);
            });

            node.addEventListener('keydown', (event) => {
                report(event.key);
                event.preventDefault();
                const yAxis = normalised(view.camera.up);
                const zAxis = normalised(subtract(view.camera.lookAt, view.camera.position));
                const xAxis = cross(zAxis, yAxis);
                if (true) {
                    yAxis[0] = 0;
                    yAxis[1] = 1;
                    yAxis[0] = 0;

                    xAxis[1] = 0;
                    zAxis[1] = 0;

                    normalise(xAxis);
                    normalise(zAxis);
                }
                const stepSize = parseFloat(view.settings.stepSize.value);
                const scale = event.ctrlKey ? 0.1 : 1;
                if (event.key === 'u') {
                    view.camera.up = [0, 1, 0];
                }
                if (event.key === 'ArrowUp') {
                    if (event.shiftKey) {
                        if (event.altKey) {
                            view.camera.rotateX(10 * scale);
                        } else {
                            view.camera.pitch(-10 * scale);
                        }
                    } else {
                        if (event.altKey) {
                            addInPlace(view.camera.lookAt, yAxis, scale * stepSize);
                            addInPlace(view.camera.position, yAxis, scale * stepSize);
                            // } else {
                            addInPlace(view.camera.lookAt, zAxis, scale * stepSize);
                            addInPlace(view.camera.position, zAxis, scale * stepSize);
                        }
                    }
                }
                if (event.key === 'ArrowDown') {
                    if (event.shiftKey) {
                        if (event.altKey) {
                            view.camera.rotateX(-10 * scale);
                        } else {
                            view.camera.pitch(10 * scale);
                        }
                    } else {
                        if (event.altKey) {
                            addInPlace(view.camera.lookAt, yAxis, -scale * stepSize);
                            addInPlace(view.camera.position, yAxis, -scale * stepSize);
                        } else {
                            addInPlace(view.camera.lookAt, zAxis, -scale * stepSize);
                            addInPlace(view.camera.position, zAxis, -scale * stepSize);
                        }
                    }
                }
                if (event.key === 'ArrowLeft') {
                    if (event.shiftKey) {
                        addInPlace(view.camera.lookAt, xAxis, -scale * stepSize);
                        addInPlace(view.camera.position, xAxis, -scale * stepSize);
                    } else {
                        if (event.altKey) {
                            view.camera.rotateY(-10 * scale);
                        } else {
                            view.camera.spinY(-10 * scale);
                        }
                    }
                }
                if (event.key === 'ArrowRight') {
                    if (event.shiftKey) {
                        addInPlace(view.camera.lookAt, xAxis, scale * stepSize);
                        addInPlace(view.camera.position, xAxis, scale * stepSize);
                    } else {
                        if (event.altKey) {
                            view.camera.rotateY(10 * scale);
                        } else {
                            view.camera.spinY(10 * scale);
                        }
                    }
                }
            });

            document.getElementById('start').addEventListener('click', (event) => state.action = 'start');
            document.getElementById('rewind').addEventListener('click', (event) => state.action = 'rewind');
            document.getElementById('play').addEventListener('click', (event) => state.action = 'play');
            document.getElementById('forward').addEventListener('click', (event) => state.action = 'forward');
            document.getElementById('end').addEventListener('click', (event) => state.action = 'end');
        }


        /**
         * Add touch controls to the vertical and horizontal separators
         */
        function addUIControls() {
            let action = null;
            const start = {};
            let before = null;
            let after = null;

            const horizontalDrag = (event, x, y) => {
                event.preventDefault();
                const delta = x - start.x;
                start.sizes[start.index - 1] += delta;
                start.sizes[start.index + 1] -= delta;
                start.container.style.gridTemplateColumns = start.sizes.map((size) => `${size}px`).join(' ');
                start.x = x;
            }

            const startHorizontalDrag = (vbar, x) => {
                start.x = x;
                start.container = vbar.parentElement;
                const content = Array.from(vbar.parentElement.children);
                const style = window.getComputedStyle(vbar.parentElement);
                start.sizes = style.gridTemplateColumns.split(' ').map((v) => parseFloat(v));//content.map((element) => element.clientWidth);
                start.index = content.indexOf(vbar);
                action = horizontalDrag;
            }

            const verticalBars = document.querySelectorAll('.vertical-bar');

            const newVerticalBar = (vbar) => {
                if (!vbar) {
                    vbar = document.createElement('div');
                    vbar.classList.add('vertical-bar');
                }
                vbar.addEventListener('mousedown', (event) => {
                    startHorizontalDrag(vbar, event.clientX);
                });
                vbar.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (event.touches.length > 0) {
                        startHorizontalDrag(vbar, event.touches[0].clientX);
                    }
                });
                return vbar;
            };

            for (const vbar of verticalBars) {
                newVerticalBar(vbar);
            }

            const verticalDrag = (event, x, y) => {
                event.preventDefault();
                const delta = y - start.y;
                start.sizes[start.index - 1] += delta;
                start.sizes[start.index + 1] -= delta;
                start.container.style.gridTemplateRows = start.sizes.map((size) => `${size}px`).join(' ');
                start.y = y;
            }

            const startVerticalDrag = (hbar, y) => {
                start.y = y;
                start.container = hbar.parentElement;
                const content = Array.from(hbar.parentElement.children);
                const style = window.getComputedStyle(hbar.parentElement);
                start.sizes = style.gridTemplateRows.split(' ').map((v) => parseFloat(v));//content.map((element) => element.clientWidth);
                //start.sizes = content.map((element) => element.clientHeight);
                start.index = content.indexOf(hbar);
                action = verticalDrag;
            }

            const horizontalBars = document.querySelectorAll('.horizontal-bar');
            const newHorizontalBar = (hbar) => {
                if (!hbar) {
                    hbar = document.createElement('div');
                    hbar.classList.add('horizontal-bar');
                }
                hbar.addEventListener('mousedown', (event) => {
                    startVerticalDrag(hbar, event.clientY);
                });
                hbar.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (event.touches.length > 0) {
                        startVerticalDrag(hbar, event.touches[0].clientY);
                    }
                });
                return hbar;
            };

            for (const hbar of horizontalBars) {
                newHorizontalBar(hbar);
            }
            document.body.addEventListener('mousemove', (event) => {
                if (action) {
                    action(event, event.clientX, event.clientY);
                }
            });

            document.body.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (action && event.touches.length === 1) {
                    action(event, event.touches[0].clientX, event.touches[0].clientY);
                }
            });

            document.body.addEventListener('mouseenter', (event) => {
                action = null
            });

            document.body.addEventListener('mouseup', (event) => {
                action = null;
            });

            document.body.addEventListener('touchend', (event) => {
                //event.preventDefault();
                action = null;
            });


            const placeholder = document.createElement('div');
            placeholder.classList.add('placeholder');
            const sidebar = document.querySelector('.sidebar');

            sidebar.addEventListener('click', (event) => {
                if (event.target === sidebar) {
                    sidebar.classList.toggle('hide-right');
                }
            });

            const insertFrame = (frame, bar) => {
                const container = bar.parentElement;
                const gridTemplate = container.classList.contains('layout-row') ? 'gridTemplateColumns' : 'gridTemplateRows';
                const content = Array.from(container.children);
                const style = window.getComputedStyle(container);
                const sizes = style[gridTemplate].split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);

                const index = (1 + content.indexOf(bar)) / 2;
                const total = sizes.reduce((sum, size) => sum + size, 0);
                const newSize = sizes.map((size) => `${size / total}fr`);
                newSize.splice(index, 0, `${1 / sizes.length}fr`);

                container.insertBefore(frame, bar);
                if (container.classList.contains('layout-row')) {
                    container.insertBefore(uiControls.newVerticalBar(), frame);
                } else {
                    container.insertBefore(uiControls.newHorizontalBar(), frame);
                }
                container.style[gridTemplate] = newSize.join(' min-content ');
            }

            const removeFrame = (frame) => {
                const container = frame.parentElement;

                const content = Array.from(container.children);
                const index = content.indexOf(frame) / 2;

                if (frame.nextSibling) {
                    frame.nextSibling.remove();
                } else if (frame.previousSibling) {
                    frame.previousSibling.remove();
                }
                
                frame.remove();
                if (container.childNodes.length === 1) {
                    container.replaceWith(container.firstChild);
                } else {
                    const gridTemplate = container.classList.contains('layout-row') ? 'gridTemplateColumns' : 'gridTemplateRows';
                    const style = window.getComputedStyle(container);

                    const sizes = style[gridTemplate].split(' ').map((v) => parseFloat(v)).filter((s, i) => (i % 2) === 0);
                    sizes.splice(index, 1);

                    const total = sizes.reduce((sum, size) => sum + size, 0);
                    const newSize = sizes.map((size) => `${size / total}fr`);

                    container.style[gridTemplate] = newSize.join(' min-content ');
                }
            }

            const newFrame = (view) => {
                const frame = document.createElement('div');
                const title = document.createElement('div');
                title.innerHTML = view.title;
                title.classList.add('frame-title');
                frame.appendChild(title);
                frame.addEventListener('focusin', (event) => frame.classList.add('selected-frame'));
                frame.addEventListener('focusout', (event) => frame.classList.remove('selected-frame'));
                frame.append(view.node);

                frame.classList.add('frame')
                const actions = {};
                const start = {};

                const frames = [];
                frame.addEventListener('click', (event) => Core.currentFrame = frame);

                const dragStart = (event, x, y) => {
                    const position = frame.getBoundingClientRect();
                    frame.classList.add('dragging')
                    frame.style.left = `${position.x}px`;
                    frame.style.top = `${position.y}px`;
                    start.x = x;
                    start.y = y;
                    start.position = position;
                    actions.move = dragBox;
                    actions.end = dragEnd;
                    frame.parentElement.insertBefore(placeholder, frame);
                    sidebar.classList.remove('hide-right');
                    sidebar.classList.add('hide-right90');
                    frames.length = 0;
                    frames.push(...Array.from(document.querySelectorAll('.frame'))
                        .map((frame) => ({ frame, bounds: frame.getBoundingClientRect() })));
                };

                const dragBox = (event, x, y) => {
                    const dx = x - start.x;
                    const dy = y - start.y;
                    frame.style.left = `${start.position.x + dx}px`;
                    frame.style.top = `${start.position.y + dy}px`;
                    actions.x = x;
                    actions.y = y;
                    actions.end = dragEnd;
                    const elements = document.elementsFromPoint(x, y);
                    const vbar = elements.find((element) => element.classList.contains('vertical-bar'));
                    const hbar = elements.find((element) => element.classList.contains('horizontal-bar'));
                    if (vbar) {
                        const rect = vbar.getBoundingClientRect();
                        frame.classList.add('vbar-hover');
                        frame.classList.remove('hbar-hover');
                    } else if (hbar) {
                        frame.classList.add('hbar-hover');
                        frame.classList.remove('vbar-hover');
                        const rect = hbar.getBoundingClientRect();
                    } else {
                        frame.classList.remove('vbar-hover');
                        frame.classList.remove('hbar-hover');
                    }
                };

                const dragEnd = (event) => {
                    frame.classList.remove('dragging');
                    placeholder.remove();
                    Core.currentFrame = frame;
                    if (actions.x !== undefined && actions.y !== undefined) {
                        const elements = document.elementsFromPoint(actions.x, actions.y);
                        if (elements[0].classList.contains('layout-main')) {
                            report('swap single');
                            elements[0].appendChild(frame);
                        } else if (elements[0].classList.contains('sidebar')) {
                            report('add to sidebar');

                            if (!sidebar.contains(frame)) {
                                removeFrame(frame);
                                sidebar.appendChild(frame)
                            }
                        } else {
                            const bar = elements.find((element) => element.classList.contains('vertical-bar')) ||
                                elements.find((element) => element.classList.contains('horizontal-bar'));
                            const target = frames.find((test) =>
                                (test.bounds.x < actions.x) && (actions.x < test.bounds.x + test.bounds.width) &&
                                (test.bounds.y < actions.y) && (actions.y < test.bounds.y + test.bounds.height));

                            if (bar) {
                                report('insert');
                                const container = FrameContainer.all.find((container) => container.node === bar.parentElement);
                                if (sidebar.contains(frame)) {
                                    container.insert(frame, bar);
                                } else if (bar.parentElement === frame.parentElement) {
                                    if (bar !== frame.nextSibling && bar !== frame.previousSibling) {
                                        report('reorder');
                                        const container = bar.parentElement;
                                        if (frame.nextSibling) {
                                            container.insertBefore(frame.nextSibling, bar);
                                            container.insertBefore(frame, bar);
                                        } else {
                                            container.insertBefore(frame.previousSibling, bar);
                                            container.insertBefore(frame, bar);
                                        }
                                    }
                                } else {
                                    removeFrame(frame);
                                    container.insert(frame, bar);
                                }
                                frame.classList.remove('vbar-hover');
                                frame.classList.remove('hbar-hover');
                            } else if (target) {
                                if (target.frame === frame) {
                                    report('cancel move');
                                } else if (event.ctrlKey) {
                                    report('split');
                                    if (!sidebar.contains(frame)) {
                                        removeFrame(frame);
                                    }
                                    const after = target.frame.parentElement.classList.contains('layout-row') ?
                                        ((actions.x - target.bounds.x) / target.bounds.width) > 0.5 :
                                        ((actions.y - target.bounds.y) / target.bounds.height) > 0.5;

                                    const container = FrameContainer.all.find((container) => container.node === target.frame.parentElement);
                                    if (container) {
                                        container.split(frame, target.frame, after);
                                    } else {
                                        const parent = target.frame.parentElement;
                                        const container = new FrameContainer(target.frame, frame);
                                        parent.appendChild(container.node);
                                    }
                                } else {
                                    report('swap');
                                    frame.parentElement.insertBefore(placeholder, frame);
                                    target.frame.replaceWith(frame);
                                    placeholder.replaceWith(target.frame);
                                }
                            } else {
                                report('remove');
                                view.node.remove();
                                removeFrame(frame);
                            }
                        }
                    }
                    frame.style.left = `unset`;
                    frame.style.top = `unset`;
                    actions.move = null;
                    actions.end = null;
                    sidebar.classList.remove('hide-right90');
                    sidebar.classList.add('hide-right');
                };

                title.addEventListener('mousedown', (event) =>
                    dragStart(event, event.clientX, event.clientY));

                title.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 1) {
                        dragStart(event, event.touches[0].clientX, event.touches[0].clientY);
                    }
                });

                frame.addEventListener('mousedown', (event) => {
                    if (event.target === frame) {
                        dragStart(event, event.clientX, event.clientY);
                    }
                });

                frame.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 1 && event.target === frame) {
                        dragStart(event, event.touches[0].clientX, event.touches[0].clientY);
                    }
                });

                const endTouch = (event) => {
                    if (actions.end) {
                        actions.end(event);
                    }
                }

                document.body.addEventListener('mouseup', (event) => endTouch(event));

                window.addEventListener('touchend', (event) => {
                    if (event.touches.length === 0) {
                        endTouch(event);
                    }
                });

                const move = (event, x, y) => {
                    if (actions.move) {
                        event.preventDefault();
                        actions.move(event, x, y);
                    }
                }

                document.body.addEventListener('mousemove', (event) =>
                    move(event, event.clientX, event.clientY));

                document.body.addEventListener('touchmove', (event) =>
                    move(event, event.touches[0].clientX, event.touches[0].clientY));
                return frame;
            };

            const newSidebarFrame = (view) => {
                const frame = newFrame(view);
                view.node.classList.add('sidebar-view');
                sidebar.append(frame);
                sidebar.classList.remove('hide-right');
            }

            return { newVerticalBar, newHorizontalBar, newFrame, newSidebarFrame };
        }
        const uiControls = addUIControls();

        /**
         * Add an overlay for the specified node
         */
        function addOverlay(node) {
            const box = document.getElementById('scene').getBoundingClientRect();
            const container = document.createElement('div');
            container.classList.add('overlay', 'fixed');

            const updateOverlay = (projectionMatrix) => {
                const modelViewMatrix = matrixMultiply(node.world, scene.modelViewMatrix);

                const transform = matrixMultiply(modelViewMatrix, scene.projectionMatrix);
                const position = transform4([0, 0, 0], transform);
                const x = box.left + (position[0] / position[3] + 1) * box.width / 2;
                const y = box.bottom - (position[1] / position[3] + 1) * box.height / 2;

                container.style.left = `${x}px`;
                container.style.top = `${y}px`;
                container.innerHTML = `<span>${node.name}</span><br>Position: <span>${node.transform.slice(12, 15).map((p) => p.toFixed(2)).join(', ')}</span>`;
            }
            updateOverlay(scene.projectionMatrix);

            document.body.appendChild(container);
            node.overlay = { container, updateOverlay };
            return node.overlay;
        }

        /**
         * Add an overlay for the specified node
         */
        function removeOverlay(node) {
            if (node.overlay) {
                node.overlay.container.remove();
                const pos = scene.overlays.indexOf(node.overlay);
                if (pos > -1) {
                    scene.overlays.splice(pos, 1);
                }
                node.overlay = null;
            }
        }

        /**
         * Display element
         */
        function showEntry(name, value, internal) {
            const addEntry = (text) => {
                const container = document.createElement('div');
                container.innerText = text;
                container.classList.add('entry');
                return container;
            }

            if (Array.isArray(value)) {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (array[${value.length}])`;
                if (internal) {
                    label.classList.add('internal');
                }
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                container.addEventListener('toggle', (event) => {
                    if (container.open) {
                        content.innerHTML = '';
                        value.forEach((element, i) =>
                            content.append(showEntry(`${i}`, element)));
                    }
                });
                return container;
            } else if (value === undefined) {
                const container = document.createElement('div');
                container.innerText = `${name}: undefined`;
                container.classList.add('entry');
                return container;
            } else if (value === null) {
                const container = document.createElement('div');
                container.innerText = `${name}: null`;
                container.classList.add('entry');
                return container;
            } else if (value && typeof (value) === 'object' && !value.toISOString) {
                const container = document.createElement('details');
                const label = document.createElement('summary');
                container.appendChild(label);
                label.innerText = `${name}: (object)`;
                const content = document.createElement('div');
                container.appendChild(content);
                content.classList.add('entry-content');
                container.addEventListener('toggle', (event) => {
                    if (container.open) {
                        content.innerHTML = '';
                        Object.entries(value).forEach(([key, value]) =>
                            content.append(showEntry(`${key}`, value)));
                    }
                });
                return container;
            }
            const container = document.createElement('div');
            if (value.toISOString) {
                container.innerText = `${name}: ${value.toISOString()}`;
            } else {
                container.innerText = `${name}: ${value}`;
            }
            container.classList.add('entry');
            return container;
        }

        /**
         *
         */
        let state = { time: 0, rate: 1, mode: 'paused', nextEvent: 0 };

        /**
         * Update the line numbers for a textarea element
         */
        function updateLineNumbers(main, lineNumbers) {
            const count = main.value.split(/\n/g).length;
            lineNumbers.value = '';
            const numbers = Array(count).fill(0).map((e, i) => i + 1);
            lineNumbers.value = numbers.join('\r\n');
            lineNumbers.cols = 1 + (count + '').length;
        }

        const actions = {};

        /**
         * Add drag control to an element
         */
        function addElementDrag(node) {
            const start = {};

            const moveNode = (eventX, eventY) => {
                const dx = eventX - start.mouseX;
                const dy = eventY - start.mouseY;
                const x = start.elementX + dx;
                const y = start.elementY + dy;
                node.style.position = 'absolute';
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.style.right = 'auto';
            }
            const mouseMove = (event) => {
                moveNode(event.clientX, event.clientY);
            }
            const touchMove = (event) => {
                moveNode(event.touches[0].clientX, event.touches[0].clientY);
            }

            node.addEventListener('mousedown', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.clientX;
                start.mouseY = event.clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.mouseMove = mouseMove;
                actions.mouseUp = (event) => actions.mouseMove = null;
            });


            node.addEventListener('touchstart', (event) => {
                const box = node.getBoundingClientRect();
                start.mouseX = event.touches[0].clientX;
                start.mouseY = event.touches[0].clientY;
                start.elementX = box.left;
                start.elementY = box.top;
                actions.touchMove = touchMove;
                actions.touchEnd = (event) => actions.touchMove = null;
            });
        }


        /**
         * Create a shader view
         */
        function createShaderView() {
            let shader;
            const layout = document.querySelector('.layout');

            const template = document.getElementById('shader-controls-template');
            const controls = template.content.firstElementChild.cloneNode(true);
            layout.appendChild(controls);
            controls.style.gridColumn = '1 / -1';
            controls.style.gridRow = '2';

            const vertexEditor = new Editor(layout);
            const fragmentEditor = new Editor(layout);

            const nameSelection = controls.querySelector('.shader-name');
            nameSelection.addEventListener('change', (event) => {
                const name = nameSelection.value;
                if (scene.shaders[name]) {
                    shader = scene.shaders[name];
                    update(scene.shaders[name]);
                }
            });
            nameSelection.value = 'shader4';

            const buildButton = controls.querySelector('.build-shader');
            const externalNames = document.getElementById('external-names');

            const attributes = [];
            const uniforms = [];

            vertexEditor.main.addEventListener('input', (event) => shader.vertex = vertexEditor.value);
            fragmentEditor.main.addEventListener('input', (event) => shader.fragment = fragmentEditor.value);

            const getNames = (shader) => {
                const attrTable = externalNames.querySelector('.attributes');
                const attributePattern = /^\s*attribute\s+(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;

                const uniformTable = externalNames.querySelector('.uniforms');
                const uniformPattern = /^\s*uniform\s+(highp\s+)?(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;
                const lines = shader.definition.vertex.split('\n');
                lines.push(...shader.definition.fragment.split('\n'));

                setters = {
                    mat4: (location, value) => view.gl.uniformMatrix4fv(location, false, value),
                    mat3: (location, value) => view.gl.uniformMatrix3fv(location, false, value),
                    vec3: (location, value) => view.gl.uniform3fv(location, value),
                    vec4: (location, value) => view.gl.uniform4fv(location, value),
                    float: (location, value) => view.gl.uniform1f(location, value),
                    sampler2D: (location, value) => view.gl.uniform1i(location, value),
                };

                lines.forEach((line) => {
                    const attrMatch = line.match(attributePattern);
                    const uniformMatch = line.match(uniformPattern);

                    if (attrMatch) {
                        const definition = shader.definition.attributes.find((def) => def.attribute === attrMatch.groups.name);
                        const attribute = {
                            attribute: attrMatch.groups.name,
                            name: definition ? definition.name : '',
                            type: attrMatch.groups.type,
                        };
                        const name = document.createElement('span');
                        attrTable.appendChild(name);
                        name.innerHTML = attrMatch.groups.name;
                        name.classList.add('cell');
                        const input = document.createElement('input');
                        attrTable.appendChild(input);
                        input.classList.add('cell');
                        input.value = attribute.name;
                        input.addEventListener('change', (event) => attribute.name = input.value);
                        const type = document.createElement('span');
                        attrTable.appendChild(type);
                        type.innerHTML = attrMatch.groups.type;
                        type.classList.add('cell');
                        attributes.push(attribute);
                    }
                    if (uniformMatch) {
                        const definition = shader.definition.uniforms.find((def) => def.uniform === uniformMatch.groups.name);
                        const uniform = {
                            uniform: uniformMatch.groups.name,
                            name: definition ? definition.name : '',
                            type: uniformMatch.groups.type,
                            set: setters[uniformMatch.groups.type],
                        };

                        const name = document.createElement('span');
                        uniformTable.appendChild(name);
                        name.innerHTML = uniformMatch.groups.name;
                        name.classList.add('cell');
                        const input = document.createElement('input');
                        uniformTable.appendChild(input);
                        input.classList.add('cell');
                        input.value = uniform.name;
                        input.addEventListener('change', (event) => uniform.name = input.value);
                        const type = document.createElement('span');
                        uniformTable.appendChild(type);
                        type.innerHTML = uniformMatch.groups.type;
                        type.classList.add('cell');
                        const defaultValue = document.createElement('input');
                        uniformTable.appendChild(defaultValue)
                        defaultValue.classList.add('cell');
                        uniforms.push(uniform);
                    }
                });
            }

            const update = (shader) => {
                attributes.length = 0;
                uniforms.length = 0;
                vertexEditor.value = shader.vertex || shader.definition.vertex;
                fragmentEditor.value = shader.fragment || shader.definition.fragment;
                for (let cell of externalNames.querySelectorAll('.cell')) {
                    cell.remove();
                }

                getNames(shader);
            }

            const show = () => {
                const shaderList = document.getElementById('shader-list');
                shaderList.innerHTML = '';
                Object.keys(scene.shaders).forEach((shaderName) => {
                    const node = document.createElement('option');
                    shaderList.appendChild(node);
                    node.innerHTML = shaderName;
                });
                layout.style.gridTemplateRows = 'min-content min-content 1fr 1fr';
                shader = shader || scene.shaders.shader4;
                update(shader);
                vertexEditor.container.style.display = 'flex';
                fragmentEditor.container.style.display = 'flex';
                vertexEditor.container.style.gridColumn = 1;
                vertexEditor.container.style.gridRow = 3;
                fragmentEditor.container.style.gridColumn = 2;
                fragmentEditor.container.style.gridrow = 3;
                buildButton.style.display = 'inline-block';
                externalNames.classList.remove('hidden');
            };

            const hide = () => {
                vertexEditor.container.style.display = 'none';
                fragmentEditor.container.style.display = 'none';
                buildButton.style.display = 'none';
                externalNames.classList.add('hidden');
            };

            const build = () => {
                const definition = {
                    name: nameSelection.value,
                    vertex: vertexEditor.value,
                    fragment: fragmentEditor.value,
                    attributes, uniforms,
                };
                scene.shaders[definition.name] = makeShader(definition);
                const shaders = Object.values(scene.shaders);
                localStorage.setItem('shaders', JSON.stringify(shaders, null, 2));
            }

            buildButton.addEventListener('click', (event) => build());

            hide();

            return { show, hide, vertexEditor, fragmentEditor };
        }

        /**
         * Build a shader from a definition.
         */
        function makeShader(definition, context) {
            const removeIndent = (text) => {
                const lines = text.split(/\n/);
                const indent = Math.min(...lines.filter((line) => line.length).map((line) => line.length - line.trimStart().length));
                return lines.map((line) => line.slice(indent)).join('\n');
            };

            definition.vertex = removeIndent(definition.vertex);
            definition.fragment = removeIndent(definition.fragment);

            const shader = {
                attribLocations: {},
                definition,
                toJSON() {
                    return this.definition
                },
            };

            shader.program = initialiseShaders(context, definition.vertex, definition.fragment);

            if (shader.program) {
                definition.attributes.forEach((attribute) =>
                    shader.attribLocations[attribute.name] = context.getAttribLocation(shader.program, attribute.attribute));
                definition.uniforms.forEach((uniform) =>
                    shader[uniform.name] = context.getUniformLocation(shader.program, uniform.uniform));
            }

            const setters = {
                mat4: (location, value) => context.uniformMatrix4fv(location, false, value),
                mat3: (location, value) => context.uniformMatrix3fv(location, false, value),
                vec3: (location, value) => context.uniform3fv(location, value),
                vec4: (location, value) => context.uniform4fv(location, value),
                float: (location, value) => context.uniform1f(location, value),
                sampler2D: (location, value) => context.uniform1i(location, value),
            };

            // Extract the declaration of uniforms from the source
            const uniformPattern = /^\s*uniform\s+(highp\s+)?(?<type>[^\s]+)\s+(?<name>[^\s;\/]+)/;
            const full = (definition.vertex + definition.fragment).split(';');
            const definedUniforms = full.map((line) => line.match(uniformPattern))
                .flatMap((match) => match ? match.groups : [])
                .reduce((obj, uniform) => { obj[uniform.name] = uniform.type; return obj }, {});

            // Generate 'setters' for each uniform
            const uniforms = definition.uniforms.map((uniform) => ({
                name: uniform.name,
                uniform: uniform.uniform,
                set: uniform.set || setters[definedUniforms[uniform.uniform]],
            })).filter((uniform) => uniform.set);

            Object.keys(definedUniforms).forEach((name) => {
                if (!uniforms.find((match) => match.uniform === name)) {
                    warn(`Warning ${name} not mapped for ${definition.name} shader`);
                }
            });

            shader.setSceneData = (scene) => {
                uniforms.forEach((uniform) => {
                    if (scene[uniform.name]) {
                        uniform.set(shader[uniform.name], scene[uniform.name]);
                    }
                });
            }
            shader.setNodeData = (gl, node) => {
                uniforms.forEach((uniform) => {
                    if (node[uniform.name]) {
                        uniform.set(shader[uniform.name], node[uniform.name]);
                    }
                });
                /*
                if (node.hit) {
                    gl.uniform4fv(shader.colour, [1, 0, 0, 1]);
                }
                */
            }
            shader.setElementData = (element) => {
                uniforms.forEach((uniform) => {
                    if (element[uniform.name]) {
                        uniform.set(shader[uniform.name], element[uniform.name]);
                    }
                });
            }

            return shader;
        }

        /**
         * Toggle fullscreen mode
         */
        function toggleFullscreen() {
            if (document.body.webkitRequestFullscreen) {
                if (document.body.webkitIsFullScreed) {
                    document.body.webkitCancelFullScreen();
                } else {
                    document.body.webkitRequestFullscreen(document.body.ALLOW_KEYBOARD_INPUT);
                }
            }
            if (document.body.requestFullscreen) {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.body.requestFullscreen();
                }
            }
        }

        /**
         * Save the content of the editor
         */
        function save() {
            const text = document.querySelector('.editor .main').value;
            const name = document.getElementById('filename').value;

            download(text, name);
            /*
            if (!config.files.includes(name)) {
                config.files.push(name);
            }
            localStorage.setItem(name, input.value);
            config.current = name;
            localStorage.setItem('scene-config', JSON.stringify(config));
            */
        }

        /**
         * Load a selected file
         */
        async function load(event) {
            if (event?.shiftKey) {
                try {
                    const content = localStorage.getItem('current_source');
                    if (content) {
                        Core.source = content;
                    }
                } catch (err) {
                    error(err);
                }
            } else {
                const name = document.getElementById('filename').value;

                const response = await fetch(`${name}`);
                const content = await response.text();

                if (content) {
                    Core.source = content;
                    Core.addFile(name);

                    config.current = name;
                    localStorage.setItem('scene-config', JSON.stringify(config));
                    document.getElementById('filename').classList.add('existing-file');
                }
            }
        }

        let config = {
            files: [],
            current: 'New Scene',
            saveState: false,
        };

        const Core = {
            allNodes: [],
            structure: [],
            filenames: new Set(),
            singleFrame: false,
            frames: [],
            mainTrees: [],
            sceneGraphTrees: [],
            views: [],
            selectedNodes: new Set(),
            initialise() {
                this.mainEditor = new StructureEditor('Main');

                const toggle = document.getElementById('toggle-secondary-controls');
                toggle.addEventListener('click', (event) =>
                    document.getElementById('secondary-controls').classList.toggle('hide-left'));

                const toggleSidebar = document.getElementById('toggle-sidebar');
                toggleSidebar.addEventListener('click', (event) =>
                    document.querySelector('.sidebar').classList.toggle('hide-right'));

                const saveLayoutSelection = document.getElementById('save-layout');
                saveLayoutSelection.addEventListener('click', (event) => {
                    const layout = getLayout();
                    console.log(layout);
                    try {
                        localStorage.setItem('scene-graph-editor-layout', layout);
                    } catch (err) {
                        error(err);
                    }
                });
                //clearSelection.addEventListener('click', (event) => Core.currentNode = null);

                const hideMenu = document.getElementById('hide-menu');
                hideMenu.addEventListener('click', (event) =>
                    document.getElementById('secondary-controls').classList.add('hide-left'));

                const vsplit = document.getElementById('add-column');
                vsplit.addEventListener('click', (event) =>
                    this._frame ? this._frame.container.verticalSplit(this._frame) : undefined);

                const hsplit = document.getElementById('add-row');
                hsplit.addEventListener('click', (event) =>
                    this._frame ? this._frame.container.horizontalSplit(this._frame) : undefined);

                const saveCanvas = document.getElementById('save-png');
                saveCanvas.addEventListener('click', (event) => this._frame.content.savePNG = true);

                const tabbed = document.getElementById('toggle-tabbed-layout');
                tabbed.addEventListener('click', (event) => this.toggleSingleFrame());

                const close = document.getElementById('close-current-frame');
                close.addEventListener('click', (event) => this._frame ? this._frame.remove() : undefined);

                const addViewSelection = document.getElementById('add-view-selection');
                addViewSelection.innerHTML = `<option value="">Add View</option>`;

                const groups = Views.reduce((groups, view) => groups.add(view.group), new Set());
                const groupMap = {};
                Array.from(groups).sort().forEach((group) => {
                    const optGroup = document.createElement('optGroup');
                    optGroup.label = group;
                    addViewSelection.append(optGroup);
                    groupMap[group] = optGroup;
                });

                Views.forEach((view, index) => {
                    const option = document.createElement('option');
                    option.innerHTML = view.name;
                    option.value = index;
                    groupMap[view.group].append(option);
                    //addViewSelection.append(option);
                });
                const option = document.createElement('option');
                option.innerHTML = '<strong>All</strong>';
                option.value = 'all';
                addViewSelection.append(option);

                addViewSelection.addEventListener('change', (event) => {
                    if (addViewSelection.value === 'all') {
                        addAllViews();
                    } else if (addViewSelection.value !== '') {
                        uiControls.newSidebarFrame(new Views[addViewSelection.value].cls());
                    }
                    addViewSelection.value = '';
                });

                const viewTypeSelection = document.getElementById('view-type-selection');
                Views.forEach((view, index) => {
                    const option = document.createElement('option');
                    option.innerHTML = view.name;
                    option.value = index;
                    viewTypeSelection.append(option);
                });

                viewTypeSelection.addEventListener('change', (event) => {
                    const view = Views[viewTypeSelection.value].make();
                    if (this._frame.content) {
                        if (this._frame.content.remove) {
                            this._frame.content.remove();
                        }
                        this._frame.content.node.replaceWith(view.node);
                    } else {
                        this._frame.node.append(view.node);
                    }
                    this._frame.content = view;
                });

                const settings = document.getElementById('view-settings');
                settings.addEventListener('click', (event) =>
                    this?._frame?.querySelector('.settings')?.classList.toggle('hide-up'));
            },
            addFile(name) {
                if (!Core.filenames.has(name)) {
                    Core.filenames.add(name);
                    localStorage.setItem('tree-data-files', JSON.stringify(Array.from(Core.filenames)));
                    const option = document.createElement('option');
                    option.innerHTML = name;
                    document.getElementById('files').append(option);
                }
            },
            process() {
                this.allNodes = [];
                const views = new Set();
                const flatten = (node) => {
                    try {
                        Object.keys(node[symbols.views]).forEach((key) => views.add(key));
                    } catch (err) {
                        error(node);
                        error(node[symbols.views]);
                    }
                    this.allNodes.push(node);
                    node[symbols.content].forEach((node) => flatten(node));
                }

                this.structure.forEach((node) => flatten(node));
                this.contexts = Array.from(views);
                this.views.forEach((view) => view.contexts = this.contexts);
            },
            find(test) {
                return this.allNodes.find(test);
            },
            select(rules) {
                const nodes = rules.startsWith('*') ? this.allNodes : this.structure;
                rules = rules.replace(/^\*/, '');
                rules = rules.split(/,/).flatMap((rule) => {
                    const match = rule.match(/(?<name>[^=><]+)(?<test>[=\/><])(?<values>.*)/);
                    if (!match) {
                        let parent = this.structure.find((node) => node.name === rule);
                        if (parent) {
                            return (node) => node[symbols.container] === parent;
                        }
                        parent = this.allNodes.find((node) => node.name === rule);
                        if (parent) {
                            return (node) => node[symbols.container] === parent;
                        }
                        return [];
                    }
                    const name = match.groups.name;
                    const test = match.groups.test;
                    const values = match.groups.values.split(',').map((v) => numberOrString(v));
                    switch (test) {
                        case '=':
                            return (node) => values.includes(node[name]);
                        case '/':
                            const patterns = values.map((value) => new RegExp(value));
                            return (node) => patterns.some((pattern) => pattern.test(node[name]));
                        case '<':
                            return (node) => values.some((value) => value > node[name]);
                        case '>':
                            return (node) => values.some((value) => value < node[name]);
                    }
                    return [];
                });
                return nodes.filter((node) => rules.some((rule) => rule(node)));
            },
            get source() {
                return this._source;
            },
            set source(content) {
                this._source = content;
                this.views.forEach((view) => view.source = content);
                this.parse();
            },
            parse() {
                const name = this?.currentNode?.name;
                this.sourceStructure = getStructure(this.source);
                this.structure = expand(this.sourceStructure, valueParser);
                this.process();
                this.views.forEach((view) => view.structure = this.structure);
                if (name) {
                    const current = this.allNodes.find((node) => node.name === name);
                    if (current) {
                        this.currentNode = current;
                    }
                }
            },
            get currentNode() {
                return this._currentNode;
            },
            set currentNode(node) {
                this._currentNode = node;
                this.views.forEach((view) => view.currentNode = node);
            },
            selectionToggle(node) {
                if (this.selectedNodes.has(node)) {
                    this.selectedNodes.delete(node);
                } else {
                    this.selectedNodes.add(node);
                }
                const selection = Array.from(this.selectedNodes);
                this.views.forEach((view) => view.selectedNodes = selection);
            },
            addFrame(frame) {
                const option = document.createElement('option');
                option.innerText = frame.content.title;
                option.value = this.frames.length;
                this.viewSelection.append(option);
                this.frames.push(frame);
                this.currentFrame = frame;
            },
            removeFrame(frame) {
                const index = this.frames.indexOf(frame);
                this.viewSelection.querySelector(`:nth-child(${index})`).remove();
                this.frames = this.frames.filter((existing) => existing !== frame);
            },
            toggleSingleFrame() {
                this.singleFrame = !this.singleFrame;
                const layout = document.querySelector('.layout');
                if (this.singleFrame) {
                    this.referenceNode = this._frame.node.nextSibling;
                    this.frames.forEach((frame) => frame.node.classList.add('hidden'));
                    for (const node of document.querySelectorAll('.vertical-bar')) {
                        node.classList.add('hidden');
                    }
                    for (const node of document.querySelectorAll('.horizontal-bar')) {
                        node.classList.add('hidden');
                    }
                    this._frame.node.classList.remove('hidden');
                    layout.append(this._frame.node);
                    layout.querySelector('.root-frame').classList.add('hidden');
                } else {
                    this.frames.forEach((frame) => frame.node.classList.remove('hidden'));
                    for (const node of document.querySelectorAll('.vertical-bar')) {
                        node.classList.remove('hidden');
                    }
                    for (const node of document.querySelectorAll('.horizontal-bar')) {
                        node.classList.remove('hidden');
                    }
                    this._frame.container.node.insertBefore(this._frame.node, this.referenceNode);
                    layout.querySelector('.root-frame').classList.remove('hidden');
                }
            },
            get currentFrame() {
                return this._frame;
            },
            set currentFrame(frame) {
                if (this._frame !== frame) {
                    for (const node of document.querySelectorAll('.selected-frame')) {
                        node.classList.remove('selected-frame');
                    }
                    if (this.singleFrame) {
                        this.frames.forEach((frame) => frame.classList.add('hidden'));
                        // put previous frame back
                        this._frame.parentElement.insertBefore(this._frame, this.referenceNode);
                        // Update reference
                        this.referenceNode = frame.nextSibling;
                        const layout = document.querySelector('.layout');
                        layout.append(frame);
                    }
                    this._frame = frame;

                    frame.classList.remove('hidden');
                    frame.classList.add('selected-frame');
                    if (frame.firstChild && frame.firstChild.focus) {
                        frame.firstChild.focus();
                    }
                    const saveCanvas = document.getElementById('save-png');
                    saveCanvas.disabled = frame?.firstChild?.canvas === undefined;
                }
            }
        }

        /**
         *
         */
        function main() {
            Core.initialise();

            const hash = window.location.hash.slice(1);
            if (hash) {
                const option = document.createElement('option');
                option.innerText = hash;
                document.getElementById('files').append(option);
            }

            let definition;
            try {
                definition = localStorage.getItem('scene-graph-editor-layout');
            } catch (err) {
                error(err);
            }
            definition = definition || `row;0.75,0.25
  column;0.5,0.5
    view;StructureEditor;title=Main
    view;TreeTableView;title=Table View
  column;0.5,0.5
    view;GLView;title=3D Scene
    view;DetailView;title=Detail View`;
            restoreLayout(definition);

            document.body.addEventListener('mousemove', (event) => {
                if (actions.mouseMove) {
                    actions.mouseMove(event);
                }
            });
            document.body.addEventListener('mouseup', (event) => {
                if (actions.mouseUp) {
                    actions.mouseUp(event);
                }
            });

            document.body.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (actions.touchMove) {
                    actions.touchMove(event);
                }
            });
            document.body.addEventListener('touchend', (event) => {
                if (actions.touchEnd) {
                    actions.touchEnd(event);
                }
            });
            addElementDrag(document.getElementById('overlay'));

            const saveButton = document.getElementById('save');
            saveButton.addEventListener('click', save);

            const loadButton = document.getElementById('load');
            loadButton.addEventListener('click', load);

            const filename = document.getElementById('filename');
            filename.value =
                filename.addEventListener('input', (event) => {
                    save.disabled = !filename.value;
                    if (config.files.includes(filename.value)) {
                        filename.classList.add('existing-file');
                    } else {
                        filename.classList.remove('existing-file');
                    }
                });
            filename.addEventListener('change', load);
            const fullscreen = document.getElementById('fullscreen');
            fullscreen.addEventListener('click', toggleFullscreen);

            const exportButton = document.getElementById('export-frame');
            exportButton.addEventListener('click', exportFrame);

            let savedShaders;
            try {
                savedShaders = localStorage.getItem('shaders');
            } catch (err) {
                error(err.toString());
                report(err.toString());
            }

            const shaders = savedShaders ? JSON.parse(savedShaders) : defaultShaders;

            let configStr;
            try {
                configStr = localStorage.getItem('scene-config');
            } catch (err) {
                error(err.toString());
                report(err.toString());
            }

            if (configStr) {
                config = JSON.parse(configStr);
                config.files.forEach((name) => {
                    const option = document.createElement('option');
                    option.innerText = name;
                    document.getElementById('files').append(option);
                });
            }

            const filesJSON = localStorage.getItem('tree-data-files');
            if (filesJSON) {
                const files = JSON.parse(filesJSON);
                files.forEach((file) => Core.addFile(file));
            }

            document.getElementById('filename').value = hash || config.current;

            if (hash) {
                load();
            } else {
                load({ shiftKey: true });
            }

            const shaderObjectList = document.getElementById('shader-object-list');
            shaderObjectList.innerHTML = '';
            shaderObjects.forEach((shader) => {
                const node = document.createElement('option');
                shaderObjectList.appendChild(node);
                node.innerHTML = shader.title || shader.name;
                node.value = shader.name;
            });
            const shaderProgramList = document.getElementById('shader-program-list');
            shaderProgramList.innerHTML = '';
            defaultShaders.forEach((shader) => {
                const node = document.createElement('option');
                shaderProgramList.appendChild(node);
                node.innerHTML = shader.name;
            });

            render();
        }

        /**
         * Return a matrix representing a rotation
         */
        function getRotationMatrix(angle, axis) {
            angle *= Math.PI / 180;
            axis = normalise(axis);

            const a = Math.cos(angle / 2);
            const b = Math.sin(angle / 2) * axis[0];
            const c = Math.sin(angle / 2) * axis[1];
            const d = Math.sin(angle / 2) * axis[2];

            return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
            2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
            2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                0, 0, 0, a * a + b * b + c * c + d * d];
        }

        /**
         * Quaternion constructor
         *
         * @param {*} w
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Quaternion {
            constructor(w, x, y, z) {
                this.w = w === undefined ? 1 : w;
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
            }
            clone() {
                return new Quaternion(this.w, this.x, this.y, this.z);
            }
            static create(w, x, y, z) {
                var v;
                if (w instanceof Vector3d && x == undefined) {
                    return new Quaternion(0, w.x, w.y, w.z);
                } else if (w instanceof Vector3d) {
                    return Quaternion.createRotation(w, x);
                } else if (w && Array.isArray(w) && w.length === 4) {
                    return new Quaternion(w[0], w[1], w[2], w[3])
                } else if (w && w.w !== undefined) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else if (x instanceof Vector3d) {
                    return Quaternion.createRotation(x, w);
                } else if (w instanceof Quaternion) {
                    return new Quaternion(w.w, w.x, w.y, w.z);
                } else {
                    return new Quaternion(w === undefined ? 1 : w, x || 0, y || 0, z || 0);
                }
            }
            static createFromObject(obj) {
                return new Quaternion(obj.w, obj.x, obj.y, obj.z);
            }
            static createRotation(axis, angle) {
                const v = axis.normal();
                return new Quaternion(
                    Math.cos(angle / 2),
                    Math.sin(angle / 2) * v.x,
                    Math.sin(angle / 2) * v.y,
                    Math.sin(angle / 2) * v.z);
            }
            get length() {
                return Math.hypot(this.w, this.x, this.y, this.z);
            }

            get values() {
                return [this.w, this.x, this.y, this.z];

            }
            get inverse() {
                return this.conjugate();
            }
            get s() {
                return this.w;
            }
            get v() {
                return new Vector3d(this.x, this.y, this.z);
            }
            invert() {
                this.x *= -1;
                this.y *= -1;
                this.z *= -1;
                return this;
            }
            conjugate() {
                return new Quaternion(this.w, -this.x, -this.y, -this.z);
            }
            apply(v) {
                var vp = this.multiply(new Quaternion(0, v.x, v.y, v.z)).multiply(this.conjugate());
                return new Vector3d(vp.x, vp.y, vp.z);
            }
            rotate(other, angle) {
                if (angle !== undefined) {
                    other = Quaternion.createRotation(other, angle);
                }
                const s = this.s * other.s - this.v.dot(other.v);
                const v = other.v.scaled(this.s).add(this.v.scaled(other.s)).add(this.v.crossProduct(other.v));
                this.w = s;
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return;
            }
            scale(value) {
                this.w *= value;
                this.x *= value;
                this.y *= value;
                this.z *= value;
                return this;
            }
            scaled(value) {
                const result = this.clone();
                return result.scale(value);
            }
            multiply(other) {
                return new Quaternion(
                    this.w * other.w - this.x * other.x - this.y * other.y - this.z * other.z,// 1
                    this.w * other.x + this.x * other.w + this.y * other.z - this.z * other.y,// i
                    this.w * other.y - this.x * other.z + this.y * other.w + this.z * other.x,// j
                    this.w * other.z + this.x * other.y - this.y * other.x + this.z * other.w // k
                );
            }
            dot(other) {
                return this.w * other.w + this.x * other.x + this.y * other.y + this.z * other.z;
            }
            getMatrix() {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                return [a * a + b * b - c * c - d * d, 2 * (b * c - a * d), 2 * (b * d + a * c), 0,
                2 * (b * c + a * d), a * a - b * b + c * c - d * d, 2 * (c * d - a * b), 0,
                2 * (b * d - a * c), 2 * (c * d + a * b), a * a - b * b - c * c + d * d, 0,
                    0, 0, 0, a * a + b * b + c * c + d * d];
            }
            setMatrix(matrix) {
                const a = this.w;
                const b = this.x;
                const c = this.y;
                const d = this.z;

                matrix[0] = a * a + b * b - c * c - d * d;
                matrix[1] = 2 * (b * c - a * d);
                matrix[2] = 2 * (b * d + a * c);
                matrix[3] = 0;
                matrix[4] = 2 * (b * c + a * d);
                matrix[5] = a * a - b * b + c * c - d * d;
                matrix[6] = 2 * (c * d - a * b);
                matrix[7] = 0;
                matrix[8] = 2 * (b * d - a * c);
                matrix[9] = 2 * (c * d + a * b);
                matrix[10] = a * a - b * b - c * c + d * d;
                matrix[11] = 0;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = 0;
                matrix[15] = a * a + b * b + c * c + d * d;
            }
        }


        /**
         * Vector3d constructor
         *
         * @param {*} x
         * @param {*} y
         * @param {*} z
         */
        class Vector3d {
            constructor(x, y, z) {
                this.x = x || 0
                this.y = y || 0
                this.z = z || 0
            }
            static create(x, y, z) {
                if (x instanceof Vector3d) {
                    return x.clone();
                } else if (x && Array.isArray(x) && x.length === 3) {
                    return new Vector3d(x[0], x[1], x[2]);
                } else if (x && x.x !== undefined) {
                    return new Vector3d(x.x, x.y, x.z);
                }
                return new Vector3d(x, y, z);
            }
            clone() {
                return new Vector3d(this.x, this.y, this.z);
            }
            static createFromObject(obj) {
                return new Vector3d(obj.x, obj.y, obj.z);
            }
            get length() {
                return Math.hypot(this.x, this.y, this.z);
            }
            get array() {
                return [this.x, this.y, this.z, 0];
            }
            get array3() {
                return [this.x, this.y, this.z];
            }
            dotProduct(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            crossProduct(other) {
                return new Vector3d(this.y * other.z - this.z * other.y,
                    this.z * other.x - this.x * other.z,
                    this.x * other.y - this.y * other.x);
            }
            cross(other) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                this.x = y * other.z - z * other.y;
                this.y = z * other.x - x * other.z;
                this.z = x * other.y - y * other.x;
                return this;
            }
            normalise() {
                var n = this.length || 1;
                this.x /= n;
                this.y /= n;
                this.z /= n;
                return this;
            }
            normal() {
                var result = this.clone();
                return result.normalise()
            }
            scale(value) {
                this.x *= value
                this.y *= value
                this.z *= value
                return this
            }
            scaled(value) {
                var result = this.clone();
                return result.scale(value);
            }
            add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                return this;
            }
            subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                return this;
            }
            plus(other) {
                var result = this.clone();
                return result.add(other);
            }
            minus(other) {
                var result = this.clone();
                return result.subtract(other);
            }
            rotate(q, angle) {
                if (angle) {
                    q = Quaternion.createRotation(q, angle);
                }

                let s = q.w;
                let u = new Vector3d(q.x, q.y, q.z);
                let v = this.clone();

                this.cross(u).scale(2 * s)
                    .add(v.scaled(s * s - u.dot(u))).add(u.scaled(2 * v.dot(u)));
                return this;
            }
            transform(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];

                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            transform2(matrix) {
                const x = matrix[0] * this.x + matrix[4] * this.y + matrix[8] * this.z + matrix[12];
                const y = matrix[1] * this.x + matrix[5] * this.y + matrix[9] * this.z + matrix[13];
                const z = matrix[2] * this.x + matrix[6] * this.y + matrix[10] * this.z + matrix[14];
                const w = matrix[3] * this.x + matrix[7] * this.y + matrix[11] * this.z + matrix[15];

                this.x = x / w;
                this.y = y / w;
                this.z = z / w;
                return this;
            }
            getProjection(rd) {
                if (rd === this.z) {
                    return { x: 0, y: 0 }
                } else {
                    return {
                        x: this.x / (1 + -this.z / rd),
                        y: -this.y / (1 + -this.z / rd)
                    }
                }
            }
        }

        /**
         *
         */
        const mat4 = {
            create: function () {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]
            },
            perspective: function (matrix, fieldOfView, aspect, zNear, zFar) {
                var f = 1 / Math.tan(fieldOfView * Math.PI / 360);
                matrix[0] = f / aspect;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 0;
                matrix[4] = 0;
                matrix[5] = f;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = 0;
                matrix[9] = 0;
                matrix[10] = (zFar + zNear) / (zNear - zFar)
                matrix[11] = -1;
                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = (2 * zFar * zNear) / (zNear - zFar);
                matrix[15] = 1;
            },
            translate: function (input, output, change) {
                var m = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    change[0], change[1], change[2], 1
                ]
                this.multiply(input, m, output);
            },
            copy: function (input, output) {
                output[0] = input[0];
                output[1] = input[1];
                output[2] = input[2];
                output[3] = input[3];
                output[4] = input[4];
                output[5] = input[5];
                output[6] = input[6];
                output[7] = input[7];
                output[8] = input[8];
                output[9] = input[9];
                output[10] = input[10];
                output[11] = input[11];
                output[12] = input[12];
                output[13] = input[13];
                output[14] = input[14];
                output[15] = input[15];
            },
            rotate2d: function (input, output, angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                var m = [
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                ]
                var t = this.create();
                this.multiply(input, m, t);
                this.copy(t, output);
            },
            rotate: function (input, output, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                this.multiply(input, q.getMatrix(), output);
            },
            rotated: function (input, axis, angleInRadians) {
                var q = Quaternion.createRotation(axis, angleInRadians);
                return matrixMultiply(input, q.getMatrix());
            },
            multiply: function (a, b, out) {
                var result = this.create();
                result[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
                result[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
                result[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
                result[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

                result[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
                result[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
                result[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
                result[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

                result[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
                result[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
                result[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
                result[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

                result[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
                result[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
                result[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
                result[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
                this.copy(result, out);
            },
            transpose: function (input, output) {
                var temp = this.create();
                this.copy(input, temp);
                output[1] = temp[4];
                output[2] = temp[8];
                output[3] = temp[12];
                output[4] = temp[2];
                output[6] = temp[9];
                output[7] = temp[13];
                output[8] = temp[2];
                output[9] = temp[6];
                output[11] = temp[14];
                output[12] = temp[3];
                output[13] = temp[7];
                output[14] = temp[11];
            },
            invert: function (input, output) {
                var x0 = input[0];
                var x1 = input[4];
                var x2 = input[8];
                var x3 = input[12];
                var x4 = input[1];
                var x5 = input[5];
                var x6 = input[9];
                var x7 = input[13];
                var x8 = input[2];
                var x9 = input[6];
                var x10 = input[10];
                var x11 = input[14];
                var x12 = input[3];
                var x13 = input[7];
                var x14 = input[11];
                var x15 = input[15];

                var a0 = x0 * x5 - x1 * x4;
                var a1 = x0 * x6 - x2 * x4;
                var a2 = x0 * x7 - x3 * x4;
                var a3 = x1 * x6 - x2 * x5;
                var a4 = x1 * x7 - x3 * x5;
                var a5 = x2 * x7 - x3 * x6;
                var b0 = x8 * x13 - x9 * x12;
                var b1 = x8 * x14 - x10 * x12;
                var b2 = x8 * x15 - x11 * x12;
                var b3 = x9 * x14 - x10 * x13;
                var b4 = x9 * x15 - x11 * x13;
                var b5 = x10 * x15 - x11 * x14;
                var invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

                output[0] = (+x5 * b5 - x6 * b4 + x7 * b3) * invdet;
                output[4] = (-x1 * b5 + x2 * b4 - x3 * b3) * invdet;
                output[8] = (+x13 * a5 - x14 * a4 + x15 * a3) * invdet;
                output[12] = (-x9 * a5 + x10 * a4 - x11 * a3) * invdet;
                output[1] = (-x4 * b5 + x6 * b2 - x7 * b1) * invdet;
                output[5] = (+x0 * b5 - x2 * b2 + x3 * b1) * invdet;
                output[9] = (-x12 * a5 + x14 * a2 - x15 * a1) * invdet;
                output[13] = (+x8 * a5 - x10 * a2 + x11 * a1) * invdet;
                output[2] = (+x4 * b4 - x5 * b2 + x7 * b0) * invdet;
                output[6] = (-x0 * b4 + x1 * b2 - x3 * b0) * invdet;
                output[10] = (+x12 * a4 - x13 * a2 + x15 * a0) * invdet;
                output[14] = (-x8 * a4 + x9 * a2 - x11 * a0) * invdet;
                output[3] = (-x4 * b3 + x5 * b1 - x6 * b0) * invdet;
                output[7] = (+x0 * b3 - x1 * b1 + x2 * b0) * invdet;
                output[11] = (-x12 * a3 + x13 * a1 - x14 * a0) * invdet;
                output[15] = (+x8 * a3 - x9 * a1 + x10 * a0) * invdet;

                return this;
            }
        }

        /**
         * Return the point of intersection of a line and plane, if line parallel to plane return undefined
         * @param {*} line 
         * @param {*} plane 
         */
        function linePlaneIntersection(line, plane) {
            var dv = plane.point.minus(line.point);
            var product = line.direction.dotProduct(plane.normal);
            if (product !== 0) {
                return line.direction.scaled(dv.dotProduct(plane.normal) / product).add(line.point);
            }
        }


        /**
         * Vector definition of a line
         */
        function Line(point, direction) {
            this.point = point.clone();
            this.direction = direction.clone();
        }

        /**
         *
         */
        Line.prototype = {
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t)
                return v.add(this.point)
            },
            intersection(other) {
                if (other instanceof Plane) {
                    return linePlaneIntersection(this, other)
                } else {
                    return this.lineIntersection(other)
                }
            },
            planeIntersection(plane) {
                const v = this.direction.clone();
                const dv = plane.point.minus(this.point);
                const div = v.dot(plane.normal);
                if (div) {
                    var a = dv.dot(plane.normal) / div;
                    return v.scale(a).add(this.point);
                }
            },
            lineIntersection(line) {
                if ((this.direction.x * line.direction.y - this.direction.y * line.direction.x) !== 0) {
                    var s = (this.direction.x * (line.point.y - this.point.y) + this.direction.y * (line.point.x - this.point.x))
                        / (this.direction.x * line.direction.y - this.direction.y * line.direction.x)
                } else {
                    var s = (this.direction.z * (line.point.y - this.point.y) + this.direction.y * (line.point.z - this.point.z))
                        / (this.direction.z * line.direction.y - this.direction.y * line.direction.z)
                }
                return line.point.plus(this.direction.scaled(s));
            }
        }


        /**
         * Definition of a segment
         */
        class Segment {
            constructor(start, end) {
                this.start = start.clone();
                this.end = end.clone();
            }

            get direction() {
                return (this.end.minus(this.start)).normalise();
            }
            set direction(direction) {
                this.end = this.start.plus(direction);
            }
            getPosition(t) {
                var v = this.direction.clone();
                v.scale(t);
                return v.add(this.start);
            }
        }

        /**
         * Vector definition of a plane
         */
        function Plane(point, normal) {
            this.point = point.clone();
            this.normal = normal.clone();
            this.normal.normalise();
            this.bounds = [];
        }

        /**
         *
         */
        Plane.prototype = {
            intersection(other) {
                if (other instanceof Plane) {
                    return this.planeIntersection(other)
                } else {
                    return linePlaneIntersection(other, this)
                }
            },
            planeIntersection(plane) {
                var d = this.normal.crossProduct(plane.normal)
                var v = d.crossProduct(this.normal)
                if (v.length === 0) {
                    return
                }
                var dv = plane.point.minus(this.point)
                var a = (dv.x * plane.normal.x + dv.y * plane.normal.y + dv.z * plane.normal.z) / (v.x * plane.normal.x + v.y * plane.normal.y + v.z * plane.normal.z)
                var p = v.scale(a).add(this.point)
                return new Line(p, d)
            },
            addBoundary(other) {
                this.bounds.push(other)
                other.bounds.push(this)
            },
            getBoundary() {
                var line = this.intersection(this.bounds[this.bounds.length - 1])
                var segments = []
                this.bounds.forEach(function (bound, index, all) {
                    var point = line.intersection(bound)
                    var segment = new Segment(point, point)
                    if (segments.length > 0) {
                        segments[segments.length - 1].end = point
                    }
                    segments.push(segment)
                    line = this.intersection(bound)
                }, this)
                segments[segments.length - 1].end = segments[0].start

                return segments
            }
        }

        /**
         *
         */
        class Triangle {
            constructor(p1, p2, p3) {
                this.p1 = Vector3d.create(p1);
                this.p2 = Vector3d.create(p2);
                this.p3 = Vector3d.create(p3);
            }
            get plane() {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                return new Plane(this.p1, n);
            }
            intersects(line) {
                const d1 = this.p2.minus(this.p1);
                const d2 = this.p3.minus(this.p1);
                const n = d1.crossProduct(d2);
                const p = line.planeIntersection(new Plane(this.p1, n));
                if (p) {
                    const dt = (d1.x * d2.y - d2.x * d1.y);
                    if (dt !== 0 && d1.x !== 0) {
                        const t = (d1.x * (p.y - d1.y) + d1.y * (d1.x - p.x)) / dt;
                        const s = (p.x - t * d2.x - this.p1.x) / d1.x;
                        return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                    } else {
                        const dt = (d1.y * d2.z - d2.y * d1.z);
                        if (dt !== 0 && d1.y !== 0) {
                            const t = (d1.y * (p.z - d1.z) + d1.z * (d1.y - p.y)) / dt;
                            const s = (p.y - t * d2.y - this.p1.y) / d1.y;
                            return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                        } else {
                            const dt = (d1.z * d2.x - d2.z * d1.x);
                            if (dt !== 0 && d1.z !== 0) {
                                const t = (d1.z * (p.x - d1.x) + d1.x * (d1.z - p.z)) / dt;
                                const s = (p.z - t * d2.z - this.p1.z) / d1.z;
                                return ((s > 0) && (t > 0) && (s + t) <= 1 ? p : false);
                            }
                        }
                    }
                }
                return false;
            }
        }
    </script>
</body>
</html>
