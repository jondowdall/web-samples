<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Process</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
            font-size: 10pt;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            width: 100dvw;
            height: 100dvh;
            overflow: hidden;
            display: grid;
            grid-template-columns: max-content 1fr;
        }

        table,
        th,
        td {
            border-collapse: collapse;
            border: 1px solid gray;
        }

        th,
        td {
            padding: 2px 5px;
        }

        #side-bar {
            background-color: lightblue;
        }

        /*
        #product-list {
            background-color: lightblue;
        }
*/
        #command-input {
            position: fixed;
            top: 1em;
            left: 50%;
            transform: translateX(-50%);
            min-width: 20em;
            padding: 0.2em 0.5em;
            outline: none;
            border: 1px solid gray;
            border-radius: 1em;
            background: white;
            box-shadow: 2px 3px 5px #333;
        }


        #process-view {
            width: 100%;
            height: 100%;
        }

        #state {
            position: fixed;
            bottom: 1em;
            right: 1em;
            width: 30vw;
            height: 20vh;
            background-color: lightgray;
            border-radius: 0.5em;
            padding: 0.5em;
            border: 2px inset white;
            display: grid;
            grid-template-rows: 1fr max-content;
            overflow: hidden;
        }

        #output {
            overflow: auto;
        }

        #selection-window {
            position: fixed;
            display: flex;
            flex-direction: column;
            top: 3em;
            right: 1em;
            width: 30vw;
            height: 20vh;
            color: antiquewhite;
            background-color: rgb(30, 30, 30, 0.8);
            border-radius: 0.5em;
            /*padding: 0.5em;*/
            border: 2px inset white;
        }

        #selection {
            background-color: rgb(150, 150, 150, 0.9);
            width: 100%;
            height: 100%;
        }

        #bin {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            font-size: 400%;
        }

        .window>h2 {
            padding: 0.5em;
            margin: 0;
        }

        .selected {
            stroke: yellow;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }

        .running {
            stroke-dasharray: 4 4;
            stroke-dashoffset: 8;
            animation: drawPath 1s infinite;
            /* Apply the animation */
        }

        @keyframes drawPath {
            to {
                stroke-dashoffset: 0;
                /* Animate to show the path */
            }
        }
    </style>
</head>

<body>
    <div id="side-bar">
        <h3>Products:</h3>
        <div id="product-list"></div>
        <h3>Assets:</h3>
        <div id="asset-list"></div>
    </div>
    <svg id="process-view"></svg>

    <div id="selection-window" class="window">
        <h2>Selection</h2>
        <div id="selection">

        </div>
    </div>

    <div id="state">
        <div id="output">Hello<br></div>
        <div id="status"></div>
    </div>

    <datalist id="command-list"></datalist>
    <input id="command-input" type="text" list="command-list" autocorrect="off" autocapitalize="off" />

    <div id="bin">&#128465;</div>

    <script>
        /**
         * SVGView component
         */
        class SVGView {
            static ns = 'http://www.w3.org/2000/svg';
            static namedArributes = Symbol('named attributes');
            constructor(id, title) {
                this.svg = document.getElementById(id);
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
                //this.svg.setAttribute("viewBox", "0 0 2000 2000");
                this.title = title || 'SVG Diagram';
                this.map = new Map();
            }
            get width() {
                return this.svg.clientWidth;
            }
            get height() {
                return this.svg.clientHeight;
            }
            make(type, attributes, content, classes) {
                const element = document.createElementNS(SVGView.ns, type);
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);
                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                if (content) {
                    element.append(content);
                }
                if (classes) {
                    element.classList.add(...classes)
                }
                return element;
            }
            add(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.appendChild(element);
                return element;
            }
            addUnder(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.insertBefore(element, parent.firstElementChild);
                return element;
            }
            updateElement(element, attributes) {
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);

                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                return element
            }
            remove(item) {
                const representation = this.map.get(item);
                Object.values(representation.nodes).forEach((node) => node.remove());
                this.map.delete(item);
            }
        }
    </script>

    <script>
        /**
         * Generate a V4 UUID
         */
        function uuidv4() {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }
    </script>


    <script>
        // States
        const ready = Symbol('ready');
        const waiting = Symbol('waiting');
        const running = Symbol('running');
        const blocked = Symbol('blocked');
        const paused = Symbol('paused');

        // Activity mode
        const asap = Symbol('asap');
        const onDemand = Symbol('on demand');

        // Simulation mode
        const byTime = Symbol('by time');
        const byEvent = Symbol('by event');


        // Ensure parent links aren't serialised by using a symbol
        const parent = Symbol('parent');
        const id = Symbol('id');

        /**
         * Evaluate a string to the canonical representation.
         */
        function resolve(str) {
            try {
                const func = new Function(`return ${str};`);
                return func();
            } catch (error) {
                appendLine(error.message);
            }
            return str;
        }

        /**
         * Parse the parameters of a command
         */
        function parseParameters(str) {
            let state;
            const parameters = [];
            let parameter = [];
            const states = {
                plainParameter: {
                    parse(char) {
                        if ([' ', '\t'].includes(char)) {
                            return states.whiteSpace;
                        } else {
                            parameter.push(char);
                        }
                        return this;
                    }
                },
                whiteSpace: {
                    parse(char) {
                        if (char === '"') {
                            parameter = [];
                            parameters.push(parameter);
                            return states.quotedParameter;
                        }
                        if (![' ', '\t'].includes(char)) {
                            parameter = [char];
                            parameters.push(parameter);
                            return states.plainParameter;
                        }
                        return this;
                    }
                },
                quotedParameter: {
                    parse(char) {
                        if (char === '"') {
                            return states.whiteSpace;
                        }
                        parameter.push(char);
                        return this;
                    }
                }
            }
            state = states.whiteSpace;
            for (let i = 0; i < str.length; ++i) {
                state = state.parse(str[i]);
            }
            return parameters.map((chars) => chars.join(''));
        }


        /**
         * An instance of a product.
         */
        class Asset {
            static all = new Set();
            static create(attributes) {
                const asset = new Asset(attributes.product, attributes.location);
                asset[id] = attributes.id;
                return asset;
            }
            constructor(product, location) {
                this[id] = uuidv4();
                this.product = product;
                this.product.instances?.add(this);
                if (location && location.content) {
                    this.move(location);
                }
                this.content = new Set();
                Asset.all.add(this);
                this.serialNumber = Asset.all.size; //...Asset.all].filter((asset) => asset.product === product).length;
            }
            delete() {
                if (this.location) {
                    this.location.content.delete(this);
                }
                Asset.all.delete(this);
            }
            get name() {
                return `${this.product.name}/${this.serialNumber}`;
            }
            move(destination) {
                if (this.location) {
                    this.location.content.delete(this);
                }
                destination.content.add?.(this);
                this.location = destination;
            }
        }

        class Product {
            static all = [];
            static create(attributes) {
                if (attributes.name === undefined) {
                    let index = 1;
                    while (Product.all.find((item) => item.id === `Product ${index}`)) {
                        index += 1;
                    }
                    attributes.name = `Product ${index}`;
                }

                const product = new Product(attributes.name);
                product[id] = attributes.id;
                return product;
            }
            static get(name) {
                return Product.all.find((existing) => existing.name === name) || new Product(name);
            }
            constructor(name) {
                this.name = name;
                this[id] = uuidv4();
                this.instances = new Set();
                Product.all.push(this);
            }
        }

        class Source {
            static create(attributes) {
                const source = new Source();
                //attributes.content.forEach((asset) => asset.move(source));
                source[id] = attributes.id;
                return source;
            }
            constructor() {
                this.links = [];
                this.content = new Set();
                this[id] = uuidv4();
                this.name = 'Source';
            }
            get available() {
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
            get(quantity = 1) {
                quantity = Math.min(quantity, this.content.length);
                return this.content.splice(0, quantity);
            }
            validate() {
                for (const asset of this.content) {
                    if (asset.location !== this) {
                        appendLine(`Warning: location mismatch`);
                        this.content.delete(asset);
                    }
                }
            }
        }

        class Store {
            static create(attributes) {
                const store = new store();
                store[id] = attributes.id;
                return store;
            }
            constructor(name, parent, capacity = Infinity) {
                this.links = [];
                this.content = new Set();
                this[id] = uuidv4();
                this.name = name || 'Store';
                this.parent = parent || app.model;
            }
            delete() {
                for (const asset of this.content) {
                    asset.delete();
                }
                this.parent.delete(this);
            }
            get available() {
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
            get(quantity = 1) {
                quantity = Math.min(quantity, this.content.length);
                return this.content.splice(0, quantity);
            }
            validate() {
                for (const asset of this.content) {
                    if (asset.location !== this) {
                        appendLine(`Warning: location mismatch`);
                        this.content.delete(asset);
                    }
                }
            }
        }

        class Port {
            static create(attributes) {
                const port = new Port(attributes.name, attributes.capacity, attributes.content);
                port[id] = attributes.id;
                return port;
            }
            constructor(product, capacity = 1, content = [], uuid) {
                this.product = product;
                this.capacity = capacity;
                this.content = new Set();
                this.links = [];
                this[id] = uuid || uuidv4();
            }
            store(item) {
                if (item.type !== this.product) {
                    appendLine(`Warning: Failed to store ${item.name} - item is not required type ${this.product.name}`);
                    return;
                }
                if (this.content.length >= this.capacity) {
                    appendLine(`Warning: Failed to storing ${item.name} - port is full`);
                    return;
                }
                this.content.add(item);
            }
        }

        class Input extends Port {
            static all = [];
            static create(attributes) {
                const input = new Input(attributes.product, attributes.capacity, attributes.content, attributes.required, attributes.id);
                input.links = attributes.links;
                return input;
            }
            constructor(product, capacity = 0, content = [], required = 1, uuid) {
                super(product, capacity, content, uuid);
                this.required = required;
                Input.all.push(this);
            }
            delete() {
                [...this.content].forEach((asset) => asset.move(app.model.store));
                this.links.forEach((link) => link.deleteTo());
                app.selected.delete(this);
                view.remove(this);
            }
            get name() {
                return `Input of ${this.parent}`;
            }
            get available() {
                if (this.links) {
                    const available = this.links.reduce((list, link) => list.concat(link.available), []);
                    return [...this.content].map((asset) => ({ asset, from: this })).concat(available);
                }
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
        }

        class Output extends Port {
            static all = [];
            static create(attributes) {
                const output = new Output(attributes.product, attributes.duration, attributes.capacity, attributes.content, attributes.id);
                return output;
            }
            constructor(product, duration = 5000, capacity = 1, content = [], uuid) {
                super(product, capacity, content, uuid);
                this.duration = duration;
                Output.all.push(this);
            }
            delete() {
                [...this.content].forEach((asset) => asset.move(app.model.store));
                this.lines.forEach((link) => link.deleteFrom());
                app.selected.delete(this);
                view.remove(this);
            }
            get name() {
                return `Output of ${this.parent}`;
            }
            get available() {
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
        }

        class Process {
            static create(attributes) {
                const process = new Process(attributes.name);
                process.inputs = new Map(attributes.inputs);
                process.outputs = new Map(attributes.outputs);
                process[id] = attributes.id;
                return process;
            }
            constructor(name) {
                this.name = name;
                this[id] = uuidv4();
            }
        }

        class Activity {
            static all = [];
            static create(attributes) {
                const activity = new Activity(attributes.name);
                //activity.inputs = new Map(attributes.inputs);
                //activity.outputs = new Map(attributes.outputs);
                activity.duration = attributes.duration;
                activity[id] = attributes.id || uuidv4();
                return activity;
            }
            constructor(name) {
                this[id] = uuidv4();
                this.name = name;
                this.state = ready;
                this.duration = 1 * 60 * 60 * 1000;
                this.inputs = new Map();
                this.outputs = new Map();
                this.content = new Set();
                Activity.all.push(this);
            }
            delete() {
                [...this.content].forEach((asset) => asset.move(app.model.store));
                this.inputs.values().forEach((input) => input.delete());
                this.outputs.values().forEach((output) => output.delete());
                Activity.all.splice(Activity.all.indexOf(this), 1);
                app.selected.delete(this);
                view.remove(this);
            }
            addInput(product, quantity = 1) {
                const state = this.inputs.get(product);
                if (state) {
                    state.required = quantity;
                } else {
                    const input = new Input(product, 1, [], quantity);
                    input[parent] = this;
                    this.inputs.set(product, input);
                }
                appendLine(`Added product ${product.name} as input to ${this.name}`);
                if (quantity === 0) {
                    this.inputs.delete(product);
                }
            }
            addOutput(name, quantity = 1) {
                const product = Product.get(name);
                const state = this.outputs.get(product);
                if (state) {
                    state.provides = quantity;
                } else {
                    const output = new Output(product, 5000, quantity, []);
                    this.outputs.set(product, output);
                    app.model.all.push(output);
                }
                appendLine(`Added product ${name} as input to ${this.name}`);
                if (quantity === 0) {
                    this.outputs.delete(product);
                }
            }
            start() {
                if (this.state !== running) {
                    this.startTime = app.simulation.runTime;
                    this.state = running;
                }
            }
            next() {
                // Return the duration in milliseconds for the next event
                const duration = app.simulation.runTime - this.startTime;
                return Math.min(...this.outputs.values().map((output) => output.duration - duration));
            }
            get nextEvent() {
                if (this.state === running) {
                    this.startTime + this.duration;
                }
                return Infinity;
            }
            getRemaining() {
                const next = this.nextEvent;
                if (next === Infinity) {
                    return 'N/A';
                }
                return getShortDurationString(next);
            }
            update() {
                if (this.state === running) {
                    const duration = app.simulation.runTime - this.startTime;
                    const outputs = this.outputs.values().filter((output) => !output.done && output.duration < duration);
                    outputs.forEach((output) => {
                        const asset = new Asset(output.product);
                        asset.move(output);
                        [...this.content].forEach((component) => component.move(asset));
                        output.links.forEach((link) => link.to.update());
                        output.done = true;
                    });
                    if (this.outputs.values().every((output) => output.done)) {
                        this.outputs.values().forEach((output) => output.done = false);
                        this.state = ready;
                    }
                } else if (this.state === blocked) {
                    // Check whether outputs are now free
                    if (this.outputs.values().every((output) =>
                        output.capacity > output.content.length)) {
                        this.state === ready;
                    }
                }
                if (this.state === ready || this.state === waiting) {
                    const inputs = [...this.inputs.values()];
                    //const available = inputs.reduce((list, input) => list.concat(input.available), []);
                    if (inputs.every((input) => input.available.length >= input.required)) {
                        inputs.forEach((input) => {
                            const available = input.available;
                            available.length = input.required;
                            available.forEach((entry) => entry.asset.move(this));
                        });
                        this.start();
                    } else {
                        this.state = waiting;
                    }
                }
            }
            getStateDescription() {
                const inputs = Array.from(this.inputs.values());
                return {
                    [ready]: `Ready`,
                    [waiting]: `Waiting for:
${inputs.filter((input) => input.available < input.required)
                            .map((input) => (input.required - input.available) + ' x ' + input.product.name).join('\n')}`,
                    [running]: `Running (${this.getRemaining()} to go)`,
                    [blocked]: `Blocked`,
                    [paused]: `Paused`,
                }[this.state];
            }
        }

        /**
         * Convert a duration in milliseconds into a string.
         */
        function getDurationString(duration) {
            const ms = duration - 1000 * (Math.floor(duration / 1000));
            const s = Math.floor((duration - (60 * 1000 * Math.floor(duration / (60 * 1000)))) / 1000);
            const m = Math.floor((duration - (60 * 60 * 1000 * Math.floor(duration / (60 * 60 * 1000)))) / (60 * 1000));
            const h = Math.floor((duration - (24 * 60 * 60 * 1000 * Math.floor(duration / (24 * 60 * 60 * 1000)))) / (60 * 60 * 1000));
            const result = [];
            const append = (value, unit) => {
                if (value > 1) {
                    result.push(`${value} ${unit}s`);
                } else if (value > 0) {
                    result.push(`${value} ${unit}`);
                }
            };

            append(h, 'hour');
            append(m, 'minute');
            append(s, 'second');
            append(ms, 'millisecond');
            if (result.length > 1) {
                result.splice(result.length - 1, 0, 'and');
            }
            return result.join(' ');
        }


        /**
         * Convert a duration in milliseconds into a string.
         */
        function getShortDurationString(duration) {
            const s = (duration - (60 * 1000 * Math.floor(duration / (60 * 1000)))) / 1000;
            const m = Math.floor((duration - (60 * 60 * 1000 * Math.floor(duration / (60 * 60 * 1000)))) / (60 * 1000));
            const h = Math.floor((duration - (24 * 60 * 60 * 1000 * Math.floor(duration / (24 * 60 * 60 * 1000)))) / (60 * 60 * 1000));
            const d = Math.floor((duration - (7 * 24 * 60 * 60 * 1000 * Math.floor(duration / (7 * 24 * 60 * 60 * 1000)))) / (24 * 60 * 60 * 1000));
            const w = Math.floor(duration / (7 * 24 * 60 * 60 * 1000));
            const result = [];
            if (w > 1) {
                result.push(`${w} weeks `)
            } else if (w > 0) {
                result.push(`${w} week `)
            }

            if (d > 1) {
                result.push(`${d} days `)
            } else if (d > 0) {
                result.push(`${d} day `)
            }
            const hours = h < 10 ? `0${h}` : h;
            const minutes = m < 10 ? `0${m}` : m;
            const seconds = s < 10 ? `0${s.toFixed(2)}` : s.toFixed(2);
            return result.join('') + `${hours}:${minutes}:${seconds}`;
        }

        class Link {
            static create(attributes) {
                const link = new Link(attributes.from, attributes.to);
                link[id] = attributes.id;
                return link;
            }
            constructor(from, to) {
                this[id] = uuidv4();
                this.from = from;
                this.to = to;
                from.links?.push(this);
                to.links?.push(this);
            }
            deleteTo() {
                this.from.links = this.from.links.filter((link) => link.to !== this.to);
                app.selected.delete(this);
                view.remove(this);
            }
            deleteFrom() {
                this.to.links = this.to.links.filter((link) => link.from !== this.from);
                app.selected.delete(this);
                view.remove(this);
            }
            get available() {
                return this.from.available;
            }
        }


        const app = {
            model: {
                name: 'model',
                all: [],
                ids: {},
                get processes() { return this.all.filter((item) => item instanceof Process) },
                get activities() { return this.all.filter((item) => item instanceof Activity) },
                get products() { return Product.all; },
                inputs: new Map(),
                outputs: new Map(),
                links: [],
                store: { content: new Set() },

                reset() {
                    this.all = [];
                    this.ids = {};
                    this.inputs = new Map();
                    this.outputs = new Map();
                    this.links = [];
                },
                addItem(item, replace = false) {
                    const pos = this.all.findIndex((existing) => existing.name === item.name);
                    if (pos !== -1) {
                        if (replace) {
                            this.all.splice(pos, 1, item);
                        } else {
                            appendLine(`Warning: ${this.all[pos].name} already exists in the model`);
                        }
                    } else {
                        this.all.push(item);
                    }
                },

                addActivity(name) {
                    if (name === undefined) {
                        let index = 1;
                        while (this.all.find((item) => (item instanceof Activity) && item.id === `Activity ${index}`)) {
                            index += 1;
                        }
                        name = `Activity ${index}`;
                    }
                    const activity = Activity.create({ name });
                    this.all.push(activity);
                    return activity;
                },
                addInput(product, quantity = 0) {
                    const input = this.inputs.get(product);
                    if (input) {
                        input.content += parseInt(quantity);
                        this.links.filter((link) => link.start === input)
                            .forEach((link) => link.end.update());
                    } else {
                        const content = Array(quantity).fill(1, 0, quantity).map((i) => new Asset(product));
                        const source = new Source();
                        content.forEach((asset) => asset.move(source));
                        this.inputs.set(product, source);
                        this.all.push(source);
                    }
                },
                addOutput(name, quantity = 0) {
                    const product = Product.get(name);
                    const output = this.outputs.get(product);
                    if (output) {
                        output.content += parseInt(quantity);
                        this.links.filter((link) => link.start === input)
                            .forEach((link) => link.end.update());
                    } else {
                        const content = Array(quantity).fill(1, 0, quantity).map((i) => ({ product }));
                        this.outputs.set(product, { content });
                    }
                },
                toJSON() {
                    return {
                        all: this.all,
                        inputs: this.inputs,
                        outputs: this.outputs,
                        links: this.links,
                    };
                }
            },
            simulation: {
                state: paused,
                mode: byTime,
                rate: 1,
                reference: 0,
                eventsPerSecond: 1,
                reset() {
                    this.reference = 0;
                    if (this.initial) {
                        this.initial.forEach(([asset, location]) => asset.move(location));
                    }
                },
                start(time) {
                    if (this.reference === 0) {
                        this.initial = [...Asset.all].map((asset) => [asset, asset.location]);
                    }
                    this.lastTime = Date.now();
                    this.startTime = Date.parse(time) || this.startTime || Date.now();
                    this.state = running;
                    this.events = app.model.activities;
                    this.events.forEach((event) => event.update());
                    this.events.sort((a, b) => a.next - b.next);
                    if (this.events[0].next() < Infinity) {
                        this.timerId = window.setTimeout(this.tick, this.events[0].next() / this.rate, this.events[0]);
                    }
                },
                pause() {
                    this.state = paused;
                },
                stop() {
                    this.state = paused;
                    window.clearTimeout(this.timerId);
                },
                get active() {
                    // Determine the time of the next event
                    const active = app.model.activities.filter((activity) => activity.state === running);
                    active.sort((a, b) => a.nextEvent - b.nextEvent);
                    return active;
                },
                get runTime() {
                    const now = Date.now();
                    const delta = (this.state === running) ? (now - this.lastTime) : 0;
                    this.lastTime = now;
                    const runTime = this.reference + delta * this.rate;
                    this.reference = runTime;
                    return runTime;
                },
                get time() {
                    return this.startTime + this.runTime;
                },
                tick(activity) {
                    activity.update();
                    appendLine('tick');
                },
            },
            timeout: 1000,
            selected: new Set(),
            actions: {},
            commandHistory: {
                position: -1,
                content: [],
            },
        };

        /**
         * Global tick function to allow time based updates.
         */
        function tick() {
            if (app.timerId) {
                window.clearTimeout(app.windowId);
            }
            updateStatus();
            if (app.timeout === 'screen') {
                window.requestAnimationFrame(tick);
                app.timerId = null;
            } else if (app.timeout > 0) {
                app.timerId = window.setTimeout(tick, app.timeout);
            }
        }



        /**
         * Find an object by it's id.
         */
        function byId(id) {
            return app.model.ids[id];
            return app.model.all.find((item) => item.id === id) ||
                app.model.inputs.values().find((item) => item.id === id) ||
                app.model.outputs.values().find((item) => item.id === id);
        }

        /**
         * Find an object by it's name.
         */
        function byName(name) {
            const item = app.model.all.find((item) => item.name === name);
            return item;
        }

        /**
         * Manage serialisation and de-serialisation.
         */

        function serialise(item) {
            const serialised = new Set();
            function replacer(key, value) {
                if (!value) {
                    return value;
                }
                if (value[id]) {
                    if (serialised.has(value[id])) {
                        return { ref: value[id], key, context: this.id };
                    }
                    serialised.add(value[id]);
                }
                if (value instanceof Map) {
                    return {
                        dataType: 'Map',
                        value: Array.from(value.entries()),
                    };
                } else if (value instanceof Set) {
                    return {
                        dataType: 'Set',
                        value: Array.from(value),
                    };
                }

                if (['Product', 'Asset', 'Process', 'Port', 'Input', 'Activity', 'Link', 'Input', 'Output', 'Source'].includes(value.constructor.name)) {
                    return {
                        dataType: value.constructor.name,
                        value: Object.assign({}, value, { id: value[id], [id]: undefined }),
                    };
                } else if (value[id]) {
                    return Object.assign({}, value, { id: value[id], [id]: undefined });
                }
                return value;
            }
            return JSON.stringify(item, replacer, 2);
        }

        function deserialise(str) {
            const datePattern = /[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{1,4}Z/
            const references = new Map();
            const unresolved = [];
            const containers = [];
            function reviver(key, value) {
                if (datePattern.test(value)) {
                    return Date.parse(value);
                }
                /* if (value && value.ref && references.has(value.ref)) {
                    return references.get(value.ref);
                } else */if (value && value.ref) {
                    unresolved.push({ key, id: value.ref, context: value.context || this });
                } else if (typeof value === 'object' && value !== null) {
                    if (value.dataType === 'Map') {
                        containers.push({ type: Map, key, content: value.value, context: this });
                        return 'tbd';
                        //return new Map(value.value);
                    } else if (value.dataType === 'Set') {
                        containers.push({ type: Set, key, content: value.value, context: this });
                        return 'tbd';
                        //return new Set(value.value);
                    } else if (value.dataType) {
                        const element = {
                            Product, Asset, Process, Port, Input, Activity, Link, Input, Output, Source,
                        }[value.dataType].create(value.value);
                        if (element[id]) {
                            references.set(element[id], element);
                        }
                        return element;
                    }
                }

                return value;
            }
            const structure = JSON.parse(str, reviver);
            unresolved.forEach((reference) => {
                const item = references.get(reference.id);
                const context = references.get(reference.context) || reference.context;

                if (item && context) {
                    context[reference.key] = item;
                } else {
                    appendLine(`Warning: unmatched reference (${reference.id}) for ${reference.key} in ${context?.name}`);
                }
            });
            containers.forEach((container) => {
                const context = references.get(container.context.id) || container.context;

                if (context) {
                    context[container.key] = new container.type(container.content);
                } else {
                    appendLine(`Warning: unmatched container (${container.id}) for ${container.key} in ${context?.name}`);
                }
            });
            return structure;
        }


        /**
         * Utility function to support downloading generated content.
         */
        function saveText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Utility function to support loading a file.
         */
        function load() {
            const tempNode = document.createElement('input');
            tempNode.type = 'file';
            tempNode.accept = '.json';
            tempNode.addEventListener('cancel', () => {
                console.log('Cancelled.');
            });

            function loadFile(file) {
                const reader = new FileReader();
                reader.addEventListener('load', (event) => {
                    const filename = file.name;
                    try {
                        app.model = deserialise(reader.result);
                        appendLine(`Loaded ${filename}`);
                    } catch (error) {
                        appendLine(error.message);
                    }
                });
                reader.readAsText(file);
            }

            tempNode.addEventListener('change', () => {
                if (tempNode.files.length === 1) {
                    console.log('File selected: ', tempNode.files[0]);
                    for (let i = 0; i < tempNode.files.length; ++i) {
                        loadFile(tempNode.files[i]);
                    }
                }
            });
            tempNode.click();
        }


        /**
         * Utility function to support downloading generated content.
         */
        function download(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Common Functions for use by commands
         */

        /**
         * Reset the parse
         */
        function reset() {
            this.chars = this.name.split('');
            return this;
        }

        /**
         * Check the next character against the command
         */
        function parse(i) {
            return this.chars.length === 0 || this.chars.shift() === i;
        }

        /**
         * Add a list to the output
         */
        function appendLine(line) {
            const output = document.getElementById('output');
            output.append(line, document.createElement('br'));
        }

        /**
         * Add a list to the output
         */
        function showList(list) {
            const output = document.getElementById('output');
            output.append(...list.flatMap((item) => [item, document.createElement('br')]));
        }


        /**
         * Load the current state from local storage
         */
        function loadLocal() {
            const stateStr = localStorage.getItem('process-model');

            if (stateStr) {
                const state = deserialise(stateStr);
                app.model.all.push(...state.model.all);
                app.model.inputs = state.model.inputs || new Map();
                app.model.outputs = state.model.outputs || new Map();

                app.model.links = state.model.links.filter((link) => link.from !== undefined && link.to !== undefined);
                if (state.history) {
                    app.commandHistory.position = state.history.position;
                    app.commandHistory.content = state.history.content;
                }
            }
        }

        /**
         * load the current state to local storage
         */
        function saveLocally() {
            const state = {
                model: app.model,
                history: app.commandHistory,
            };

            const str = serialise(state);
            localStorage.setItem('process-model', str);
        }

        /**
         * User commands that can be used in the input box.
         */
        const commands = [
            {
                name: 'load',
                action(str) {
                    load();
                },
                reset,
                parse,
            },
            {
                name: 'save',
                action(str) {
                    saveText(serialise(app.model), 'process_model.json');
                },
                reset,
                parse,
            },
            {
                name: 'clear model',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.stop();
                    app.model.reset();
                    view.svg.innerHTML = '';
                },
                reset,
                parse,
            },
            {
                name: 'clear',
                action(str) {
                    const output = document.getElementById('output');
                    output.innerHTML = '';
                },
                reset,
                parse,
            },
            {
                name: 'add process',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    app.model.processes.push({ name });
                    app.selected.add(app.model.processes.at(-1));

                    appendLine(`Added process: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'processes',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0].trim();
                    if (pattern === '') {
                        showList(app.model.processes.map((process) => process.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.processes.filter((process) => expr.test(process.name))
                            .map((process) => process.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add activity',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.selected.add(app.model.addActivity(...parameters));
                    appendLine(`Added activity: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'activities',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0].trim();
                    if (pattern === '') {
                        showList(app.model.activities.map((activity) => activity.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.activities.filter((activity) => expr.test(activity.name))
                            .map((activity) => activity.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add input',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [productName, quantity] = parameters;
                    const product = Product.get(productName);
                    if (app.selected.size > 0) {
                        for (const item of app.selected) {
                            if (item.addInput) {
                                item.addInput(product, quantity);
                                appendLine(`Added input of ${product.name} to ${item.name}`);
                            }
                        }
                    } else {
                        app.model.addInput(product, quantity);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add source',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [productName, quantity] = parameters;
                    const product = Product.get(productName);
                    app.model.addInput(product, quantity);
                },
                reset,
                parse,
            },
            {
                name: 'inputs',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    for (const item of app.selected) {
                        appendLine(item.name);
                        for (const [product, state] of item.inputs) {
                            appendLine(`  ${product.name} ${state.current}/${state.required}`);
                        }
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add output',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [product, quantity] = parameters;
                    if (app.selected.size > 0) {
                        for (const item of app.selected) {
                            if (item.addOutput) {
                                item.addOutput(product, quantity);
                                appendLine(`Added output of ${product} to ${item.name}`);
                            }
                        }
                    } else {
                        app.model.addOutput(product, quantity);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add product',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    const product = Product.create({ name });
                    app.model.addItem(product);
                    app.selected.add(product);

                    appendLine(`Added product: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'products',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.model.products.map((product) => product.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'link',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    const product = app.model.products.find((product) => product.name === name);
                    if (product) {
                        const from = app.model.inputs.get(product);
                        if (from) {
                            for (const item of app.selected) {
                                if (item.inputs) {
                                    const to = item.inputs.get(product);
                                    if (to) {
                                        app.model.links.push(new Link(from, to));
                                    }
                                }
                            }
                        }
                    }
                },
                reset,
                parse,
            },
            {
                name: 'links',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.model.links.map((link) => `${link.source.name} -> ${link.destination.name}`));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'delete',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (parameters.length === 0) {
                        for (const item of app.selected) {
                            app.model.all = app.model.all.filter((element) => element !== item);
                            item.delete();
                            item.deleted = true;
                            appendLine(`${item.name} deleted`);
                        }
                        app.selected.clear();
                    } else {
                    }
                },
                reset,
                parse,
            },
            {
                name: 'rate',
                description: 'Set the application tick timer',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const value = Number(parameters[0]);
                    if (value > 0) {
                        app.simulation.rate = value;
                    } else {
                        appendLine(`Simulation rate = ${app.simulation.rate}`);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'tick',
                description: 'Set the application tick timer',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (parameters.length === 0) {
                        app.timeout = 0;
                    } else {
                        const value = Number(parameters[0]);
                        if (isNaN(value)) {
                            app.timeout = 'screen';
                        } else {
                            app.timeout = value;
                        }
                    }
                    tick();
                },
                reset,
                parse,
            },
            {
                name: 'start',
                description: 'Start the simulation',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.start(parameters[0]);
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'stop',
                description: 'Pause the simulation',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.pause();
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'reset',
                description: 'Restart the simulation',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.reset();
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'update',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'redraw',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    redraw();
                },
                reset,
                parse,
            },
            {
                name: 'draw',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        if (app.selected.size > 0) {
                            draw(app.selected);
                        } else {
                            draw([...app.model.processes, ...app.model.activities, ...app.model.products, ...app.model.links]);
                        }
                    } else {

                    }
                },
                reset,
                parse,
            },
            {
                name: 'none',
                action(str) {
                    app.selected.clear();
                },
                reset,
                parse,
            },
            {
                name: 'set',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (parameters.length === 2) {
                        const [attribute, str] = parameters;
                        const value = resolve(str);
                        app.selected.forEach((item) => item[attribute] = value);
                    } else if (parameters.length > 2) {
                        const value = resolve(parameters.pop());
                        const attribute = parameters.pop();
                        const items = parameters.flatMap((str) => {
                            const pattern = new RegExp(str);
                            return app.model.all.filter((item) => pattern.test(item.name));
                        });
                        items.forEach((item) => item[attribute] = value);
                    }
                    app.selected.clear();
                },
                reset,
                parse,
            },
            {
                name: 'selected',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.selected.map((item) => item.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.selected.filter((item) => expr.test(item.name))
                            .map((item) => item.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'commands',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(commands.map((command) => command.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(commands.filter((command) => expr.test(command.name))
                            .map((command) => command.name));
                    }
                },
                reset,
                parse,
            },
        ];

        /**
         * Update the command list for completions.
         */
        function updateCommandList() {
            const commandList = document.getElementById('command-list');
            commandList.innerHTML = commands.map((command) => `<option>${command.name}</option>`).join('');
        }


        /**
         * Handle a command entered in the input box.
         */
        function processCommand(event) {
            const input = document.getElementById('command-input');

            let validCommands = commands.map((command) => command.reset());
            const command = input.value.split('');

            const parse = (i) => validCommands = validCommands.filter((command) => command.parse(i));

            while (validCommands.length > 0 && command.length > 0) {
                parse(command.shift());
            }
            if (input.value.startsWith('$')) {
                try {
                    const func = new Function('app', '_', `return ${input.value.slice(1)};`);
                    appendLine(func(app, byName));
                } catch (error) {
                    appendLine(`Error: ${error.message}`);
                }
            } else if (validCommands.length === 1) {
                validCommands[0].action(input.value);
            } else if (validCommands.length > 1) {
                validCommands.sort((a, b) => b.length - a.length);
                validCommands[0].action(input.value);
            } else {
                const pattern = new RegExp(input.value);
                const items = app.model.all.filter((item) => pattern.test(item.name));

                if (items.length > 0) {
                    items.forEach((item) => {
                        if (app.selected.has(item)) {
                            app.selected.delete(item);
                            appendLine(`Deselected ${item.name}`);
                        } else {
                            app.selected.add(item);
                            appendLine(`Selected ${item.name}`);
                        }
                    });

                } else {
                    appendLine(`Warning: unrecognised input "${input.value}"`);
                }
            }

            if (event.ctrlKey) {
                app.commandHistory.content[app.commandHistory.position++] = input.value;
                input.value = app.commandHistory.content[app.commandHistory.position] || '';
            } else if (event.shiftKey) {
                input.value = '';
                app.commandHistory.position = -1;
            } else {
                app.commandHistory.content.push(input.value);
                app.commandHistory.position = -1;
                input.value = '';
            }
        }


        /**
         * Validate the content of the input box.
         */
        function processKey(event) {
            const input = document.getElementById('command-input');

            if (event.key === 'Enter') {
                processCommand(event);
                update();
                saveLocally();
                updateSelected();
            } else if (event.key === 'Escape') {
                document.body.focus();
            } else if (event.key === 'ArrowUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.position = app.commandHistory.content.length - 1;
                    app.commandHistory.content.push(input.value);
                    input.value = app.commandHistory.content[app.commandHistory.position];
                } else {
                    app.commandHistory.position = (app.commandHistory.content.length - 1 + app.commandHistory.position) % app.commandHistory.content.length;
                    input.value = app.commandHistory.content[app.commandHistory.position];
                }
            } else if (event.key === 'DownUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.content.push(input.value);
                }
                app.commandHistory.position = (app.commandHistory.content.length + 1 + app.commandHistory.position) % app.commandHistory.content.length;
                input.value = app.commandHistory.content[app.commandHistory.position];
            }
        }

        const view = new SVGView('process-view', 'Process View');

        /**
         *
         */
        function update() {
            updateStatus();
            updateView();
        }


        /**
         * Update the status line.
         */
        function updateStatus() {
            const node = document.getElementById('status');
            const modeString = {
                // Simulation mode
                [byTime]: `time based (${getShortDurationString(app.simulation.runTime)})`,
                [byEvent]: 'event based',
            }[app.simulation.mode];
            const stateString = {
                [running]: `Running ${modeString}`,
                [blocked]: 'Blocked',
                [paused]: 'Paused',
            }[app.simulation.state];
            node.innerHTML = `${stateString}`;
        }


        /**
         * Select an item, updating the representation as necessary.
         */
        function select(item, node) {
            app.selected.add(item);
            node.classList.add('selected');
            updateSelected();
        }

        /**
         * Deselect an item, updating the representation as necessary.
         */
        function deselect(item, node) {
            app.selected.delete(item);
            node.classList.remove('selected');
            updateSelected();
        }

        /**
         * Redraw the view
         */
        function redraw() {
            view.svg.innerHTML = '';
            view.map.clear()
            updateView();
        }


        /**
         * Make an svg element moveable
         */
        function moveable(representation) {
            const group = representation.nodes.group;
            group.addEventListener('mousedown', (event) => {
                app.actions.start = { x: event.clientX, y: event.clientY, nodeX: representation.x, nodeY: representation.y };
                app.actions.move = (event) => {
                    const delta = {
                        x: event.clientX - app.actions.start.x,
                        y: event.clientY - app.actions.start.y,
                    };
                    x = app.actions.start.nodeX + delta.x;
                    y = app.actions.start.nodeY + delta.y;
                    representation.nodes.group.setAttribute('transform', `translate(${x} ${y})`);
                    //updateView();
                };
                app.actions.mouseup = (event) => {
                    const delta = {
                        x: event.clientX - app.actions.start.x,
                        y: event.clientY - app.actions.start.y,
                    };
                    representation.x = app.actions.start.nodeX + delta.x;
                    representation.y = app.actions.start.nodeY + delta.y;
                    updateView();
                };
            });
        }

        /**
         * Make an svg element a target for dropping assets
         */
        function contentTarget(container, node) {
            node.addEventListener('dragover', (event) => event.preventDefault());
            node.addEventListener('drop', (event) => {
                event.preventDefault();
                const assetId = event.dataTransfer.getData('text/plain');
                const item = [...Asset.all].find((asset) => asset[id] === assetId);
                if (item.product === product) {
                    item.move(container);
                }
                updateView();
            });
        }


        /**
         * Update the SVG that represents the current process and its state.
         */
        function updateView() {
            updateProductList();
            updateAssetList();
            // Remove deleted items
            for (const [item, representation] of view.map.entries()) {
                if (item.deleted) {
                    Object.values(representation.nodes).forEach((node) => node.remove(node));
                    view.map.delete(item);
                }
            }

            let x = 10;
            let y = 20;
            const textAttrs = { x: 10, y: 20, fill: 'black', stroke: 'none', 'text-anchor': 'start', 'alignment-baseline': 'middle' };
            const representations = [];
            for (const input of app.model.inputs) {
                const [product, state] = input;
                const fill = state.content.size > 0 ? 'lightgreen' : 'white';
                const representation = view.map.get(state);
                if (representation) {
                    representation.nodes.group.setAttribute('fill', fill);
                    representations.push(representation);
                    representation.nodes.label.innerHTML = product.name;
                    representation.bbox = representation.nodes.label.getBBox();
                    representation.nodes.title.innerHTML = representation.nodes.textTitle.innerHTML = `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`;
                } else {
                    const group = view.add('g');
                    const outline = view.add('path', group, { fill, stroke: 'black' });
                    const title = view.add('title', outline, {}, `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`);

                    const label = view.add('text', group, textAttrs, `${product.name}`);
                    const textTitle = view.add('title', label, {}, `${product.name} (${state.content.size})`);

                    const representation = { x: 0, y: 0, nodes: {group, outline, title, label, textTitle}, bbox: label.getBBox() };
                    representations.push(representation);
                    view.map.set(state, representation);

                    outline.addEventListener('click', (event) => {
                        if (event.altKey) {
                            state.validate();
                        } else if (event.shiftKey) {
                            deselect(state, outline);
                        } else {
                            select(state, outline);
                        }
                        updateView();
                    });
                    outline.addEventListener('dblclick', (event) => {
                        const asset = new Asset(product);
                        asset.move(state);
                        state.content.add(asset);
                        state.links.forEach((link) => link.to.update);
                        updateView();
                    });
                    moveable(representation);
                    contentTarget(state, outline);
                }
                textAttrs.y += 50;
            }

            const textWidth = Math.max(0, ...representations.map((representation) => representation.bbox.width));
            const textHeight = Math.max(0, ...representations.map((representation) => representation.bbox.height));

            representations.forEach((representation, index) => {
                const x = 10 - textHeight / 2;
                const y = 20 + index * 50 - textHeight / 2;
                const d = `M ${x} ${y} h ${textWidth + textHeight} l ${textHeight / 2} ${textHeight / 2} l ${-textHeight / 2} ${textHeight / 2} h ${-textWidth - textHeight} z`;
                representation.nodes.outline.setAttribute('d', d);
                representation.x = x;
                representation.y = y;
                representation.width = textWidth + textHeight * 1.5;
                representation.height = textHeight;
            });

            x = textWidth + textHeight + 50;
            y = 30;
            const width = 100;
            const horizontalSpace = 100;
            const height = 50;
            const verticalSpace = 30;
            app.model.activities.forEach((activity) => {
                const classes = app.selected.has(activity) ? ['selected'] : [];

                const representation = view.map.get(activity) || {};
                if (representation.nodes) {
                    representation.nodes.outline.innerHTML = activity.name;
                    representation.nodes.label.setAttribute('x', width / 2);
                    representation.nodes.label.setAttribute('y', 15);
                    representation.nodes.title.innerHTML = activity.getStateDescription();
                } else {
                    const group = view.add('g', null, { transform: `translate (${x}, ${y})` });
                    const outline = view.add('rect', group, { width, height, rx: 5, ry: 5, fill: 'white', stroke: 'black' }, null, classes);
                    const label = view.add('text', group, { x: width / 2, y: 15, 'text-anchor': 'middle' }, activity.name);
                    const title = view.add('title', group, {}, activity.getStateDescription());
                    representation.x = x;
                    representation.y = y;
                    representation.nodes = {group, outline, label, title};
                    view.map.set(activity, representation);

                    outline.addEventListener('click', (event) => {
                        if (app.selected.has(activity)) {
                            deselect(activity, group);
                        } else {
                            select(activity, group);
                        }
                        updateSelected();
                    });
                    moveable(representation);
                }

                const step = (height - 10) / activity.inputs.size;
                let iy = 10 + step / 2;
                for (const input of activity.inputs) {
                    const [product, state] = input;
                    const node = view.map.get(state);

                    if (node) {
                        node.x = node.parent.x - 5;
                        node.y = node.parent.y + iy - 5;
                        node.nodes.title = `${product.name} (${state.content.size}/${state.required})`
                    } else {
                        const outline = view.add('circle', representation.nodes.group, { cx: 0, cy: iy, r: 5, fill: 'white', stroke: 'black' })
                        const title = view.add('title', outline, {}, `${product.name} (${state.content.size}/${state.required})`);
                        view.map.set(state, { x: x - 5, y: y + iy - 5, width: 10, height: 10, nodes: {outline, title}, parent: representation });

                        outline.addEventListener('click', (event) => {
                            appendLine(`Product: ${product.name}`);
                            appendLine(`Available: ${state.available.map((available) => available.asset.id).join(', ')}`);
                        });
                    }
                    iy += step;
                }

                const oStep = (height - 10) / activity.outputs.size;
                let oy = 10 + y + oStep / 2;
                for (const output of activity.outputs) {
                    const [product, state] = output;
                    const node = view.map.get(state);

                    if (node) {
                        node.x = node.parent.x + width - 5;
                        node.y = node.parent.y + oy - 5;
                        node.nodes.group = `${product.name} (${state.content.size}/${state.required})`
                    } else {
                        const outline = view.add('circle', representation.nodes.group, { cx: width, cy: oy, r: 5, fill: 'white', stroke: 'black' })
                        const title = view.add('title', outline, {}, `${product.name} (${state.content.size}/${state.required})`);
                        view.map.set(state, { x: x - 5, y: y + oy - 5, width: 10, height: 10, nodes: {outline, title}, parent: representation });

                        outline.addEventListener('click', (event) => {
                            appendLine(`Product: ${product.name}`);
                            appendLine(`Available: ${state.available.map((available) => available.asset.id).join(', ')}`);
                        });
                    }
                    oy += step;
                }

                y += height + verticalSpace;
                if (y + 50 > 500) {
                    y = 10;
                    x += width + horizontalSpace;
                }
                if (representation) {
                    representation.nodes.group.classList.remove('ready');
                    representation.nodes.group.classList.remove('running');
                    representation.nodes.group.classList.remove('waiting');
                    representation.nodes.group.classList.remove('blocked');
                    representation.nodes.group.classList.remove('paused');

                    representation.nodes.group.classList.add({
                        [ready]: 'ready',
                        [running]: 'running',
                        [waiting]: 'waiting',
                        [blocked]: 'blocked',
                        [paused]: 'paused',
                    }[activity.state]);
                }
            });












            x = 1000;
            y = 50;
            Object.assign(textAttrs, { x, y: y + 30, 'text-anchor': 'center', 'alignment-baseline': 'hanging' });
            representations.length = 0;
            for (const output of app.model.outputs) {
                const [product, state] = output;
                const fill = state.content.size > 0 ? 'lightgreen' : 'white';
                const representation = view.map.get(state);
                if (representation) {
                    representation.nodes.outline.setAttribute('fill', fill);
                    representations.push(representation);
                    representation.nodes.label.innerHTML = product.name;
                    representation.bbox = representation.nodes.group.getBBox();
                    representation.nodes.title.innerHTML = representation.nodes[3].innerHTML = `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`;
                } else {
                    const group = view.add('g', null, { transform: `translate (${x}, ${y})` });
                    const w = 30;
                    const h = 10;
                    const d = `M ${x} ${y + h} l ${w} ${-h} l ${w} ${h} l ${-w} ${h} l ${-w} ${-h} v 5 l ${w} ${h} l ${w} ${-h} v -5 M ${x + w} ${y + 2 * h} v 5`;
                    const outline = view.add('path', group, { d, fill, stroke: 'black' });
                    const title = view.add('title', outline, {}, `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`);

                    const label = view.add('text', group, textAttrs, `${product.name}`);
                    const textTitle = view.add('title', label, {}, `${product.name} (${state.content.size})`);

                    const representation = { nodes: {group, outline, title, label, textTitle}, bbox: group.getBBox() };
                    representations.push(representation);
                    view.map.set(state, representation);
                    outline.addEventListener('click', (event) => {
                        if (event.altKey) {
                            state.validate();
                        } else if (event.shiftKey) {
                            deselect(state, outline);
                        } else {
                            select(state, outline);
                        }
                        updateView();
                    });
                    outline.addEventListener('dblclick', (event) => {
                        const asset = new Asset(product);
                        asset.move(state);
                        state.content.add(asset);
                        state.links.forEach((link) => link.to.update);
                        updateView();
                    });
                    moveable(group);
                    contentTarget(state, outline);
                }
                textAttrs.y += 50;
            }








            for (const link of app.model.links) {
                const representation = view.map.get(link);
                const start = view.map.get(link.from);
                const end = view.map.get(link.to);
                if (start && end) {
                    const x1 = start.x + start.width;
                    const y1 = start.y + start.height / 2;
                    const x2 = end.x;
                    const y2 = end.y + end.height / 2;
                    const mx = (x1 + x2) / 2;
                    const d = `M ${x1} ${y1} C ${mx} ${y1} ${mx} ${y2} ${x2} ${y2}`;
                    if (representation) {
                        representation.nodes.edge.setAttribute('d', d);
                    } else {
                        const edge = view.addUnder('path', null, { d, fill: 'none', stroke: 'black' });
                        view.map.set(link, { nodes: {edge} });
                    }
                }
            }
        }

        /**
         * Update the table of products
         */
        function updateProductList() {
            const container = document.getElementById('product-list');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>Index</th><th>Name</th><th>Qty</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            Product.all.sort((a, b) => a.name?.localeCompare(b.name));
            Product.all.forEach((product, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${index}</td><td>${product.name}</td><td>${product.instances.size}</td>`;
                const idx = row.firstChild;
                const name = idx.nextSibling;
                name.contentEditable = true;
                name.addEventListener('focus', (event) => {
                    name.contentEditable = true;

                });
                name.addEventListener('blur', (event) => {
                    product.name = name.innerText;
                    name.contentEditable = false;
                });
                name.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        name.innerText = product.name;
                        input.focus();
                    }
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        product.name = name.innerText;
                    }
                });
                body.append(row);
            });
        }

        /**
         * Update the table of products
         */
        function updateAssetList(product) {
            const container = document.getElementById('asset-list');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>Product</th><th>S/N</th><th>Location</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            const products = new Map();
            [...Asset.all].forEach((asset) => {
                const list = products.get(asset.product) || [];
                products.set(asset.product, list);
                list.push(asset);
            });
            const entries = [...products];
            entries.sort((a, b) => a[0].name?.localeCompare(b[0].name));
            entries.forEach(([product, assets]) => {
                assets.forEach((asset) => {
                    const row = document.createElement('tr');
                    row.draggable = true;
                    row.title = asset[id];
                    row.addEventListener('dragstart', (event) => {
                        event.dataTransfer.setData('text/plain', asset[id]);
                    });
                    row.innerHTML = `<td>${product.name}</td><td>${asset.serialNumber}</td><td>${asset.location?.name}</td>`;
                    const idx = row.firstChild;
                    const name = idx.nextSibling;
                    name.contentEditable = true;
                    name.addEventListener('focus', (event) => {
                        name.contentEditable = true;
                    });
                    name.addEventListener('blur', (event) => {
                        product.name = name.innerText;
                        name.contentEditable = false;
                    });
                    name.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            event.preventDefault();
                            name.innerText = product.name;
                            input.focus();
                        }
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            product.name = name.innerText;
                        }
                    });
                    body.append(row);
                });
            });
        }

        /**
         * Update the list of selected items.
         */
        function updateSelected() {
            const node = document.getElementById('selection');
            node.innerHTML = '';
            const list = document.createElement('ul');
            node.append(list);
            for (let element of app.selected) {
                const item = document.createElement('li');
                item.innerHTML = element.name || element.constructor.__name__;
                list.append(item);
                item.addEventListener('click', (event) => {
                    if (app.selected.has(element)) {
                        app.selected.delete(element);
                        updateSelected();
                    }
                });
            }
        }

        loadLocal();
        update();
        tick();

        const input = document.getElementById('command-input');
        //input.addEventListener('change', processCommand);
        input.addEventListener('keydown', processKey);


        const bin = document.getElementById('bin');
        bin.addEventListener('dragover', (event) => event.preventDefault());
        bin.addEventListener('drop', (event) => {
            const assetId = event.dataTransfer.getData('text/plain');
            const item = [...Asset.all].find((asset) => asset[id] === assetId);
            if (item) {
                item.delete();
            }
            updateView();
        });


        //updateCommandList();
        document.body.addEventListener('mousemove', (event) => {
            if (app.actions.move) {
                app.actions.move(event);
            }
        });
        document.body.addEventListener('mouseup', (event) => {
            if (app.actions.mouseup) {
                app.actions.mouseup(event);
            }
            app.actions.move = null
            app.actions.mouseup = null;
        });


        input.focus();
    </script>
</body>

</html>