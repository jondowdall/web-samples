<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Process</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
            font-size: 10pt;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            overflow: hidden;
        }

        table,
        th,
        td {
            border-collapse: collapse;
            border: 1px solid gray;
        }

        th,
        td {
            padding: 2px 5px;
        }

        #command-input {
            position: fixed;
            top: 1em;
            left: 50%;
            transform: translateX(-50%);
            min-width: 20em;
            padding: 0.2em 0.5em;
            outline: none;
            border: 1px solid gray;
            border-radius: 1em;
            background: white;
            box-shadow: 2px 3px 5px #333;
        }


        #process-view {
            width: 100vw;
            height: 100vh;
        }

        #output {
            position: fixed;
            bottom: 1em;
            right: 1em;
            width: 30vw;
            height: 20vh;
            background-color: lightgray;
            border-radius: 0.5em;
            padding: 0.5em;
            border: 2px inset white;
        }

        #selection-window {
            position: fixed;
            display: flex;
            flex-direction: column;
            top: 3em;
            right: 1em;
            width: 30vw;
            height: 20vh;
            color: antiquewhite;
            background-color: rgb(30, 30, 30, 0.8);
            border-radius: 0.5em;
            /*padding: 0.5em;*/
            border: 2px inset white;
        }

        #selection {
            background-color: rgb(150, 150, 150, 0.9);
            width: 100%;
            height: 100%;
        }

        .window>h2 {
            padding: 0.5em;
            margin: 0;
        }

        .selected {
            stroke: yellow;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }
    </style>
</head>

<body>
    <svg id="process-view"></svg>

    <div id="selection-window" class="window">
        <h2>Selection</h2>
        <div id="selection">

        </div>
    </div>
    <div id="output">Hello<br></div>

    <datalist id="command-list"></datalist>
    <input id="command-input" type="text" list="command-list" autocorrect="off" autocapitalize="off" />


    <script>
        /**
         * SVGView component
         */
        class SVGView {
            static ns = 'http://www.w3.org/2000/svg';
            static namedArributes = Symbol('named attributes');
            constructor(id, title) {
                this.svg = document.getElementById(id);
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
                //this.svg.setAttribute("viewBox", "0 0 2000 2000");
                this.title = title || 'SVG Diagram';
                this.map = new Map();
            }
            get width() {
                return this.svg.clientWidth;
            }
            get height() {
                return this.svg.clientHeight;
            }
            make(type, attributes, content, classes) {
                const element = document.createElementNS(SVGView.ns, type);
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);
                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                if (content) {
                    element.append(content);
                }
                if (classes) {
                    element.classList.add(...classes)
                }
                return element;
            }
            add(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.appendChild(element);
                return element;
            }
            addUnder(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.insertBefore(element, parent.firstElementChild);
                return element;
            }
            updateElement(element, attributes) {
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);

                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                return element
            }
        }
    </script>


    <script>
        // States
        const waiting = Symbol('waiting');
        const running = Symbol('running');
        const blocked = Symbol('blocked');
        const paused = Symbol('paused');

        // Activity mode
        const asap = Symbol('asap');
        const onDemand = Symbol('on demand');

        // Simulation mode
        const byTime = Symbol('by time');
        const byEvent = Symbol('by event');


        class Product {
            static create(attributes) {
                const product = new Product(attributes.name);
                product.instances = attributes.instances;
                return product;
            }
            constructor(name) {
                this.name = name;
                this.instances = [];
            }
            toJSON() {
                return {
                    dataType: 'Product',
                    value: Object.assign({}, this),
                }
            }

        }


        class Port {
            static create(attributes) {
                return new Port(attributes.name, attributes.capacity, attributes.content);
            }

            constructor(product, capacity = 1, content = []) {
                this.product = product;
                this.capacity = capacity;
                this.content = content;
            }
            store(item) {
                if (item.type !== this.product) {
                    appendLine(`Warning: Failed to store ${item.name} - item is not required type ${this.product.name}`);
                    return;
                }
                if (this.content.length >= this.capacity) {
                    appendLine(`Warning: Failed to storing ${item.name} - port is full`);
                    return;
                }
                this.content.push(item);
            }
            toJSON() {
                return {
                    dataType: 'Port',
                    value: Object.assign({}, this),
                }
            }

        }

        class Input extends Port {
            static create(attributes) {
                return new Input(attributes.name, attributes.capacity, attributes.content, attributes.required);
            }

            constructor(product, capacity = 1, content = [], required = 1) {
                super(product, capacity, content);
                this.required = required;
            }
            toJSON() {
                return {
                    dataType: 'Input',
                    value: Object.assign({}, this),
                }
            }
        }

        class Process {
            static create(attributes) {
                const process = new Process(attributes.name);
                process.inputs = new Map(attributes.inputs);
                process.outputs = new Map(attributes.outputs);
                return process;
            }

            toJSON() {
                return {
                    dataType: 'Process',
                    value: Object.assign({}, this),
                }
            }

        }

        class Activity {
            static create(attributes) {
                const activity = new Activity(attributes.name);
                activity.inputs = new Map(attributes.inputs);
                activity.outputs = new Map(attributes.outputs);
                return activity;
            }
            constructor(name) {
                this.name = name;
                this.state = waiting;
                this.inputs = new Map();
                this.outputs = new Map();
            }
            addInput(name, quantity = 1) {
                const product = app.model.products.find((product) => product.name === name);
                if (product) {
                    const state = this.inputs.get(product);
                    if (state) {
                        state.required = quantity;
                    } else {
                        this.inputs.set(product, { required: quantity, current: 0 });
                    }
                    appendLine(`Added product ${name} as input to ${this.name}`);
                } else {
                    appendLine(`Warning: product ${name} not found, ignoring request`);
                }
                if (quantity === 0) {
                    this.inputs.delete(product);
                }
            }
            toJSON() {
                return {
                    dataType: 'Activity',
                    value: Object.assign({}, this),
                }
            }
        }

        class Link {
            static create(attributes) {
                const source = app.model.all.find((item) => item.name === attributes.source);
                const destination = app.model.all.find((item) => item.name === attributes.destination);
                return new Link(source, destination);
            }
            constructor(source, destination) {
                this.source = source;
                this.destination = this.destination;
            }
            toJSON() {
                return {
                    dataType: 'Activity',
                    value: { source: this.source.name, destination: this.destination.name },
                }
            }
        }

        /**
         * Revive classes from definitions in objects
         */
        function revive(definition) {
            const item = {
                Product, Process, Port, Input, Activity, Link,
            }[definition.dataType].create(definition.value);
            return item;
        }


        const app = {
            model: {
                all: [],
                get processes() { return this.all.filter((item) => item instanceof Process) },
                get activities() { return this.all.filter((item) => item instanceof Activity) },
                get products() { return this.all.filter((item) => item instanceof Product) },
                inputs: new Map(),
                outputs: new Map(),
                links: [],

                addItem(item, replace = false) {
                    const pos = this.all.findIndex((existing) => existing.name === item.name);
                    if (pos !== -1) {
                        if (replace) {
                            this.all.splice(pos, 1, item);
                        } else {
                            appendLine(`Warning: ${this.all[pos].name} already exists in the model`);
                        }
                    } else {
                        this.all.push(item);
                    }
                },

                addActivity(attributes) {
                    const activity = Activity.create(attributes);
                    //const activity = Object.assign(Object.create(Activity), { state: waiting, inputs: new Map(), }, attributes);
                    this.all.push(activity);
                    return activity;
                },
                addInput(name, quantity = 0) {
                    const product = this.products.find((product) => product.name === name);
                    if (product) {
                        const input = this.inputs.get(product);
                        if (input) {
                            input.content += parseInt(quantity);
                            this.links.filter((link) => link.start === input)
                                .forEach((link) => link.end.update());
                        } else {
                            this.inputs.set(product, { content: quantity });
                        }
                    } else {
                        appendLine(`Warning: product ${name} not found`);
                    }
                },
                toJSON() {
                    return {
                        all: this.all,
                        links: this.links,
                    };
                }
            },
            simulation: {
                state: paused,
            },

            selected: new Set(),
            commandHistory: {
                position: -1,
                content: [],
            },
        };


        // Source - https://stackoverflow.com/a
        // Posted by Pawel, modified by community. See post 'Timeline' for change history
        // Retrieved 2025-11-18, License - CC BY-SA 4.0

        function replacer(key, value) {
            if (value instanceof Map) {
                return {
                    dataType: 'Map',
                    value: Array.from(value.entries()), // or with spread: value: [...value]
                };
            }
            return value;
        }
        // Source - https://stackoverflow.com/a
        // Posted by Pawel, modified by community. See post 'Timeline' for change history
        // Retrieved 2025-11-18, License - CC BY-SA 4.0

        function reviver(key, value) {
            if (typeof value === 'object' && value !== null) {
                if (value.dataType === 'Map') {
                    return new Map(value.value);
                } else if (value.dataType) {
                    return revive(value);
                }
            }
            return value;
        }



        /**
         * Utility function to support downloading generated content.
         */
        function saveText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Utility function to support loading a file.
         */
        function load() {
            const tempNode = document.createElement('input');
            tempNode.type = 'file';
            tempNode.accept = '.json';
            tempNode.addEventListener('cancel', () => {
                console.log('Cancelled.');
            });

            function loadFile(file) {
                const reader = new FileReader();
                reader.addEventListener('load', (event) => {
                    const filename = file.name;
                    try {
                        app.model = JSON.parse(reader.result, reviver);
                        appendLine(`Loaded ${filename}`);
                    } catch (error) {
                        appendLine(error.message);
                    }
                });
                reader.readAsText(file);
            }

            tempNode.addEventListener('change', () => {
                if (tempNode.files.length === 1) {
                    console.log('File selected: ', tempNode.files[0]);
                    for (let i = 0; i < tempNode.files.length; ++i) {
                        loadFile(tempNode.files[i]);
                    }
                }
            });
            tempNode.click();
        }


        /**
         * Utility function to support downloading generated content.
         */
        function download(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Common Functions for use by commands
         */

        /**
         * Reset the parse
         */
        function reset() {
            this.chars = this.name.split('');
            return this;
        }

        /**
         * Check the next character against the command
         */
        function parse(i) {
            return this.chars.length === 0 || this.chars.shift() === i;
        }

        /**
         * Add a list to the output
         */
        function appendLine(line) {
            const output = document.getElementById('output');
            output.append(line, document.createElement('br'));
        }

        /**
         * Add a list to the output
         */
        function showList(list) {
            const output = document.getElementById('output');
            output.append(...list.flatMap((item) => [item, document.createElement('br')]));
        }


        /**
         * Load the current state from local storage
         */
        function loadLocal() {
            const stateStr = localStorage.getItem('process-model');

            if (stateStr) {
                const state = JSON.parse(stateStr, reviver);
                app.model.all.push(...state.model.all);
                app.inputs = state.model.inputs;

                app.model.links = state.model.links;
                if (state.history) {
                    app.commandHistory.position = state.history.position;
                    app.commandHistory.content = state.history.content;
                }
            }
        }

        /**
         * load the current state to local storage
         */
        function saveLocally() {
            const state = {
                model: app.model,
                history: app.commandHistory,
            };
            localStorage.setItem('process-model', JSON.stringify(state, replacer, 2));
        }

        /**
         * User commands that can be used in the input box.
         */
        const commands = [
            {
                name: 'load',
                action(str) {
                    load();
                },
                reset,
                parse,
            },
            {
                name: 'save',
                action(str) {
                    saveText(JSON.stringify(app.model, replacer, 2), 'process_model.json');
                },
                reset,
                parse,
            },
            {
                name: 'clear',
                action(str) {
                    const output = document.getElementById('output');
                    output.innerHTML = '';
                },
                reset,
                parse,
            },
            {
                name: 'add process',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const name = parameters.trim();
                    app.model.processes.push({ name });
                    app.selected.add(app.model.processes.at(-1));

                    appendLine(`Added process: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'processes',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        showList(app.model.processes.map((process) => process.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.processes.filter((process) => expr.test(process.name))
                            .map((process) => process.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add activity',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const name = parameters.trim();
                    app.selected.add(app.model.addActivity({ name }));
                    appendLine(`Added activity: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'activities',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        showList(app.model.activities.map((activity) => activity.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.activities.filter((activity) => expr.test(activity.name))
                            .map((activity) => activity.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add input',
                action(str) {
                    const parameters = str.replace(this.name, '').trim();
                    const [product, quantity] = parameters.split(/\s+/);
                    if (app.selected.size > 0) {
                        for (const item of app.selected) {
                            item.addInput(product, quantity);
                            appendLine(`Added input of ${product} to ${item.name}`);
                        }
                    } else {
                        app.model.addInput(product, quantity);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'inputs',
                action(str) {
                    const parameters = str.replace(this.name, '').trim();
                    for (const item of app.selected) {
                        appendLine(item.name);
                        for (const [product, state] of item.inputs) {
                            appendLine(`  ${product.name} ${state.current}/${state.required}`);
                        }
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add product',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const name = parameters.trim();
                    const product = Product.create({ name });
                    app.model.addItem(product);
                    app.selected.add(product);

                    appendLine(`Added product: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'products',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        showList(app.model.products.map((product) => product.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'join',
                action(str) {
                    const parameters = str.replace(this.name, '').trim();
                    const name = parameters;
                    const product = app.model.products.find((product) => product.name === name);
                    if (product) {
                        const source = app.model.inputs.get(product);
                        if (source) {
                            for (const item of app.selected) {
                                const destination = item.inputs.get(product);
                                if (destination) {
                                    app.model.links.push({ source, destination });
                                }
                            }
                        }
                    }
                },
                reset,
                parse,
            },
            {
                name: 'links',
                action(str) {
                    const parameters = str.replace(this.name, '').trim();
                    const name = parameters;
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        showList(app.model.links.map((link) => `${link.source.name} -> ${link.destination.name}`));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'delete',
                action(str) {
                    const parameters = str.replace(this.name, '').trim();
                    const name = parameters;
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        for (const item of app.selected) {
                            app.model.processes = app.model.processes.filter((process) => process !== item);
                            app.model.activities = app.model.activities.filter((activity) => activity !== item);
                            app.model.products = app.model.products.filter((product) => product !== item);
                            app.model.links = app.model.links.filter((link) => link.source !== item && link.destination !== item);
                            item.deleted = true;
                            appendLine(`${item.name} deleted`);
                        }
                        app.selected.clear();
                    } else {
                    }
                },
                reset,
                parse,
            },
            {
                name: 'update',
                action(str) {
                    const parameters = str.replace(this.name, '').trim();
                    updateView();
                },
                reset,
                parse,
            },
            {
                name: 'draw',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        if (app.selected.size > 0) {
                            draw(app.selected);
                        } else {
                            draw([...app.model.processes, ...app.model.activities, ...app.model.products, ...app.model.links]);
                        }
                    } else {

                    }
                },
                reset,
                parse,
            },
            {
                name: 'none',
                action(str) {
                    app.selected.clear();
                },
                reset,
                parse,
            },
            {
                name: 'selected',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        showList(app.selected.map((item) => item.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.selected.filter((item) => expr.test(item.name))
                            .map((item) => item.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'commands',
                action(str) {
                    const parameters = str.replace(this.name, '');
                    const pattern = parameters.trim();
                    if (pattern === '') {
                        showList(commands.map((command) => command.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(commands.filter((command) => expr.test(command.name))
                            .map((command) => command.name));
                    }
                },
                reset,
                parse,
            },
        ];

        /**
         * Update the command list for completions.
         */
        function updateCommandList() {
            const commandList = document.getElementById('command-list');
            commandList.innerHTML = commands.map((command) => `<option>${command.name}</option>`).join('');
        }


        /**
         * Handle a command entered in the input box.
         */
        function processCommand(event) {
            const input = document.getElementById('command-input');

            let validCommands = commands.map((command) => command.reset());
            const command = input.value.split('');

            const parse = (i) => validCommands = validCommands.filter((command) => command.parse(i));

            while (validCommands.length > 0 && command.length > 0) {
                parse(command.shift());
            }
            if (validCommands.length === 1) {
                validCommands[0].action(input.value);
            } else {
                const pattern = new RegExp(input.value);
                const items = app.model.all.filter((item) => pattern.test(item.name));

                if (items.length > 0) {
                    items.forEach((item) => {
                        if (app.selected.has(item)) {
                            app.selected.delete(item);
                            appendLine(`Deselected ${item.name}`);
                        } else {
                            app.selected.add(item);
                            appendLine(`Selected ${item.name}`);
                        }
                    });
                } else {
                    appendLine(`Warning: unrecognised input "${input.value}"`);
                }
            }

            if (event.ctrlKey) {
                app.commandHistory.content[app.commandHistory.position++] = input.value;
                input.value = app.commandHistory.content[app.commandHistory.position] || '';
            } else if (event.shiftKey) {
                input.value = '';
                app.commandHistory.position = -1;
            } else {
                app.commandHistory.content.push(input.value);
                app.commandHistory.position = -1;
                input.value = '';
            }
        }


        /**
         * Validate the content of the input box.
         */
        function processKey(event) {
            const input = document.getElementById('command-input');

            if (event.key === 'Enter') {
                processCommand(event);
                updateView();
                saveLocally();
                updateSelected();
            } else if (event.key === 'Escape') {
                document.body.focus();
            } else if (event.key === 'ArrowUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.position = app.commandHistory.content.length - 1;
                    app.commandHistory.content.push(input.value);
                    input.value = app.commandHistory.content[app.commandHistory.position];
                } else {
                    app.commandHistory.position = (app.commandHistory.content.length - 1 + app.commandHistory.position) % app.commandHistory.content.length;
                    input.value = app.commandHistory.content[app.commandHistory.position];
                }
            } else if (event.key === 'DownUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.content.push(input.value);
                }
                app.commandHistory.position = (app.commandHistory.content.length + 1 + app.commandHistory.position) % app.commandHistory.content.length;
                input.value = app.commandHistory.content[app.commandHistory.position];
            }
        }

        const view = new SVGView('process-view', 'Process View');

        function updateView() {
            // Remove deleted items
            for (const [item, nodes] of view.map.entries()) {
                if (item.deleted) {
                    nodes.forEach((node) => node.remove(node));
                    view.map.delete(item);
                }
            }

            let cx = 20;
            let cy = 20;
            for (const input of app.model.inputs) {
                const [product, state] = input;
                const port = view.map.get(input);
                const fill = state.content.length > 0 ? 'green' : 'white';
                if (port) {
                    port.setAttribute('fill', fill);
                } else {
                    const port = view.add('circle', null, { cx, cy, r: 10, fill, stroke: 'black' });
                    const title = view.add('title', port, {}, `${product.name} (${state.content})`);
                    view.map.set(input, [port, title]);
                }
                cy += 50;
            }

            let x = 50;
            let y = 30;
            const width = 100;
            const horizontalSpace = 100;
            const height = 50;
            const verticalSpace = 30;
            app.model.activities.forEach((activity) => {
                const classes = app.selected.has(activity) ? ['selected'] : [];
                const nodes = view.map.get(activity) || [view.add('rect', null, { width, height, rx: 5, ry: 5, fill: 'white', stroke: 'black' }, null, classes)];
                nodes[0].addEventListener('click', (event) => {
                    if (app.selected.has(activity)) {
                        app.selected.delete(activity);
                        nodes[0].classList.remove('selected');
                    } else {
                        app.selected.add(activity);
                        nodes[0].classList.add('selected');
                    }
                    updateSelected();
                });

                nodes[0].setAttribute('x', x);
                nodes[0].setAttribute('y', y);
                if (nodes.length === 1) {
                    const label = view.add('text', null, { x: x + width / 2, y: y + 15, 'text-anchor': 'middle' }, activity.name);
                    nodes.push(label);
                } else {
                    nodes[1].innerHTML = activity.name;
                }
                const step = (height - 10) / activity.inputs.size;
                let iy = 10 + y + step / 2;
                for (const input of activity.inputs) {
                    const [product, state] = input;
                    const port = view.map.get(input) || view.add('circle', null, { cx: x, cy: iy, r: 5, fill: 'white', stroke: 'black' });
                    view.map.set(input, [port]);
                    view.add('title', port, {}, `${product.name} (${state.current}/${state.required})`);
                    iy += step;
                }

                y += height + verticalSpace;
                if (y + 50 > 500) {
                    y = 10;
                    x += width + horizontalSpace;
                }
                view.map.set(activity, nodes);
            });

            for (const link of app.model.links) {
                const nodes = view.map.get(link);
                const edge = nodes[0];
                const start = view.map.get(link.source)[0];
                const end = view.map.get(link.destination)[0];
                if (start && end) {
                    const x1 = start.cx;
                    const y1 = start.cy;
                    const x2 = end.cx;
                    const y2 = end.cy;
                    const mx = (x1 + x2) / 2;
                    const d = `M ${x1} ${y1} C ${xm} ${y1} ${xm} ${y2} ${x2} ${y2}`;
                    if (!edge) {
                        const edge = view.add('path', null, { d, fill: 'none', stroke: 'black' });
                        //const title = view.add('title', edge, {}, `${product.name} (${state.content})`);
                        view.map.set(link, [edge]);
                    } else {
                        edge.setAttribute('d', d);
                    }
                }
            }
        }

        /**
         * Update the list of selected items.
         */
        function updateSelected() {
            const node = document.getElementById('selection');
            node.innerHTML = '';
            const list = document.createElement('ul');
            node.append(list);
            for (let element of app.selected) {
                const item = document.createElement('li');
                item.innerHTML = element.name;
                list.append(item);
                item.addEventListener('click', (event) => {
                    if (app.selected.has(element)) {
                        app.selected.delete(element);
                        updateSelected();
                    }
                });
            }
        }

        loadLocal();
        updateView();

        const input = document.getElementById('command-input');
        //input.addEventListener('change', processCommand);
        input.addEventListener('keydown', processKey);

        //updateCommandList();



        input.focus();
    </script>
</body>

</html>
