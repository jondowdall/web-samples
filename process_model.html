<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Process</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
            font-size: 10pt;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            width: 100dvw;
            height: 100dvh;
            overflow: hidden;
            display: grid;
            grid-template-columns: max-content 1fr;
        }

        table,
        th,
        td {
            border-collapse: collapse;
            border: 1px solid gray;
        }

        th,
        td {
            padding: 2px 5px;
        }

        #product-list {
            background-color: lightblue;
        }

        #command-input {
            position: fixed;
            top: 1em;
            left: 50%;
            transform: translateX(-50%);
            min-width: 20em;
            padding: 0.2em 0.5em;
            outline: none;
            border: 1px solid gray;
            border-radius: 1em;
            background: white;
            box-shadow: 2px 3px 5px #333;
        }


        #process-view {
            width: 100%;
            height: 100%;
        }

        #output {
            position: fixed;
            bottom: 1em;
            right: 1em;
            width: 30vw;
            height: 20vh;
            background-color: lightgray;
            border-radius: 0.5em;
            padding: 0.5em;
            border: 2px inset white;
        }

        #selection-window {
            position: fixed;
            display: flex;
            flex-direction: column;
            top: 3em;
            right: 1em;
            width: 30vw;
            height: 20vh;
            color: antiquewhite;
            background-color: rgb(30, 30, 30, 0.8);
            border-radius: 0.5em;
            /*padding: 0.5em;*/
            border: 2px inset white;
        }

        #selection {
            background-color: rgb(150, 150, 150, 0.9);
            width: 100%;
            height: 100%;
        }

        .window>h2 {
            padding: 0.5em;
            margin: 0;
        }

        .selected {
            stroke: yellow;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }
    </style>
</head>

<body>
    <div id="product-list"></div>
    <svg id="process-view"></svg>

    <div id="selection-window" class="window">
        <h2>Selection</h2>
        <div id="selection">

        </div>
    </div>
    <div id="output">Hello<br></div>

    <datalist id="command-list"></datalist>
    <input id="command-input" type="text" list="command-list" autocorrect="off" autocapitalize="off" />

    <script>
        /**
         * SVGView component
         */
        class SVGView {
            static ns = 'http://www.w3.org/2000/svg';
            static namedArributes = Symbol('named attributes');
            constructor(id, title) {
                this.svg = document.getElementById(id);
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
                //this.svg.setAttribute("viewBox", "0 0 2000 2000");
                this.title = title || 'SVG Diagram';
                this.map = new Map();
            }
            get width() {
                return this.svg.clientWidth;
            }
            get height() {
                return this.svg.clientHeight;
            }
            make(type, attributes, content, classes) {
                const element = document.createElementNS(SVGView.ns, type);
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);
                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                if (content) {
                    element.append(content);
                }
                if (classes) {
                    element.classList.add(...classes)
                }
                return element;
            }
            add(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.appendChild(element);
                return element;
            }
            addUnder(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.insertBefore(element, parent.firstElementChild);
                return element;
            }
            updateElement(element, attributes) {
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);

                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                return element
            }
        }
    </script>

    <script>
        /**
         * Generate a V4 UUID
         */
        function uuidv4() {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }
    </script>


    <script>
        // States
        const ready = Symbol('ready');
        const waiting = Symbol('waiting');
        const running = Symbol('running');
        const blocked = Symbol('blocked');
        const paused = Symbol('paused');

        // Activity mode
        const asap = Symbol('asap');
        const onDemand = Symbol('on demand');

        // Simulation mode
        const byTime = Symbol('by time');
        const byEvent = Symbol('by event');


        // Ensure parent links aren't serialised by using a symbol
        const parent = Symbol('parent');
        const id = Symbol('id');

        /**
         * Evaluate a string to the canonical representation.
         */
        function resolve(str) {
            try {
                const func = new Function(`return ${str};`);
                return func();
            } catch (error) {
                appendLine(error.message);
            }
            return str;
        }

        /**
         * Parse the parameters of a command
         */
        function parseParameters(str) {
            let state;
            const parameters = [];
            let parameter = [];
            const states = {
                plainParameter: {
                    parse(char) {
                        if ([' ', '\t'].includes(char)) {
                            return states.whiteSpace;
                        } else {
                            parameter.push(char);
                        }
                        return this;
                    }
                },
                whiteSpace: {
                    parse(char) {
                        if (char === '"') {
                            parameter = [];
                            parameters.push(parameter);
                            return states.quotedParameter;
                        }
                        if (![' ', '\t'].includes(char)) {
                            parameter = [char];
                            parameters.push(parameter);
                            return states.plainParameter;
                        }
                        return this;
                    }
                },
                quotedParameter: {
                    parse(char) {
                        if (char === '"') {
                            return states.whiteSpace;
                        }
                        parameter.push(char);
                        return this;
                    }
                }
            }
            state = states.whiteSpace;
            for (let i = 0; i < str.length; ++i) {
                state = state.parse(str[i]);
            }
            return parameters.map((chars) => chars.join(''));
        }


        /**
         * An instance of a product.
         */
        class Asset {
            static create(attributes) {
                const asset = new Asset(attributes.product);
                Object.assign(asset, attributes);
                asset[id] = attributes.id;
                return asset;
            }
            constructor(product) {
                this[id] = uuidv4();
                this.product = product;
                this.product.instances?.add(this);
            }
        }

        class Product {
            static all = [];
            static create(attributes) {
                if (attributes.name === undefined) {
                    let index = 1;
                    while (Product.all.find((item) => item.id === `Product ${index}`)) {
                        index += 1;
                    }
                    attributes.name = `Product ${index}`;
                }

                const product = new Product(attributes.product);
                Object.assign(product, attributes);
                product[id] = attributes.id;
                return product;
            }
            static get(name) {
                return Product.all.find((existing) => existing.name === name) || new Product(name);
            }
            constructor(name, instances = []) {
                this.name = name;
                this[id] = uuidv4();
                this.instances = new Set(instances);
                Product.all.push(this);
            }
        }

        class Source {
            static create(attributes) {
                const source = new Source(attributes.content);
                source[id] = attributes.id;
                return source;
            }
            constructor(content) {
                this.content = content;
                this[id] = uuidv4();
            }
            get available() {
                return this.content.length;
            }
            get(quantity = 1) {
                quantity = Math.min(quantity, this.content.length);
                return this.content.splice(0, quantity);
            }
        }

        class Port {
            static create(attributes) {
                const port = new Port(attributes.name, attributes.capacity, attributes.content);
                port[id] = attributes.id;
                return port;
            }
            constructor(product, capacity = 1, content = [], uuid) {
                this.product = product;
                this.capacity = capacity;
                this.content = content;
                this[id] = uuid || uuidv4();
            }
            store(item) {
                if (item.type !== this.product) {
                    appendLine(`Warning: Failed to store ${item.name} - item is not required type ${this.product.name}`);
                    return;
                }
                if (this.content.length >= this.capacity) {
                    appendLine(`Warning: Failed to storing ${item.name} - port is full`);
                    return;
                }
                this.content.push(item);
            }
        }

        class Input extends Port {
            static all = [];
            static create(attributes) {
                const input = new Input(attributes.name, attributes.capacity, attributes.content, attributes.required, attributes.id);
                return input;
            }
            constructor(product, capacity = 1, content = [], required = 1, uuid) {
                super(product, capacity, content, uuid);
                this.required = required;
                Input.all.push(this);
            }
            get available() {
                if (this.link) {
                    return this.content.length + this.link.from.available;
                }
                return this.content.length;
            }
        }

        class Output extends Port {
            static all = [];
            static create(attributes) {
                const output = new Output(attributes.name, attributes.capacity, attributes.content, attributes.required, attributes.id);
                return output;
            }
            constructor(product, capacity = 1, content = [], required = 1, uuid) {
                super(product, capacity, content, uuid);
                this.required = required;
                Output.all.push(this);
            }
        }

        class Process {
            static create(attributes) {
                const process = new Process(attributes.name);
                process.inputs = new Map(attributes.inputs);
                process.outputs = new Map(attributes.outputs);
                process[id] = attributes.id;
                return process;
            }
            constructor(name) {
                this.name = name;
                this[id] = uuidv4();
            }
        }

        class Activity {
            static all = [];
            static create(attributes) {
                const activity = new Activity(attributes.name);
                activity.inputs = new Map(attributes.inputs);
                activity.outputs = new Map(attributes.outputs);
                activity.duration = attributes.duration;
                activity[id] = attributes.id || uuidv4();
                return activity;
            }
            constructor(name) {
                this[id] = uuidv4();
                this.name = name;
                this.state = ready;
                this.duration = 1 * 60 * 60 * 1000;
                this.inputs = new Map();
                this.outputs = new Map();
                Activity.all.push(this);
            }
            addInput(product, quantity = 1) {
                const state = this.inputs.get(product);
                if (state) {
                    state.required = quantity;
                } else {
                    const input = new Input(product, 1, [], quantity);
                    input[parent] = this;
                    this.inputs.set(product, input);
                }
                appendLine(`Added product ${product.name} as input to ${this.name}`);
                if (quantity === 0) {
                    this.inputs.delete(product);
                }
            }
            addOutput(name, quantity = 1) {
                const product = Product.get(name);
                const state = this.outputs.get(product);
                if (state) {
                    state.provides = quantity;
                } else {
                    const output = new Output(product, 1, [], quantity);
                    this.outputs.set(product, output);
                    app.model.all.push(output);
                }
                appendLine(`Added product ${name} as input to ${this.name}`);
                if (quantity === 0) {
                    this.outputs.delete(product);
                }
            }
            getRemaining() {
                return getDurationString(this.duration - (app.simulation.now - this.start));
            }
            getStateDescription() {
                const inputs = Array.from(this.inputs.values());
                return {
                    [ready]: `Ready`,
                    //[waiting]: `Waiting for ${inputs.filter((input) => input.available < input.required).map((input) => input.product.name).join(', ')}`,
                    [waiting]: `Waiting for ${inputs.reduce((sum, input) => sum + (input.required - input.available > 0 ? input.required - input.available : 0), 0)}`,
                    [running]: `Running (${this.getRemaining()} to go)`,
                    [blocked]: `Blocked`,
                    [paused]: `Paused`,
                }[this.state];
            }
        }

        /**
         * Convert a duration in milliseconds into a string.
         */
        function getDurationString(duration) {
            const ms = duration - 1000 * (Math.floor(duration / 1000));
            const s = Math.floor((duration - (60 * 1000 * Math.floor(duration / (60 * 1000)))) / 1000);
            const m = Math.floor((duration - (60 * 60 * 1000 * Math.floor(duration / (60 * 60 * 1000)))) / (60 * 1000));
            const h = Math.floor((duration - (24 * 60 * 60 * 1000 * Math.floor(duration / (24 * 60 * 60 * 1000)))) / (60 * 60 * 1000));
            const result = [];
            const append = (value, unit) => {
                if (value > 1) {
                    result.push(`${value} ${unit}s`);
                } else if (value > 0) {
                    result.push(`${value} ${unit}`);
                }
            };

            append(h, 'hour');
            append(m, 'minute');
            append(s, 'second');
            append(ms, 'millisecond');
            if (result.length > 1) {
                result.splice(result.length - 1, 0, 'and');
            }
            return result.join(' ');
        }


        class Link {
            static create(attributes) {
                const link = new Link(attributes.from, attributes.to);
                link[id] = attributes.id;
                return link;
            }
            constructor(from, to) {
                this[id] = uuidv4();
                this.from = from;
                this.to = to;
            }
        }


        const app = {
            model: {
                name: 'model',
                all: [],
                ids: {},
                get processes() { return this.all.filter((item) => item instanceof Process) },
                get activities() { return this.all.filter((item) => item instanceof Activity) },
                get products() { return Product.all; },
                inputs: new Map(),
                outputs: new Map(),
                links: [],

                addItem(item, replace = false) {
                    const pos = this.all.findIndex((existing) => existing.name === item.name);
                    if (pos !== -1) {
                        if (replace) {
                            this.all.splice(pos, 1, item);
                        } else {
                            appendLine(`Warning: ${this.all[pos].name} already exists in the model`);
                        }
                    } else {
                        this.all.push(item);
                    }
                },

                addActivity(name) {
                    if (name === undefined) {
                        let index = 1;
                        while (this.all.find((item) => (item instanceof Activity) && item.id === `Activity ${index}`)) {
                            index += 1;
                        }
                        name = `Activity ${index}`;
                    }
                    const activity = Activity.create({ name });
                    this.all.push(activity);
                    return activity;
                },
                addInput(product, quantity = 0) {
                    const input = this.inputs.get(product);
                    if (input) {
                        input.content += parseInt(quantity);
                        this.links.filter((link) => link.start === input)
                            .forEach((link) => link.end.update());
                    } else {
                        const content = Array(5).fill(1, 0, quantity).map((i) => new Asset(product));
                        const input = new Source(content);
                        this.inputs.set(product, input);
                        this.all.push(input);
                    }
                },
                addOutput(name, quantity = 0) {
                    const product = Product.get(name);
                    const output = this.outputs.get(product);
                    if (output) {
                        output.content += parseInt(quantity);
                        this.links.filter((link) => link.start === input)
                            .forEach((link) => link.end.update());
                    } else {
                        const content = Array(5).fill(1, 0, quantity).map((i) => ({ product }));
                        this.outputs.set(product, { content });
                    }
                },
                toJSON() {
                    return {
                        all: this.all,
                        inputs: this.inputs,
                        outputs: this.outputs,
                        links: this.links,
                    };
                }
            },
            simulation: {
                state: paused,
            },

            selected: new Set(),
            commandHistory: {
                position: -1,
                content: [],
            },
        };

        /**
         * Find an object by it's id.
         */
        function byId(id) {
            return app.model.ids[id];
            return app.model.all.find((item) => item.id === id) ||
                app.model.inputs.values().find((item) => item.id === id) ||
                app.model.outputs.values().find((item) => item.id === id);
        }

        /**
         * Find an object by it's name.
         */
        function byName(name) {
            const item = app.model.all.find((item) => item.name === name);
            return item;
        }

        /**
         * Manage serialisation and de-serialisation.
         */

        function serialise(item) {
            const serialised = new Set();
            const replacer = (key, value) => {
                if (!value) {
                    return value;
                }
                if (value[id]) {
                    if (serialised.has(value[id])) {
                        return { ref: value[id] };
                    }
                    serialised.add(value[id]);
                }
                if (value instanceof Map) {
                    return {
                        dataType: 'Map',
                        value: Array.from(value.entries()), // or with spread: value: [...value]
                    };
                } else if (value instanceof Set) {
                    return {
                        dataType: 'Set',
                        value: Array.from(value),
                    };
                }

                if (['Product', 'Asset', 'Process', 'Port', 'Input', 'Activity', 'Link', 'Input', 'Output', 'Source'].includes(value.constructor.name)) {
                    return {
                        dataType: value.constructor.name,
                        value: Object.assign({}, value, { id: value[id], [id]: undefined }),
                    };
                } else if (value[id]) {
                    return Object.assign({}, value, { id: value[id], [id]: undefined });
                }
                return value;
            }
            return JSON.stringify(item, replacer, 2);
        }

        function deserialise(str) {
            const datePattern = /[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{1,4}Z/
            const references = new Map();
            const reviver = (key, value) => {
                if (value && value.ref && references.has(value.ref)) {
                    return references.get(value.ref);
                }
                if (datePattern.test(value)) {
                    return Date.parse(value);
                }
                if (typeof value === 'object' && value !== null) {
                    if (value.dataType === 'Map') {
                        return new Map(value.value);
                    } else if (value.dataType === 'Set') {
                        return new Set(value.value);
                    } else if (value.dataType === 'Date') {
                        return new Date(value.value);
                    } else if (value.dataType) {
                        const element = {
                            Product, Asset, Process, Port, Input, Activity, Link, Input, Output, Source,
                        }[value.dataType].create(value.value);
                        if (element[id]) {
                            references.set(element[id], element);
                        }
                        return element;
                    }
                }

                return value;
            }
            return JSON.parse(str, reviver);
        }


        /**
         * Utility function to support downloading generated content.
         */
        function saveText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Utility function to support loading a file.
         */
        function load() {
            const tempNode = document.createElement('input');
            tempNode.type = 'file';
            tempNode.accept = '.json';
            tempNode.addEventListener('cancel', () => {
                console.log('Cancelled.');
            });

            function loadFile(file) {
                const reader = new FileReader();
                reader.addEventListener('load', (event) => {
                    const filename = file.name;
                    try {
                        app.model = deserialise(reader.result);
                        appendLine(`Loaded ${filename}`);
                    } catch (error) {
                        appendLine(error.message);
                    }
                });
                reader.readAsText(file);
            }

            tempNode.addEventListener('change', () => {
                if (tempNode.files.length === 1) {
                    console.log('File selected: ', tempNode.files[0]);
                    for (let i = 0; i < tempNode.files.length; ++i) {
                        loadFile(tempNode.files[i]);
                    }
                }
            });
            tempNode.click();
        }


        /**
         * Utility function to support downloading generated content.
         */
        function download(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Common Functions for use by commands
         */

        /**
         * Reset the parse
         */
        function reset() {
            this.chars = this.name.split('');
            return this;
        }

        /**
         * Check the next character against the command
         */
        function parse(i) {
            return this.chars.length === 0 || this.chars.shift() === i;
        }

        /**
         * Add a list to the output
         */
        function appendLine(line) {
            const output = document.getElementById('output');
            output.append(line, document.createElement('br'));
        }

        /**
         * Add a list to the output
         */
        function showList(list) {
            const output = document.getElementById('output');
            output.append(...list.flatMap((item) => [item, document.createElement('br')]));
        }


        /**
         * Load the current state from local storage
         */
        function loadLocal() {
            const stateStr = localStorage.getItem('process-model');

            if (stateStr) {
                const state = deserialise(stateStr);
                app.model.all.push(...state.model.all);
                app.model.inputs = state.model.inputs || new Map();
                app.model.outputs = state.model.outputs || new Map();

                /*
                app.model.inputs.values().forEach((input) => input.id = input.id || uuidv4());
                app.model.outputs.values().forEach((output) => output.id = output.id || uuidv4());
                */

                app.model.links = state.model.links.filter((link) => link.from !== undefined && link.to !== undefined);
                if (state.history) {
                    app.commandHistory.position = state.history.position;
                    app.commandHistory.content = state.history.content;
                }
            }
        }

        /**
         * load the current state to local storage
         */
        function saveLocally() {
            const state = {
                model: app.model,
                history: app.commandHistory,
            };

            const str = serialise(state);
            localStorage.setItem('process-model', str);
        }

        /**
         * User commands that can be used in the input box.
         */
        const commands = [
            {
                name: 'load',
                action(str) {
                    load();
                },
                reset,
                parse,
            },
            {
                name: 'save',
                action(str) {
                    saveText(serialise(app.model), 'process_model.json');
                },
                reset,
                parse,
            },
            {
                name: 'clear',
                action(str) {
                    const output = document.getElementById('output');
                    output.innerHTML = '';
                },
                reset,
                parse,
            },
            {
                name: 'add process',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    app.model.processes.push({ name });
                    app.selected.add(app.model.processes.at(-1));

                    appendLine(`Added process: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'processes',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0].trim();
                    if (pattern === '') {
                        showList(app.model.processes.map((process) => process.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.processes.filter((process) => expr.test(process.name))
                            .map((process) => process.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add activity',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.selected.add(app.model.addActivity(...parameters));
                    appendLine(`Added activity: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'activities',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0].trim();
                    if (pattern === '') {
                        showList(app.model.activities.map((activity) => activity.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.activities.filter((activity) => expr.test(activity.name))
                            .map((activity) => activity.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add input',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [productName, quantity] = parameters;
                    const product = Product.get(productName);
                    if (app.selected.size > 0) {
                        for (const item of app.selected) {
                            if (item.addInput) {
                                item.addInput(product, quantity);
                                appendLine(`Added input of ${product.name} to ${item.name}`);
                            }
                        }
                    } else {
                        app.model.addInput(product, quantity);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add source',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [productName, quantity] = parameters;
                    const product = Product.get(productName);
                    app.model.addInput(product, quantity);
                },
                reset,
                parse,
            },
            {
                name: 'inputs',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    for (const item of app.selected) {
                        appendLine(item.name);
                        for (const [product, state] of item.inputs) {
                            appendLine(`  ${product.name} ${state.current}/${state.required}`);
                        }
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add output',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [product, quantity] = parameters;
                    if (app.selected.size > 0) {
                        for (const item of app.selected) {
                            if (item.addOutput) {
                                item.addOutput(product, quantity);
                                appendLine(`Added output of ${product} to ${item.name}`);
                            }
                        }
                    } else {
                        app.model.addOutput(product, quantity);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add product',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    const product = Product.create({ name });
                    app.model.addItem(product);
                    app.selected.add(product);

                    appendLine(`Added product: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'products',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.model.products.map((product) => product.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'join',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    const product = app.model.products.find((product) => product.name === name);
                    if (product) {
                        const from = app.model.inputs.get(product);
                        if (from) {
                            for (const item of app.selected) {
                                if (item.inputs) {
                                    const to = item.inputs.get(product);
                                    if (to) {
                                        app.model.links.push(new Link(from, to));
                                    }
                                }
                            }
                        }
                    }
                },
                reset,
                parse,
            },
            {
                name: 'links',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.model.links.map((link) => `${link.source.name} -> ${link.destination.name}`));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'delete',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        for (const item of app.selected) {
                            app.model.processes = app.model.processes.filter((process) => process !== item);
                            app.model.activities = app.model.activities.filter((activity) => activity !== item);
                            app.model.products = app.model.products.filter((product) => product !== item);
                            app.model.links = app.model.links.filter((link) => link.source !== item && link.destination !== item);
                            item.deleted = true;
                            appendLine(`${item.name} deleted`);
                        }
                        app.selected.clear();
                    } else {
                    }
                },
                reset,
                parse,
            },
            {
                name: 'update',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    updateView();
                },
                reset,
                parse,
            },
            {
                name: 'draw',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        if (app.selected.size > 0) {
                            draw(app.selected);
                        } else {
                            draw([...app.model.processes, ...app.model.activities, ...app.model.products, ...app.model.links]);
                        }
                    } else {

                    }
                },
                reset,
                parse,
            },
            {
                name: 'none',
                action(str) {
                    app.selected.clear();
                },
                reset,
                parse,
            },
            {
                name: 'set',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (parameters.length === 2) {
                        const [attribute, str] = parameters;
                        const value = resolve(str);
                        app.selected.forEach((item) => item[attribute] = value);
                    } else if (parameters.length > 2) {
                        const value = resolve(parameters.pop());
                        const attribute = parameters.pop();
                        const items = parameters.flatMap((str) => {
                            const pattern = new RegExp(str);
                            return app.model.all.filter((item) => pattern.test(item.name));
                        });
                        items.forEach((item) => item[attribute] = value);
                    }
                    app.selected.clear();
                },
                reset,
                parse,
            },
            {
                name: 'selected',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.selected.map((item) => item.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.selected.filter((item) => expr.test(item.name))
                            .map((item) => item.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'commands',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(commands.map((command) => command.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(commands.filter((command) => expr.test(command.name))
                            .map((command) => command.name));
                    }
                },
                reset,
                parse,
            },
        ];

        /**
         * Update the command list for completions.
         */
        function updateCommandList() {
            const commandList = document.getElementById('command-list');
            commandList.innerHTML = commands.map((command) => `<option>${command.name}</option>`).join('');
        }


        /**
         * Handle a command entered in the input box.
         */
        function processCommand(event) {
            const input = document.getElementById('command-input');

            let validCommands = commands.map((command) => command.reset());
            const command = input.value.split('');

            const parse = (i) => validCommands = validCommands.filter((command) => command.parse(i));

            while (validCommands.length > 0 && command.length > 0) {
                parse(command.shift());
            }
            if (validCommands.length === 1) {
                validCommands[0].action(input.value);
            } else if (input.value.startsWith('$')) {
                try {
                    const func = new Function('app', '_', `return ${input.value.slice(1)};`);
                    appendLine(func(app, byName));
                } catch (error) {
                    appendLine(`Error: ${error.message}`);
                }
            } else {
                const pattern = new RegExp(input.value);
                const items = app.model.all.filter((item) => pattern.test(item.name));

                if (items.length > 0) {
                    items.forEach((item) => {
                        if (app.selected.has(item)) {
                            app.selected.delete(item);
                            appendLine(`Deselected ${item.name}`);
                        } else {
                            app.selected.add(item);
                            appendLine(`Selected ${item.name}`);
                        }
                    });

                } else {
                    appendLine(`Warning: unrecognised input "${input.value}"`);
                }
            }

            if (event.ctrlKey) {
                app.commandHistory.content[app.commandHistory.position++] = input.value;
                input.value = app.commandHistory.content[app.commandHistory.position] || '';
            } else if (event.shiftKey) {
                input.value = '';
                app.commandHistory.position = -1;
            } else {
                app.commandHistory.content.push(input.value);
                app.commandHistory.position = -1;
                input.value = '';
            }
        }


        /**
         * Validate the content of the input box.
         */
        function processKey(event) {
            const input = document.getElementById('command-input');

            if (event.key === 'Enter') {
                processCommand(event);
                updateView();
                saveLocally();
                updateSelected();
            } else if (event.key === 'Escape') {
                document.body.focus();
            } else if (event.key === 'ArrowUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.position = app.commandHistory.content.length - 1;
                    app.commandHistory.content.push(input.value);
                    input.value = app.commandHistory.content[app.commandHistory.position];
                } else {
                    app.commandHistory.position = (app.commandHistory.content.length - 1 + app.commandHistory.position) % app.commandHistory.content.length;
                    input.value = app.commandHistory.content[app.commandHistory.position];
                }
            } else if (event.key === 'DownUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.content.push(input.value);
                }
                app.commandHistory.position = (app.commandHistory.content.length + 1 + app.commandHistory.position) % app.commandHistory.content.length;
                input.value = app.commandHistory.content[app.commandHistory.position];
            }
        }

        const view = new SVGView('process-view', 'Process View');

        function updateView() {
            updateProductList();
            // Remove deleted items
            for (const [item, representation] of view.map.entries()) {
                if (item.deleted) {
                    representation.nodes.forEach((node) => node.remove(node));
                    view.map.delete(item);
                }
            }

            let x = 10;
            let y = 20;
            const textAttrs = { x: 10, y: 20, fill: 'black', stroke: 'none', 'text-anchor': 'start', 'alignment-baseline': 'middle' };
            const representations = [];
            for (const input of app.model.inputs) {
                const [product, state] = input;
                const representation = view.map.get(input);
                const fill = state.content.length > 0 ? 'lightgreen' : 'white';
                if (representation) {
                    representation.nodes[0].setAttribute('fill', fill);
                    representations.push(representation);
                    representation.text.innerHTML = product.name;
                    representation.bbox = text.getBBox();
                } else {
                    const outline = view.add('path', null, { fill, stroke: 'black' });
                    const title = view.add('title', outline, {}, `${product.name} (${state.content.length})`);

                    const text = view.add('text', null, textAttrs, `${product.name}`);
                    const textTitle = view.add('title', text, {}, `${product.name} (${state.content.length})`);

                    const representation = { nodes: [outline, title, text, textTitle], bbox: text.getBBox() };
                    representations.push(representation);
                    view.map.set(state, representation);
                }
                textAttrs.y += 50;
            }

            const textWidth = Math.max(0, ...representations.map((representation) => representation.bbox.width));
            const textHeight = Math.max(0, ...representations.map((representation) => representation.bbox.height));

            representations.forEach((representation, index) => {
                const x = 10 - textHeight / 2;
                const y = 20 + index * 50 - textHeight / 2;
                const d = `M ${x} ${y} h ${textWidth + textHeight} l ${textHeight / 2} ${textHeight / 2} l ${-textHeight / 2} ${textHeight / 2} h ${-textWidth - textHeight} z`;
                representation.nodes[0].setAttribute('d', d);
                representation.x = x;
                representation.y = y;
                representation.width = textWidth + textHeight * 1.5;
                representation.height = textHeight;
            });

            x = textWidth + textHeight + 50;
            y = 30;
            const width = 100;
            const horizontalSpace = 100;
            const height = 50;
            const verticalSpace = 30;
            app.model.activities.forEach((activity) => {
                const classes = app.selected.has(activity) ? ['selected'] : [];
                const representation = view.map.get(activity) ||
                    { nodes: [view.add('rect', null, { width, height, rx: 5, ry: 5, fill: 'white', stroke: 'black' }, null, classes)] };

                representation.nodes[0].setAttribute('x', x);
                representation.nodes[0].setAttribute('y', y);

                if (representation.nodes.length === 1) {
                    representation.nodes[0].addEventListener('click', (event) => {
                        if (app.selected.has(activity)) {
                            app.selected.delete(activity);
                            representation.nodes[0].classList.remove('selected');
                        } else {
                            app.selected.add(activity);
                            representation.nodes[0].classList.add('selected');
                        }
                        updateSelected();
                    });
                    const label = view.add('text', null, { x: x + width / 2, y: y + 15, 'text-anchor': 'middle' }, activity.name);
                    const title = view.add('title', representation.nodes[0], {}, activity.getStateDescription());
                    representation.nodes.push(label, title);
                } else {
                    representation.nodes[1].innerHTML = activity.name;
                    representation.nodes[1].setAttribute('x', x + width / 2);
                    representation.nodes[1].setAttribute('y', y + 15);
                    representation.nodes[2].innerHTML = activity.getStateDescription();
                }
                const step = (height - 10) / activity.inputs.size;
                let iy = 10 + y + step / 2;
                for (const input of activity.inputs) {
                    const [product, state] = input;
                    const representation = view.map.get(state) || {
                        nodes: [view.add('circle', null, { r: 5, fill: 'white', stroke: 'black' })],
                    };
                    representation.nodes[0].setAttribute('cx', x);
                    representation.nodes[0].setAttribute('cy', iy);
                    view.map.set(state, representation);
                    representation.x = x - 5;
                    representation.y = iy - 5;
                    representation.width = 10;
                    representation.height = 10;

                    view.add('title', representation.nodes[0], {}, `${product.name} (${state.content.length}/${state.required})`);
                    iy += step;
                }

                const oStep = (height - 10) / activity.outputs.size;
                let oy = 10 + y + oStep / 2;

                for (const output of activity.outputs) {
                    const [product, state] = output;
                    const representation = view.map.get(state) || {
                        nodes: [view.add('circle', null, { cx: x + width, cy: oy, r: 5, fill: 'white', stroke: 'black' })]
                    };
                    view.map.set(state, representation);
                    representation.x = x + width - 5;
                    representation.y = oy - 5;
                    representation.width = 10;
                    representation.height = 10;

                    view.add('title', representation.nodes[0], {}, `${product.name} (${state.content.length})`);
                    oy += oStep;
                }

                y += height + verticalSpace;
                if (y + 50 > 500) {
                    y = 10;
                    x += width + horizontalSpace;
                }
                view.map.set(activity, representation);
            });

            for (const link of app.model.links) {
                const representation = view.map.get(link);
                const start = view.map.get(link.from);
                const end = view.map.get(link.to);
                if (start && end) {
                    const x1 = start.x + start.width;
                    const y1 = start.y + start.height / 2;
                    const x2 = end.x;
                    const y2 = end.y + end.height / 2;
                    const mx = (x1 + x2) / 2;
                    const d = `M ${x1} ${y1} C ${mx} ${y1} ${mx} ${y2} ${x2} ${y2}`;
                    if (!representation) {
                        const edge = view.addUnder('path', null, { d, fill: 'none', stroke: 'black' });
                        view.map.set(link, { nodes: [edge] });
                    } else {
                        representation.nodes[0].setAttribute('d', d);
                    }
                }
            }
        }

        /**
         * Update the table of products
         */
        function updateProductList() {
            const container = document.getElementById('product-list');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>Index</th><th>Name</th><th>Qty</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            Product.all.forEach((product, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${index}</td><td>${product.name}</td><td>${product.instances.size}</td>`;
                body.append(row);
            });
        }


        /**
         * Update the list of selected items.
         */
        function updateSelected() {
            const node = document.getElementById('selection');
            node.innerHTML = '';
            const list = document.createElement('ul');
            node.append(list);
            for (let element of app.selected) {
                const item = document.createElement('li');
                item.innerHTML = element.name;
                list.append(item);
                item.addEventListener('click', (event) => {
                    if (app.selected.has(element)) {
                        app.selected.delete(element);
                        updateSelected();
                    }
                });
            }
        }

        loadLocal();
        updateView();

        const input = document.getElementById('command-input');
        //input.addEventListener('change', processCommand);
        input.addEventListener('keydown', processKey);

        //updateCommandList();

        input.focus();
    </script>
</body>

</html>
