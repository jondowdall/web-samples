<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Process</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
            font-size: 10pt;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            width: 100dvw;
            height: 100dvh;
            overflow: hidden;
            display: grid;
            grid-template-columns: max-content 1fr;
        }

        table,
        th,
        td {
            border-collapse: collapse;
            border: 1px solid gray;
        }

        th,
        td {
            padding: 2px 5px;
        }

        #side-bar {
            background-color: lightblue;
            padding: 0.5em;
        }

        #side-bar table {
            background: white;
        }

        #side-bar th {
            background-color: lightgray;
            font-weight: bold;
        }

        /*
        #product-list {
            background-color: lightblue;
        }
*/
        #command-input {
            position: fixed;
            top: 1em;
            left: 50%;
            transform: translateX(-50%);
            min-width: 20em;
            padding: 0.2em 0.5em;
            outline: none;
            border: 1px solid gray;
            border-radius: 1em;
            background: white;
            box-shadow: 2px 3px 5px #333;
        }


        #process-view {
            width: 100%;
            height: 100%;
        }

        #state {
            position: fixed;
            bottom: 1em;
            right: 1em;
            width: 30vw;
            height: 20vh;
            background-color: lightgray;
            border-radius: 0.5em;
            padding: 0.5em;
            border: 2px inset white;
            display: grid;
            grid-template-rows: 1fr max-content;
            overflow: hidden;
        }

        #output {
            overflow: auto;
        }

        #selection-window {
            position: fixed;
            display: flex;
            flex-direction: column;
            top: 3em;
            right: 1em;
            min-width: 10em;
            /*height: 20vh; */
            color: antiquewhite;
            background-color: rgb(30, 30, 30, 0.8);
            border-radius: 0.5em;
            /*padding: 0.5em;*/
            border: 2px inset white;
        }

        #selection {
            background-color: rgb(150, 150, 150, 0.9);
            width: 100%;
            height: 100%;
            padding: 0.5em;
        }

        #selection-window ul {
            padding-inline-start: 1em;
        }

        #bin {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            font-size: 400%;
        }

        .window>h2 {
            padding: 0.5em;
            margin: 0;
        }

        .unused {
            background-color: gray;
        }

        svg {
            background-color: lavender;
        }

        .selected {
            stroke: yellow;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5)) drop-shadow(0 0 5px yellow);
        }

        .running {
            stroke-dasharray: 4 4;
            stroke-dashoffset: 8;
            animation: drawPath 1s infinite;
            /* Apply the animation */
        }

        @keyframes drawPath {
            to {
                stroke-dashoffset: 0;
                /* Animate to show the path */
            }
        }
    </style>
</head>

<body>
    <div id="side-bar">
        <h3>Products:</h3>
        <div id="product-list"></div>
        <h3>Assets:</h3>
        <div id="asset-list"></div>
        <h3>Activities:</h3>
        <div id="activity-list"></div>
        <h3>Links:</h3>
        <div id="link-list"></div>
    </div>
    <svg id="process-view"></svg>

    <div id="selection-window" class="window">
        <h2>Selection</h2>
        <div id="selection">

        </div>
    </div>

    <div id="state">
        <div id="output">Hello<br></div>
        <div id="status"></div>
    </div>

    <datalist id="command-list"></datalist>
    <input id="command-input" type="text" list="command-list" autocorrect="off" autocapitalize="off" />

    <div id="bin">&#128465;</div>

    <script>
        /**
         * SVGView component
         */
        class SVGView {
            static ns = 'http://www.w3.org/2000/svg';
            static namedArributes = Symbol('named attributes');
            constructor(id, title) {
                this.svg = document.getElementById(id);
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
                this.svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
                //this.svg.setAttribute("viewBox", "0 0 2000 2000");
                this.title = title || 'SVG Diagram';
                this.map = new Map();
            }
            get width() {
                return this.svg.clientWidth;
            }
            get height() {
                return this.svg.clientHeight;
            }
            make(type, attributes, content, classes) {
                const element = document.createElementNS(SVGView.ns, type);
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);
                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                if (content) {
                    element.append(content);
                }
                if (classes) {
                    element.classList.add(...classes)
                }
                return element;
            }
            add(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.appendChild(element);
                return element;
            }
            addUnder(type, parent, attributes = {}, content, classes) {
                parent = parent || this.svg;
                const element = this.make(type, attributes, content, classes);
                parent.insertBefore(element, parent.firstElementChild);
                return element;
            }
            updateElement(element, attributes) {
                Object.entries(attributes).forEach(([name, value]) =>
                    name !== 'name' ? element.setAttribute(name, value) : null);

                if (attributes[SVGView.namedAttributes]) {
                    Object.entries(attributes[SVGView.namedAttributes]).forEach(([namespace, values]) =>
                        Object.entries(values).forEach(([name, value]) =>
                            element.setAttributeNS(namespace, name, value)));
                }
                return element
            }
            remove(item) {
                const representation = this.map.get(item);
                if (representation) {
                    Object.values(representation.nodes).forEach((node) => node.remove());
                    this.map.delete(item);
                }
            }
        }
    </script>

    <script>
        /**
         * Generate a V4 UUID
         */
        function uuidv4() {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }
    </script>


    <script>
        // States
        const ready = Symbol('ready');
        const waiting = Symbol('waiting');
        const running = Symbol('running');
        const blocked = Symbol('blocked');
        const paused = Symbol('paused');

        // Activity mode
        const asap = Symbol('asap');
        const onDemand = Symbol('on demand');

        // Simulation mode
        const byTime = Symbol('by time');
        const byEvent = Symbol('by event');


        // Ensure parent links aren't serialised by using a symbol
        const parent = Symbol('parent');
        const id = Symbol('id');

        /**
         * Evaluate a string to the canonical representation.
         */
        function resolve(str) {
            try {
                const func = new Function(`return ${str};`);
                return func();
            } catch (error) {
                appendLine(error.message);
            }
            return str;
        }

        /**
         * Parse the parameters of a command
         */
        function parseParameters(str) {
            let state;
            const parameters = [];
            let parameter = [];
            const states = {
                plainParameter: {
                    parse(char) {
                        if ([' ', '\t'].includes(char)) {
                            return states.whiteSpace;
                        } else {
                            parameter.push(char);
                        }
                        return this;
                    }
                },
                whiteSpace: {
                    parse(char) {
                        if (char === '"') {
                            parameter = [];
                            parameters.push(parameter);
                            return states.quotedParameter;
                        }
                        if (![' ', '\t'].includes(char)) {
                            parameter = [char];
                            parameters.push(parameter);
                            return states.plainParameter;
                        }
                        return this;
                    }
                },
                quotedParameter: {
                    parse(char) {
                        if (char === '"') {
                            return states.whiteSpace;
                        }
                        parameter.push(char);
                        return this;
                    }
                }
            }
            state = states.whiteSpace;
            for (let i = 0; i < str.length; ++i) {
                state = state.parse(str[i]);
            }
            return parameters.map((chars) => chars.join(''));
        }


        /**
         * An instance of a product.
         */
        class Asset {
            static all = new Set();
            static make(attributes) {
                const asset = new Asset(attributes.product, attributes.location);
                asset[id] = attributes.id;
                asset.serialNumber = attributes.serialNumber;
                return asset;
            }
            constructor(product, location) {
                this[id] = uuidv4();
                this.product = product;
                this.product.instances?.add(this);
                if (location && location.content) {
                    this.move(location);
                }
                this.content = new Set();
                Asset.all.add(this);
                this.serialNumber = Asset.all.size; //...Asset.all].filter((asset) => asset.product === product).length;
            }
            delete() {
                if (this.location) {
                    this.location.content.delete(this);
                }
                Asset.all.delete(this);
            }
            get name() {
                return `${this.product.name}/${this.serialNumber}`;
            }
            move(destination) {
                if (this.location) {
                    this.location.content.delete(this);
                }
                destination.content.add?.(this);
                this.location = destination;
            }
        }

        class Product {
            static all = [];
            static make(attributes) {
                if (attributes.name === undefined) {
                    let index = 1;
                    while (Product.all.find((item) => item.name === `Product ${index}`)) {
                        index += 1;
                    }
                    attributes.name = `Product ${index}`;
                }

                const product = new Product(attributes.name);
                product[id] = attributes.id;
                return product;
            }
            static get(name) {
                return Product.all.find((existing) => existing.name === name) || new Product(name);
            }
            constructor(name) {
                this.name = name;
                this[id] = uuidv4();
                this.instances = new Set();
                Product.all.push(this);
            }
        }

        class Source {
            static make(attributes) {
                const source = new Source();
                //attributes.content.forEach((asset) => asset.move(source));
                source[id] = attributes.id;
                return source;
            }
            constructor() {
                this.links = [];
                this.content = new Set();
                this[id] = uuidv4();
                this.name = 'Source';
            }
            delete() {
                this.links.forEach((link) => link.delete);
                this.content.entries().forEach((asset) => asset.delete());
                [...app.model.inputs].filter(([key, value]) => value === this)
                    .forEach(([key, value]) => app.model.inputs.delete(key));
                app.selected.delete(this);
                view.remove(this);
            }
            get available() {
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
            get(quantity = 1) {
                quantity = Math.min(quantity, this.content.length);
                return this.content.splice(0, quantity);
            }
            validate() {
                for (const asset of this.content) {
                    if (asset.location !== this) {
                        appendLine(`Warning: location mismatch`);
                        this.content.delete(asset);
                    }
                }
            }
        }

        class Store {
            static make(attributes) {
                const store = new Store();
                store[id] = attributes.id;
                return store;
            }
            constructor(name, parent, capacity = Infinity) {
                this.links = [];
                this.content = new Set();
                this[id] = uuidv4();
                this.parent = parent || app.model;
            }
            delete() {
                for (const asset of this.content) {
                    asset.delete();
                }
                this.parent.delete(this);
            }
            get name() {
                const products = new Set([...this.content].map((asset) => asset.product));
                const names = [...products].map((product) => product.name).join(', ');
                if (names) {
                    return `Store of ${names}`;
                }
                return 'Empty Store'
            }
            get available() {
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
            get(quantity = 1) {
                quantity = Math.min(quantity, this.content.length);
                return this.content.splice(0, quantity);
            }
            validate() {
                for (const asset of this.content) {
                    if (asset.location !== this) {
                        appendLine(`Warning: location mismatch`);
                        this.content.delete(asset);
                    }
                }
            }
        }

        class Port {
            static make(attributes) {
                const port = new Port(attributes.name, attributes.capacity, attributes.content);
                port[id] = attributes.id;
                return port;
            }
            constructor(product, capacity = 1, content = [], uuid) {
                this.product = product;
                this.capacity = capacity;
                this.content = new Set();
                this.links = [];
                this[id] = uuid || uuidv4();
            }
            store(item) {
                if (item.type !== this.product) {
                    appendLine(`Warning: Failed to store ${item.name} - item is not required type ${this.product.name}`);
                    return;
                }
                if (this.content.length >= this.capacity) {
                    appendLine(`Warning: Failed to storing ${item.name} - port is full`);
                    return;
                }
                this.content.add(item);
            }
        }

        class Input extends Port {
            static all = [];
            static make(attributes) {
                const input = new Input(attributes.product, attributes.capacity, attributes.content, attributes.required, attributes.id);
                input.links = attributes.links;
                input.parent = attributes.parent;
                return input;
            }
            constructor(product, capacity = 0, content = [], required = 1, uuid) {
                super(product, capacity, content, uuid);
                this.required = required;
                Input.all.push(this);
            }
            delete() {
                [...this.content].forEach((asset) => asset.move(app.model.store));
                this.links.forEach((link) => link.deleteTo());
                app.selected.delete(this);
                view.remove(this);
            }
            get name() {
                return `Input of ${this.parent.name}`;
            }
            get available() {
                if (this.links) {
                    const available = this.links.reduce((list, link) => list.concat(link.available), []);
                    return [...this.content].map((asset) => ({ asset, from: this })).concat(available);
                }
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
        }

        class Output extends Port {
            static all = [];
            static make(attributes) {
                const output = new Output(attributes.product, attributes.duration, attributes.capacity, attributes.content, attributes.id);
                return output;
            }
            constructor(product, duration = 5000, capacity = 1, content = [], uuid) {
                super(product, capacity, content, uuid);
                this.duration = duration;
                Output.all.push(this);
            }
            delete() {
                [...this.content].forEach((asset) => asset.move(app.model.store));
                this.lines.forEach((link) => link.deleteFrom());
                app.selected.delete(this);
                view.remove(this);
            }
            get name() {
                return `Output of ${this.parent.name}`;
            }
            get available() {
                return [...this.content].map((asset) => ({ asset, from: this }));
            }
        }

        class Process {
            static make(attributes) {
                const process = new Process(attributes.name);
                process.inputs = new Map(attributes.inputs);
                process.outputs = new Map(attributes.outputs);
                process[id] = attributes.id;
                return process;
            }
            constructor(name) {
                this.name = name;
                this[id] = uuidv4();
            }
        }

        class Activity {
            static all = [];
            static make(attributes) {
                const activity = new Activity(attributes.name);
                activity.duration = attributes.duration;
                activity[id] = attributes.id || uuidv4();
                app.model.ids[activity[id]] = activity;
                return activity;
            }
            constructor(name) {
                this[id] = uuidv4();
                this.name = name;
                this.state = ready;
                this.duration = 1 * 60 * 60 * 1000;
                this.inputs = new Map();
                this.outputs = new Map();
                this.content = new Set();
                Activity.all.push(this);
            }
            delete() {
                [...this.content].forEach((asset) => asset.move(app.model.store));
                this.inputs.values().forEach((input) => input.delete());
                this.outputs.values().forEach((output) => output.delete());
                Activity.all.splice(Activity.all.indexOf(this), 1);
                app.selected.delete(this);
                view.remove(this);
            }
            addInput(product, quantity = 1) {
                const state = this.inputs.get(product);
                if (state) {
                    state.required = quantity;
                } else {
                    const input = new Input(product, 1, [], quantity);
                    input.parent = this;
                    this.inputs.set(product, input);
                }
                appendLine(`Added product ${product.name} as input to ${this.name}`);
                if (quantity === 0) {
                    this.inputs.delete(product);
                }
                return this.inputs.get(product);
            }
            addOutput(name, quantity = 1) {
                const product = Product.get(name);
                const state = this.outputs.get(product);
                if (state) {
                    state.provides = quantity;
                } else {
                    const output = new Output(product, 5000, quantity, []);
                    output.parent = this;
                    this.outputs.set(product, output);
                    app.model.all.push(output);
                }
                appendLine(`Added product ${name} as input to ${this.name}`);
                if (quantity === 0) {
                    this.outputs.delete(product);
                }
                return this.outputs.get(product);
            }
            start() {
                if (this.state !== running) {
                    this.startTime = app.simulation.runTime;
                    this.state = running;
                }
            }
            next() {
                // Return the duration in milliseconds for the next event
                const duration = app.simulation.runTime - this.startTime;
                return Math.min(...this.outputs.values().map((output) => output.duration - duration));
            }
            get nextEvent() {
                if (this.state === running) {
                    this.startTime + this.duration;
                }
                return Infinity;
            }
            getRemaining() {
                const next = this.nextEvent;
                if (next === Infinity) {
                    return 'N/A';
                }
                return getShortDurationString(next);
            }
            update() {
                if (this.state === running) {
                    const duration = app.simulation.runTime - this.startTime;
                    const outputs = this.outputs.values().filter((output) => !output.done && output.duration < duration);
                    outputs.forEach((output) => {
                        const asset = new Asset(output.product);
                        asset.move(output);
                        [...this.content].forEach((component) => component.move(asset));
                        output.links.forEach((link) => link.to.update());
                        output.done = true;
                    });
                    if (this.outputs.values().every((output) => output.done)) {
                        this.outputs.values().forEach((output) => output.done = false);
                        this.state = ready;
                    }
                } else if (this.state === blocked) {
                    // Check whether outputs are now free
                    if (this.outputs.values().every((output) =>
                        output.capacity > output.content.length)) {
                        this.state === ready;
                    }
                }
                if (this.state === ready || this.state === waiting) {
                    const inputs = [...this.inputs.values()];
                    //const available = inputs.reduce((list, input) => list.concat(input.available), []);
                    if (inputs.every((input) => input.available.length >= input.required)) {
                        inputs.forEach((input) => {
                            const available = input.available;
                            available.length = input.required;
                            available.forEach((entry) => entry.asset.move(this));
                        });
                        this.start();
                    } else {
                        this.state = waiting;
                    }
                }
            }
            getStateDescription() {
                const inputs = Array.from(this.inputs.values());
                return {
                    [ready]: `Ready`,
                    [waiting]: `Waiting for:
${inputs.filter((input) => input.available < input.required)
                            .map((input) => (input.required - input.available) + ' x ' + input.product.name).join('\n')}`,
                    [running]: `Running (${this.getRemaining()} to go)`,
                    [blocked]: `Blocked`,
                    [paused]: `Paused`,
                }[this.state];
            }
            getContentString() {
                const content = [...this.content].reduce((products, asset) => {
                    const name = asset.product.name;
                    products[name] = products[name] || 0;
                    ++products[name];
                    return products;
                }, {});
                return Object.entries(content).map(([name, count]) => `${name}: ${count}`).join('<br>');
            }
        }

        /**
         * Convert a duration in milliseconds into a string.
         */
        function getDurationString(duration) {
            const ms = duration - 1000 * (Math.floor(duration / 1000));
            const s = Math.floor((duration - (60 * 1000 * Math.floor(duration / (60 * 1000)))) / 1000);
            const m = Math.floor((duration - (60 * 60 * 1000 * Math.floor(duration / (60 * 60 * 1000)))) / (60 * 1000));
            const h = Math.floor((duration - (24 * 60 * 60 * 1000 * Math.floor(duration / (24 * 60 * 60 * 1000)))) / (60 * 60 * 1000));
            const result = [];
            const append = (value, unit) => {
                if (value > 1) {
                    result.push(`${value} ${unit}s`);
                } else if (value > 0) {
                    result.push(`${value} ${unit}`);
                }
            };

            append(h, 'hour');
            append(m, 'minute');
            append(s, 'second');
            append(ms, 'millisecond');
            if (result.length > 1) {
                result.splice(result.length - 1, 0, 'and');
            }
            return result.join(' ');
        }


        /**
         * Convert a duration in milliseconds into a string.
         */
        function getShortDurationString(duration) {
            const s = (duration - (60 * 1000 * Math.floor(duration / (60 * 1000)))) / 1000;
            const m = Math.floor((duration - (60 * 60 * 1000 * Math.floor(duration / (60 * 60 * 1000)))) / (60 * 1000));
            const h = Math.floor((duration - (24 * 60 * 60 * 1000 * Math.floor(duration / (24 * 60 * 60 * 1000)))) / (60 * 60 * 1000));
            const d = Math.floor((duration - (7 * 24 * 60 * 60 * 1000 * Math.floor(duration / (7 * 24 * 60 * 60 * 1000)))) / (24 * 60 * 60 * 1000));
            const w = Math.floor(duration / (7 * 24 * 60 * 60 * 1000));
            const result = [];
            if (w > 1) {
                result.push(`${w} weeks `)
            } else if (w > 0) {
                result.push(`${w} week `)
            }

            if (d > 1) {
                result.push(`${d} days `)
            } else if (d > 0) {
                result.push(`${d} day `)
            }
            const hours = h < 10 ? `0${h}` : h;
            const minutes = m < 10 ? `0${m}` : m;
            const seconds = s < 10 ? `0${s.toFixed(2)}` : s.toFixed(2);
            return result.join('') + `${hours}:${minutes}:${seconds}`;
        }

        class Link {
            static make(attributes) {
                const link = new Link(attributes.from, attributes.to);
                link[id] = attributes.id;
                return link;
            }
            constructor(from, to) {
                this[id] = uuidv4();
                this.from = from;
                this.to = to;
                from.links?.push(this);
                to.links?.push(this);
            }
            deleteTo() {
                this.from.links = this.from.links.filter((link) => link.to !== this.to);
                app.selected.delete(this);
                view.remove(this);
            }
            deleteFrom() {
                this.to.links = this.to.links.filter((link) => link.from !== this.from);
                app.selected.delete(this);
                view.remove(this);
            }
            delete() {
                if (this.from.links) {
                    this.from.links = this.from.links.filter((link) => link !== this);
                }
                if (this.to.links) {
                    this.to.links = this.to.links.filter((link) => link !== this);
                }
                app.model.links = app.model.links.filter((link) => link !== this);
                view.remove(this);
            }
            get available() {
                return this.from.available;
            }
        }


        const app = {
            model: {
                [id]: uuidv4(),
                name: 'model',
                all: [],
                ids: {},
                get processes() { return this.all.filter((item) => item instanceof Process) },
                get activities() { return this.all.filter((item) => item instanceof Activity) },
                get products() { return Product.all; },
                inputs: new Map(),
                outputs: new Map(),
                links: [],
                store: { content: new Set() },
                issues: [],

                reset() {
                    this.all = [];
                    this.ids = {};
                    this.inputs = new Map();
                    this.outputs = new Map();
                    this.links = [];
                },
                addItem(item, replace = false) {
                    const pos = this.all.findIndex((existing) => existing.name === item.name);
                    if (pos !== -1) {
                        if (replace) {
                            this.all.splice(pos, 1, item);
                        } else {
                            appendLine(`Warning: ${this.all[pos].name} already exists in the model`);
                        }
                    } else {
                        this.all.push(item);
                    }
                },

                addActivity(name) {
                    if (name === undefined) {
                        let index = 1;
                        while (this.all.find((item) => (item instanceof Activity) && item.name === `Activity ${index}`)) {
                            index += 1;
                        }
                        name = `Activity ${index}`;
                    }
                    const activity = Activity.make({ name });
                    this.all.push(activity);
                    return activity;
                },
                addInput(product, quantity = 0) {
                    const input = this.inputs.get(product);
                    if (input) {
                        input.content += parseInt(quantity);
                        this.links.filter((link) => link.start === input)
                            .forEach((link) => link.end.update());
                    } else {
                        const content = Array(quantity).fill(1, 0, quantity).map((i) => new Asset(product));
                        const source = new Source();
                        content.forEach((asset) => asset.move(source));
                        this.inputs.set(product, source);
                        this.all.push(source);
                    }
                },
                addOutput(name, quantity = 0) {
                    const product = Product.get(name);
                    const output = this.outputs.get(product);
                    if (output) {
                        output.content += parseInt(quantity);
                        this.links.filter((link) => link.start === input)
                            .forEach((link) => link.end.update());
                    } else {
                        const content = Array(quantity).fill(1, 0, quantity).map((i) => ({ product }));
                        this.outputs.set(product, new Store(content));
                    }
                },
                toJSON() {
                    return {
                        all: this.all,
                        inputs: this.inputs,
                        outputs: this.outputs,
                        links: this.links,
                    };
                }
            },
            simulation: {
                state: paused,
                mode: byTime,
                rate: 1,
                reference: 0,
                eventsPerSecond: 1,
                reset() {
                    this.reference = 0;
                    if (this.initial) {
                        this.initial.forEach(([asset, location]) => asset.move(location));
                    }
                },
                start(time) {
                    if (this.reference === 0) {
                        this.initial = [...Asset.all].map((asset) => [asset, asset.location]);
                    }
                    this.lastTime = Date.now();
                    this.startTime = Date.parse(time) || this.startTime || Date.now();
                    this.state = running;
                    this.events = app.model.activities;
                    this.events.forEach((event) => event.update());
                    this.events.sort((a, b) => a.next - b.next);
                    if (this.events[0].next() < Infinity) {
                        this.timerId = window.setTimeout(this.tick, this.events[0].next() / this.rate, this.events[0]);
                    }
                },
                pause() {
                    this.state = paused;
                },
                stop() {
                    this.state = paused;
                    window.clearTimeout(this.timerId);
                },
                get active() {
                    // Determine the time of the next event
                    const active = app.model.activities.filter((activity) => activity.state === running);
                    active.sort((a, b) => a.nextEvent - b.nextEvent);
                    return active;
                },
                get runTime() {
                    const now = Date.now();
                    const delta = (this.state === running) ? (now - this.lastTime) : 0;
                    this.lastTime = now;
                    const runTime = this.reference + delta * this.rate;
                    this.reference = runTime;
                    return runTime;
                },
                get time() {
                    return this.startTime + this.runTime;
                },
                tick(activity) {
                    activity.update();
                    appendLine('tick');
                },
            },
            undo: [],
            redo: [],
            timeout: 1000,
            selected: new Set(),
            actions: {},
            commandHistory: {
                position: -1,
                content: [],
            },
        };

        /**
         * Global tick function to allow time based updates.
         */
        function tick() {
            if (app.timerId) {
                window.clearTimeout(app.windowId);
            }
            updateStatus();
            if (app.timeout === 'screen') {
                window.requestAnimationFrame(tick);
                app.timerId = null;
            } else if (app.timeout > 0) {
                app.timerId = window.setTimeout(tick, app.timeout);
            }
        }



        /**
         * Find an object by it's id.
         */
        function byId(id) {
            return app.model.ids[id];
            return app.model.all.find((item) => item.id === id) ||
                app.model.inputs.values().find((item) => item.id === id) ||
                app.model.outputs.values().find((item) => item.id === id);
        }

        /**
         * Find an object by it's name.
         */
        function byName(name) {
            const item = app.model.all.find((item) => item.name === name);
            return item;
        }

        /**
         * Manage serialisation and de-serialisation.
         */

        function serialise(item) {
            const serialised = new Set();
            const seen = new Map();
            function replacer(key, value) {
                if (!value) {
                    return value;
                }
                if (value[id]) {
                    if (serialised.has(value[id])) {
                        return { ref: value[id], };
                    }
                    serialised.add(value[id]);
                } else if (value instanceof Object && seen.has(value)) {
                    console.log('Duplicate reference to: ', value);
                    console.log('Previous context:', seen.get(value));
                    console.log('Current context:', this);
                }
                seen.set(value, this);
                if (value instanceof Map) {
                    return {
                        dataType: 'Map',
                        value: Array.from(value.entries()),
                    };
                } else if (value instanceof Set) {
                    return {
                        dataType: 'Set',
                        value: Array.from(value),
                    };
                }

                if (value.constructor.make) {
                    return {
                        dataType: value.constructor.name,
                        value: Object.assign({}, value, { id: value[id], [id]: undefined }),
                    };
                } else if (value[id]) {
                    return Object.assign({}, value, { id: value[id], [id]: undefined });
                }
                return value;
            }
            return JSON.stringify(item, replacer, 2);
        }

        function deserialise(str) {
            const datePattern = /[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{1,4}Z/
            const references = new Map();
            const unresolved = [];
            const containers = [];
            function reviver(key, value) {
                if (datePattern.test(value)) {
                    return Date.parse(value);
                }
                if (!value) {
                    return value;
                }
                if (value.ref) {
                    if (references.has(value.ref)) {
                        return references.get(value.ref);
                    } else {
                        unresolved.push({ key, id: value.ref, context: this });
                    }
                } else if (typeof value === 'object') {
                    if (value.dataType === 'Map') {
                        containers.push({ type: Map, key, content: value.value, context: this });
                        return value;
                    } else if (value.dataType === 'Set') {
                        containers.push({ type: Set, key, content: value.value, context: this });
                        return value;
                    } else if (value.dataType) {
                        const element = {
                            Product, Asset, Process, Port, Input, Activity, Link, Input, Output, Source, Store,
                        }[value.dataType].make(value.value);
                        const elementId = element[id] || value.id;
                        if (elementId) {
                            references.set(elementId, element);
                        }
                        return element;
                    }
                    const valueId = value[id] || value.id;
                    if (valueId) {
                        references.set(valueId, value);
                    }
                }

                return value;
            }
            const structure = JSON.parse(str, reviver);
            unresolved.forEach((reference) => {
                const item = references.get(reference.id);
                const context = references.get(reference.context) || references.get(reference.context.id) || reference.context;

                if (item && context) {
                    context[reference.key] = item;
                } else if (item) {
                    console.log(`context of ${reference.context} for ${item} not found`);
                } else {
                    appendLine(`Warning: unmatched reference (${reference.id}) for ${reference.key} in ${context?.name}`);
                }
            });
            containers.forEach((container) => {
                const context = references.get(container.context.id) || container.context;

                if (context) {
                    context[container.key] = new container.type(container.content);
                } else {
                    appendLine(`Warning: unmatched container (${container.id}) for ${container.key} in ${context?.name}`);
                }
            });
            return structure;
        }


        /**
         * Utility function to support downloading generated content.
         */
        function saveText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Utility function to support loading a file.
         */
        function load() {
            const tempNode = document.createElement('input');
            tempNode.type = 'file';
            tempNode.accept = '.json';
            tempNode.addEventListener('cancel', () => {
                console.log('Cancelled.');
            });

            function loadFile(file) {
                const reader = new FileReader();
                reader.addEventListener('load', (event) => {
                    const filename = file.name;
                    try {
                        view.map.clear();
                        view.svg.innerHTML = '';
                        Asset.all = new Set();
                        Product.add = new Set();
                        Input.add = new Set();
                        Output.add = new Set();
                        Activity.add = new Set();
                        app.model.all.length = 0;

                        const state = deserialise(reader.result);
                        app.model.all.push(...state.all);
                        app.model.inputs = state.inputs || new Map();
                        app.model.outputs = state.outputs || new Map();

                        app.model.links = state.links.filter((link) => link.from !== undefined && link.to !== undefined);

                        appendLine(`Loaded ${filename}`);
                    } catch (error) {
                        appendLine(error.message);
                    }
                });
                reader.readAsText(file);
            }

            tempNode.addEventListener('change', () => {
                if (tempNode.files.length === 1) {
                    console.log('File selected: ', tempNode.files[0]);
                    for (let i = 0; i < tempNode.files.length; ++i) {
                        loadFile(tempNode.files[i]);
                    }
                }
            });
            tempNode.click();
        }


        /**
         * Utility function to support downloading generated content.
         */
        function download(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }


        /**
         * Common Functions for use by commands
         */

        /**
         * Reset the parse
         */
        function reset() {
            this.chars = this.name.split('');
            return this;
        }

        /**
         * Check the next character against the command
         */
        function parse(i) {
            return this.chars.length === 0 || this.chars.shift() === i;
        }

        /**
         * Add a list to the output
         */
        function appendLine(line) {
            const output = document.getElementById('output');
            output.append(line, document.createElement('br'));
        }

        /**
         * Add a list to the output
         */
        function showList(list) {
            const output = document.getElementById('output');
            output.append(...list.flatMap((item) => [item, document.createElement('br')]));
        }


        /**
         * Load the current state from local storage
         */
        function loadLocal() {
            const stateStr = localStorage.getItem('process-model');

            if (stateStr) {
                const state = deserialise(stateStr);
                if (Array.isArray(state.model.all)) {
                    app.model.all.push(...state.model.all);
                } else {
                    app.model.all.push(...Object.entries(state.model.all).reduce((arr, [key, value]) => {
                        if (!isNaN(Number(key))) {
                            arr[Number(key)] = value;
                        }
                        return arr;
                    }, []));
                }
                app.model.inputs = state.model.inputs || new Map();
                app.model.outputs = state.model.outputs || new Map();

                // ToDo: remove temporary fix for input / output parents
                app.model.activities.forEach((activity) => {
                    activity.inputs.values().forEach((input) => input.parent = activity);
                    activity.outputs.values().forEach((output) => output.parent = activity);
                });

                const keys = [];
                for (const [key, value] of app.model.outputs.entries()) {
                    if (!(value instanceof Store)) {
                        keys.push(key);
                    }
                }
                keys.forEach((key) => app.model.outputs.delete(key));

                app.model.links = state.model.links.filter((link) => link.from !== undefined && link.to !== undefined);
                if (state.history) {
                    app.commandHistory.position = state.history.position;
                    app.commandHistory.content = state.history.content;
                }

                if (state.view) {
                    state.view.forEach((item) => {
                        const element = byId(item.element);
                        if (element) {
                            view.map.set(element, { x: item.x, y: item.y, width: item.width, height: item.height, moved: true });
                        } else {
                            appendLine(`Info: element ${item.element} not found when setting representation.`)
                        }
                    });
                }
            }
        }

        /**
         * load the current state to local storage
         */
        function saveLocally() {
            const viewData = [...view.map.entries()].filter(([item, representation]) => representation.moved)
                .map(([item, representation]) => ({
                    element: item[id],
                    x: representation.x, y: representation.y, width: representation.width, height: representation.height
                }));
            const state = {
                model: app.model,
                view: viewData,
                history: app.commandHistory,
            };

            state.model.all[id] = uuidv4();
            const str = serialise(state);
            localStorage.setItem('process-model', str);
        }

        /**
         * User commands that can be used in the input box.
         */
        const commands = [
            {
                name: 'load',
                action(str) {
                    load();
                },
                reset,
                parse,
            },
            {
                name: 'save',
                action(str) {
                    saveText(serialise(app.model), 'process_model.json');
                },
                reset,
                parse,
            },
            {
                name: 'clear model',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.stop();
                    app.model.reset();
                    view.svg.innerHTML = '';
                },
                reset,
                parse,
            },
            {
                name: 'clear',
                action(str) {
                    const output = document.getElementById('output');
                    output.innerHTML = '';
                },
                reset,
                parse,
            },
            {
                name: 'undo',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (app.undo.length > 0) {
                        const action = app.undo.pop();
                        app.redo.push(action);
                        action.undo();
                    } else {
                        appendLine('Info: undo queue is empty');
                    }
                },
                reset,
                parse,
            },
            {
                name: 'redo',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (app.redo.length > 0) {
                        const action = app.redo.pop();
                        app.undo.push(action);
                        action.redo();
                    } else {
                        appendLine('Info: redo queue is empty');
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add process',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    app.model.processes.push({ name });
                    app.selected.add(app.model.processes.at(-1));

                    appendLine(`Added process: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'processes',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0].trim();
                    if (pattern === '') {
                        showList(app.model.processes.map((process) => process.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.processes.filter((process) => expr.test(process.name))
                            .map((process) => process.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add activity',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.selected.add(app.model.addActivity(...parameters));
                    appendLine(`Added activity: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'activities',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0].trim();
                    if (pattern === '') {
                        showList(app.model.activities.map((activity) => activity.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.activities.filter((activity) => expr.test(activity.name))
                            .map((activity) => activity.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add issue',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.selected.forEach((component) =>
                        app.model.issues.push({ component, text: parameters.join(' ') }));
                },
                reset,
                parse,
            },
            {
                name: 'add input',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [productName, quantity] = parameters;
                    const product = Product.get(productName);
                    if (app.selected.size > 0) {
                        for (const item of app.selected) {
                            if (item.addInput) {
                                item.addInput(product, quantity);
                                appendLine(`Added input of ${product.name} to ${item.name}`);
                            }
                        }
                    } else {
                        app.model.addInput(product, quantity);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add source',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [productName, quantity] = parameters;
                    const product = Product.get(productName);
                    app.model.addInput(product, quantity);
                },
                reset,
                parse,
            },
            {
                name: 'inputs',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    for (const item of app.selected) {
                        appendLine(item.name);
                        for (const [product, state] of item.inputs) {
                            appendLine(`  ${product.name} ${state.current}/${state.required}`);
                        }
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add output',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const [product, quantity] = parameters;
                    if (app.selected.size > 0) {
                        for (const item of app.selected) {
                            if (item.addOutput) {
                                item.addOutput(product, quantity);
                                appendLine(`Added output of ${product} to ${item.name}`);
                            }
                        }
                    } else {
                        app.model.addOutput(product, quantity);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'add product',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    const product = Product.make({ name });
                    app.model.addItem(product);
                    app.selected.add(product);

                    appendLine(`Added product: ${name}`);
                },
                reset,
                parse,
            },
            {
                name: 'products',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.model.products.map((product) => product.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'link',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const name = parameters[0];
                    const product = app.model.products.find((product) => product.name === name);
                    if (product) {
                        if (app.model.inputs.get(product)) {
                            for (const item of app.selected) {
                                if (item.inputs) {
                                    const to = item.inputs.get(product);
                                    if (to) {
                                        app.model.links.push(new Link(app.model.inputs.get(product), to));
                                    }
                                }
                            }
                        }
                        if (app.model.outputs.get(product)) {
                            for (const item of app.selected) {
                                if (item.outputs) {
                                    const from = item.outputs.get(product);
                                    if (from) {
                                        app.model.links.push(new Link(from, app.model.outputs.get(product)));
                                    }
                                }
                            }
                        }
                    } else {
                        const outputs = [...app.selected].filter((item) => item instanceof Output || item instanceof Source);
                        const inputs = [...app.selected].filter((item) => item instanceof Input || item instanceof Store);

                        outputs.forEach((output) =>
                            inputs.forEach((input) => app.model.links.push(new Link(output, input))));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'links',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.model.links.map((link) => `${link.source.name} -> ${link.destination.name}`));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.model.products.filter((product) => expr.test(product.name))
                            .map((product) => product.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'delete',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (parameters.length === 0) {
                        for (const item of app.selected) {
                            app.model.all = app.model.all.filter((element) => element !== item);
                            item.delete();
                            item.deleted = true;
                            appendLine(`${item.name} deleted`);
                        }
                        app.selected.clear();
                    } else {
                    }
                },
                reset,
                parse,
            },
            {
                name: 'rate',
                description: 'Set the application tick timer',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const value = Number(parameters[0]);
                    if (value > 0) {
                        app.simulation.rate = value;
                    } else {
                        appendLine(`Simulation rate = ${app.simulation.rate}`);
                    }
                },
                reset,
                parse,
            },
            {
                name: 'tick',
                description: 'Set the application tick timer',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (parameters.length === 0) {
                        app.timeout = 0;
                    } else {
                        const value = Number(parameters[0]);
                        if (isNaN(value)) {
                            app.timeout = 'screen';
                        } else {
                            app.timeout = value;
                        }
                    }
                    tick();
                },
                reset,
                parse,
            },
            {
                name: 'start',
                description: 'Start the simulation',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.start(parameters[0]);
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'stop',
                description: 'Pause the simulation',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.pause();
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'reset',
                description: 'Restart the simulation',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    app.simulation.reset();
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'update',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    update();
                },
                reset,
                parse,
            },
            {
                name: 'redraw',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    redraw();
                },
                reset,
                parse,
            },
            {
                name: 'draw',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        if (app.selected.size > 0) {
                            draw(app.selected);
                        } else {
                            draw([...app.model.processes, ...app.model.activities, ...app.model.products, ...app.model.links]);
                        }
                    } else {

                    }
                },
                reset,
                parse,
            },
            {
                name: 'none',
                action(str) {
                    app.selected.clear();
                },
                reset,
                parse,
            },
            {
                name: 'set',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    if (parameters.length === 2) {
                        const [attribute, str] = parameters;
                        const value = resolve(str);
                        app.selected.forEach((item) => item[attribute] = value);
                    } else if (parameters.length > 2) {
                        const value = resolve(parameters.pop());
                        const attribute = parameters.pop();
                        const items = parameters.flatMap((str) => {
                            const pattern = new RegExp(str);
                            return app.model.all.filter((item) => pattern.test(item.name));
                        });
                        items.forEach((item) => item[attribute] = value);
                    }
                    app.selected.clear();
                },
                reset,
                parse,
            },
            {
                name: 'selected',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(app.selected.map((item) => item.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(app.selected.filter((item) => expr.test(item.name))
                            .map((item) => item.name));
                    }
                },
                reset,
                parse,
            },
            {
                name: 'commands',
                action(str) {
                    const parameters = parseParameters(str.replace(this.name, ''));
                    const pattern = parameters[0];
                    if (pattern === '') {
                        showList(commands.map((command) => command.name));
                    } else {
                        const expr = new RegExp(pattern);
                        showList(commands.filter((command) => expr.test(command.name))
                            .map((command) => command.name));
                    }
                },
                reset,
                parse,
            },
        ];

        /**
         * Update the command list for completions.
         */
        function updateCommandList() {
            const commandList = document.getElementById('command-list');
            commandList.innerHTML = commands.map((command) => `<option>${command.name}</option>`).join('');
        }


        /**
         * Handle a command entered in the input box.
         */
        function processCommand(event) {
            const input = document.getElementById('command-input');

            let validCommands = commands.map((command) => command.reset());
            const command = input.value.split('');

            const parse = (i) => validCommands = validCommands.filter((command) => command.parse(i));

            while (validCommands.length > 0 && command.length > 0) {
                parse(command.shift());
            }
            if (input.value.startsWith('$')) {
                try {
                    const func = new Function('app', '_', `return ${input.value.slice(1)};`);
                    appendLine(func(app, byName));
                } catch (error) {
                    appendLine(`Error: ${error.message}`);
                }
            } else if (validCommands.length === 1) {
                validCommands[0].action(input.value);
            } else if (validCommands.length > 1) {
                validCommands.sort((a, b) => b.length - a.length);
                validCommands[0].action(input.value);
            } else {
                const pattern = new RegExp(input.value);
                const items = app.model.all.filter((item) => pattern.test(item.name));

                if (items.length > 0) {
                    items.forEach((item) => {
                        if (app.selected.has(item)) {
                            app.selected.delete(item);
                            appendLine(`Deselected ${item.name}`);
                        } else {
                            app.selected.add(item);
                            appendLine(`Selected ${item.name}`);
                        }
                    });

                } else {
                    appendLine(`Warning: unrecognised input "${input.value}"`);
                }
            }

            if (event.ctrlKey) {
                app.commandHistory.content[app.commandHistory.position++] = input.value;
                input.value = app.commandHistory.content[app.commandHistory.position] || '';
            } else if (event.shiftKey) {
                input.value = '';
                app.commandHistory.position = -1;
            } else {
                app.commandHistory.content.push(input.value);
                app.commandHistory.position = -1;
                input.value = '';
            }
        }


        /**
         * Validate the content of the input box.
         */
        function processKey(event) {
            const input = document.getElementById('command-input');

            if (event.key === 'Enter') {
                processCommand(event);
                update();
                saveLocally();
                updateSelected();
            } else if (event.key === 'Escape') {
                document.body.focus();
            } else if (event.key === 'ArrowUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.position = app.commandHistory.content.length - 1;
                    app.commandHistory.content.push(input.value);
                    input.value = app.commandHistory.content[app.commandHistory.position];
                } else {
                    app.commandHistory.position = (app.commandHistory.content.length - 1 + app.commandHistory.position) % app.commandHistory.content.length;
                    input.value = app.commandHistory.content[app.commandHistory.position];
                }
            } else if (event.key === 'DownUp') {
                if (app.commandHistory.position === -1) {
                    app.commandHistory.content.push(input.value);
                }
                app.commandHistory.position = (app.commandHistory.content.length + 1 + app.commandHistory.position) % app.commandHistory.content.length;
                input.value = app.commandHistory.content[app.commandHistory.position];
            }
        }

        const view = new SVGView('process-view', 'Process View');

        /**
         *
         */
        function update() {
            updateStatus();
            updateView();
        }


        /**
         * Update the status line.
         */
        function updateStatus() {
            const node = document.getElementById('status');
            const modeString = {
                // Simulation mode
                [byTime]: `time based (${getShortDurationString(app.simulation.runTime)})`,
                [byEvent]: 'event based',
            }[app.simulation.mode];
            const stateString = {
                [running]: `Running ${modeString}`,
                [blocked]: 'Blocked',
                [paused]: 'Paused',
            }[app.simulation.state];
            node.innerHTML = `${stateString}`;
        }


        /**
         * Select an item, updating the representation as necessary.
         */
        function select(item, node) {
            app.selected.add(item);
            node.classList.add('selected');
            updateSelected();
        }

        /**
         * Deselect an item, updating the representation as necessary.
         */
        function deselect(item, node) {
            app.selected.delete(item);
            node.classList.remove('selected');
            updateSelected();
        }

        /**
         * Redraw the view
         */
        function redraw() {
            view.svg.innerHTML = '';
            view.map.clear()
            updateView();
        }


        /**
         * Get the cursor position relative to an element
         */
        function localPosition(screenPosition, element) {
            const box = element.getBoundingClientRect();
            return {
                x: screenPosition.x - box.x,
                y: screenPosition.y - box.y,
            }
        }


        /**
         * Make an svg element linkable
         */
        function linkable(element, representation, action) {
            return {
                start(event) {
                    app.actions.element = element;
                    app.actions.start = { x: event.clientX, y: event.clientY, nodeX: representation.x, nodeY: representation.y };

                    event.preventDefault();
                    const pos = localPosition({ x: event.clientX, y: event.clientY }, view.svg);
                    app.actions.node = view.add('path', null, { fill: 'none', stroke: 'gray' });
                    app.actions.point = view.add('circle', null, { cx: pos.x, cy: pos.y, r: 5, fill: 'gray', stroke: 'gray' });
                },
                move(event) {
                    const pos = localPosition({ x: event.clientX, y: event.clientY }, view.svg);
                    const delta = {
                        x: event.clientX - app.actions.start.x,
                        y: event.clientY - app.actions.start.y,
                    };

                    const d = `M ${pos.x} ${pos.y} L ${pos.x - delta.x} ${pos.y - delta.y}`;
                    view.updateElement(app.actions.node, { d });
                },
                up(event) {
                    app.actions.node.remove();
                    app.actions.point.remove();
                    action(event);
                    updateView();
                    saveLocally();
                },
            }
        }


        /**
         * Make an svg element moveable
         */
        function moveable(representation) {
            return {
                start() {
                    app.actions.start = { x: event.clientX, y: event.clientY, nodeX: representation.x, nodeY: representation.y };
                },
                move(event) {
                    const delta = {
                        x: event.clientX - app.actions.start.x,
                        y: event.clientY - app.actions.start.y,
                    };
                    const dist = Math.hypot(delta.x, delta.y);
                    if (dist > 5) {
                        representation.moved = true;
                    }
                    representation.x = app.actions.start.nodeX + delta.x;
                    representation.y = app.actions.start.nodeY + delta.y;

                    representation.nodes.group.setAttribute('transform', `translate(${representation.x} ${representation.y})`);
                    representation.dependencies.forEach((dependency) => dependency.update(event, representation));
                },
                up(event) {
                    updateView();
                },
            };
        }


        /**
         * Add mouse controls to an element on the SVG
         */
        function addMouseControls(node, controls) {
            node.addEventListener('mousedown', (event) => {
                if (event.ctrlKey && controls.ctrl) {
                    controls.ctrl.start(event);
                    app.actions.move = controls.ctrl.move;
                    app.actions.up = controls.ctrl.up;
                } else {
                    controls.start(event);
                    app.actions.move = controls.move;
                    app.actions.up = controls.up;
                }
            });
        }

        /**
         * Make an svg element a target for dropping assets
         */
        function contentTarget(container, node) {
            node.addEventListener('dragover', (event) => event.preventDefault());
            node.addEventListener('drop', (event) => {
                event.preventDefault();
                const assetId = event.dataTransfer.getData('text/plain');
                const item = [...Asset.all].find((asset) => asset[id] === assetId);
                if (container.product === undefined || item.product === container.product) {
                    item.move(container);
                }
                updateView();
            });
        }


        /**
         * Update the SVG that represents the current process and its state.
         */
        function updateView() {
            Product.all.sort((a, b) => a.name?.localeCompare(b.name));
            updateList(Product.all, [{
                title: 'Index',
                get: (item, index) => index,
            },
            {
                title: 'Name',
                get: (item) => item.name,
                set: (item, value) => item.name = value,
            },
            {
                title: 'Qty',
                get: (item) => item.instances.size,
            },
            ], 'product-list', { draggable: true });

            const data = [...Asset.all.values()];
            data.sort((a, b) => a.product === b.product ?
                a.name?.localeCompare(b.name) :
                a.product.name?.localeCompare(b.product.name));

            updateList(data, [{
                title: 'Product',
                get: (item) => item.product.name,
            },
            {
                title: 'S/N',
                get: (item) => item.serialNumber,
                set: (item, value) => item.serialNumber = value,
            },
            {
                title: 'Location',
                get: (item) => item.location?.name,
            },
            ], 'asset-list', {
                draggable: true,
                append: {
                    type: Asset, require: [0],
                    set(item, value) {
                        new Asset(Product.get(value));
                    }
                },
            });
            updateActivityList();
            updateLinkList();
            // Remove deleted items
            for (const [item, representation] of view.map.entries()) {
                if (item.deleted) {
                    Object.values(representation.nodes).forEach((node) => node.remove(node));
                    view.map.delete(item);
                }
            }

            const toggleSelection = (item, node) => {
                if (app.selected.has(item)) {
                    deselect(item, node);
                } else {
                    select(item, node);
                }
                updateSelected();
            }

            let x = 10;
            let y = 100;
            const textAttrs = { x: 2, y: 2, fill: 'black', stroke: 'none', 'text-anchor': 'start', 'alignment-baseline': 'hanging' };
            const representations = [];
            for (const input of app.model.inputs) {
                const [product, state] = input;
                const fill = state.content.size > 0 ? 'lightgreen' : 'white';
                const representation = view.map.get(state);
                if (representation) {
                    representation.dependencies = [];
                    representation.group = 0;
                    representation.nodes.group.setAttribute('fill', fill);
                    if (!representation.moved) {
                        representations.push(representation);
                    }
                    representation.nodes.label.innerHTML = product.name;
                    representation.bbox = representation.nodes.label.getBBox();
                    representation.nodes.title.innerHTML = representation.nodes.textTitle.innerHTML = `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`;
                } else {
                    const group = view.add('g', null, { transform: `translate(${x}, ${y})` });
                    const outline = view.add('path', group, { fill, stroke: 'black' });
                    const title = view.add('title', outline, {}, `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`);

                    const label = view.add('text', group, textAttrs, `${product.name}`);
                    const textTitle = view.add('title', label, {}, `${product.name} (${state.content.size})`);

                    const representation = {
                        nodes: { group, outline, title, label, textTitle },
                        bbox: label.getBBox(), dependencies: [], group: 0,
                    };
                    representations.push(representation);
                    view.map.set(state, representation);

                    outline.addEventListener('click', (event) => {
                        if (event.altKey) {
                            representation.moved = false;
                            updateView();
                        } else if (event.shiftKey) {
                            deselect(state, outline);
                        } else {
                            select(state, outline);
                        }
                        updateView();
                    });
                    outline.addEventListener('dblclick', (event) => {
                        const asset = new Asset(product);
                        asset.move(state);
                        state.content.add(asset);
                        state.links.forEach((link) => link.to.update);
                        updateView();
                    });

                    const controls = moveable(representation);
                    controls.ctrl = linkable(input, representation, (event) => {
                        const elements = document.elementsFromPoint(event.clientX, event.clientY);
                        const items = [...view.map].filter(([item, element]) => elements.includes(element.nodes.outline)).map(([item, element]) => item);
                        const product = app.actions.element[0];
                        for (const item of items) {
                            if (item instanceof Activity) {
                                const input = item.inputs.get(product);
                                if (input) {
                                    const existing = input.links.filter((link) => link.from === app.actions.element);
                                    if (existing.length < 1) {
                                        app.model.links.push(new Link(app.actions.element[1], input));
                                    } else {
                                        appendLine(`${app.actions.element[1].name} is already linked to ${item.name}`);
                                    }
                                } else {
                                    const input = item.addInput(product);
                                    app.model.links.push(new Link(app.actions.element[1], input));
                                }
                            }
                        }
                    });

                    addMouseControls(representation.nodes.group, controls);
                    contentTarget(state, outline);
                }
            }

            const textWidth = Math.max(0, ...representations.map((representation) => representation.bbox.width));
            const textHeight = Math.max(0, ...representations.map((representation) => representation.bbox.height));

            representations.forEach((representation, index) => {
                const x = representation.x ?? 10;
                const y = representation.y ?? (100 + index * 50 - textHeight / 2);
                const w = textWidth;
                const h = textHeight;
                const d = `M 0 0 h ${w + 4} l ${h / 2} ${h / 2} l ${-h / 2} ${h / 2} h ${-w - 4} z`;
                view.updateElement(representation.nodes.group, { transform: `translate(${x}, ${y})` });
                representation.nodes.outline.setAttribute('d', d);
                representation.x = x;
                representation.y = y;
                representation.width = textWidth + 4 + textHeight * 0.5;
                representation.height = textHeight;
            });


            // Add activities
            //
            x = textWidth + textHeight + 50;
            y = 100;
            const width = 100;
            const horizontalSpace = 100;
            const height = 50;
            const verticalSpace = 30;
            app.model.activities.forEach((activity) => {
                const classes = app.selected.has(activity) ? ['selected'] : [];

                const representation = view.map.get(activity) || {};
                representation.dependencies = [];
                representation.group = null;
                representation.width = representation.width ?? width;
                representation.height = representation.height ?? height;
                if (representation.nodes) {
                    representation.nodes.outline.innerHTML = activity.name;
                    representation.nodes.label.setAttribute('x', width / 2);
                    representation.nodes.label.setAttribute('y', 15);
                    representation.nodes.title.innerHTML = activity.getStateDescription();
                } else {
                    const group = view.add('g', null, { transform: `translate (${representation.x ?? x}, ${representation.y ?? y})` });
                    const outline = view.add('rect', group, { width, height, rx: 5, ry: 5, fill: 'white', stroke: 'black', }, null, classes);
                    const label = view.add('text', group, { x: width / 2, y: 15, 'text-anchor': 'middle', stroke: 'none', }, activity.name);
                    const title = view.add('title', group, {}, activity.getStateDescription());
                    representation.x = representation.x ?? x;
                    representation.y = representation.y ?? y;
                    representation.nodes = { group, outline, label, title };
                    view.map.set(activity, representation);
                    outline.addEventListener('click', (event) => {
                        if (event.altKey) {
                            representation.moved = false;
                            updateView();
                        } else {
                            toggleSelection(activity, group);
                        }
                    });
                    const controls = moveable(representation);
                    controls.ctrl = linkable(activity, representation, (event) => {
                        const elements = document.elementsFromPoint(event.clientX, event.clientY);
                        const items = [...view.map].filter(([item, element]) => elements.includes(element.nodes.outline)).map(([item, element]) => item);
                        const inputProducts = new Set([...app.actions.element.inputs.keys()]);
                        const unlinkedInputs = [...app.actions.element.inputs.values()].filter((input) => input.links.length === 0);
                        const outputProducts = new Set([...app.actions.element.outputs.keys()]);
                        const unlinkedOutputs = [...app.actions.element.outputs.values()].filter((output) => output.links.length === 0);
                        for (const item of items) {
                            if (item instanceof Activity) {
                                // Find potential links based on inputs and outputs
                                const targetInputProducts = new Set([...item.inputs.keys()]);
                                const targetOutputProducts = new Set([...item.outputs.keys()]);
                                const outputs = outputProducts.intersection(targetInputProducts);
                                const inputs = inputProducts.intersection(targetOutputProducts);
                                if (outputs.size) {
                                    for (const product of outputs) {
                                        const from = app.actions.element.outputs.get(product);
                                        const to = item.inputs.get(product);
                                        app.model.links.push(new Link(from, to));
                                    }
                                } else if (inputs.size) {
                                    for (const product of inputs) {
                                        const from = item.outputs.get(product);
                                        const to = app.actions.element.inputs.get(product);
                                        app.model.links.push(new Link(from, to));
                                    }
                                } else if (unlinkedOutputs.length > 0) {
                                    const product = unlinkedOutputs[0].product;
                                    const from = unlinkedOutputs[0];
                                    const to = item.addInput(product);
                                    app.model.links.push(new Link(from, to));
                                } else if (unlinkedInputs.length > 0) {
                                    const product = unlinkedInputs[0].product;
                                    const from = item.addOutput(product);
                                    const to = unlinkedInputs[0];
                                    app.model.links.push(new Link(from, to));
                                }
                            }
                            if (item instanceof Store) {
                                const outputs = [...app.actions.element.outputs.values()].filter((output) => output.links.length < 1);
                                outputs.forEach((output) => app.model.links.push(new Link(output, item)));
                            }
                        }
                    });
                    addMouseControls(representation.nodes.group, controls);
                }

                const step = (height - 10) / activity.inputs.size;
                let iy = 10 + step / 2;
                for (const input of activity.inputs) {
                    const [product, state] = input;
                    const node = view.map.get(state) || {};

                    if (node.nodes) {
                        node.dependencies = [];
                        node.x = node.parent.x - 5;
                        node.y = node.parent.y + iy - 5;
                        node.nodes.title = `${product.name} (${state.content.size}/${state.required})`
                    } else {
                        const outline = view.add('circle', representation.nodes.group, { cx: 0, cy: iy, r: 5, fill: 'white', stroke: 'black' })
                        const title = view.add('title', outline, {}, `${product.name} (${state.content.size}/${state.required})`);
                        node.x = (representation.x ?? x) - 5;
                        node.y = (representation.y ?? y) + iy - 5;
                        node.iy = iy;
                        node.width = 10;
                        node.height = 10;
                        node.nodes = { outline, title };
                        node.parent = representation;
                        node.dependencies = [];
                        view.map.set(state, node);

                        outline.addEventListener('click', (event) => {
                            appendLine(`Product: ${product.name}`);
                            appendLine(`Available: ${state.available.map((available) => available.asset.name).join(', ')}`);
                            toggleSelection(state, outline);
                        });
                    }
                    representation.dependencies.push({
                        update: (event, parent) => {
                            node.x = node.parent.x - 5;
                            node.y = node.parent.y + node.iy - 5
                            node.dependencies.forEach((dependency) => dependency.update(event, node));
                        }
                    });
                    iy += step;
                }

                const oStep = (height - 10) / activity.outputs.size;
                let oy = 10 + oStep / 2;
                for (const output of activity.outputs) {
                    const [product, state] = output;
                    const node = view.map.get(state) || {};

                    if (node.nodes) {
                        node.dependencies = [];
                        node.x = node.parent.x + width - 5;
                        node.y = node.parent.y + oy - 5;
                        node.nodes.group = `${product.name} (${state.content.size}/${state.required})`
                    } else {
                        const fill = state.content.size > 0 ? (state.content.size < state.capacity ? 'green' : 'red') : 'white';
                        const outline = view.add('circle', representation.nodes.group, { cx: width, cy: oy, r: 5, fill, stroke: 'black' })
                        const title = view.add('title', outline, {}, `${product.name} (${state.content.size}/${state.capacity || '-'})`);
                        node.x = (representation.x ?? x) + width - 5;
                        node.y = (representation.y ?? y) + oy - 5;
                        node.oy = oy;
                        node.width = 10;
                        node.height = 10;
                        node.nodes = { outline, title };
                        node.parent = representation;
                        node.dependencies = [];
                        view.map.set(state, node);

                        outline.addEventListener('click', (event) => {
                            appendLine(`Product: ${product.name}`);
                            appendLine(`Available: ${state.available.map((available) => available.asset.name).join(', ')}`);
                            toggleSelection(state, outline);
                        });
                    }
                    representation.dependencies.push({
                        update: (event, parent) => {
                            node.x = node.parent.x + width - 5;
                            node.y = node.parent.y + node.oy - 5
                            node.dependencies.forEach((dependency) => dependency.update(event, node));
                        }
                    });

                    oy += step;
                }

                y += height + verticalSpace;
                if (y + 50 > 500) {
                    y = 10;
                    x += width + horizontalSpace;
                }
                if (representation) {
                    representation.nodes.group.classList.remove('ready');
                    representation.nodes.group.classList.remove('running');
                    representation.nodes.group.classList.remove('waiting');
                    representation.nodes.group.classList.remove('blocked');
                    representation.nodes.group.classList.remove('paused');

                    representation.nodes.group.classList.add({
                        [ready]: 'ready',
                        [running]: 'running',
                        [waiting]: 'waiting',
                        [blocked]: 'blocked',
                        [paused]: 'paused',
                    }[activity.state]);
                }
            });

            const positioned = [...view.map.values()].filter((representation) => representation.moved);
            positioned.sort((a, b) => (a.y + a.height) - (b.y + b.height));
            view.firstColumn = Math.max(textWidth + textHeight, view.firstColumn || 100);
            // Update activity positions based on dependencies, ignoring user positioned activities
            const activities = app.model.activities.filter((activity) => !view.map.get(activity)?.moved);
            const order = (activity, representation, path = []) => {
                if (representation.group || representation.group === 0) {
                    return representation.group;
                }
                const inputs = [...activity.inputs.values()];
                const links = inputs.flatMap((input) => input.links);
                const sources = links.map((link) => link.from.parent || link.from).filter((source) => !path.includes(source));
                if (sources.length) {
                    representation.group = Math.max(0, ...sources.map((source) =>
                        order(source, view.map.get(source), [...path, activity]))) + 1;
                } else {
                    representation.group = 1;
                }
                return representation.group;
            }
            const groups = [];
            activities.forEach((activity) => {
                const representation = view.map.get(activity);
                order(activity, representation);
                groups[representation.group] = groups[representation.group] || 80;

                if (!representation.moved) {
                    representation.y = groups[representation.group];
                    const y = representation.y = positioned.reduce((y, moved) =>
                        (((representation.x + representation.width) > moved.x) &&
                            (representation.x < (moved.x + moved.width)) &&
                            ((representation.y + representation.height) > (moved.y - 30)) &&
                            (representation.y < (moved.y + moved.height))) ? moved.y + moved.height + 30 : y,
                        groups[representation.group]);
                    groups[representation.group] = y + height + verticalSpace;
                    const x = representation.x = view.firstColumn + 50 + (representation.group - 1) * (width + horizontalSpace);
                    // Check for overlap with user positioned item
                    view.updateElement(representation.nodes.group, { transform: `translate (${x}, ${y})` });

                    representation.dependencies.forEach((dependency) =>
                        dependency.update({}, representation));
                }
            });


            // Add stores
            x = view.firstColumn + 50 + (groups.length - 1) * (width + horizontalSpace);
            y = 80;
            const w = 30;
            const h = 10;
            Object.assign(textAttrs, { x: w, y: 30, 'text-anchor': 'middle', 'alignment-baseline': 'hanging' });
            representations.length = 0;
            for (const output of app.model.outputs) {
                const [product, state] = output;
                const fill = state.content.size > 0 ? 'lightgreen' : 'white';
                const representation = view.map.get(state);
                if (representation) {
                    representation.dependencies = [];
                    representation.nodes.outline.setAttribute('fill', fill);
                    representations.push(representation);
                    representation.nodes.label.innerHTML = product.name;
                    representation.bbox = representation.nodes.group.getBBox();
                    representation.nodes.title.innerHTML = representation.nodes.textTitle.innerHTML = `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`;
                } else {
                    const group = view.add('g', null, { transform: `translate (${x}, ${y})` });
                    const d = `M 0 ${h} l ${w} ${-h} l ${w} ${h} v 5 l ${-w} ${h} l ${-w} ${-h} v -5`;
                    const outline = view.add('path', group, { d, fill, stroke: 'black' });
                    const d1 = `M 0 ${h} l ${w} ${h} l ${w} ${-h} M ${w} ${2 * h} v 5`;
                    const detail = view.add('path', group, { d: d1, fill: 'none', stroke: 'black' });
                    const title = view.add('title', outline, {}, `${product.name} (${state.content.size})
${[...state.content].map((asset) => asset.name).join('\n')}`);

                    const label = view.add('text', group, textAttrs, `${product.name}`);
                    const textTitle = view.add('title', label, {}, `${product.name} (${state.content.size})`);

                    const representation = {
                        x, y, width: w * 2, height: h * 2,
                        nodes: { group, outline, detail, title, label, textTitle },
                        bbox: group.getBBox(), dependencies: [],
                    };
                    representations.push(representation);
                    view.map.set(state, representation);
                    outline.addEventListener('click', (event) => {
                        if (event.altKey) {
                            state.validate();
                        } else if (event.shiftKey) {
                            deselect(state, outline);
                        } else {
                            select(state, outline);
                        }
                        updateView();
                    });
                    outline.addEventListener('dblclick', (event) => {
                        const asset = new Asset(product);
                        asset.move(state);
                        state.content.add(asset);
                        state.links.forEach((link) => link.to.update);
                        updateView();
                    });

                    const controls = moveable(representation);
                    addMouseControls(representation.nodes.group, controls);
                    contentTarget(state, outline);
                }
                y += 100;
            }


            // Add links
            for (const link of app.model.links) {
                const representation = view.map.get(link) || {};
                const start = view.map.get(link.from);
                const end = view.map.get(link.to);
                if (start && end) {
                    const x1 = start.x + start.width;
                    const y1 = start.y + start.height / 2;
                    const x2 = end.x;
                    const y2 = end.y + end.height / 2;
                    const mx = (x1 + x2) / 2;
                    const d = `M ${x1} ${y1} C ${mx} ${y1} ${mx} ${y2} ${x2} ${y2}`;
                    if (representation.nodes) {
                        representation.nodes.edge.setAttribute('d', d);
                    } else {
                        const edge = view.addUnder('path', null, { d, fill: 'none', stroke: 'black' });
                        representation.nodes = { edge, };
                        view.map.set(link, representation);
                    }
                    const update = {
                        update(event, changed) {
                            const x1 = start.x + start.width;
                            const y1 = start.y + start.height / 2;
                            const x2 = end.x;
                            const y2 = end.y + end.height / 2;
                            const mx = (x1 + x2) / 2;
                            const d = `M ${x1} ${y1} C ${mx} ${y1} ${mx} ${y2} ${x2} ${y2}`;
                            representation.nodes.edge.setAttribute('d', d);
                        },
                    }
                    start.dependencies.push(update);
                    end.dependencies.push(update);
                }
            }

            app.model.issues.forEach((issue) => {
                const representation = view.map.get(issue) || {};
                const parent = view.map.get(issue.component);
                if (!representation.nodes) {
                    if (parent) {
                        const attrs = {
                            d: `M ${parent.width - 10} 0 h 10 v 10 z`,
                            fill: 'red',
                        };
                        representation.nodes = { main: view.add('path', parent.nodes.group, attrs) };
                        representation.nodes.title = view.add('title', representation.nodes.main, {}, issue.text);
                    }
                }
            });
        }


        /**
         * Make a node editable
         */
        function makeEditable(node, obj, attr) {
            node.contentEditable = true;
            node.addEventListener('blur', (event) => {
                if (attr.set) {
                    attr.set(obj, node.innerText);
                } else {
                    obj[attr] = node.innerText;
                }
            });
            node.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    node.innerText = obj[attr];
                    if (attr.edit) {
                        node.innerText = attr.get(obj);
                    } else {
                        node.innerText = obj[attr];
                    }
                    input.focus();
                }
                if (event.key === 'Enter') {
                    event.preventDefault();
                    if (attr.edit) {
                        attr.set(obj, node.innerText);
                    } else {
                        obj[attr] = node.innerText;
                    }
                }
            });
        }

        /**
         * Update the table of products
         */
        function updateProductList() {
            const container = document.getElementById('product-list');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>Index</th><th>Name</th><th>Qty</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            Product.all.sort((a, b) => a.name?.localeCompare(b.name));
            Product.all.forEach((product, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${index}</td><td>${product.name}</td><td>${product.instances.size}</td>`;
                const idx = row.firstChild;
                const name = idx.nextSibling;
                makeEditable(name, product, 'name');
                body.append(row);
            });
        }

        /**
         * Update the table of assets
         */
        function updateAssetList(product) {
            const container = document.getElementById('asset-list');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>Product</th><th>S/N</th><th>Location</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            const products = new Map();
            [...Asset.all].forEach((asset) => {
                const list = products.get(asset.product) || [];
                products.set(asset.product, list);
                list.push(asset);
            });
            const entries = [...products];
            entries.sort((a, b) => a[0].name?.localeCompare(b[0].name));
            entries.forEach(([product, assets]) => {
                assets.forEach((asset) => {
                    const row = document.createElement('tr');
                    row.draggable = true;
                    row.title = asset[id];
                    row.addEventListener('dragstart', (event) => {
                        event.dataTransfer.setData('text/plain', asset[id]);
                    });
                    row.innerHTML = `<td>${product.name}</td><td>${asset.serialNumber}</td><td>${asset.location?.name}</td>`;
                    const idx = row.firstChild;
                    const serialNumber = idx.nextSibling;
                    makeEditable(serialNumber, asset, 'serialNumber');
                    body.append(row);
                });
            });
        }

        /**
         * Update the table of activities
         */
        function updateActivityList() {
            const container = document.getElementById('activity-list');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>Activity</th><th>Content</th><th>State</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            const activities = app.model.activities;
            activities.sort((a, b) => a.name?.localeCompare(b.name));
            activities.forEach((activity) => {
                const row = document.createElement('tr');
                row.draggable = true;
                row.title = activity[id];
                row.addEventListener('dragstart', (event) => {
                    event.dataTransfer.setData('text/plain', activity[id]);
                });
                row.innerHTML = `<td>${activity.name}</td><td>${activity.getContentString()}</td><td>${activity.getStateDescription()}</td>`;
                const name = row.firstChild;
                makeEditable(name, activity, 'name');
                body.append(row);
            });
        }

        /**
         * Update the table of activities
         */
        function updateList(data, columns, elementId, options = {}) {
            const container = elementId ? document.getElementById(elementId) : document.createElement('div');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>${columns.map((column) => column.title).join('</th><th>')}</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            const activities = app.model.activities;
            data.sort((a, b) => a.name?.localeCompare(b.name));
            data.forEach((item, index) => {
                const row = document.createElement('tr');
                row.title = item[id];
                if (options.draggable) {
                    row.draggable = true;
                    row.addEventListener('dragstart', (event) => {
                        event.dataTransfer.setData('text/plain', item[id]);
                    });
                }
                columns.forEach((column) => {
                    const cell = document.createElement('td');
                    cell.innerHTML = column.get(item, index);
                    if (column.set) {
                        makeEditable(cell, item, column);
                    }
                    row.append(cell);
                });
                body.append(row);
            });
            if (options.append) {
                const row = document.createElement('tr');
                row.title = `Add new ${options.append.type.constructor.__name__}`;

                columns.forEach((column, col) => {
                    const cell = document.createElement('td');
                    const newItem = {};
                    if (options.append.require.includes(col)) {
                        makeEditable(cell, newItem, {
                            get: () => '',
                            set: options.append.set,
                        });
                    } else {
                        cell.classList.add('unused');
                    }
                    row.append(cell);
                });
                body.append(row);
            }
        }

        /**
         * Update the table of links
         */
        function updateLinkList() {
            const container = document.getElementById('link-list');
            container.innerHTML = `
            <table>
                <thead>
                    <tr><th>Product</th><th>From</th><th>To</th></tr>
                </thead>
                <tbody>
                </tbody>`;
            const body = container.lastElementChild;
            const products = app.model.links.reduce((products, link) => {
                const name = link.to.product?.name || 'Any';
                products[name] = products[name] || [];
                products[name].push(link);
                return products;
            }, {});
            const names = Object.keys(products);
            names.sort((a, b) => a.localeCompare(b));

            names.forEach((name) => {
                products[name].forEach((link) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `<td>${name}</td><td>${link.from.name}</td><td>${link.to.name}</td>`;
                    row.draggable = true;
                    row.title = link[id];
                    row.addEventListener('dragstart', (event) => {
                        event.dataTransfer.setData('text/plain', link[id]);
                    });

                    body.append(row);
                });
            });
        }

        /**
         * Update the list of selected items.
         */
        function updateSelected() {
            const node = document.getElementById('selection');
            node.innerHTML = '';
            const list = document.createElement('ul');
            node.append(list);
            for (let element of app.selected) {
                const item = document.createElement('li');
                item.innerHTML = element.name || element.constructor.__name__;
                list.append(item);
                item.addEventListener('click', (event) => {
                    if (app.selected.has(element)) {
                        app.selected.delete(element);
                        updateSelected();
                    }
                });
            }
        }

        loadLocal();
        update();
        tick();

        const input = document.getElementById('command-input');
        //input.addEventListener('change', processCommand);
        input.addEventListener('keydown', processKey);


        const bin = document.getElementById('bin');
        bin.addEventListener('dragover', (event) => event.preventDefault());
        bin.addEventListener('drop', (event) => {
            const itemId = event.dataTransfer.getData('text/plain');
            const asset = [...Asset.all].find((asset) => asset[id] === itemId);
            if (asset) {
                asset.delete();
            }
            const link = app.model.links.find((link) => link[id] === itemId);
            if (link) {
                link.delete();
            }

            updateView();
        });


        //updateCommandList();
        document.body.addEventListener('mousemove', (event) => {
            if (app.actions.move) {
                app.actions.move(event);
            }
        });
        document.body.addEventListener('mouseup', (event) => {
            if (app.actions.up) {
                app.actions.up(event);
            }
            app.actions.move = null
            app.actions.up = null;
        });


        input.focus();
    </script>
</body>

</html>