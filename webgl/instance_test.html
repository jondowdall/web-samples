<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Instances</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            overflow: hidden;
        }

        ul {
            margin: 0;
        }

        #main-canvas {
            width: 100dvw;
            height: 100dvh;
        }

        #top-left {
            position: absolute;
            background-color: white;
            left: 0;
            top: 0;
        }

        #projection-control {
            display: grid;
            grid-template-columns: repeat(2, max-content);
            grid-template-rows: repeat(4, max-content);
        }

        #top-right {
            position: absolute;
            right: 0;
            top: 0;
            display: flex;
            flex-direction: column;
            align-items: end;
        }

        #movement {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            background-color: white;
        }

        #stock {
            background-color: white;
        }

        #view-vectors {
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            background-color: white;
        }

        .matrix-input {
            width: 5em;
        }

        #projection-control>details {
            grid-column: 1 / -1;
        }

        details details {
            margin-left: 1em;
        }

        #structure {
            display: grid;
            grid-template-columns: minmax(10em, min-content) repeat(7, max-content);
            grid-template-columns: minmax(10em, min-content) repeat(13, max-content);

            grid-gap: 3px;
            overflow: auto;
            max-height: 50vh;
        }

        #structure .value {
            text-align: center;
        }

        #notification {
            position: fixed;
            top: 1em;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 0.5em;
            padding: 0.3em;
        }

        #state {
            position: fixed;
            bottom: 1em;
            left: 1em;
            background-color: white;
            border-radius: 0.5em;
            padding: 0.3em;
        }

        #info {
            position: fixed;
            bottom: 1em;
            right: 1em;
            color: yellow;
            background-color: rgb(80, 80, 30, 0.8);
            border: 1px solid orange;
            border-radius: 0.5em;
            padding: 0.5em;
            min-width: 20em;
            display: grid;
            grid-template-columns: max-content 1fr;
            grid-auto-rows: max-content;
            grid-row-gap: 3px;
        }

        .all-columns {
            grid-column: 1 / -1;
        }

        #info h2 {
            margin-block-start: 0em;
        }

        #info textarea {
            background-color: none;
            width: 100%;
            height: 12em;
        }

        #load-file {
            display: none;
        }

        .texture-canvas {
            position: fixed;
            top: 200px;
            left: 0;
            z-index: 1000;
        }

        .selected {
            font-weight: bold;
        }

        .hidden {
            color: gray;
            font-style: italic;
        }

        .hide {
            display: none !important;
        }

        .three-columns {
            grid-column: span 3;
        }

        .two-rows {
            grid-row: span 2;
        }

        .expander {
            display: inline-block;
            width: 0.8em;
            height: 0.8em;
            text-align: center;
            font-size: 80%;
            padding-right: 0.5em;
        }
    </style>
</head>

<body>
    <canvas id="main-canvas" tabindex="1">HTML canvas not supported!</canvas>

    <div id="top-left">
        <details>
            <summary>View Control</summary>
            <div id="projection-control">
                Field of View<input id="field-of-view" type="number" />
                Aspect<input id="aspect" type="number" />
                Near<input id="near" type="number" />
                Far<input id="far" type="number" />
            </div>
        </details>
        <details>
            <summary>Structure</summary>
            <div id="structure">
                <span class="two-rows">Name</span>
                <span class="three-columns">Position</span>
                <span class="three-columns">Size</span>
                <span class="two-rows">Angle</span>
                <span class="three-columns">Axis</span>
                <span class="two-rows">Colour</span>
                <span class="two-rows">Specular</span>
                <span class="two-rows">Opacity</span>

                <span>x</span>
                <span>y</span>
                <span>z</span>

                <span>x</span>
                <span>y</span>
                <span>z</span>

                <span>x</span>
                <span>y</span>
                <span>z</span>
            </div>
        </details>

    </div>
    <div id="top-right">
        <input type="file" id="load-file" multiple />
        <div id="view-vectors"></div>
        <div id="stock"></div>
    </div>
    <div id="movement">
        <button id="anti-clockwise">&#8634;</button>
        <button id="move-up">&#8593;</button>
        <button id="clockwise">&#8635;</button>

        <button id="move-left">&#8592;</button>
        <button id="clear">&#9114;</button>
        <button id="move-right">&#8594;</button>

        <button id="move-forward">&#8634;</button>
        <button id="move-down">&#8595;</button>
        <button id="move-backwards">&#8634;</button>
    </div>
    <div id="state"></div>
    <div id="info" class="hide"></div>

    <script type="x-shader/x-vertex" id="vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in vec3 normal;
    in mat4 model;
    in vec3 ambientColour;
    in vec3 diffuseColour;
    in vec3 specularColour;
    in float specularIntensity;
    in float opacity;

    out vec4 v_vertex;
    out vec4 v_normal;
    out vec3 v_ambientColour;
    out vec3 v_diffuseColour;
    out vec3 v_specularColour;
    out float v_opacity;
    out float v_specularIntensity;

    void main() {
        v_vertex = model * vec4(position, 1.0);
        gl_Position = projection * view * v_vertex;
        v_normal = model * vec4(normal, 0.0);
        v_ambientColour = ambientColour;
        v_diffuseColour = diffuseColour;
        v_specularColour = specularColour;
        v_opacity = opacity;
        v_specularIntensity = specularIntensity;

        gl_PointSize = 50.0;//50.0 * model[0][0];

        if (opacity < 1.0) {
            gl_Position.z = gl_Position.w;
        }
    }
    </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
    #version 300 es
    precision highp float;

    uniform vec3 lightPosition1;
    uniform vec3 lightPosition2;
    uniform vec3 lightPosition3;
    uniform vec3 cameraPosition;

    in vec4 v_vertex;
    in vec4 v_normal;
    in vec3 v_ambientColour;
    in vec3 v_diffuseColour;
    in vec3 v_specularColour;
    in float v_specularIntensity;
    in float v_opacity;

    out vec4 fragmentColour;

    void main() {
        vec3 toLight1 = normalize(lightPosition1 - v_vertex.xyz);
        vec3 toLight2 = normalize(lightPosition2 - v_vertex.xyz);
        vec3 toLight3 = normalize(lightPosition3 - v_vertex.xyz);
        vec3 normal = normalize(v_normal.xyz);

        float df = max(0.0, dot(normal, toLight1)) + 0.2 * max(0.0, dot(normal, toLight2)) + 0.1 * max(0.0, dot(normal, toLight3));

        vec3 reflection1 = normalize(2.0 * dot(normal, toLight1) * normal - toLight1);
        vec3 reflection2 = normalize(2.0 * dot(normal, toLight2) * normal - toLight2);
        vec3 reflection3 = normalize(2.0 * dot(normal, toLight3) * normal - toLight3);
        vec3 toEye = normalize(cameraPosition - v_vertex.xyz);
        float sf = clamp(dot(reflection1, toEye), 0.0, 1.0) + 0.2 * clamp(dot(reflection2, toEye), 0.0, 1.0) + 0.1 * clamp(dot(reflection3, toEye), 0.0, 1.0);
        sf = pow(sf, v_specularIntensity);

        vec3 colour = v_ambientColour + v_diffuseColour * df + v_specularColour * sf;
        fragmentColour = vec4(colour, v_opacity);

        /*
        if (v_opacity > 0.0 && dot(normal, toEye) > -0.1) {
            discard;
            return;
        }
        fragmentColour = vec4(colour, 1.0);
        */
    }
    </script>
    <script type="x-shader/x-fragment" id="text-vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in mat4 model;

    in vec2 offset;
    in vec2 size;
    in vec2 textureSize;
    in vec2 textureOrigin;

    in vec4 colour;

    out vec4 v_colour;
    out vec2 v_textureCoordinate;

    void main() {
        gl_Position = projection * view * model * vec4(position, 1.0);
        gl_Position = vec4(gl_Position.xy + offset * size * gl_Position.w, gl_Position.zw);

        vec2 textureOffset = (offset + vec2(1.0, -1.0)) / vec2(2.0, -2.0);
        v_textureCoordinate = textureOrigin + textureOffset * textureSize;
        v_colour = colour;

    }
    </script>
    <script type="x-shader/x-fragment" id="text-fragment-shader">
    #version 300 es
    precision highp float;
    uniform sampler2D source;

    in vec2 v_textureCoordinate;
    in vec4 v_colour;

    out vec4 fragmentColour;

    void main() {
        fragmentColour = v_colour * texture(source, v_textureCoordinate);

        if (fragmentColour.a < 0.001) {
            discard;
            return;
        }
    }
    </script>

    <script>
        /**
         * Update report display.
         */
        function report(...text) {
            document.getElementById('state').innerText = text.join();
        }

        /**
         * Return an identity matrix
         */
        function identityMatrix() {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }

        /**
         * Get the hex value of the input number
         */
        function toHex(number, chars) {
            const result = [];
            const sign = number < 0 ? '-' : '';
            number = Math.floor(Math.abs(number));
            const digit = number & 0xf;
            result.push('0123456789ABCDEF'.charAt(digit));
            number >>= 4;
            while (number) {
                const digit = number & 0xf;
                result.unshift('0123456789ABCDEF'.charAt(digit));
                number >>= 4;
            }
            if (chars) {
                return `${sign}${result.join('')}`.padStart(chars, '0');
            }
            return sign + result.join('');
        }

        /**
         * Create matrix control.
         */
        function projectionControl() {
            const fov = document.getElementById('field-of-view');
            fov.value = app.initial.fov;
            const aspect = document.getElementById('aspect');
            aspect.value = app.initial.aspect;
            const near = document.getElementById('near');
            near.value = app.initial.near;
            const far = document.getElementById('far');
            far.value = app.initial.far;

            const update = () => {
                app.fov = fov.valueAsNumber;
                app.aspect = aspect.valueAsNumber;
                app.near = near.valueAsNumber;
                app.far = far.valueAsNumber;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            }
            fov.addEventListener('change', (event) => update());
            aspect.addEventListener('change', (event) => update());
            near.addEventListener('change', (event) => update());
            far.addEventListener('change', (event) => update());
            update();
        }

        /**
         * Get view vectors
         */
        function viewVectors() {
            const viewVector = subtract(app.camera.lookAt, app.camera.position);
            const distance = Math.hypot(...viewVector);
            const zAxis = normalised(viewVector);
            const xAxis = normalised(cross(zAxis, app.camera.up));
            const yAxis = normalised(cross(xAxis, zAxis));
            return { xAxis, yAxis, zAxis, distance };
        }

        /**
         * Move Forward.
         */
        function forward(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const offset = scale(zAxis, amount * distance / 10);
            moveCamera(add(app.camera.position, offset), add(app.camera.lookAt, offset), app.camera.up);
            canvas.focus();

        }

        /**
         * Move right.
         */
        function right(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const offset = scale(xAxis, amount * distance / 10);
            moveCamera(add(app.camera.position, offset), add(app.camera.lookAt, offset), app.camera.up);
            canvas.focus();

        }

        /**
         * Move up.
         */
        function up(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const offset = scale(yAxis, amount * distance / 10);
            moveCamera(add(app.camera.position, offset), add(app.camera.lookAt, offset), app.camera.up);
            canvas.focus();
        }

        /**
         * Roll clockwise.
         */
        function clockwise(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const rotation = getRotation(-amount * 15, zAxis);
            const roll = applyTransform(yAxis, rotation);
            moveCamera(app.camera.position, app.camera.lookAt, roll);
            canvas.focus();

        }

        /**
         * Rotate right
         */
        function rotateRight(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const direction = subtract(app.camera.lookAt, app.camera.position);
            const rotation = getRotation(-amount * 15, yAxis);
            const newDirection = applyTransform(direction, rotation);
            moveCamera(app.camera.position, add(app.camera.position, newDirection), app.camera.up);
        }

        /**
         * Get a unique name for a new block
         */
        function getUniqueName(base = 'block') {
            let index = 1;
            let name = `${base} ${index++}`;
            while (app.instances.find((instance) => instance.name === name)) {
                name = `${base} ${index++}`;
            }
            return name
        }

        /**
         * Add a new block
         */
        function newBlock(offset) {
            const selected = app.instances.filter((instance) => instance.selected);
            if (selected.length) {

            } else {
                const scale = Math.hypot(...subtract(app.camera.lookAt, app.camera.position)) / 10;
                const name = getUniqueName();
                const newInstance = app.addRoot(name, [...app.camera.lookAt], [scale, scale, scale]);
            }
            initialiseInstances()
            app.colourUpdate = true;
            updateText();
            showStructure();
        }

        /**
         * Add a block next to the current block
         */
        function addBlocks(offset) {
            const selected = app.instances.filter((instance) => instance.selected);
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            selected.forEach((selected) => {
                offset = applyTransform(offset, selected.rotation);
                const position = add(selected.position, product(selected.size, offset));
                const name = getUniqueName(selected.name.replace(/\s*[0-9]+/, ''));
                const attributes = [
                    name,
                    position,
                    [...selected.size],
                    selected.angle,
                    [...selected.axis],
                    [...selected.colour],
                    selected.opacity,
                    selected.specular
                ];
                if (selected.parent) {
                    const newInstance = selected.parent.addChild(...attributes);
                    newInstance.selected = true;
                } else {
                    const newInstance = app.addRoot(...attributes);
                    newInstance.selected = true;
                }
                selected.selected = false;
            });
            initialiseInstances();
            app.colourUpdate = true;
            updateText();
            showStructure();
        }

        /**
         * Add a block next to the current block
         */
        function deleteBlocks(offset) {
            const selected = app.instances.filter((instance) => instance.selected);
            selected.forEach((selected) => {
                selected.delete();
            });
            app.instances = app.instances.filter((instance) => !selected.includes(instance));
            initialiseInstances()
            app.colourUpdate = true;
            updateText();
            showStructure();
        }

        /**
         * Move the camera to a new position
         */
        function setView(direction = [0, 0, 1], up = [0, 1, 0]) {
            // Use the initial position to determine the desired distance from viewpoint
            const lookAt = app.initial.lookAt;
            const viewVector = subtract(app.initial.lookAt, app.initial.position);
            const dist = Math.hypot(...viewVector);
            const offset = scale(direction, dist);
            const position = add(lookAt, offset);

            moveCamera(position, lookAt, up);
        }

        /**
         * Move the camera based on the updated position, lookAt and 'up' vectors
         */
        function moveCamera(position, lookAt, up) {
            // Get the current directions and distance to view point.
            const { xAxis, yAxis, zAxis, distance } = viewVectors();

            const direction = subtract(lookAt, position);
            const endDistance = Math.hypot(...direction);
            app.movement = {
                state: 'start',
                start: null,
                duration: 1000,
                lookAt: {
                    start: app.camera.lookAt,
                    delta: subtract(lookAt, app.camera.lookAt),
                },
                distance: {
                    start: distance,
                    delta: endDistance - distance,
                },
                direction: scale(zAxis, -1),
            };

            // Calculate the axis and angle from the cross product of the view directions
            const axis = cross(zAxis, normalised(direction));
            const opposite = Math.sign(dot(zAxis, direction)) || 1;
            const deg = -180 * Math.asin(Math.hypot(...axis)) / Math.PI;
            // Allow for angles greater than 90 degrees
            const angle = opposite < 0 ? 180 + deg : deg;
            if (Math.abs(angle) < 0.001) {
                axis[1] = 1;
            }
            app.movement.rotation = { angle, axis: normalised(scale(axis, opposite)), };
            const rotation = getRotation(app.movement.rotation.angle, app.movement.rotation.axis);
            const endUp = applyTransform(yAxis, rotation);
            const x1 = normalised(cross(up, direction));
            const x2 = normalised(cross(endUp, direction));
            // Calculate the axis and angle from the cross product of the view directions
            const rollAxis = cross(x1, x2);
            const accute = dot(x1, x2) || 1;
            const sign = Math.sign(dot(rollAxis, direction));
            const roll1 = -180 * sign * Math.asin(Math.hypot(...rollAxis)) / Math.PI;
            const roll = accute < 0 ? -180 - roll1 : roll1;
            // Check for 180 degree rotation
            if (Math.abs(roll) < 0.1 && dot(endUp, up) < 0) {
                app.movement.roll = 180;
            } else {
                app.movement.roll = roll;
            }
            app.movement.up = yAxis;
            app.movement.timing = (input) => 0.5 - 0.5 * Math.cos(input * Math.PI);
        }

        /**
         * Reset the view and clear the points
         */
        function reset() {
            moveCamera(app.initial.position, app.initial.lookAt, app.initial.up);

            app.fov = app.initial.fov;
            app.near = app.initial.near;
            app.far = app.initial.far;
            app.aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;

            app.points = [];
        }

        /**
         * Add actions for the movement controls
         */
        function addMovementControls() {
            document.getElementById('anti-clockwise').addEventListener('click', (event) => clockwise(-1));
            document.getElementById('move-up').addEventListener('click', (event) => up());
            document.getElementById('clockwise').addEventListener('click', (event) => clockwise());

            document.getElementById('move-left').addEventListener('click', (event) => right(-1));
            document.getElementById('clear').addEventListener('click', (event) => reset());
            document.getElementById('move-right').addEventListener('click', (event) => right());

            document.getElementById('move-forward').addEventListener('click', (event) => forward());
            document.getElementById('move-down').addEventListener('click', (event) => up(-1));
            document.getElementById('move-backwards').addEventListener('click', (event) => forward(-1));
        }

        /**
         * Create matrix control.
         */
        function viewControl() {
            const container = document.getElementById('view-vectors');

            const update = () => {
                const { xAxis, yAxis, zAxis, distance } = viewVectors();
                app.camera.up = yAxis; // Ensure 'up' is perpendicular to look direction
                app.viewMatrix = viewMatrix(app.camera.position, app.camera.lookAt, app.camera.up);
            }

            const vectorControl = (attribute, name) => {
                app.camera[attribute].forEach((value, index) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = value;
                    input.id = `${name}-${index}`;
                    input.classList.add('matrix-input');
                    input.addEventListener('input', (event) => {
                        app.camera[attribute][index] = input.valueAsNumber;
                        update();
                    });
                    input.addEventListener('focus', (event) => app.editingViewControls = true);
                    input.addEventListener('blur', (event) => app.editingViewControls = false);
                    container.appendChild(input);
                });
            };
            app.camera.position = [0, 0, 15];
            app.camera.lookAt = [0, 0, 0];
            app.camera.up = [0, 1, 0];
            viewVectors();
            vectorControl('position', 'camera-position')
            vectorControl('lookAt', 'look-at');
            vectorControl('up', 'up');
            update();
            app.camera.updateViewControls = () => {
                if (!app.editingViewControls) {
                    document.getElementById('camera-position-0').value = app.camera.position[0].toFixed(1);
                    document.getElementById('camera-position-1').value = app.camera.position[1].toFixed(1);
                    document.getElementById('camera-position-2').value = app.camera.position[2].toFixed(1);

                    document.getElementById('look-at-0').value = app.camera.lookAt[0].toFixed(1);
                    document.getElementById('look-at-1').value = app.camera.lookAt[1].toFixed(1);
                    document.getElementById('look-at-2').value = app.camera.lookAt[2].toFixed(1);

                    document.getElementById('up-0').value = app.camera.up[0].toFixed(2);
                    document.getElementById('up-1').value = app.camera.up[1].toFixed(2);
                    document.getElementById('up-2').value = app.camera.up[2].toFixed(2);
                }
            }
        }

        /**
         * This script manages a single gl context so intialise here for simplicity.
         */
        const canvas = document.getElementById('main-canvas');
        const gl = canvas.getContext('webgl2');

        /**
         * Utility function to parse and report errors
         */
        function glErrors(context = '') {
            const err = gl.getError();

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.trace();
                console.log(context, errors[err]);
            }
        }

        /**
         * App object to minimise global namespace polution.
         */
        const app = {
            camera: {
                position: [0, 0, 15],
                lookAt: [0, 0, 0],
                up: [0, 1, 0],
            },
            initial: {
                position: [0, 0, 15],
                lookAt: [0, 0, 0],
                up: [0, 1, 0],
                fov: 30,
                aspect: gl.canvas.clientWidth / gl.canvas.clientHeight,
                near: 1,
                far: 10000,
            },
            movement: {},
            projectionMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            viewMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            instances: [],
            stock: {},
            nodes: [],
            points: [],
            connections: [],
            text: [],
            scale: 1, //0.001,
            roots: [],
            wireframe: false,
            cullFaces: true,
            cornerOrigin: true,
            velocity: [0, 0, 0],
            rotation: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            addRoot(name, position, size, rotation, axis, colour, opacity, specular) {
                const data = name;
                if (typeof name === 'object') {
                    position = getAttribute(name, 'position');
                    size = getAttribute(name, 'size');
                    angle = getAttribute(name, 'angle');
                    axis = getAttribute(name, 'axis');
                    colour = getAttribute(name, 'colour');
                    opacity = getAttribute(name, 'opacity');
                    specular = getAttribute(name, 'specular');
                    name = getAttribute(name, 'name');
                }
                const root = new Instance(
                    undefined,
                    name,
                    position,
                    size,
                    rotation,
                    axis,
                    colour,
                    opacity,
                    specular,
                    data);
                this.instances.push(root);
                this.roots.push(root);
                return root;
            },
        };

        const shaderSource = {
            vertex: document.querySelector("#vertex-shader").innerHTML,
            fragment: document.querySelector("#fragment-shader").innerHTML,
        }
        const textShaderSource = {
            vertex: document.querySelector("#text-vertex-shader").innerHTML,
            fragment: document.querySelector("#text-fragment-shader").innerHTML,
        }

        /**
         * Create and compile a shader of the specified type using the source provided.
         */
        function makeShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source.trim());
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return;
            }
            return shader;
        }

        /**
         * Compile shaders into a program.
         */
        function makeProgram(source, attributes = [], uniforms = []) {
            const vertex = makeShader(gl.VERTEX_SHADER, source.vertex);
            const fragment = makeShader(gl.FRAGMENT_SHADER, source.fragment);

            // Create a program instance for the shaders
            if (vertex && fragment) {
                const shader = {
                    program: gl.createProgram(),
                };
                gl.attachShader(shader.program, vertex);
                gl.attachShader(shader.program, fragment);
                gl.linkProgram(shader.program);

                // See if it linked successfully
                if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
                    alert('Unable to initialise the shader program: ' + gl.getProgramInfoLog(shader.program));
                    return null;
                }

                uniforms.forEach((uniform) => shader[uniform] = gl.getUniformLocation(shader.program, uniform));
                attributes.forEach((attribute) => shader[attribute] = gl.getAttribLocation(shader.program, attribute));

                return shader;
            }
        }

        /**
         * Generate the vertex data for a cube.
         */
        function makeCube() {
            const positions = [
                [-1, -1, -1,],
                [1, -1, -1,],
                [-1, 1, -1,],
                [1, 1, -1,],
                [-1, -1, 1,],
                [1, -1, 1,],
                [-1, 1, 1,],
                [1, 1, 1,],
            ].map((v) => v.map((i) => i / 2));
            const normals = [
                [-1, 0, 0,],
                [0, -1, 0,],
                [0, 0, -1,],
                [1, 0, 0,],
                [0, 1, 0,],
                [0, 0, 1,],
            ];

            /*
            *       4 ------ 5
            *      /|        | \
            *    0 ------------ 1
            *    |  |        |  |
            *    |  |        |  |
            *    |  |        |  |
            *    |  6 ------ 7  |
            *    | /          \ |
            *    2 ------------ 3
            */

            const triangles = [
                { p1: positions[0], p2: positions[1], p3: positions[2], n: normals[2] },
                { p1: positions[1], p2: positions[3], p3: positions[2], n: normals[2] },

                { p1: positions[0], p2: positions[4], p3: positions[5], n: normals[1] },
                { p1: positions[5], p2: positions[1], p3: positions[0], n: normals[1] },

                { p1: positions[4], p2: positions[6], p3: positions[7], n: normals[5] },
                { p1: positions[5], p2: positions[4], p3: positions[7], n: normals[5] },

                { p1: positions[6], p2: positions[2], p3: positions[3], n: normals[4] },
                { p1: positions[7], p2: positions[6], p3: positions[3], n: normals[4] },

                { p1: positions[3], p2: positions[1], p3: positions[5], n: normals[3] },
                { p1: positions[5], p2: positions[7], p3: positions[3], n: normals[3] },

                { p1: positions[6], p2: positions[4], p3: positions[0], n: normals[0] },
                { p1: positions[6], p2: positions[0], p3: positions[2], n: normals[0] },
            ];
            const lines = [
                positions[0], positions[1],
                positions[1], positions[3],
                positions[3], positions[2],
                positions[2], positions[0],

                positions[0], positions[4],
                positions[1], positions[5],
                positions[2], positions[6],
                positions[3], positions[7],

                positions[4], positions[5],
                positions[5], positions[7],
                positions[7], positions[6],
                positions[6], positions[4],
            ];
            const normalised = ([x, y, z]) => {
                const l = Math.hypot(x, y, z);
                return [x / l, y / l, z / l];
            };
            return [...triangles.flatMap((t) => [...t.p1, ...t.n, ...t.p2, ...t.n, ...t.p3, ...t.n]),
            ...lines.flatMap((p) => [...p, ...normalised(p)])];
        }

        /**
         * Generate the vertex data for a cube.
         */
        function makeBanner() {
            return [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
        }

        /**
         * Update the gl buffers used to define the base object used for instancing.
         */
        function updateObject() {

        }

        /**
         * Initialise Instances
         */
        function initialiseInstances() {
            const matrices = [];
            const reversed = app.instances.filter((instance) => !instance.hidden).toReversed();
            reversed.forEach((instance) => matrices.push(...instance.transform));

            app.modelMatrix = new Float32Array(matrices); // 4 bytes per float, 16 floats per matrix
            reversed.forEach((instance, index) =>
                instance.matrix = new Float32Array(app.modelMatrix.buffer, index * 16 * 4, 16));

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferData(gl.ARRAY_BUFFER, app.modelMatrix.byteLength, gl.DYNAMIC_DRAW);

            app.colourUpdate = true;

            app.instancesChanged = true;
            app.instanceCount = reversed.length;
        }

        /**
         * Update the colour data from the instances.
         */
        function updateColours() {
            const colourBuffer = [];
            const setTransparency = (instance) => {
                instance.state.transparent = instance.content.reduce((result, instance) => result || (setSelected(instance)), 1);
                return instance.state.transparent || instance.selected;
            }
            app.roots.forEach((instance) => setTransparency(instance));
            app.instances.filter((instance) => !instance.hidden).toReversed().forEach((instance, index) => {
                if (instance.state.ghost) {
                    colourBuffer.push(0.3, 0.3, 0.3);
                    colourBuffer.push(0.3, 0.3, 0.3);
                    colourBuffer.push(0.1, 0.1, 0.1);
                    colourBuffer.push(instance.specular);
                    colourBuffer.push(0.05);
                } else if (instance.state.set) {
                    colourBuffer.push(0.3, 0.0, 0.0);
                    colourBuffer.push(0.3, 0.0, 0.0);
                    colourBuffer.push(0.1, 0.0, 0.0);
                    colourBuffer.push(instance.specular);
                    colourBuffer.push(0.1);
                } else if (instance.state.constraint) {
                    colourBuffer.push(0.3, 1.0, 0.3);
                    colourBuffer.push(0.3, 1.0, 0.3);
                    colourBuffer.push(0.1, 1.0, 0.1);
                    colourBuffer.push(instance.specular);
                    colourBuffer.push(0.1);
                } else if (instance.state.hit) {
                    colourBuffer.push(1.0, 0.0, 0.0);
                    colourBuffer.push(1.0, 0.0, 0.0);
                    colourBuffer.push(1.0, 0.0, 0.0);
                    colourBuffer.push(instance.specular);
                    colourBuffer.push(1.0);
                } else {
                    const colour = instance.selected ? [1, 1, 1] : (instance.statusColour ?? instance.colour);
                    colourBuffer.push(...colour.map((v) => v * 0.3));
                    colourBuffer.push(...colour.map((v) => v * 0.3));
                    colourBuffer.push(...colour.map((v) => v * 1.0));
                    colourBuffer.push(instance.specular);
                    const opacity = ((app.solid && !instance.state.transparent) || instance.state.moving) ? 1 : app.wireframe ? 0.1 : instance.content.length > 0 ? 0.5 : 1;
                    colourBuffer.push(opacity);
                }
            });
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colourBuffer), gl.STATIC_DRAW);
        }

        /**
         * Update the colour data from the instances.
         */
        function updatePoints() {
            const points = app.points.flatMap((point) => [...point.position, 1, 1, 1]);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.DYNAMIC_DRAW);
        }

        /**
         * Initialise the text data
         */
        function initialiseText() {
            gl.useProgram(app.textShader.program);
            app.textVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.textVertexArray);

            const shape = makeBanner();
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textInstance);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);

            gl.vertexAttribPointer(app.textShader.offset, 2, gl.FLOAT, false, 4 * 2, 0);
            gl.enableVertexAttribArray(app.textShader.offset);

            const stride = 4 * (3 + 2 + 2 + 2 + 4 + 16);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textItems);

            gl.vertexAttribPointer(app.textShader.position, 3, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(app.textShader.position);
            gl.vertexAttribDivisor(app.textShader.position, 1);

            gl.vertexAttribPointer(app.textShader.size, 2, gl.FLOAT, false, stride, 4 * 3);
            gl.enableVertexAttribArray(app.textShader.size);
            gl.vertexAttribDivisor(app.textShader.size, 1);

            gl.vertexAttribPointer(app.textShader.textureSize, 2, gl.FLOAT, false, stride, 4 * (3 + 2));
            gl.enableVertexAttribArray(app.textShader.textureSize);
            gl.vertexAttribDivisor(app.textShader.textureSize, 1);

            gl.vertexAttribPointer(app.textShader.textureOrigin, 2, gl.FLOAT, false, stride, 4 * (3 + 2 + 2));
            gl.enableVertexAttribArray(app.textShader.textureOrigin);
            gl.vertexAttribDivisor(app.textShader.textureOrigin, 1);

            gl.vertexAttribPointer(app.textShader.colour, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2));
            gl.enableVertexAttribArray(app.textShader.colour);
            gl.vertexAttribDivisor(app.textShader.colour, 1);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.textShader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2 + 4 + i * 4));
                gl.enableVertexAttribArray(location);
                gl.vertexAttribDivisor(location, 1);
            }
        }

        /**
         * Initialise a texture and copy an image from the specified canvas.
         */
        function copyTexture(canvas) {
            app.textTexture = app.textTexture ?? gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, app.textTexture);

            // target, level, internalFormat, srcFormat, srcType, source
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);

            glErrors(gl, 'Load Texture');
        }

        /**
         * Update text data
         */
        function updateText() {
            const width = 2048;
            if (!app.textureCanvas) {
                app.textureCanvas = document.createElement('canvas');
                app.textureCanvas.classList.add('texture-canvas', 'hide');
                document.body.appendChild(app.textureCanvas);
            }
            const context = app.textureCanvas.getContext('2d');
            app.textureCanvas.width = width;
            app.textureCanvas.height = 2048;

            context.fillStyle = 'white';
            context.font = '24px sans-serif';
            context.textBaseline = 'hanging';

            let x = y = 0;
            let lineHeight = 0;

            // Create dictionary of all labels
            const labels = new Set(app.instances.map((instance) => instance.name));

            // Determine size of canvas required
            labels.forEach((label) => {
                const metrics = context.measureText(label);
                const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                if (x + metrics.width + (fontHeight * 2) > width) {
                    x = 0;
                    y += lineHeight;
                    lineHeight = 0;
                }
                x += metrics.width + (fontHeight * 2);
                lineHeight = Math.max(lineHeight, fontHeight);
            });

            if (y + lineHeight > context.height) {
                context.height = app.textureCanvas.height = y + lineHeight;
                context.clearRect(0, 0, app.textureCanvas.width, app.textureCanvas.height);

                context.fillStyle = 'white';
                context.font = '24px sans-serif';

                context.textBaseline = 'hanging';
            }

            context.clearRect(0, 0, app.textureCanvas.width, app.textureCanvas.height);

            lineHeight = x = y = 0;
            app.text = {};
            labels.forEach((label) => {
                const metrics = context.measureText(label);

                const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;

                if (x + metrics.width + (fontHeight * 2) > width) {
                    x = 0;
                    y += lineHeight;
                    lineHeight = 0;
                }
                const radius = fontHeight / 2;
                const textureOrigin = [x, y];
                context.fillStyle = 'rgb(0, 0, 80, 0.9)';
                context.beginPath();
                context.moveTo(x + radius, y);
                context.lineTo(x + radius + metrics.width, y);

                context.arcTo(x + radius * 2 + metrics.width, y, x + radius * 2 + metrics.width, y + radius, radius);
                context.arcTo(x + radius * 2 + metrics.width, y + fontHeight, x + radius + metrics.width, y + fontHeight, radius);

                context.lineTo(x + radius + metrics.width, y + fontHeight);
                context.lineTo(x + radius, y + fontHeight);

                context.arcTo(x, y + fontHeight, x, y + radius, radius);
                context.arcTo(x, y, x + radius, y, radius);

                context.fill();

                context.fillStyle = 'white';
                context.fillText(label, x + radius, y + 2);
                x += metrics.width + fontHeight;
                lineHeight = Math.max(lineHeight, fontHeight);

                app.text[label] = {
                    size: [metrics.width + fontHeight, fontHeight],
                    textureOrigin,
                    canvas: app.textureCanvas,
                }
            });
            /*
            app.text = {};
            names.forEach((name) => {
                const metrics = context.measureText(instance.name);

                const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;

                if (x + metrics.width > width) {
                    x = 0;
                    y += lineHeight;
                    lineHeight = 0;
                }
                const textureOrigin = [x, y];
                context.fillText(instance.name, x, y);
                x += metrics.width;

                lineHeight = Math.max(lineHeight, fontHeight);
                const scale = instance.labelScale ?? 1;

                return {
                    position: instance.labelPosition ?? [0.0, 0.0, 0.0],
                    size: [scale * metrics.width, scale * fontHeight],
                    textureOrigin,
                    colour: instance.labelColour ?? [1, 1, 1, 1],
                    instance,
                    canvas: app.textureCanvas,
                }
            });
            */
            copyTexture(app.textureCanvas);
            updateTextBuffer();
        }

        /**
         * Update the buffer containing the text instance data.
         */
        function updateTextBuffer() {
            const data = [];
            const selected = app.showNames ? app.instances : app.instances.filter((instance) => instance.selected);
            selected.forEach((instance) => {
                const text = app.text[instance.name];
                const position = instance.labelPosition ?? [0.0, 0.0, 0.0];
                const scale = instance.labelScale ?? 1;
                const size = [scale * text.size[0], scale * text.size[1]];
                const colour = instance.labelColour ?? [1, 1, 1, 1];
                data.push(...position);
                data.push(size[0] / gl.canvas.clientWidth, size[1] / gl.canvas.clientHeight); // image size
                data.push(size[0] / text.canvas.width, size[1] / text.canvas.height);  // Texture Size
                data.push(text.textureOrigin[0] / text.canvas.width, text.textureOrigin[1] / text.canvas.height); // Texture origin
                data.push(...colour);
                data.push(...instance.origin);
            });
            app.textItemCount = selected.length;
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textItems);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        }

        /**
         * Add instance
         */
        function addInstance(size, position, rotation) {

        }

        /**
         * Calculate the product of 2 4 x 4 matrices and store the result in the third.
         */
        function multiply(a, b, matrix) {
            matrix = matrix || Array(16);
            matrix[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
            matrix[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
            matrix[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
            matrix[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

            matrix[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
            matrix[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
            matrix[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
            matrix[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

            matrix[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
            matrix[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
            matrix[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
            matrix[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

            matrix[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
            matrix[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
            matrix[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
            matrix[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
            return matrix;
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateInstances(time) {
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, app.modelMatrix);
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateLines(time) {
            const vertices = [];
            app.connections.flatMap((connection) => connection.addVertices(vertices));
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.lines);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
        }

        /**
         * Update the object definition and the instances if required.
         */
        function updateBuffers(time) {
            if (app.colourUpdate) {
                updateColours();
                app.updateColours = false;
            }
            if (app.objectChanged) {
                updateObject(time);
            }
            if (app.instancesChanged) {
                updateInstances(time);
                app.instancesChanged = false;
            }
            updateLines(time);
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            const f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zNear + zFar) / (zNear - zFar), -1,
                0, 0, 2 * (zFar * zNear) / (zNear - zFar), 0,
            ];
        }

        /**
         * Calculate a view matrix from camera position, focus point and up vecotrs.
         */
        function viewMatrix(cameraPosition, lookAt, up) {
            const negate = (v) => { v[0] *= -1; v[1] *= -1; v[2] *= -1; };
            const zaxis = normalised(subtract(lookAt, cameraPosition));
            const xaxis = normalised(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, cameraPosition), -dot(yaxis, cameraPosition), -dot(zaxis, cameraPosition), 1,
            ];
        }

        /**
         * Set Attribute pointers for drawing boxes.
         */
        function setBoxAttributes() {
            app.boxVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.boxVertexArray);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride = 3 * 4 * 2,  offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.normal);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);
        }

        /**
         * Set Attribute pointers for drawing points.
         */
        function setPointAttributes() {
            app.pointVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.pointVertexArray);

            gl.disableVertexAttribArray(app.shader.normal);
            gl.vertexAttrib3f(app.shader.normal, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.model);
            gl.disableVertexAttribArray(app.shader.model + 1);
            gl.disableVertexAttribArray(app.shader.model + 2);
            gl.disableVertexAttribArray(app.shader.model + 3);
            gl.vertexAttrib4f(app.shader.model, 1, 0, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 1, 0, 1, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 2, 0, 0, 1, 0);
            gl.vertexAttrib4f(app.shader.model + 3, 0, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttrib1f(app.shader.specularIntensity, 1);

            gl.disableVertexAttribArray(app.shader.opacity);
            gl.vertexAttrib1f(app.shader.opacity, 1);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);

            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.ambientColour);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.specularColour);
        }


        /**
         * Set Attribute pointers for drawing boxes.
         */
        function setLineAttributes() {
            app.lineVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.lineVertexArray);

            gl.disableVertexAttribArray(app.shader.normal);
            gl.vertexAttrib3f(app.shader.normal, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.model);
            gl.vertexAttrib4f(app.shader.model, 1, 0, 0, 0);

            gl.disableVertexAttribArray(app.shader.model + 1);
            gl.vertexAttrib4f(app.shader.model + 1, 0, 1, 0, 0);

            gl.disableVertexAttribArray(app.shader.model + 2);
            gl.vertexAttrib4f(app.shader.model + 2, 0, 0, 1, 0);

            gl.disableVertexAttribArray(app.shader.model + 3);
            gl.vertexAttrib4f(app.shader.model + 3, 0, 0, 0, 1);

            /*
                        gl.vertexAttrib3f(app.shader.ambientColour, 1, 1, 1);
                        gl.disableVertexAttribArray(app.shader.ambientColour);
                        gl.vertexAttribDivisor(app.shader.ambientColour, 0);
            
                        gl.vertexAttrib3f(app.shader.diffuseColour, 1, 1, 1);
                        gl.disableVertexAttribArray(app.shader.diffuseColour);
                        gl.vertexAttribDivisor(app.shader.diffuseColour, 0);
            
                        gl.vertexAttrib3f(app.shader.specularColour, 1, 1, 1);
                        gl.disableVertexAttribArray(app.shader.specularColour);
                        gl.vertexAttribDivisor(app.shader.specularColour, 0);
            */

            gl.disableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttrib1f(app.shader.specularIntensity, 1);

            gl.disableVertexAttribArray(app.shader.opacity);
            gl.vertexAttrib1f(app.shader.opacity, 0.5);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.lines);

            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);
            /*
                        gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, true, 24, 0);
                        gl.enableVertexAttribArray(app.shader.normal);
            */
            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.ambientColour);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.specularColour);
        }


        /**
         * Render loop function to update the display
         */
        let start;
        function render(time) {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            app.aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            if (start) {
                if (app.movement.state === 'start') {
                    app.movement.start = time;
                    app.movement.state = 'running';
                }
                if (app.movement.state === 'running') {
                    const timing = app.movement.timing ?? ((i) => i);
                    const linear = (time - app.movement.start) / app.movement.duration;
                    const progress = timing(linear);

                    app.camera.lookAt = add(app.movement.lookAt.start, scale(app.movement.lookAt.delta, progress));
                    const dist = app.movement.distance.start + progress * app.movement.distance.delta;
                    app.movement.distance.remaining = (1 - progress) * app.movement.distance.delta;
                    const view = scale(app.movement.direction, dist);
                    const rotation = getRotation(app.movement.rotation.angle * progress, app.movement.rotation.axis);
                    const offset = applyTransform(view, rotation);
                    app.camera.position = add(app.camera.lookAt, offset);

                    const roll = getRotation(app.movement.roll * progress, offset);
                    app.camera.up = applyTransform(applyTransform(app.movement.up, rotation), roll);

                    if (linear >= 1.0) {
                        app.movement.state = 'complete';
                        app.movement.distance.remaining = 0;
                    }
                }
                const delta = time - start;
                /*
                app.camera.position = add(app.camera.position, scale(app.velocity, delta / 1000));
                app.camera.lookAt = add(app.camera.lookAt, scale(app.velocity, delta / 1000));
                const direction = applyTransform(subtract(app.camera.lookAt, app.camera.position), app.rotation);
                app.rotation = scaleMatrix(app.rotation, 0.1);
                app.camera.lookAt = add(app.camera.position, direction);
                */
                app.camera.updateViewControls();
                app.viewMatrix = viewMatrix(app.camera.position, app.camera.lookAt, app.camera.up);
                app.velocity = scale(app.velocity, 0.9);
                updateBuffers(time);

                gl.useProgram(app.shader.program);
                gl.bindVertexArray(app.boxVertexArray);

                gl.uniformMatrix4fv(app.shader.projection, false, app.projectionMatrix);
                gl.uniformMatrix4fv(app.shader.view, false, app.viewMatrix);
                gl.uniform3fv(app.shader.cameraPosition, app.camera.position);
                gl.uniform3fv(app.shader.lightPosition1, [5000, 5000, 5000]);
                gl.uniform3fv(app.shader.lightPosition2, [500, -500, 5000]);
                gl.uniform3fv(app.shader.lightPosition3, [1000, 15000, 1000]);

                if (!app.wireframe) {
                    gl.drawArraysInstanced(gl.TRIANGLES, 0, app.vertexCount, app.instanceCount);
                }
                if (app.wireframe || !app.solid) {
                    gl.drawArraysInstanced(gl.LINES, 36, 24, app.instanceCount);
                }

                if (app.points.length > 0) {
                    gl.bindVertexArray(app.pointVertexArray);
                    gl.drawArrays(gl.POINTS, 0, app.points.length);
                }

                if (app.connections.length > 0) {
                    gl.bindVertexArray(app.lineVertexArray);
                    app.connections.forEach((connection) =>
                        gl.drawArrays(gl.LINE_STRIP, connection.first, connection.length));
                }

                if (app.textItemCount > 0) {
                    gl.disable(gl.DEPTH_TEST);
                    gl.colorMask(true, true, true, false);

                    gl.useProgram(app.textShader.program);
                    gl.bindVertexArray(app.textVertexArray);

                    gl.uniformMatrix4fv(app.textShader.projection, false, app.projectionMatrix);
                    gl.uniformMatrix4fv(app.textShader.view, false, app.viewMatrix);
                    gl.uniform1i(app.textShader.texture, gl.TEXTURE0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, app.textTexture);

                    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, app.textItemCount);

                    gl.enable(gl.DEPTH_TEST);
                    gl.colorMask(true, true, true, true);
                }
                glErrors();
            } else {
                start = time;
            }
            requestAnimationFrame(render);
        }

        /**
         * translate a touch event into a simplified mouse event.
         */
        function touch(event) {
            event.preventDefault();
            event.stopPropagation();
            return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
        }


        /**
         * Actions that can be performed on definition objects.
         */
        const actions = {
            'make instance'(source, parent) {
                const get = (attribute) => {
                    if (source.data[attribute] !== undefined) {
                        return source.data[attribute];
                    }
                    if (source.types) {
                        const stack = [...source.types];
                        while (stack.length > 0) {
                            const prototype = stack.shift();
                            if (prototype.data[attribute] !== undefined) {
                                return prototype.data[attribute];
                            }
                            stack.push(...prototype.types);
                        }
                    }
                }
                if (source.data.position) {
                    const position = evaluate(get('position'));
                    const size = evaluate(get('size'));
                    const angle = evaluate(get('angle'));
                    const axis = normalised(evaluate(get('axis')));
                    const colour = evaluate(get('colour'));
                    const opacity = evaluate(get('opacity'));
                    const specular = evaluate(get('specular'));
                    if (size && angle !== undefined && axis && colour && opacity !== undefined && specular !== undefined) {
                        if (parent) {
                            parent = parent.addChild(undefined, position, size, angle, axis, colour, opacity, specular);
                        } else {
                            parent = app.addRoot(undefined, position, size, angle, axis, colour, opacity, specular);
                        }
                    }
                    source.content.forEach((child) => actions[child.action](child, parent));
                }
            }
        }

        /**
         * Evaluate the element passed in.
         */
        function evaluate(item) {
            if (Array.isArray(item)) {
                return item.map((element) => evaluate(element));
            }
            if (isNaN(item)) {
                const func = new Function(...Object.keys(mathFunctions), `return ${item};`);
                return func(...Object.values(mathFunctions));
            }
            return item;
        }


        /**
         * Return an attribute value, doing a breadth first search of the types.
         */
        function getAttribute(item, attribute) {
            if (item[attribute] !== undefined) {
                return item[attribute];
            }
            if (item.types) {
                const stack = [...item.types];
                while (stack.length > 0) {
                    const prototype = stack.shift();
                    if (prototype.data[attribute] !== undefined) {
                        return prototype.data[attribute];
                    }
                    stack.push(...prototype.types);
                }
            }
        }

        /**
         * Manage an instance.
         */
        class Instance {
            static make(parent, source) {
                if (source.position) {
                    const instance = new Instance(parent, source.position, source.size, source.angle, source.axis, source.colour, source.opacity, source.specular);
                    instance.content = source.content.flatMap((child) => Instance.make(instance, child));
                    return instance;
                }
                return source.content.flatMap((child) => Instance.make(parent, child));
            }

            constructor(parent, name, position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour = [0.5, 0.5, 0.5], opacity = 1, specular = 10, data = {}) {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                this.parent = parent;
                if (position.name) {
                    this.name = position.name;
                    size = position.size;
                    angle = position.angle;
                    axis = position.axis;
                    colour = position.colour;
                    opacity = position.opacity;
                    specular = position.specular;

                    position = position.position;
                } else {
                    this.name = name || `Instance ${app.instances.length + 1}`;
                }
                this.position = evaluate(position);
                this.size = evaluate(size);
                this.angle = evaluate(angle);
                this.axis = normalised(evaluate(axis));
                this.colour = evaluate(colour);
                this.opacity = evaluate(opacity);
                this.specular = evaluate(specular);
                this.data = data;

                if (app.adjustOrigin) {
                    this.position = add(this.position, scale(this.size, 0.5));
                    if (this.parent) {
                        this.position = add(this.position, scale(this.parent.size, -0.5));
                    }
                }


                this.position[2] = - this.position[2];

                this.origin = Array(16);
                this.content = [];
                this.rate = 0;
                this.offset = 0;
                this.setTransform();
                this.state = {};
            }
            asString() {
                const getVector = (vector, places = 2) => vector.map((v) => v.toFixed(places)).join(', ');
                const local = this.parent ? invert(this.parent.transform) : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                const parentScale = getScale(extractScale(local).map((v) => 1 / v));
                const transform = matrixMultiply(this.transform, matrixMultiply(local, parentScale));
                const { translation, scale, angle, axis } = decompose(transform);
                const attributes = [
                    this.name,
                    getVector(translation),
                    getVector(scale),
                    angle,
                    getVector(axis),
                    getVector(this.colour),
                    this.specular,
                    this.opacity,
                ];
                return attributes.join('; ');
            }
            showInfo() {
                const container = document.getElementById('info');
                container.classList.remove('hide');
                container.innerHTML = `
                <h2 class="all-columns">${this.name}</h2>
                <span class="all-columns">/${this.path.map((instance) => instance.name).join('/')}</span>
                <span>P/N:</span><span>${this.partNumber}</span>
                <span>S/N:</span><span>${this.serialNumber}</span>
                <span>Notes:</span>`;
                const notes = document.createElement('textarea');
                notes.value = this.notes || '';
                notes.classList.add('all-columns')
                notes.addEventListener('blur', (event) => {
                    this.notes = notes.value;
                });
                container.append(notes);

            }
            get path() {
                if (this.parent) {
                    return [...this.parent.path, this]
                }
                return [this];
            }
            /**
             * Set the transform of a shape based on its position, rotation and scale.
             * 
             * Calculate the origin for content of the shape
             */
            setTransform() {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                const parent = this.parent || { origin: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
                const origin = parent.origin;
                const angle = this.angle * Math.PI / 360;
                const qw = Math.cos(angle);
                const axis = normalised(this.axis);
                const qx = axis[0] * Math.sin(angle);
                const qy = axis[1] * Math.sin(angle);
                const qz = axis[2] * Math.sin(angle);

                const translation = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    app.scale * this.position[0],
                    app.scale * this.position[1],
                    app.scale * this.position[2], 1
                ];
                this.rotation = [
                    1 - 2 * qy * qy - 2 * qz * qz,
                    2 * qx * qy - 2 * qz * qw,
                    2 * qx * qz + 2 * qy * qw,
                    0,

                    2 * qx * qy + 2 * qz * qw,
                    1 - 2 * qx * qx - 2 * qz * qz,
                    2 * qy * qz - 2 * qx * qw,
                    0,

                    2 * qx * qz - 2 * qy * qw,
                    2 * qy * qz + 2 * qx * qw,
                    1 - 2 * qx * qx - 2 * qy * qy,
                    0,

                    0, 0, 0, 1
                ];

                const rotationTranslate = multiply(this.rotation, translation);
                this.origin = multiply(rotationTranslate, origin);
            }
            get transform() {
                const scaleMatrix = getScale(scale(this.size, app.scale));
                return multiply(scaleMatrix, this.origin);
            }
            apply(action) {
                action(this);
                this.content.forEach((child) => child.apply(action));
            }
            update(child) {
                for (let i = 0; i < 16; ++i) {
                    this.matrix[i] = this.transform[i];
                }
                this.content.forEach((child) => child.update(true));
                app.instancesChanged = true;
                this.updateNodes();
                if (!child) {
                    app.colourUpdate = true;
                    updateTextBuffer();
                }
            }
            updateNodes() {
                const local = this.parent ? invert(this.parent.origin) : identityMatrix();
                const transform = matrixMultiply(this.transform, local);
                const { translation, scale, angle, axis } = decompose(transform);
                const nodes = this.nodes;
                nodes[0].innerHTML = this.name;
                nodes[2].innerHTML = translation[0].toFixed(2);
                nodes[3].innerHTML = translation[1].toFixed(2);
                nodes[4].innerHTML = translation[2].toFixed(2);

                nodes[5].innerHTML = scale[0].toFixed(2);
                nodes[6].innerHTML = scale[1].toFixed(2);
                nodes[7].innerHTML = scale[2].toFixed(2);

                nodes[8].innerHTML = angle.toFixed(2);
                nodes[9].innerHTML = axis[0].toFixed(2);
                nodes[10].innerHTML = axis[1].toFixed(2);
                nodes[11].innerHTML = axis[2].toFixed(2);
            }
            translate(vector) {
                const translation = getTranslation(vector);
                this.origin = matrixMultiply(this.origin, translation);
                this.updateNodes();
                app.instancesChanged = true;
            }
            rotate(angle, axis) {
                const rotation = getRotation(angle, axis);
                const offset = extractTranslation(this.origin);
                const translation = getTranslation(offset);
                const translationBack = getTranslation(scale(offset, -1));
                const transform = matrixMultiply(translationBack, matrixMultiply(rotation, translation));

                this.apply((instance) =>
                    instance.origin = matrixMultiply(instance.origin, transform));

                this.update();
                this.updateNodes();
                app.instancesChanged = true;
            }
            addChild(name, position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour, opacity, specular) {
                const data = name;
                if (typeof name === 'object') {
                    position = getAttribute(name, 'position');
                    size = getAttribute(name, 'size');
                    angle = getAttribute(name, 'angle');
                    axis = getAttribute(name, 'axis');
                    colour = getAttribute(name, 'colour');
                    opacity = getAttribute(name, 'opacity');
                    specular = getAttribute(name, 'specular');
                    name = getAttribute(name, 'name');
                }
                const newInstance = new Instance(
                    this,
                    name,
                    position,
                    size,
                    angle,
                    axis,
                    colour || this.colour,
                    opacity || this.opacity,
                    specular || this.specular,
                    data);
                this.content.push(newInstance);
                app.instances.push(newInstance);
                return newInstance;
            }
            delete() {
                const content = [...this.content];
                content.forEach((child) => child.delete);
                if (this.parent) {
                    const position = this.parent.content.indexOf(this);
                    this.parent.content.splice(position, 1);
                } else {
                    const position = app.roots.indexOf(this);
                    app.roots.splice(position, 1);
                }
            }
            get siblings() {
                const list = this.parent ? this.parent.content : app.roots;
                return list.filter((child) => child !== this)
            }
            get nodes() {
                return app.nodeMap.get(this);
            }
            overlap(position, other) {
                const otherPosition = extractTranslation(other.origin);
                return ((position[0] + this.size[0]) >= otherPosition[0])
                    && (position[0] <= (otherPosition[0] + other.size[0]))
                    && ((position[1] + this.size[1]) >= otherPosition[1])
                    && (position[1] <= (otherPosition[1] + other.size[1]))
                    && ((position[2] + this.size[2]) >= otherPosition[2])
                    && (position[2] <= (otherPosition[2] + other.size[2]));
            }
            move(vector) {
                this.siblings.forEach((sibling) => {
                    sibling.state.constraint = true;
                    sibling.state.hit = false;

                    const requestedPosition = add(this.start, vector);
                    if (this.overlap(requestedPosition, sibling)) {
                        const delta = [0, 0, 0];
                        const siblingPosition = extractTranslation(sibling.origin);

                        for (let i = 0; i < 3; ++i) {
                            const d1 = siblingPosition[i] - requestedPosition[i] - this.size[i];
                            const d2 = siblingPosition[i] + sibling.size[i] - requestedPosition[i];
                            delta[i] = Math.abs(d1) < Math.abs(d2) ? d1 : d2;
                        }
                        if (Math.abs(delta[1]) < Math.abs(delta[0])) {
                            delta[0] = 0;
                            if (Math.abs(delta[2]) < Math.abs(delta[1])) {
                                delta[1] = 0;
                            } else {
                                delta[2] = 0;
                            }
                        } else {
                            delta[1] = 0;
                            if (Math.abs(delta[0]) < Math.abs(delta[2])) {
                                delta[2] = 0;
                            } else {
                                delta[0] = 0;
                            }
                        }
                        vector = add(vector, delta);
                        sibling.state.hit = true;
                    }
                });
                // update position
                this.apply((instance) => {
                    instance.origin[12] = instance.start[0] + vector[0];
                    instance.origin[13] = instance.start[1] + vector[1];
                    instance.origin[14] = instance.start[2] + vector[2];
                });

                this.update();
                app.colourUpdate = true;
            }
            promote() {
                if (this.parent) {
                    const siblings = this.parent.content;
                    const position = siblings.indexOf(this);
                    const content = siblings.splice(position, siblings.length - position);
                    content.shift();
                    this.content.push(...content);
                    content.forEach((child) => child.parent = this);
                    this.update();
                    const list = this.parent.parent ? this.parent.parent.content : app.roots;
                    const pos = list.indexOf(this.parent);
                    list.splice(pos + 1, 0, this);
                    this.parent = this.parent.parent;
                }
            }
            demote() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position > 1) {
                    list.splice(position, 1);
                    list[position - 1].content.unshift(this);
                    this.parent = list[position - 1];
                    this.update();
                }
            }
            down() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position < list.length - 1) {
                    list.splice(position, 1);
                    list.splice(position + 1, 0, this);
                    this.update();
                }
            }
            up() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position > 0) {
                    list.splice(position, 1);
                    list.splice(position - 1, 0, this);
                    this.update();
                }
            }
        }

        /**
         * Manage a connection between two instances
         */
        class Connection {
            constructor(start, end, points = [[], [], []]) {
                this.start = start;
                this.end = end;
                this.points = points;
                this.colour = [1, 1, 1];
            }
            get context() {
                const startPath = this.start.path;
                const endPath = this.end.path;
                const path = [];
                while (startPath[0] === endPath[0] && startPath.length && endPath.length) {
                    path.push(startPath.shift);
                    endPath.shift();
                }
                return path.at(-1);
            }
            addVertices(vertices) {
                this.first = vertices.length / 6;
                this.length = 0;
                if (this.points[0].length) {
                    this.points[0].forEach((point) => {
                        vertices.push(...applyTransform(point, this.start.origin));
                        vertices.push(...this.colour);
                    });
                    this.length += this.points[0].length;
                } else {
                    vertices.push(...applyTransform([0, 0, 0], this.start.origin));
                    vertices.push(...this.start.colour);
                    this.length += 1;
                }
                const context = this.context;
                this.points[1].forEach((point) => {
                    vertices.push(...applyTransform(point, context.origin));
                    vertices.push(...this.colour);
                });
                this.length += this.points[1].length;

                if (this.points[2].length) {
                    this.points[2].forEach((point) => {
                        vertices.push(...applyTransform(point, this.end.origin));
                        vertices.push(...this.colour);
                    });
                    this.length += this.points[2].length;
                } else {
                    vertices.push(...applyTransform([0, 0, 0], this.end.origin));
                    vertices.push(...this.end.colour);
                    this.length += 1;
                }
            }
        }

        const action = {};
        const history = [];
        let historyPosition;

        /**
         * End a mouse movement and store change in history.
         */
        function endMove(event) {
            if (action.moved) {
                const instances = new Set();
                app.instances.filter((instance) => instance.selected)
                    .forEach((instance) => instance.apply((instance) => instances.add(instance)));
                const undo = Array.from(instances).map((instance) => ({
                    instance, start: [...instance.start],
                }));
                const redo = Array.from(instances).map((instance) => ({
                    instance, end: extractTranslation(action.selected.origin),
                }));
                const start = [...action.selected.start];
                const end = extractTranslation(action.selected.origin);
                history.push({
                    undo: () =>
                        undo.forEach((action) => {
                            action.instance.origin[12] = action.start[0];
                            action.instance.origin[13] = action.start[1];
                            action.instance.origin[14] = action.start[2];
                            action.instance.update();
                        }),
                    redo: () => redo.forEach((action) => {
                        action.instance.origin[12] = action.end[0];
                        action.instance.origin[13] = action.end[1];
                        action.instance.origin[14] = action.end[2];
                        action.instance.update();
                    }),
                });
            } else {
                if ((event.crtlKey || action.selected?.data.load !== true) && action.selected?.data?.url) {
                    load(action.selected.data.url, action.selected, event.shiftKey);
                    action.selected.data.load = true;
                }
            }
            action.move = null;
            historyPosition = null;
            app.instances.forEach((instance) => {
                instance.state = {};
            });
        }

        const completeAction = (event) => {
            if (action.end) {
                action.end(event);
                action.end = null;
            }
        }
        document.body.addEventListener('mousemove', (event) => action.move?.(event));
        document.body.addEventListener('mouseup', completeAction);

        document.body.addEventListener('touchmove', (event) => action.move?.(touch(event)));
        document.body.addEventListener('touchend', completeAction);

        /**
         * Show structure
         */
        function showStructure() {
            const structure = document.getElementById('structure');
            structure.innerHTML = `
                <span class="value two-rows">Name</span>
                <span class="value three-columns">Position</span>
                <span class="value three-columns">Size</span>
                <span class="value two-rows">Angle</span>
                <span class="value three-columns">Axis</span>
                <span class="value two-rows">Colour</span>
                <span class="value two-rows">Specular</span>
                <span class="value two-rows">Opacity</span>

                <span class="value">x</span>
                <span class="value">y</span>
                <span class="value">z</span>

                <span class="value">x</span>
                <span class="value">y</span>
                <span class="value">z</span>

                <span class="value">x</span>
                <span class="value">y</span>
                <span class="value">z</span>`;

            app.nodeMap = new Map();
            const addInstance = (instance, level = 0) => {
                const nodes = [];
                const addControls = (node, item, element, scaled) => {
                    node.contentEditable = true;
                    node.addEventListener('focus', (event) => {
                        if (!event.shiftKey) {
                            app.instances.forEach((instance) => instance.selected = false);
                        }
                        instance.selected = true;
                        app.colourUpdate = true;
                    });

                    node.addEventListener('blur', (event) => {
                        if (isNaN(Number(item[element]))) {
                            item[element] = node.innerText;
                        } else {
                            item[element] = Number(node.innerText);
                        }
                    });
                    node.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            if (isNaN(Number(item[element]))) {
                                node.innerHTML = item[element];
                            } else {
                                node.innerHTML = item[element].toFixed();
                            }
                        }
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            if (event.shiftKey) {
                                instance.addChild([0, 0, 0], scale(instance.size, 0.5));
                                initialiseInstances();
                                showStructure();
                            } else {
                                if (isNaN(Number(node.innerText))) {
                                    item[element] = node.innerText;
                                } else {
                                    item[element] = Number(node.innerText);
                                }
                                instance.update();
                            }
                        }
                        if (event.ctrlKey) {
                            if (event.key === 'ArrowLeft') {
                                instance.promote();
                                showStructure();
                            }
                            if (event.key === 'ArrowRight') {
                                instance.demote();
                                showStructure();
                            }
                            if (event.key === 'ArrowUp') {
                                instance.up();
                                showStructure();
                            }
                            if (event.key === 'ArrowDown') {
                                instance.down();
                                showStructure();
                            }
                        }
                    });

                    if (!isNaN(Number(item[element]))) {
                        const places = Math.floor(Math.log10(1 / scaled));
                        node.addEventListener('mousedown', (event) => {
                            action.last = event.clientY;
                            action.moved = false;
                            action.move = (event) => {
                                action.moved = true;
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.setTransform();
                                instance.update();
                            };
                            const initial = item[element];
                            action.end = () => {
                                action.move = null;
                                if (action.moved) {
                                    const end = item[element];
                                    history.push({
                                        undo: () => {
                                            item[element] = initial;
                                            instance.setTransform();
                                            instance.update();
                                        },
                                        redo: () => {
                                            item[element] = initial;
                                            instance.setTransform();
                                            instance.update();
                                        },
                                    });
                                }
                            };
                        });
                        node.addEventListener('touchstart', (event) => {
                            event = touch(event);
                            action.last = event.clientY;
                            action.moved = false;
                            action.move = (event) => {
                                action.moved = true;
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.update();
                            };
                            const initial = item[element];
                            action.end = () => {
                                action.move = null;
                                if (action.moved) {
                                    const end = item[element];
                                    history.push({
                                        undo: () => {
                                            item[element] = initial;
                                            instance.update();
                                        },
                                        redo: () => {
                                            item[element] = initial;
                                            instance.update();
                                        },
                                    });
                                }
                            };
                        });
                    }
                }
                const addSpan = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    const node = document.createElement('span');
                    nodes.push(node);
                    if (isNaN(Number(instance[argument]))) {
                        node.innerHTML = instance[argument];
                    } else {
                        node.innerHTML = instance[argument].toFixed();
                        node.classList.add('value');
                    }
                    addControls(node, instance, argument, scaled);
                    return node;
                }
                const addColour = (argument, scaled = 0.1) => {
                    const node = document.createElement('input');
                    nodes.push(node);
                    node.type = 'color';
                    const value = instance[argument];
                    const string = `#${toHex(value[0] * 255, 2)}${toHex(value[1] * 255, 2)}${toHex(value[2] * 255, 2)}`;
                    node.value = string;

                    node.addEventListener('change', (event) => {
                        const string = node.value;
                        const value = [parseInt(string.slice(1, 3), 16) / 255, parseInt(string.slice(3, 5), 16) / 255, parseInt(string.slice(5), 16) / 255];
                        instance[argument] = value;
                        app.colourUpdate = true;
                    });
                    return node;
                }
                const addVec = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    return instance[argument].map((item, index) => {
                        const node = document.createElement('span');
                        nodes.push(node);
                        node.classList.add('value');
                        node.innerHTML = item.toFixed(places);
                        addControls(node, instance[argument], index, scaled);
                        return node;
                    });
                }


                if (instance.nodes) {
                    structure.append(...instance.nodes);
                    instance.content.map((child) => addInstance(child, level + 1));
                } else {
                    const expander = document.createElement('span');
                    expander.innerHTML = instance.content.length ? '&#9660;' : '';
                    expander.classList.add('expander');

                    const name = document.createElement('span');
                    name.style.whiteSpace = 'pre';
                    name.append(''.padStart(level * 2, ' '), expander, addSpan('name'));

                    nodes.push(name);
                    app.nodeMap.set(instance, nodes);
                    structure.append(name,
                        ...addVec('position'),
                        ...addVec('size'),
                        addSpan('angle'),
                        ...addVec('axis'),
                        addColour('colour'),
                        addSpan('specular'),
                        addSpan('opacity'));
                    instance.content.map((child) => addInstance(child, level + 1));

                    const descend = (node, action) => {
                        action(node);
                        node.content.forEach((child) => descend(child, action));
                    }

                    expander.addEventListener('click', (event) => {
                        const recursive = event.ctrlKey;
                        expander.classList.toggle('collapsed');
                        if (expander.classList.contains('collapsed')) {
                            expander.innerHTML = instance.content.length ? '&#9654;' : '';
                            instance.content.forEach((child) =>
                                descend(child, (node) => {
                                    if (recursive && node.content.length > 0) {
                                        node.nodes[1].querySelector('.expander').classList.add('collapsed');
                                    }
                                    node.nodes.forEach((node) => node.classList.add('hide'));
                                }));
                        } else {
                            expander.innerHTML = instance.content.length ? '&#9660;' : '';
                            instance.content.forEach((child) =>
                                descend(child, (node) => {
                                    if (recursive && node.content.length > 0) {
                                        node.nodes[1].querySelector('.expander').classList.remove('collapsed');
                                    }
                                    if (!node.nodes[1].querySelector('.expander').classList.contains('collapsed')) {
                                        node.nodes.forEach((node) => node.classList.remove('hide'));
                                    }
                                }));
                        }
                    });
                }

            }
            app.roots.forEach((child) => addInstance(child));
        }


        /**
         * Utility function to make a node draggable
         */
        function makeDraggable(node, type, data) {
            node.draggable = true;
            node.addEventListener('dragstart', (event) => {
                event.dataTransfer.setData(type, data);
            });
        }

        /**
         * Display the stock by Part / serial number and it's location
         */
        function showStock() {
            const container = document.getElementById('stock');
            const parts = Object.keys(app.stock);
            parts.sort((a, b) => a.localeCompare(b));
            parts.forEach((part) => {
                const partNode = document.createElement('details');
                partNode.innerHTML = `<summary>${part}</summary>`;
                container.append(partNode);
                const items = app.stock[part];
                const locations = items.entries().reduce((locations, [item, loc]) => {
                    locations[loc] = locations[loc] || [];
                    locations[loc].push(item);
                    return locations;
                }, {});
                Object.entries(locations).forEach(([name, items]) => {
                    const locationNode = document.createElement('details');
                    partNode.append(locationNode);
                    locationNode.innerHTML = `<summary>${name}</summary>`;
                    items.sort((a, b) => a.localeCompare(b));
                    const list = document.createElement('ul');
                    items.forEach((item) => {
                        const itemNode = document.createElement('li');
                        makeDraggable(itemNode, part, item);
                        itemNode.innerHTML = item;
                        list.append(itemNode);
                    });
                    locationNode.append(list);
                });
            });
        }

        const commands = {
            'camera position'(value) {
                app.initial.position = value.split(/,/g).map((v) => parseFloat(v));
                app.camera.position = [...app.initial.position];
            },
            'look at'(value) {
                app.initial.lookAt = value.split(/,/g).map((v) => parseFloat(v));
                app.camera.lookAt = [...app.initial.lookAt];
            },
            up(value) {
                app.initial.up = value.split(/,/g).map((v) => parseFloat(v));
                app.camera.up = [...app.initial.up];
            },
            fov(value) {
                app.initial.fov = parseFloat(value);
                app.fov = app.initial.fov;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            aspect(value) {
                app.initial.aspect = parseFloat(value);
                app.aspect = app.initial.aspect;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            near(value) {
                app.initial.near = parseFloat(value);
                app.near = app.initial.far;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            far(value) {
                app.initial.far = parseFloat(value);
                app.far = app.initial.far;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            origin(value) {
                app.adjustOrigin = true;
            },
            background(value) {
                const colour = value.split(/,/g).map((v) => parseFloat(v));
                gl.clearColor(...colour, 1.0);
            }
        }


        /**
         * Convert a string to the best canonical object
         */
        function interpret(string) {
            if (string === undefined) {
                return;
            }
            const trimmed = string.trim();
            if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
                return string.replace(/^\s*"/, '').replace(/"\s*$/, '');
            }
            const datePattern = /(?<day>[0-9]{1,4})[-\._\/](?<month>[0-9]{1,2})[-\._\/](?<year>[0-9]{2,4})/;
            const dateMatch = string.match(datePattern);
            if (dateMatch) {
                const [p1, month, p3] = dateMatch.slice(1).map((v) => parseInt(v));
                const [year, day] = p1 > 31 ? [p1, p3] : [p3, p1];
                return new Date((year < 2000 ? year + 2000 : year), month - 1, day);
            }
            if (!isNaN(Number(string))) {
                return Number(string);
            }
            const parts = string.split(/\s*,\s*/g);
            if (parts.length > 1) {
                return parts.map((part) => interpret(part));
            }
            return string;
        }

        /**
         * Load a definition file
         */
        async function load(url, parent, replace) {
            document.body.style.cursor = 'progress';
            const response = await fetch(url);
            const content = await response.text();
            processText(content, parent, replace);
            document.body.style.cursor = 'auto';
        }


        /**
         * Convert lines to objects
         */
        function processText(text, parent, replace) {
            if (replace) {
                app.instances = [];
                app.roots = [];
                app.stock = {};
            }

            const lines = text.split(/\r?\n/g);
            const roots = [];
            const stack = [{
                level: -1,
                action(obj) { roots.push(obj) }
            }];

            const getLevel = (line) => {
                let level = 0;
                for (let i = 0; i < line.length; ++i) {
                    if (line[i] === ' ' || line[i] === '\t') {
                        level += line[i] === '\t' ? 4 - (level % 4) : 1;
                    } else {
                        break;
                    }
                }
                return level;
            }

            let process = true;
            lines.forEach((line, lineNumber) => {
                if (line === '!stop') {
                    process = false;
                }
                if (process && line.trim() !== '' && !/^\s*#/.test(line)) {
                    const level = getLevel(line);
                    while (level <= stack.at(-1).level) {
                        stack.pop();
                    }
                    const item = { line, lineNumber, content: [] };
                    stack.at(-1).action(item);
                    stack.push({
                        level,
                        item,
                        lineNumber,
                        action(item) {
                            item.parent = this.item;
                            this.item.content.push(item);
                        },
                    });
                }
            });

            const groupPattern = /^\[([^\]]+)\]\s*(.*)/;
            const templatePattern = /\s*\[([^\]]+)\]$/;
            const expand = (item, instance = []) => {
                const line = item.line.trim();
                const group = line.match(groupPattern);
                if (group) {
                    const instances = getList(group[1]);
                    const name = group[2];
                    return instances.flatMap((label, index) =>
                        item.content.flatMap((child) => expand(child, [{ label, name, index }, ...instance])));
                } else {
                    const template = line.match(templatePattern);
                    const instances = template ? getList(template[1]) : undefined;
                    const value = line.replace(groupPattern, '').replace(templatePattern, '');
                    if (instances) {
                        return instances.flatMap((name, index) => ({
                            value,
                            lineNumber: item.lineNumber,
                            content: item.content.flatMap((child) => expand(child, [{ name, index }, ...instance])),
                            instance: [{ name, index }, ...instance],
                        }));
                    }
                    return {
                        value,
                        lineNumber: item.lineNumber,
                        content: item.content.flatMap((child) => expand(child, instance)),
                        instance,
                    };
                }
            };

            const expanded = roots.flatMap((item) => expand(item));

            const find = (string) => {
                const path = string.split(/\/\./g);
                let target;
                while (path.length) {
                    if (target) {
                        const name = path.shift();
                        target = target.content.find((child) => child.name === name) ?? target.attrs[name];
                    } else {
                        target = named[path.shift()];
                    }
                }
            }

            const named = {};

            const resolve = (string, instance, vars) =>
                string.replace(/<([0-9]*)>/g, (match, num) => instance[parseInt(num) || 0]?.name ?? match)
                    .replace(/<n([0-9]*)>/g, (match, num) => instance[parseInt(num) || 0]?.index ?? match)
                    .replace(/<([^>]+)>/g, (match, val) => vars[val] ?? match);

            const content = Symbol('content');
            const graph = { [content]: [], }
            const contextStack = [{ object: graph, name: 0, defaultParameters: [], action: 'make instance' }];
            /*
             * lines starting with '>' provide app settings
             * lines starting with '!' control context to modify object interpretation
             * other lines are either objects or values
             * lines starting with '`' are unparsed values
             */
            const evaluate = (line) => {
                const context = Object.assign({}, contextStack.at(-1));
                context.parameters = [...context.defaultParameters];
                const vars = Object.assign(named);
                const resolved = resolve(line.value, line.instance, vars);

                const add = (item) => {
                    //const arg = context.parameters.shift()?.name ?? context.parameter ?? content;
                    const arg = context.parameter ?? content;
                    if (Array.isArray(context.object[arg])) {
                        context.object[arg].push(item);
                    } else if (context.object[arg] === undefined) {
                        context.object[arg] = item;
                    } else {
                        context.object[arg] = [context.object[arg], item];
                    }
                }

                if (line.value.startsWith('`')) {
                    add(line.value);
                } else if (line.value.startsWith("'")) {
                    add(resolved);
                } else if (line.value.startsWith('>')) {
                    const [command, value] = resolved.replace(/^>\s*/, '').split('=').map((v) => v.trim());
                    if (!parent && commands[command]) {
                        commands[command](value);
                    }
                } else {
                    // Options
                    // 1 component
                    //   assignment
                    //     has content
                    //       - assign value as first element of array
                    //     no content
                    //       - assign value to parameter
                    //   value
                    //     has content
                    //       - assign content as elements
                    //     no content
                    //       unused context parameters
                    //         - assign to next content parameter
                    //       no unused parameters
                    //         - assign as specified by context
                    // multiple components
                    //  - create object and update context
                    const components = resolved.split(/\s*[;\|\t\u{1f}]\s*/ug);

                    const addComponent = (component, content = []) => {
                        if (component.includes('=')) {
                            const [name, value] = component.split(/\s*=\s*/);
                            if (content.length > 0) {
                                context.object[name] = context.object[name] || [];
                                context.object[name].push(interpret(value));
                            } else {
                                context.object[name] = value;
                            }
                        } else {
                            if (content.length > 0) {
                                context.parameter === interpret(component);
                            } else {
                                const arg = context.parameters.shift()?.name ?? context.parameter ?? content;
                                if (Array.isArray(context.object[arg])) {
                                    context.object[arg].push(interpret(component));
                                } else if (context.object[arg] === undefined) {
                                    context.object[arg] = interpret(component);
                                } else {
                                    context.object[arg] = [context.object[arg], interpret(component)];
                                }

                                //add(interpret(component));
                            }
                        }
                    }

                    if (components[0] === '') {
                        components.shift();
                        components.forEach((element, index) => {
                            const [name, value] = element.split(/\s*=\s*/);
                            context.defaultParameters[index] = { name, value: interpret(value) };
                        });
                        contextStack.push(context);
                        line.content.forEach((child) => evaluate(child));
                        contextStack.pop();
                    } else if (components.length === 1) {
                        if (components[0].endsWith('=')) {
                            context.parameter = components[0].replace(/\s*=$/, '');
                            contextStack.push(context);
                            line.content.forEach((item) => evaluate(item));
                            contextStack.pop()
                        } else {
                            addComponent(components[0], line.content);
                            line.content.forEach((item) => evaluate(item));
                        }
                    } else if (components.length > 1) {
                        const obj = { [content]: [], };
                        add(obj);
                        context.object = obj;
                        if (components.at(-1).endsWith('=')) {
                            context.parameter = components.at(-1).replace(/\s*=$/, '');
                            components.pop();
                        }


                        contextStack.push(context);
                        components.forEach((component) => addComponent(component));
                        line.content.forEach((item) => evaluate(item));
                        contextStack.pop();

                        const [name, ...typeNames] = (context.object.name ?? '').split(/\s*:\s*/g);
                        const types = typeNames.flatMap((type) => (named[type] || find(type)) ?? []);
                        context.object.name = name;
                        context.object.types = (context.object.types || []).flatMap((type) =>
                            typeof type === 'object' ? type : (named[type] || find(type)) ?? []);
                        context.object.types.push(...types);

                        // Add remaining default values
                        while (context.parameters.length) {
                            const parameter = context.parameters.shift();
                            if (parameter.value !== undefined) {
                                context.object[parameter.name] = parameter.value;
                            }
                        }
                    }
                }
            };

            expanded.flatMap((node) => evaluate(node));

            const addItems = (parent, node) => {
                node[content].forEach((node) => {
                    if (node.size) {
                        const child = parent.addChild(node);
                        addItems(child, node);
                    }
                });
            }
            graph[content].forEach((node) => {
                if (node.position) {
                    const root = parent ? parent.addChild(node) : app.addRoot(node);
                    addItems(root, node);
                }
            })
            initialiseInstances();
            if (parent) {
                updateText();
                showStructure();
                showStock();

            }
        }

        /**
         * Convert text to objects
         */
        function getObjects(text) {
            const lines = text.split(/\r?\n/g);
            let processLine = true;
            return lines.flatMap((line) => {
                if (line === '!stop') {
                    processLine = false;
                }
                if (processLine && line.trim() !== '' && !line.trim().startsWith('#') && !line.trim().startsWith('!')) {
                    if (line.startsWith('>')) {
                        const [command, value] = line.replace(/^>\s*/, '').split('=').map((v) => v.trim());
                        if (commands[command]) {
                            commands[command](value);
                        }
                        return [];
                    }
                    const [indentedName, positionStr, sizeStr, angleStr, axisStr, colourStr, specularStr, opacityStr, serialNumberStr] = line.split(/\s*;\s*/);
                    const indent = indentedName.replace(/\S.*/, '');
                    const rangeName = indentedName.replace(/^\s+/, '');
                    const match = rangeName.match(/(\[(?<instances>[^\]]+)\]\s*)?(?<name>.*)/);
                    const qualifiedName = match.groups.name;
                    const [name, ...types] = qualifiedName.split(/\s*:\s*/);

                    let level = 0;
                    for (let i = 0; i < indent.length; ++i) {
                        if (indent[i] === '\t') {
                            level += 4 - (level % 4);
                        } else {
                            level += 1;
                        }
                    }
                    const position = positionStr ? positionStr.split(',') : null;
                    const size = sizeStr ? sizeStr.split(',') : null;
                    const angle = angleStr ? angleStr : null;
                    const axis = axisStr ? axisStr.split(',') : null;
                    const colour = colourStr ? colourStr.split(',') : null;
                    const specular = specularStr ? specularStr : null;
                    const opacity = opacityStr ? opacityStr : null;
                    const serialNumbers = serialNumberStr ? serialNumberStr.split(/\s*,\s*/g) : [];
                    const obj = {
                        name,
                        types,
                        level,
                        position,
                        size,
                        angle,
                        axis,
                        colour,
                        specular,
                        opacity,
                        instances: match.groups.instances,
                        content: [],
                        serialNumbers,
                    }
                    return obj;
                }
                return [];
            });
        }

        /**
         * Convert a list of objects into a tree structure based on the level of the objects
         */
        function getTree(objs) {
            const defaults = {
                size: [0, 0, 0],
                angle: 0,
                axis: [0, 1, 0],
                colour: [1, 1, 0],
                specular: 10,
                opacity: 1,
            }
            const roots = [];
            const stack = [];
            const named = {};
            objs.forEach((obj) => {
                named[obj.name] = obj;
                obj.types = obj.types.flatMap((type) => named[type]);

                if (obj.types.length) {
                    Object.getOwnPropertyNames(obj).filter((property) => obj[property] === null)
                        .forEach((property) => {
                            const stack = [...obj.types];
                            while (obj[property] === null && stack.length) {
                                const type = stack.shift();
                                stack.push(...type.types);
                                obj[property] = type[property];
                            }
                        });
                    obj.types.forEach((type) =>
                        obj.content.push(...type.content.map((child) => Object.assign({}, child))));
                }
                Object.getOwnPropertyNames(defaults).filter((property) => obj[property] === null)
                    .forEach((property) => obj[property] = [defaults[property]].flatMap((v) => v));

                while (stack.length && obj.level <= stack[0].level) {
                    stack.shift();
                }
                if (stack.length > 0) {
                    if (name.startsWith('^')) {
                        stack[0].serialNumbers.push(this.name);
                    } else {
                        stack[0].content.push(obj);
                        obj.parent = stack[0];
                    }
                } else {
                    roots.push(obj);
                }
                stack.unshift(obj);
            });
            return roots;
        }

        /**
         * Convert a range specifier to a list.
         */
        function getList(definition) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*:\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(definition);
            const list = [];
            if (isNaN(count)) {
                list.push(...definition.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return item.trim();
                }));
            } else {
                for (let i = 1; i <= count; ++i) {
                    list.push(i);
                }
            }
            return list;
        }

        const mathFunctions = Object.getOwnPropertyNames(Math).reduce((context, key) => {
            context[key] = Math[key];
            return context;
        }, {});

        /**
         * Expand a template graph to a full graph.
         */
        function expandGraph(templateGraph) {
            const expand = (node, context = [], positioned) => {
                if (node.name.startsWith('~')) {
                    return [node];
                }
                const resolve = (value, context) => {
                    if (isNaN(Number(value))) {
                        value = value.replace(/<([0-9]*)>/g, (match, level) => (context[parseInt(level || 0)].instance) ?? 0)
                            .replace(/<n([0-9]*)>/g, (match, level) => (context[parseInt(level || 0)].idx) ?? 0)
                            .replace(/<i([0-9]*)>/g, (match, level) => (context[parseInt(level || 0)].index) ?? 0);
                        if (isNaN(Number(value))) {
                            const func = new Function(...Object.keys(mathFunctions), `return ${value};`);
                            return func(...Object.values(mathFunctions));
                        }
                    }
                    return Number(value);
                }
                const makeInstance = (node, context) => ({
                    name: node.name.replace(/<([0-9]*)>/g, (match, level) =>
                        context[parseInt(level || 0)].instance),
                    position: node.position.map((v) => resolve(v, context)),
                    size: node.size.map((v) => resolve(v, context)),
                    angle: resolve(node.angle, context),
                    axis: node.axis.map((v) => resolve(v, context)),
                    colour: node.colour.map((v) => resolve(v, context)),
                    specular: resolve(node.specular, context),
                    opacity: resolve(node.opacity, context),
                    content: node.content.flatMap((child, index) => expand(child, [{ index }, ...context], positioned)),
                });

                if (node.instances) {
                    const instances = getList(node.instances);
                    if (node.position) {
                        return instances.flatMap((instance, idx) => {
                            context[0].instance = instance;
                            context[0].idx = idx;
                            return makeInstance(node, [{ instance, idx }, ...context]);
                        });
                    } else {
                        return instances.flatMap((instance, idx) =>
                            node.content.flatMap((child, index) => expand(child, [{ instance, index, idx }, ...context], positioned)));
                    }
                } else if (node.position) {
                    return makeInstance(node, context);
                } else if (positioned) {
                    return node.content.flatMap((child, index) => expand(child, [{ index }, ...context]), true);
                } else {
                    app.nodes.push(node);
                }
                return [];
            }

            return templateGraph.flatMap((node, index) => expand(node, [{ index }], node.position));
        }

        /**
         * Make a test graph.
         */
        function makeGraph(source, replace) {
            if (source) {
                if (replace) {
                    app.instances = [];
                    app.roots = [];
                    app.stock = {};
                }
                app.nodes.forEach((node) => {
                    const items = node.content.filter((child) => child.name.startsWith('#'));
                    if (items.length) {
                        app.stock[node.name] = app.stock[node.name] || new Map();

                        items.forEach((item) => {
                            const [name, loc] = item.name.replace(/^#\s*/, '').split(/\s*->\s*/);
                            if (app.stock[node.name].has(name) && loc !== app.stock[node.name].get(name)) {
                                report(`Warning part ${name} in two locations (${app.stock[node.name].get(name)} and ${loc})!`);
                            } else {
                                app.stock[node.name].set(name, loc);
                            }
                        });
                    }
                });
                const adjustOrigin = (node, offset = [0, 0, 0]) => {
                    if (app.cornerOrigin) {
                        node.position = add(node.position, scale(node.size, 0.5), offset);
                        node.content.filter((child) => child.position).forEach((child) => adjustOrigin(child, scale(node.size, -0.5)));
                    }
                }

                source.forEach((node) => adjustOrigin(node));

                const addNode = (parent, node) => {
                    if (node.name.startsWith('~')) {
                        parent.parts = parent.parts || [];
                        parent.parts.push(node.name.replace(/^~\s*/, '').toLowerCase());
                    } else {
                        const child = parent.addChild(node);
                        node.content.forEach((node) => addNode(child, node));
                    }
                }
                source.forEach((node) => {
                    const root = app.addRoot(undefined, node);
                    node.content.forEach((child) => addNode(root, child));
                });
                initialiseInstances();
            } else {
                const root = app.addRoot(
                    'cube',
                    [0, 0, 0],    // Position
                    [1, 1, 1],    // Size
                    0,            // Rotation
                    [0, 1, 0],    // Axis
                    [1, 1, 0],    // Colour
                    1.0,          // opacity
                    10.0);        // Specular
                /*
            const child = root.addChild([0, 750, 0], [500, 500, 500], 30);
            const grandchild = child.addChild([750, 0, 0], [1000, 500, 500], 45, [1, 0, 0], [1, 0, 0]);
            const grandchild2 = child.addChild([0, 0, 500], [500, 500, 500]);
            const greatgrandchild = grandchild.addChild([250, 1100, 0], [500, 1500, 500]);
            */
            }

            showStructure();
            updateText();
        }

        /**
         * Return a normalised version of the given vector.
         */
        function normalised(vector) {
            const l = Math.hypot(...vector);
            return vector.map((i) => i / l);
        }

        /**
         * Return vector A scaled by s
         */
        function scale(vector, scale) {
            return vector.map((v) => v * scale);
        }

        /**
         * Return matrix scaled by s to the unity matrix
         */
        function scaleMatrix(matrix, scale) {
            const ident = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            return matrix.map((v, i) => v + (ident[i] - v) * scale);
        }

        /**
         * Component-wise sum of vectors
         */
        function add(...vectors) {
            const length = Math.max(...vectors.map((v) => v.length));
            const result = [];
            for (let i = 0; i < length; ++i) {
                result.push(vectors.reduce((s, v) => s + (v[i] ?? 0), 0));
            }
            return result;
        }

        /**
         * Return vector A minus vector B
         */
        function subtract(a, b) {
            return a.map((v, i) => v - b[i]);
        }

        /**
         * Component-wise product of vectors
         */
        function product(v1, v2) {
            return v1.map((v, i) => v * v2[i]);
        }

        /**
         * Return the dot product of two vectors
         */
        function dot(v1, v2) {
            return v1.reduce((s, v, i) => s + v * v2[i], 0);
        }

        /**
         * Return the cross product of two vectors
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0],
            ];
        }

        /**
         * Apply a transform by multiplying a vector by a matrix
         */
        function applyTransform(vector, matrix) {
            return [
                matrix[0] * vector[0] + matrix[4] * vector[1] + matrix[8] * vector[2] + matrix[12],
                matrix[1] * vector[0] + matrix[5] * vector[1] + matrix[9] * vector[2] + matrix[13],
                matrix[2] * vector[0] + matrix[6] * vector[1] + matrix[10] * vector[2] + matrix[14],
            ];
        }

        /**
         * Return the result of multiplying 2 4x4 matrices
         */
        function matrixMultiply(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
            ];
        }

        /**
         * Calculate the inverse of a 4x4 matrix.
         * 
         * Input: 16 element array
         * Output: 16 element array
         */
        function invert(matrix) {
            const a0 = matrix[0] * matrix[5] - matrix[1] * matrix[4];
            const a1 = matrix[0] * matrix[6] - matrix[2] * matrix[4];
            const a2 = matrix[0] * matrix[7] - matrix[3] * matrix[4];
            const a3 = matrix[1] * matrix[6] - matrix[2] * matrix[5];
            const a4 = matrix[1] * matrix[7] - matrix[3] * matrix[5];
            const a5 = matrix[2] * matrix[7] - matrix[3] * matrix[6];
            const b0 = matrix[8] * matrix[13] - matrix[9] * matrix[12];
            const b1 = matrix[8] * matrix[14] - matrix[10] * matrix[12];
            const b2 = matrix[8] * matrix[15] - matrix[11] * matrix[12];
            const b3 = matrix[9] * matrix[14] - matrix[10] * matrix[13];
            const b4 = matrix[9] * matrix[15] - matrix[11] * matrix[13];
            const b5 = matrix[10] * matrix[15] - matrix[11] * matrix[14];
            const invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

            return [
                (+matrix[5] * b5 - matrix[6] * b4 + matrix[7] * b3) * invdet,
                (-matrix[1] * b5 + matrix[2] * b4 - matrix[3] * b3) * invdet,
                (+matrix[13] * a5 - matrix[14] * a4 + matrix[15] * a3) * invdet,
                (-matrix[9] * a5 + matrix[10] * a4 - matrix[11] * a3) * invdet,
                (-matrix[4] * b5 + matrix[6] * b2 - matrix[7] * b1) * invdet,
                (+matrix[0] * b5 - matrix[2] * b2 + matrix[3] * b1) * invdet,
                (-matrix[12] * a5 + matrix[14] * a2 - matrix[15] * a1) * invdet,
                (+matrix[8] * a5 - matrix[10] * a2 + matrix[11] * a1) * invdet,
                (+matrix[4] * b4 - matrix[5] * b2 + matrix[7] * b0) * invdet,
                (-matrix[0] * b4 + matrix[1] * b2 - matrix[3] * b0) * invdet,
                (+matrix[12] * a4 - matrix[13] * a2 + matrix[15] * a0) * invdet,
                (-matrix[8] * a4 + matrix[9] * a2 - matrix[11] * a0) * invdet,
                (-matrix[4] * b3 + matrix[5] * b1 - matrix[6] * b0) * invdet,
                (+matrix[0] * b3 - matrix[1] * b1 + matrix[2] * b0) * invdet,
                (-matrix[12] * a3 + matrix[13] * a1 - matrix[14] * a0) * invdet,
                (+matrix[8] * a3 - matrix[9] * a1 + matrix[10] * a0) * invdet];
        }


        /**
         * Extract translation from a transformation matrix
         */
        function extractTranslation(matrix) {
            return [matrix[12], matrix[13], matrix[14]];
        }

        /**
         * Extract scale vector from a transformation matrix
         */
        function extractScale(matrix) {
            return [
                Math.hypot(matrix[0], matrix[1], matrix[2]),
                Math.hypot(matrix[4], matrix[5], matrix[6]),
                Math.hypot(matrix[8], matrix[9], matrix[10])];
        }

        /**
         * Extract rotation from a transformation matrix
         */
        function extractRotation(matrix, scale) {
            scale = scale || extractScale(matrix);
            return [
                matrix[0] / scale[0], matrix[1] / scale[0], matrix[2] / scale[0], 0,
                matrix[4] / scale[1], matrix[5] / scale[1], matrix[6] / scale[1], 0,
                matrix[8] / scale[2], matrix[9] / scale[2], matrix[10] / scale[2], 0,
                0, 0, 0, 1,
            ];
        }

        /**
         * Extract quaternion from a rotation matrix
         */
        function extractQuaternion(rotation) {
            const tr = rotation[0] + rotation[5] + rotation[10];
            const quaternion = {};

            // From: https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
            if (tr > 0) {
                const S = Math.sqrt(tr + 1.0) * 2; // S=4*quaternion.w 
                quaternion.w = 0.25 * S;
                quaternion.x = (rotation[9] - rotation[6]) / S;
                quaternion.y = (rotation[2] - rotation[8]) / S;
                quaternion.z = (rotation[4] - rotation[1]) / S;
            } else if ((rotation[0] > rotation[5]) & (rotation[0] > rotation[10])) {
                const S = Math.sqrt(1.0 + rotation[0] - rotation[5] - rotation[10]) * 2; // S=4*quaternion.x 
                quaternion.w = (rotation[9] - rotation[6]) / S;
                quaternion.x = 0.25 * S;
                quaternion.y = (rotation[1] + rotation[4]) / S;
                quaternion.z = (rotation[2] + rotation[8]) / S;
            } else if (rotation[5] > rotation[10]) {
                const S = Math.sqrt(1.0 + rotation[5] - rotation[0] - rotation[10]) * 2; // S=4*quaternion.y
                quaternion.w = (rotation[2] - rotation[8]) / S;
                quaternion.x = (rotation[1] + rotation[4]) / S;
                quaternion.y = 0.25 * S;
                quaternion.z = (rotation[6] + rotation[9]) / S;
            } else {
                const S = Math.sqrt(1.0 + rotation[10] - rotation[0] - rotation[5]) * 2; // S=4*quaternion.z
                quaternion.w = (rotation[4] - rotation[1]) / S;
                quaternion.x = (rotation[2] + rotation[8]) / S;
                quaternion.y = (rotation[6] + rotation[9]) / S;
                quaternion.z = 0.25 * S;
            }
            return quaternion;
        }

        /**
         * Get angle and axis from a quaternion
         */
        function getAngleAxis(quaternion) {
            const radians = Math.acos(quaternion.w);
            const angle = 360 * radians / Math.PI;
            if (Math.abs(angle) > 0.0001) {
                const s = 1 / Math.sin(radians);
                const axis = [quaternion.x * s, quaternion.y * s, quaternion.z * s];
                return { angle, axis };
            }
            return { angle: 0, axis: [0, 1, 0] };
        }

        /**
         * Decompose a transform matrix into a translation, rotation and scale
         */
        function decompose(matrix) {
            const translation = extractTranslation(matrix);
            const scale = extractScale(matrix);
            const rotation = extractRotation(matrix, scale);
            const quaternion = extractQuaternion(rotation);
            const { angle, axis } = getAngleAxis(quaternion);
            return { translation, scale, angle, axis };
        }

        /**
         * Return the translation matrix based on vector transation.
         */
        function getTranslation(vector) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                vector[0], vector[1], vector[2], 1
            ];
        }

        /**
         * Return the scale matrix based on vector scales.
         */
        function getScale(vector) {
            return [
                vector[0], 0, 0, 0,
                0, vector[1], 0, 0,
                0, 0, vector[2], 0,
                0, 0, 0, 1
            ];
        }

        /**
         * Return the rotation matrix based on angle and axis.
         */
        function getRotation(angle, axis) {
            angle = angle * Math.PI / 360;
            const qw = Math.cos(angle);
            axis = normalised(axis);
            const qx = axis[0] * Math.sin(angle);
            const qy = axis[1] * Math.sin(angle);
            const qz = axis[2] * Math.sin(angle);

            return [
                1 - 2 * qy * qy - 2 * qz * qz,
                2 * qx * qy - 2 * qz * qw,
                2 * qx * qz + 2 * qy * qw,
                0,

                2 * qx * qy + 2 * qz * qw,
                1 - 2 * qx * qx - 2 * qz * qz,
                2 * qy * qz - 2 * qx * qw,
                0,

                2 * qx * qz - 2 * qy * qw,
                2 * qy * qz + 2 * qx * qw,
                1 - 2 * qx * qx - 2 * qy * qy,
                0,

                0, 0, 0, 1
            ];
        }

        /**
         * Get ray from screen position
         */
        function getRay(x, y) {
            const f = 1 / Math.tan(app.fov * Math.PI / 360);

            const w = canvas.clientWidth / 2;
            const h = canvas.clientHeight / 2;

            const zAxis = normalised(subtract(app.camera.lookAt, app.camera.position));
            const yAxis = normalised(app.camera.up);
            const xAxis = cross(zAxis, yAxis);

            const position = add(scale(xAxis, x - w), scale(yAxis, h - y), scale(zAxis, h * f));
            const direction = normalised(position);

            return { point: app.camera.position, direction };
        }

        /**
         * Get the point of intersection of a plane and line
         */
        function planeIntercept(line, plane) {
            const v = subtract(plane.point, line.point);
            const n = dot(plane.normal, v) / dot(plane.normal, line.direction);
            return n;
        }

        /**
         * Determine the intecept of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalised(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start && start > -Infinity) {
                return [start, end];
            }
        }

        /**
         * Find the intersection of a ray and objects
         */
        function getIntersection(line, all = false) {
            // Check whether a line passes within the radius of the bounding sphere
            const hits = [];
            const test = (instance) => {
                const size = scale(instance.size, 0.5 * app.scale);
                const origin = [0, 0, 0];
                const centre = applyTransform(origin, instance.origin);
                const radius = Math.hypot(...size);

                if (radius === 0) {
                    return instance.content.filter((child) => test(child)).length > 0;
                } else {

                    const l = dot(line.direction, subtract(centre, line.point));
                    const n = l / line.direction.reduce((s, v) => s + v * v, 0);
                    const p = add(line.point, scale(line.direction, n));
                    const v = subtract(p, centre);
                    const dist = Math.hypot(...v);
                    if (dist < radius) {
                        const corner1 = applyTransform(scale(size, -1), instance.origin);
                        const corner2 = applyTransform(size, instance.origin);
                        const rotation = extractRotation(instance.transform);
                        const planes = [
                            { point: corner1, normal: applyTransform([-1, 0, 0], rotation) },
                            { point: corner1, normal: applyTransform([0, -1, 0], rotation) },
                            { point: corner1, normal: applyTransform([0, 0, -1], rotation) },
                            { point: corner2, normal: applyTransform([1, 0, 0], rotation) },
                            { point: corner2, normal: applyTransform([0, 1, 0], rotation) },
                            { point: corner2, normal: applyTransform([0, 0, 1], rotation) },
                        ];
                        const points = convexHullIntercept(line, planes);
                        if (points) {
                            const p1 = add(line.point, scale(line.direction, points[0]));
                            const p2 = add(line.point, scale(line.direction, points[1]));
                            //app.points.push({ position: p1 }, { position: p2 });
                            instance.points = [p1, p2];

                            if (app.solid && !instance.state.transparent) {
                                hits.push(instance);
                            } else {
                                const content = instance.content.filter((child) => test(child));
                                if (all || content.length === 0) {
                                    hits.push(instance);
                                }
                            }
                            return true;
                        }
                    }
                }
            };

            app.roots.forEach((instance) => test(instance));
            return hits;
        }

        /**
         * Find the intersection of a ray and objects
         */
        function getSelected(hits) {
            if (hits.length) {
                const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));
                // Find the closest to the view position that isn't a parent
                const hit = hits.filter((hit) => hit.content.filter((child) => hits.includes(child)).length === 0);
                hit.sort((a, b) => dist(app.camera.position, a.points[0]) - dist(app.camera.position, b.points[0]));
                if (event.shiftKey) {
                    if (event.ctrlKey) {
                        hit.forEach((instance) => instance.selected = true);
                    } else {
                        hit[0].selected = true;
                    }
                } else {
                    app.instances.forEach((instance) => instance.selected = instance === hit[0]);
                }
                return hit;
            }
            app.instances.forEach((instance) => instance.selected = false);
        }

        /**
         * Utility function to support downloading generated content.
         */
        function downloadText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }

        /**
         * Save the current state
         */
        function save() {
            const lines = [];
            lines.push(`>eye position = ${app.camera.position.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push(`>look at = ${app.camera.lookAt.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push(`>up = ${app.camera.up.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push('');

            const addInstance = (instance, level = 0) => {
                lines.push(`${''.padStart(level * 2, ' ')}${instance.asString()}`);
                instance.content.forEach((child) => addInstance(child, level + 1));
            };
            app.roots.forEach((root) => addInstance(root));
            downloadText(lines.join('\n'));
        }

        /**
         * Clear Selection
         */
        function clearSelection() {
            app.instances.forEach((instance) => instance.selected = false);
            document.getElementById('info').innerHTML = '';
            document.getElementById('info').classList.add('hide');
            updateTextBuffer();
            app.colourUpdate = true;
        }

        /**
         * Rotate the selected item
         */
        function rotateSelected(angle, axis, local) {
            app.instances.filter((instance) => instance.selected)
                .forEach((instance) => {
                    if (local) {
                        axis = applyTransform(axis, extractRotation(instance.origin));
                    }
                    instance.rotate(angle, axis);
                });
        }

        /**
         * Selected item(s) parent.
         */
        function selectParent() {
            const parents = app.instances.flatMap((instance) => instance.selected ? (instance.parent ?? []) : []);
            if (!event.shiftKey) {
                app.instances.forEach((instance) => instance.selected = false);
            }
            parents.forEach((instance) => instance.selected = true);
            app.instancesChanged = true;
            updateText();
            app.colourUpdate = true;
        }

        /**
         * 'Hide' the selected item(s).
         */
        function hideSelected() {
            app.instances.filter((instance) => instance.selected)
                .forEach((instance) => instance.hidden = !instance.hidden);
            app.instances.forEach((instance) => {
                const node = app.nodeMap.get(instance)[0];
                if (instance.hidden) {
                    node.classList.add('hidden');
                } else {
                    node.classList.remove('hidden');
                }
            });
            initialiseInstances();
        }

        /**
         * Undo the last action
         */
        function undo() {
            historyPosition = historyPosition ?? history.length;
            if (historyPosition) {
                historyPosition -= 1;
            }
            if (history[historyPosition]) {
                history[historyPosition].undo();
            }
        }

        /**
         * Re do an action
         */
        function redo() {
            if (history[historyPosition]) {
                history[historyPosition].redo();
                historyPosition += 1;
            }
        }

        /**
         * Add the event handlers for the canvas.
         */
        function addCanvasEvents(canvas) {
            canvas.tabIndex = 0;
            canvas.addEventListener('keydown', (event) => {
                report(event.key);
                const altShiftMapping = {
                    X: (event) => rotateSelected(-45, [1, 0, 0], true),
                    Y: (event) => rotateSelected(-45, [0, 1, 0], true),
                    Z: (event) => rotateSelected(-45, [0, 0, 1], true),
                }

                const shiftMapping = {
                    ArrowUp: (event) => up(),
                    ArrowDown: (event) => up(-1),
                    ArrowLeft: (event) => right(-1),
                    ArrowRight: (event) => right(),
                    '+': (event) => newBlock(),
                    R: (event) => reset(),
                    W: (event) => app.solid = !app.solid,
                    X: (event) => rotateSelected(-45, [1, 0, 0]),
                    Y: (event) => rotateSelected(-45, [0, 1, 0]),
                    Z: (event) => rotateSelected(-45, [0, 0, 1]),
                }
                const ctrlMapping = {
                    ArrowUp: (event) => addBlocks([0, 1, 0]),
                    ArrowDown: (event) => addBlocks([0, -1, 0]),
                    ArrowLeft: (event) => addBlocks([-1, 0, 0]),
                    ArrowRight: (event) => addBlocks([1, 0, 0]),
                    l: (event) => document.getElementById('load-file').click(),
                    r: (event) => processDefinition(app.definition, true),
                    z: (event) => undo(),
                    Z: (event) => redo(),
                }
                const altMapping = {
                    ArrowUp: (event) => addBlocks([0, 0, -1]),
                    ArrowDown: (event) => addBlocks([0, 0, 1]),
                    ArrowLeft: (event) => addBlocks([-1, 0, 0]),
                    ArrowRight: (event) => addBlocks([1, 0, 0]),
                    x: (event) => rotateSelected(45, [1, 0, 0], true),
                    y: (event) => rotateSelected(45, [0, 1, 0], true),
                    z: (event) => rotateSelected(45, [0, 0, 1], true),
                }
                const mapping = {
                    ArrowUp: (event) => forward(),
                    ArrowDown: (event) => forward(-1),
                    ArrowLeft: (event) => rotateRight(-1),
                    ArrowRight: (event) => rotateRight(),
                    Escape: (event) => clearSelection(),
                    Delete: (event) => deleteBlocks(event),
                    a: (event) => { app.showNames = !app.showNames; updateTextBuffer() },
                    b: (event) => setView([0, -1, 0], [0, 0, -1]),
                    c: (event) => { app.points = []; updatePoints(); },
                    f: (event) => setView([0, 0, 1]),
                    h: (event) => hideSelected(event),
                    i: (event) => { app.solid = !app.solid; app.colourUpdate = true; },
                    l: (event) => setView([-1, 0, 0]),
                    p: (event) => selectParent(event),
                    q: (event) => document.querySelector('.texture-canvas').classList.toggle('hide'),
                    r: (event) => setView([1, 0, 0]),
                    s: (event) => save(),
                    t: (event) => setView([0, 1, 0], [0, 0, -1]),
                    w: (event) => app.wireframe = !app.wireframe,
                    x: (event) => rotateSelected(45, [1, 0, 0]),
                    y: (event) => rotateSelected(45, [0, 1, 0]),
                    z: (event) => rotateSelected(45, [0, 0, 1]),
                }

                if (event.ctrlKey && ctrlMapping[event.key]) {
                    event.preventDefault();
                    ctrlMapping[event.key](event);
                } else if (event.shiftKey && event.altKey && altShiftMapping[event.key]) {
                    altShiftMapping[event.key](event);
                } else if (event.shiftKey && shiftMapping[event.key]) {
                    shiftMapping[event.key](event);
                } else if (event.altKey && altMapping[event.key]) {
                    event.preventDefault();
                    altMapping[event.key](event);
                } else {
                    mapping[event.key]?.(event);
                }
            });

            const mouseDown = (event) => {
                action.lastX = event.clientX;
                action.lastY = event.clientY;
                const mouseLine = getRay(event.clientX, event.clientY);
                const hits = getSelected(getIntersection(mouseLine));
                for (const node of document.body.querySelectorAll('.selected')) {
                    node.classList.remove('selected');
                }
                if (hits && action.selected && event.ctrlKey) {
                    hits.forEach((hit) =>
                        app.connections.push(new Connection(action.selected, hit)));
                }
                action.selected = null;
                action.moved = false;
                if (hits) {
                    // Move the clicked object
                    const { xAxis, yAxis, zAxis, distance } = viewVectors();
                    action.selected = hits[0];
                    action.selected.showInfo();

                    action.selected.nodes[0].scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
                    if (action.selected.serialNumber) {

                    } else {
                        action.selected.state.selected = true;

                        report(action.selected.name);
                        app.nodeMap.get(action.selected).forEach((node) => node.classList.add('selected'));
                        action.plane = { point: action.selected.points[0] };
                        if (Math.abs(dot(app.camera.up, [0, 1, 0])) > 0.9) {
                            action.plane.normal = zAxis;
                        } else {
                            action.plane.normal = [0, 1, 0];
                        }
                        const apply = (instance, action) => {
                            action(instance);
                            instance.content.forEach((child) => apply(child, action));
                        }
                        const selected = app.instances.filter((instance) => instance.selected);
                        selected.forEach((instance) =>
                            instance.apply((instance) => instance.start = extractTranslation(instance.origin)));
                        action.move = (event) => {
                            app.instances.forEach((instance) => instance.state.ghost = true);
                            action.selected.siblings.forEach((instance) => instance.state.constraint = true);
                            action.selected.state.moving = true;

                            action.moved = true;
                            const mouseLine = getRay(event.clientX, event.clientY);
                            const n = planeIntercept(mouseLine, action.plane);
                            const point = add(mouseLine.point, scale(mouseLine.direction, n));
                            const delta = subtract(point, action.plane.point);

                            selected.forEach((selected) => {
                                selected.statusColour = null;
                                selected.move(delta);
                                selected.update();
                            });
                        };
                        action.end = endMove;
                    }
                } else {
                    // Rotate the view
                    action.move = (event) => {
                        action.moved = true;
                        const deltaX = event.clientX - action.lastX;
                        const deltaY = event.clientY - action.lastY;
                        action.lastX = event.clientX;
                        action.lastY = event.clientY;
                        const sightLine = subtract(app.camera.lookAt, app.camera.position);
                        const xAxis = cross(sightLine, app.camera.up);
                        const yAxis = cross(sightLine, xAxis);
                        if (event.shiftKey) {
                            const dist = Math.hypot(...sightLine) / -1000;
                            const movement = add(scale(normalised(xAxis), deltaX * dist), scale(normalised(yAxis), deltaY * dist));
                            app.camera.position = add(app.camera.position, movement);
                            app.camera.lookAt = add(app.camera.lookAt, movement);
                        } else {
                            const xRotation = getRotation(deltaY * Math.PI / 30, xAxis);
                            const yRotation = getRotation(deltaX * Math.PI / 30, app.camera.up);
                            const rotation = multiply(xRotation, yRotation);
                            app.camera.position = subtract(app.camera.lookAt, applyTransform(sightLine, rotation));
                            app.camera.up = applyTransform(app.camera.up, rotation);
                        }
                        app.viewMatrix = viewMatrix(app.camera.position, app.camera.lookAt, app.camera.up);
                        app.camera.updateViewControls();
                    };
                    const start = {
                        position: [...app.camera.position],
                        lookAt: [...app.camera.lookAt],
                        up: [...app.camera.up],
                    };
                    action.end = () => {
                        action.move = null;
                        const end = {
                            position: [...app.camera.position],
                            lookAt: [...app.camera.lookAt],
                            up: [...app.camera.up],
                        };
                        if (action.moved) {
                            history.push({
                                undo: () => moveCamera(start.position, start.lookAt, start.up),
                                redo: () => moveCamera(end.position, end.lookAt, end.up),
                            });
                        }
                    }
                }
                app.colourUpdate = true;
                updateTextBuffer();
                updatePoints();
            };
            canvas.addEventListener('mousedown', (event) => mouseDown(event));
            canvas.addEventListener('touchstart', (event) => mouseDown(touch(event)));
            canvas.addEventListener('wheel', (event) => {
                report(`Wheel (${event.deltaY})`);
                event.preventDefault();
                const dist = Math.pow(2, event.deltaY / 100);
                const sightLine = subtract(app.camera.lookAt, app.camera.position);
                const current = (app.movement?.distance?.remaining ?? 0) / Math.hypot(...sightLine);
                const move = sightLine.map((v) => v * (dist + current));
                const position = subtract(app.camera.lookAt, move);
                moveCamera(position, app.camera.lookAt, app.camera.up);
            });

            /**
             * Process a dropped file
             */
            function dropHandler(event) {
                dragPart = false;
                app.instances.forEach((instance) => instance.state = {});

                event.preventDefault();
                const replace = event.shiftKey;

                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        app.definition = reader.result;
                        processDefinition(app.definition, replace);
                    });
                    reader.readAsText(file);
                }

                if (event.dataTransfer.items) {
                    [...event.dataTransfer.items].forEach((item, index) => {
                        if (item.kind === 'file') {
                            const file = item.getAsFile();
                            loadFile(file);
                            item.getAsFileSystemHandle().then((handle) => {
                                //saveFileHandles([{ name: file.name, handle }]);
                            });
                        }
                    });
                } else {
                    // Use DataTransfer interface to access the file(s)
                    [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
                }
                const types = event.dataTransfer.types;
                if (types.length) {
                    const mouseLine = getRay(event.clientX, event.clientY);
                    const hits = getIntersection(mouseLine).filter((instance) => instance.parts?.includes(types[0]));
                    if (hits.length) {
                        const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));
                        hits.sort((a, b) => dist(app.camera.position, a.points[0]) - dist(app.camera.position, b.points[0]));
                        if (hits[0]) {
                            hits[0].serialNumber = event.dataTransfer.getData(types[0]);
                            hits[0].colour = [1, 0, 0];
                            hits[0].showInfo();
                        }
                    }
                }
                app.colourUpdate = true;
            }

            let dragPart = false;
            function dragOverHandler(event) {
                // Prevent default behavior (Prevent file from being opened)
                event.preventDefault();
                const types = event.dataTransfer.types;
                if (types.length) {
                    const mouseLine = getRay(event.clientX, event.clientY);
                    const hits = getIntersection(mouseLine).filter((instance) => instance.parts?.includes(types[0]));
                    if (hits.length) {
                        const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));
                        hits.sort((a, b) => dist(app.camera.position, a.points[0]) - dist(app.camera.position, b.points[0]));
                    }
                    app.instances.forEach((instance) => {
                        instance.state.highlight = instance === hits[0];
                        instance.state.hasPart = instance.serialNumber;
                        instance.state.constraint = instance.parts?.includes(types[0]);
                        instance.state.ghost = true;
                    });
                    app.colourUpdate = true;
                }
            }

            canvas.addEventListener('dragover', dragOverHandler);
            canvas.addEventListener('drop', dropHandler);
        }

        /**
         * Process definition
         */
        function processDefinition(definition, replace) {
            processText(definition, undefined, replace);

            /*
            const objs = getObjects(definition);
            const tree = getTree(objs);
            const graph = expandGraph(tree);
            //makeGraph(graph, replace);
*/
            updateText();
            showStructure();
            showStock();
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            app.camera.up = yAxis;
        }

        /**
         * Load file
         */
        async function loadFile(url) {
            const result = await fetch(url);
            const content = await result.text();
            processDefinition(content);
        }

        /**
         * Perform all once off set-up (e.g. creating buffer etc.)
         */
        function initialise() {
            addMovementControls();
            projectionControl();
            viewControl(document.getElementById('view-vectors'));
            addCanvasEvents(canvas);

            // Set clear color to black, fully opaque
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            // Should be update to track canvas size changes
            gl.canvas.width = gl.canvas.clientWidth;
            gl.canvas.height = gl.canvas.clientHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            const attributes = ['position', 'normal', 'model', 'ambientColour', 'diffuseColour', 'specularColour', 'specularIntensity', 'opacity'];
            app.shader = makeProgram(shaderSource, attributes, ['projection', 'view', 'lightPosition1', 'lightPosition2', 'lightPosition3', 'cameraPosition']);
            app.textShader = makeProgram(textShaderSource, ['position', 'model', 'offset', 'size', 'textureSize', 'textureOrigin', 'colour',],
                ['projection', 'view', 'texture']);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            app.buffers = {
                vertex: gl.createBuffer(),
                instances: gl.createBuffer(),
                colour: gl.createBuffer(),
                points: gl.createBuffer(),
                lines: gl.createBuffer(),
                textInstance: gl.createBuffer(),
                textItems: gl.createBuffer(),
            };
            app.textTexture = gl.createTexture();
            app.vertexCount = 36;
            initialiseText();
            const shape = makeCube();
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);
            setBoxAttributes();
            setPointAttributes();
            setLineAttributes();
            if (location.protocol === 'http:') {
                loadFile('start.txt');
            } else {
                makeGraph();
            }
            initialiseInstances();

            const fileSelection = document.getElementById('load-file');
            fileSelection.addEventListener('change', (event) => {
                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        const objs = getObjects(reader.result);
                        const tree = getTree(objs);
                        const graph = expandGraph(tree);
                        makeGraph(graph, true);
                    });
                    reader.readAsText(file);
                }
                for (const file of fileSelection.files) {
                    loadFile(file);
                }
            });
        }

        /**
         * Called once html has loaded.
         *
         * Create the Webgl context, set up the buffers and call the event loop.
         */
        function main(event) {
            initialise();
            requestAnimationFrame(render);
            report(location.protocol);
        }

        window.addEventListener('load', main);
    </script>
</body>

</html>
