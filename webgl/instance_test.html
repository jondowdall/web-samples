<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>3d System Model</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
            font-size: 10pt;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            overflow: hidden;
        }

        table,
        th,
        td {
            border-collapse: collapse;
            border: 1px solid gray;
        }

        th,
        td {
            padding: 2px 5px;
        }

        ul {
            margin: 0;
        }

        #main-canvas {
            width: 100dvw;
            height: 100dvh;
        }

        #top-left {
            position: absolute;
            background-color: white;
            left: 0;
            top: 0;
            max-height: 100vh;
            max-width: 80vw;
        }

        #projection-control {
            display: grid;
            grid-template-columns: repeat(2, max-content);
            grid-template-rows: repeat(4, max-content);
        }

        #top-right {
            position: absolute;
            right: 0;
            top: 0;
            display: flex;
            flex-direction: column;
            align-items: end;
        }

        #bottom-right {
            position: absolute;
            right: 1em;
            bottom: 1em;
        }

        #movement {
            position: fixed;
            bottom: 1em;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
        }

        #stock {
            background-color: white;
        }

        #view-vectors {
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            background-color: white;
        }

        .matrix-input {
            width: 5em;
        }

        #projection-control>details {
            grid-column: 1 / -1;
        }

        details details {
            margin-left: 1em;
        }

        #model {
            overflow: auto;
            /*
            width: 50vw;
            height: 50vh;
            */
            resize: both;
        }

        #model .title {
            position: sticky;
            left: 0;
            background-color: white;
        }

        #model .displayed {
            font-weight: bold;
        }

        #model th {
            position: sticky;
            top: 0;
            background-color: white;
        }

        #structure {
            display: grid;
            grid-template-columns: minmax(10em, min-content) repeat(7, max-content);
            grid-template-columns: minmax(10em, min-content) repeat(13, max-content);

            grid-gap: 3px;
            overflow: auto;
            /*
            height: 50vh;
            width: 50vw;
            */
            resize: both;
        }

        #structure .value {
            text-align: center;
        }

        #notification {
            position: fixed;
            top: 1em;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 0.5em;
            padding: 0.3em;
        }

        #state {
            position: fixed;
            bottom: 1em;
            left: 1em;
            background-color: white;
            border-radius: 0.5em;
            padding: 0.3em;
        }

        #info {
            position: fixed;
            bottom: 3em;
            right: 1em;
            color: yellow;
            background-color: rgb(80, 80, 30, 0.8);
            border: 1px solid orange;
            border-radius: 0.5em;
            padding: 0.5em;
            min-width: 20em;
            display: grid;
            grid-template-columns: max-content 1fr;
            grid-auto-rows: max-content;
            grid-row-gap: 3px;
        }

        .all-columns {
            grid-column: 1 / -1;
        }

        #info h2 {
            margin-block-start: 0em;
        }

        #info textarea {
            background-color: none;
            width: 100%;
            height: 12em;
        }

        #load-file {
            display: none;
        }

        .texture-canvas {
            position: fixed;
            top: 200px;
            left: 0;
            z-index: 1000;
        }

        .selected {
            font-weight: bold;
        }

        .hidden {
            color: gray;
            font-style: italic;
        }

        .hide {
            display: none !important;
        }

        .undefined {
            background-color: lightgrey;
        }

        .inherited {
            font-style: italic;
        }

        .three-columns {
            grid-column: span 3;
        }

        .two-rows {
            grid-row: span 2;
        }

        .expander {
            display: inline-block;
            width: 0.8em;
            height: 0.8em;
            text-align: center;
            font-size: 80%;
            padding-right: 0.5em;
        }
    </style>
</head>

<body>
    <canvas id="main-canvas" tabindex="1">HTML canvas not supported!</canvas>

    <div id="top-left">
        <details>
            <summary>View Control</summary>
            <div id="projection-control">
                Field of View<input id="field-of-view" type="number" />
                Near<input id="near" type="number" />
                Far<input id="far" type="number" />
            </div>
        </details>
        <details>
            <summary>Model</summary>
            <div id="model">
            </div>
        </details>
        <details>
            <summary>Structure</summary>
            <div id="structure">
                <span class="two-rows">Name</span>
                <span class="three-columns">Position</span>
                <span class="three-columns">Size</span>
                <span class="two-rows">Angle</span>
                <span class="three-columns">Axis</span>
                <span class="two-rows">Colour</span>
                <span class="two-rows">Specular</span>
                <span class="two-rows">Opacity</span>

                <span>x</span>
                <span>y</span>
                <span>z</span>

                <span>x</span>
                <span>y</span>
                <span>z</span>

                <span>x</span>
                <span>y</span>
                <span>z</span>
            </div>
        </details>

    </div>
    <div id="top-right">
        <input type="file" id="load-file" multiple />
        <div id="view-vectors"></div>
        <div id="stock"></div>
    </div>
    <div id="movement">
        <button id="anti-clockwise">&#8634;</button>
        <button id="move-up">&#8593;</button>
        <button id="clockwise">&#8635;</button>

        <button id="move-left">&#8592;</button>
        <button id="clear">&#9114;</button>
        <button id="move-right">&#8594;</button>

        <button id="move-forward">&#8634;</button>
        <button id="move-down">&#8595;</button>
        <button id="move-backwards">&#8634;</button>
    </div>
    <div id="bottom-right">
        <button id="save">&#x1F4BE;</button>
    </div>
    <div id="state"></div>
    <div id="info" class="hide"></div>

    <script type="x-shader/x-vertex" id="vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in vec3 normal;
    in mat4 model;
    in vec3 ambientColour;
    in vec3 diffuseColour;
    in vec3 specularColour;
    in float specularIntensity;
    in float opacity;

    out vec4 v_vertex;
    out vec4 v_normal;
    out vec3 v_ambientColour;
    out vec3 v_diffuseColour;
    out vec3 v_specularColour;
    out float v_opacity;
    out float v_specularIntensity;

    void main() {
        v_vertex = model * vec4(position, 1.0);
        gl_Position = projection * view * v_vertex;
        v_normal = model * vec4(normal, 0.0);
        v_ambientColour = ambientColour;
        v_diffuseColour = diffuseColour;
        v_specularColour = specularColour;
        v_opacity = opacity;
        v_specularIntensity = specularIntensity;

        gl_PointSize = 5.0;//50.0 * model[0][0];

        if (opacity < 1.0) {
            gl_Position.z = gl_Position.w;
        }
    }
    </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
    #version 300 es
    precision highp float;

    uniform vec3 lightPosition1;
    uniform vec3 lightPosition2;
    uniform vec3 lightPosition3;
    uniform vec3 cameraPosition;

    in vec4 v_vertex;
    in vec4 v_normal;
    in vec3 v_ambientColour;
    in vec3 v_diffuseColour;
    in vec3 v_specularColour;
    in float v_specularIntensity;
    in float v_opacity;

    out vec4 fragmentColour;

    void main() {
        vec3 toLight1 = normalize(lightPosition1 - v_vertex.xyz);
        vec3 toLight2 = normalize(lightPosition2 - v_vertex.xyz);
        vec3 toLight3 = normalize(lightPosition3 - v_vertex.xyz);
        vec3 normal = normalize(v_normal.xyz);

        float df = max(0.0, dot(normal, toLight1)) + 0.2 * max(0.0, dot(normal, toLight2)) + 0.1 * max(0.0, dot(normal, toLight3));

        vec3 reflection1 = normalize(2.0 * dot(normal, toLight1) * normal - toLight1);
        vec3 reflection2 = normalize(2.0 * dot(normal, toLight2) * normal - toLight2);
        vec3 reflection3 = normalize(2.0 * dot(normal, toLight3) * normal - toLight3);
        vec3 toEye = normalize(cameraPosition - v_vertex.xyz);
        float sf = clamp(dot(reflection1, toEye), 0.0, 1.0) + 0.2 * clamp(dot(reflection2, toEye), 0.0, 1.0) + 0.1 * clamp(dot(reflection3, toEye), 0.0, 1.0);
        sf = pow(sf, v_specularIntensity);

        vec3 colour = v_ambientColour + v_diffuseColour * df + v_specularColour * sf;
        fragmentColour = vec4(colour, v_opacity);

        /*
        if (v_opacity > 0.0 && dot(normal, toEye) > -0.1) {
            discard;
            return;
        }
        fragmentColour = vec4(colour, 1.0);
        */
    }
    </script>
    <script type="x-shader/x-vertex" id="text-vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in mat4 model;

    in vec2 offset;
    in vec2 size;
    in vec2 textureSize;
    in vec2 textureOrigin;

    in vec4 colour;

    out vec4 v_colour;
    out vec2 v_textureCoordinate;

    void main() {
        gl_Position = projection * view * model * vec4(position, 1.0);
        gl_Position = vec4(gl_Position.xy + offset * size * gl_Position.w, gl_Position.zw);

        vec2 textureOffset = (offset + vec2(1.0, -1.0)) / vec2(2.0, -2.0);
        v_textureCoordinate = textureOrigin + textureOffset * textureSize;
        v_colour = colour;

    }
    </script>
    <script type="x-shader/x-fragment" id="text-fragment-shader">
    #version 300 es
    precision highp float;
    uniform sampler2D source;

    in vec2 v_textureCoordinate;
    in vec4 v_colour;

    out vec4 fragmentColour;

    void main() {
        fragmentColour = v_colour * texture(source, v_textureCoordinate);

        if (fragmentColour.a < 0.001) {
            discard;
            return;
        }
    }
    </script>


    <script type="x-shader/x-vertex" id="texture-vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in vec3 normal;
    in mat4 model;
    in vec3 ambientColour;
    in vec3 diffuseColour;
    in vec3 specularColour;
    in float specularIntensity;
    in float opacity;

    out vec4 v_vertex;
    out vec4 v_normal;
    out vec3 v_ambientColour;
    out vec3 v_diffuseColour;
    out vec3 v_specularColour;
    out float v_opacity;
    out float v_specularIntensity;

    void main() {
        v_vertex = model * vec4(position, 1.0);
        gl_Position = projection * view * v_vertex;
        v_normal = model * vec4(normal, 0.0);
        v_ambientColour = ambientColour;
        v_diffuseColour = diffuseColour;
        v_specularColour = specularColour;
        v_opacity = opacity;
        v_specularIntensity = specularIntensity;

        gl_PointSize = 5.0;//50.0 * model[0][0];

        if (opacity < 1.0) {
            gl_Position.z = gl_Position.w;
        }
    }
    </script>

    <script type="x-shader/x-vertex" id="pbr-vertex-shader">
        #version 300 es
        precision highp float;

        uniform mat4 projection;
        uniform mat4 view;

        in mat4 model;
        in mat3 normalMatrix;

        in vec3 position;
        in vec3 normal;
        in vec3 colour;
        in vec3 emissivityColour;
        in float roughness;
        in vec3 reflectivity;
        in float opacity;
        in float metallic;

        out vec3 v_position;
        out vec3 v_normal;
        out vec3 v_colour;
        out vec3 v_emissivityColour;
        out float v_roughness;
        out vec3 v_baseReflectivity;
        out float v_opacity;
        out float v_metallic;

        void main() {            
            vec4 worldPosition = model * vec4(position, 1.0);
            gl_Position = projection * view * worldPosition;

            v_position = worldPosition.xyz;
            v_normal = normalMatrix * normal;
            v_colour = colour;
            v_emissivityColour = emissivityColour;
            v_roughness = roughness;
            v_baseReflectivity = reflectivity;
            v_opacity = opacity;
            v_metallic = metallic;
        }
    </script>

    <script type="x-shader/x-fragment" id="pbr-fragment-shader">
        #version 300 es
        precision highp float;

        #define PI 3.1415926538

        uniform vec3 lightPosition1;
        uniform vec3 lightColour1;

        uniform vec3 lightPosition2;
        uniform vec3 lightColour2;
        
        uniform vec3 lightPosition3;
        uniform vec3 lightColour3;

        uniform vec3 cameraPosition;

        in vec3 v_position;
        in vec3 v_normal;
        in vec3 v_colour;
        in vec3 v_emissivityColour;
        in float v_roughness;
        in vec3 v_baseReflectivity;

        in float v_opacity;
        in float v_metallic;

        out vec4 fragmentColour;

        // GGX / Trowbridge-Reitz Normal Distribution Vector
        float Distribution(float alpha, vec3 normal, vec3 halfVector) {
            float a2 = alpha * alpha;

            float NdotH = dot(normal, halfVector);
            float f = NdotH * NdotH * (a2 - 1.0) + 1.0;

            return a2 / (PI * f * f);
        }

        // Schlick-Beckmann Geometry Shadowing Function
        float G1(float alpha, vec3 normal, vec3 vector) {
            float numerator = max(dot(normal, vector), 0.0);

            float k = alpha / 2.0;
            float denominator = max(dot(normal, vector), 0.0) * (1.0 - k) + k;
            denominator = max(denominator, 0.000001);

            return numerator / denominator;
        }

        // Smith Model
        float Geometry(float alpha, vec3 normal, vec3 view, vec3 light) {
            return G1(alpha, normal, view) * G1(alpha, normal, light);
        }
        
        // Fresnel-Schlick function
        vec3 Fresnel(vec3 reflectivity, vec3 view, vec3 halfVector) {
            return reflectivity + (vec3(1.0) - reflectivity) * pow(clamp(1.0 - dot(view, halfVector), 0.0, 1.0), 5.0);
        }

        // Cook-Torrance based BRDF function
        vec3 BRDF(float alpha, vec3 lambert, vec3 normal, vec3 viewVector, vec3 lightVector, vec3 reflectivity, float metallic) {
            vec3 halfVector = normalize(lightVector + viewVector);

            vec3 Ks = Fresnel(reflectivity, viewVector, halfVector);
            vec3 Kd = (vec3(1.0) - Ks) * (1.0 - metallic);

            //vec3 numerator = Distribution(alpha, normal, halfVector) * Geometry(alpha, normal, viewVector, lightVector) * Ks;
            vec3 numerator = vec3(1.0, 0.3, 0.7);
            float denominator = 4.0 *  max(dot(viewVector, normal), 0.0) * max(dot(lightVector, normal), 0.0);
            denominator = max(denominator, 0.000001);

            return Kd * lambert +  numerator / denominator;
        }

        void main() {
            vec3 normal = normalize(v_normal);
            vec3 viewVector = normalize(cameraPosition - v_position);

            vec3 lightVector1 = normalize(lightPosition1);

            vec3 light2 = lightPosition2 - v_position;
            float dist2 = length(light2);
            float intensity2 = 1.0 / (dist2 * dist2);
            vec3 lightVector2 = normalize(light2);

            vec3 light3 = lightPosition3 - v_position;
            float dist3 = length(light3);
            float intensity3 = 1.0 / (dist3 * dist3);
            vec3 lightVector3 = normalize(light3);

            float alpha = v_roughness * v_roughness;

            vec3 lambert = v_colour / PI;

            vec3 BRDF1 = BRDF(alpha, lambert, normal, viewVector, lightVector1, v_baseReflectivity, v_metallic);
            vec3 BRDF2 = BRDF(alpha, lambert, normal, viewVector, lightVector2, v_baseReflectivity, v_metallic);
            vec3 BRDF3 = BRDF(alpha, lambert, normal, viewVector, lightVector3, v_baseReflectivity, v_metallic);

            fragmentColour = vec4(v_emissivityColour
                + BRDF1 * lightColour1 * max(dot(lightVector1, normal), 0.0) * 0.5
                + BRDF2 * lightColour2 * max(dot(lightVector2, normal), 0.0) * intensity2
                + BRDF3 * lightColour3 * max(dot(lightVector3, normal), 0.0) * intensity3,
                v_opacity);
            fragmentColour = vec4(1.0, 0.2, 0.8, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="textured-pbr-shader">
    #version 300 es
    precision highp float;

    #define PI 3.1415926538

    uniform vec3 lightPosition1;
    uniform vec3 lightColour1;

    uniform vec3 lightPosition2;
    uniform vec3 lightColour2;
    
    uniform vec3 lightPosition3;
    uniform vec3 lightColour3;
    
    uniform vec3 cameraPosition;

    in vec4 v_position;
    in vec4 v_normal;
    in vec3 v_colour;
    in vec3 v_emissivityColour;
    in float v_roughness;
    in vec3 v_baseReflectivity;

    in float v_opacity;

    out vec4 fragmentColour;

    // GGX / Trowbridge-Reitz Normal Distribution Vector
    float Distribution(float alpha, vec3 normal, vec3 halfVector) {
        float numerator = pow(alpha, 2.0);

        float NdotH = max(dot(normal, halfVector), 0.0);
        float denominator = PI * pow((pow(NdotH, 2.0) * pow(alpha, 2.0) - 1.0) + 1.0, 2.0);
        denominator = max(denominator, 0.000001);

        return numerator / denominator;
    }

    // Schlick-Beckmann Geometry Shadowing Function
    float G1(float alpha, vec3 normal, vec3 vector) {
        float numerator = max(dot(normal, vector), 0.0);

        float k = alpha / 2.0;
        float denominator = max(dot(normal, vector), 0.0) * (1.0 - k) + k;
        denominator = max(denominator, 0.000001);

        return numerator / denominator;
    }

    // Smith Model
    float Geometry(float alpha, vec3 normal, vec3 view, vec2 light) {
        return G1(alpha, normal, view) * G1(alpha, normal, light);
    }
    
    // Fresnel-Schlick function
    vec3 Fresnel(vec3 reflectivity, vec3 view, vec3 halfVector) {
        return reflectivity + (vec3(1.0) - reflectivity) * pow(1 - max(dot(view, halfVector), 0.0), 5.0);
    }

    void main() {
        vec3 normal = normalize(v_normal.xyz);
        vec3 viewVector = normalize(CameraPosition - v_position.xyz);
        vec3 lightVector1 = normalize(lightPosition1);
        vec3 halfVector1 = normalize(lightVector1, viewVector);

        vec3 lightVector2 = normalize(lightPosition2 - v_position.xyz);
        vec3 halfVector2 = normalize(lightVector2, viewVector);

        vec3 lightVector3 = normalize(lightPosition3 - v_position.xyz);
        vec3 halfVector3 = normalize(lightVector3, viewVector);

        vec3 Ks = Fresnel(v_baseReflectivity, viewVector, halfVector1);
        vec3 Kd = vec3(1.0 - u_metallic) - Ks;
        float alpha = pow(v_roughness, 2.0)

        vec3 lambert = v_colour / PI;

        vec3 numerator = Distribution(alpha, normal, halfVector1) * Geometry(alpha, normal, viewVector, lightVector1) * Ks;
        float denominator = 4.0 *  max(dot(viewVector, normal), 0.0) * max(dot(lightVector1, normal), 0.0);
        denominator = max(denominator, 0.000001);

        vec3 cookTorrance = numerator / denominator;
        vec3 BRDF = Kd * lambert + cookTorrance;

        fragmentColour = v_emissivityColour + BRDF * lightColour1 * max(dot(lightVector1, normal), 0.0);
    }
    </script>


    <script>
        const CYLINDER_SIDES = 24;
        /**
         * Update report display.
         */
        function report(...text) {
            document.getElementById('state').innerText = text.join();
        }

        /**
         * Return an identity matrix
         */
        function identityMatrix() {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }

        /**
         * Get the hex value of the input number
         */
        function toHex(number, chars) {
            const result = [];
            const sign = number < 0 ? '-' : '';
            number = Math.floor(Math.abs(number));
            const digit = number & 0xf;
            result.push('0123456789ABCDEF'.charAt(digit));
            number >>= 4;
            while (number) {
                const digit = number & 0xf;
                result.unshift('0123456789ABCDEF'.charAt(digit));
                number >>= 4;
            }
            if (chars) {
                return `${sign}${result.join('')}`.padStart(chars, '0');
            }
            return sign + result.join('');
        }


        /**
         * Get a timestamp suitable for file names
         */
        function timestamp() {
            const now = new Date();
            const year = now.getFullYear();
            const month = ('' + (now.getMonth() + 1)).padStart(2, '0');
            const day = ('' + now.getDate()).padStart(2, '0');
            const hours = now.getHours();
            const minutes = now.getMinutes();
            return `${year}-${month}-${day}_${hours}${minutes}`;
        }


        /**
         * Save a canvas as png
         */
        function savePNG(canvas) {
            const videoCanvas = document.createElement('canvas');
            document.body.append(videoCanvas);
            const videoContext = videoCanvas.getContext('2d');
            videoContext.drawImage(canvas, 0, 0);
            const capturedImage = videoCanvas.toDataURL();

            const data = canvas.toDataURL('image/png');

            // Create an anchor, and set the href value to our data URL
            const link = document.createElement('a');
            link.href = data;

            link.download = `system-view-${timestamp()}`;

            link.click();
            link.remove();
            videoCanvas.remove();
        }


        /**
         * Create matrix control.
         */
        function projectionControl() {
            const fov = document.getElementById('field-of-view');
            fov.value = app.initial.fov;
            const near = document.getElementById('near');
            near.value = app.initial.near;
            const far = document.getElementById('far');
            far.value = app.initial.far;

            const update = () => {
                app.fov = fov.valueAsNumber;
                app.near = near.valueAsNumber;
                app.far = far.valueAsNumber;
                app.aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;

                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            }
            fov.addEventListener('change', (event) => update());
            near.addEventListener('change', (event) => update());
            far.addEventListener('change', (event) => update());
            update();
        }

        /**
         * Get view vectors
         */
        function viewVectors() {
            const viewVector = subtract(app.camera.lookAt, app.camera.position);
            const distance = Math.hypot(...viewVector);
            const zAxis = normalised(viewVector);
            const xAxis = normalised(cross(zAxis, app.camera.up));
            const yAxis = normalised(cross(xAxis, zAxis));
            return { xAxis, yAxis, zAxis, distance };
        }

        /**
         * Add Light controls
         */
        function addLightControls() {
            app.lightPosition1 = [0.5, 0.5, 0.5];
            app.lightColour1 = [1, 1, 1];
            app.lightPosition2 = [5, 5, 20];
            app.lightColour2 = [10, 10, 10];
            app.lightPosition3 = [-50, 50, -50];
            app.lightColour3 = [1, 1, 1];

            const container = document.getElementById('top-right');

            const addControls = (light) => {
                const details = document.createElement('details');
                details.style.backgroundColor = 'white';
                details.innerHTML = `<summary>${light.name}</summary><div></div>`;
                const container = details.lastElementChild;
                const x = document.createElement('input');
                x.type = 'range';
                x.min = light.directional ? -1 : -30;
                x.max = light.directional ? 1 : 30;
                x.step = light.directional ? 0.1 : 1;
                x.value = light.position[0];
                x.addEventListener('input', (event) => light.position[0] = x.valueAsNumber);
                const y = document.createElement('input');
                y.type = 'range';
                y.min = light.directional ? -1 : -30;
                y.max = light.directional ? 1 : 30;
                y.step = light.directional ? 0.1 : 1;
                y.value = light.position[1];
                y.addEventListener('input', (event) => light.position[1] = y.valueAsNumber);
                const z = document.createElement('input');
                z.type = 'range';
                z.min = light.directional ? -1 : -30;
                z.max = light.directional ? 1 : 30;
                z.step = light.directional ? 0.1 : 1;
                z.value = light.position[2];
                z.addEventListener('input', (event) => light.position[2] = z.valueAsNumber);
                container.append(x, document.createElement('br'), y, document.createElement('br'), z);
                return details;
            }

            container.append(addControls({ name: 'Light 1 (directional)', directional: true, position: app.lightPosition1, colour: app.lightColour1 }));
            container.append(addControls({ name: 'Light 2 (point)', position: app.lightPosition2, colour: app.lightColour2 }));
            container.append(addControls({ name: 'Light 3 (point)', position: app.lightPosition3, colour: app.lightColour3 }));
        }



        /**
         * Move Forward.
         */
        function forward(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const offset = scale(zAxis, amount * distance / 10);
            moveCamera(add(app.camera.position, offset), sum(app.camera.lookAt, offset), app.camera.up);
            canvas.focus();

        }

        /**
         * Move right.
         */
        function right(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const offset = scale(xAxis, amount * distance / 10);
            moveCamera(add(app.camera.position, offset), sum(app.camera.lookAt, offset), app.camera.up);
            canvas.focus();

        }

        /**
         * Move up.
         */
        function up(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const offset = scale(yAxis, amount * distance / 10);
            moveCamera(add(app.camera.position, offset), sum(app.camera.lookAt, offset), app.camera.up);
            canvas.focus();
        }

        /**
         * Roll clockwise.
         */
        function clockwise(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const rotation = getRotation(-amount * 15, zAxis);
            const roll = applyTransform(yAxis, rotation);
            moveCamera(app.camera.position, app.camera.lookAt, roll);
            canvas.focus();

        }

        /**
         * Rotate right
         */
        function rotateRight(amount = 1) {
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const direction = subtract(app.camera.lookAt, app.camera.position);
            const rotation = getRotation(-amount * 15, yAxis);
            const newDirection = applyTransform(direction, rotation);
            moveCamera(app.camera.position, sum(app.camera.position, newDirection), app.camera.up);
        }

        /**
         * Get a unique name for a new block
         */
        function getUniqueName(base = 'block') {
            let index = 1;
            let name = `${base} ${index++}`;
            while (app.boxes.find((box) => box.name === name)) {
                name = `${base} ${index++}`;
            }
            return name
        }

        /**
         * Add a new block
         */
        function newBlock(offset) {
            const selected = app.boxes.filter((box) => box.selected);
            if (selected.length) {

            } else {
                const scale = Math.hypot(...subtract(app.camera.lookAt, app.camera.position)) / 10;
                const definition = {
                    [meta]: { name: [getUniqueName()] },
                    [content]: [],
                    position: [0, 0, 0],    // Position
                    size: scale,
                }

                const box = Box.make(null, definition);
                app.boxes.push(box);
                app.roots.push(box);
            }
            initialiseBoxes()
            app.colourUpdate = true;
            updateText();
            showStructure();
        }

        /**
         * Add a block next to the current block
         */
        function addBlocks(offset) {
            const selected = app.boxes.filter((box) => box.selected);
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            selected.forEach((selected) => {
                offset = applyTransform(offset, selected.rotation);
                const position = sum(selected.position, product(selected.size, offset));
                const name = getUniqueName(selected[meta].name[0].replace(/\s*[0-9]+/, ''));
                const attributes = {
                    [meta]: { name: [name] },
                    position,
                    size: [...selected.size],
                    angle: selected.angle,
                    axis: [...selected.axis],
                    colour: [...selected.colour],
                    opacity: selected.opacity,
                    specular: selected.specular,
                };
                if (selected.parent) {
                    const newBox = Box.make(selected.parent, attributes);
                    app.boxes.push(newBox);
                    selected.parent.push(newBox);
                    newBox.selected = true;
                } else {
                    const newBox = Box.make(null, ...attributes);
                    app.boxes.push(newBox);
                    app.roots.push(newBox);
                    newBox.selected = true;
                }
                selected.selected = false;
            });
            initialiseBoxes();
            app.colourUpdate = true;
            updateText();
            showStructure();
        }

        /**
         * Add a block next to the current block
         */
        function deleteBlocks(offset) {
            const selected = app.boxes.filter((instance) => instance.selected);
            selected.forEach((selected) => {
                selected.delete();
            });
            app.boxes = app.boxes.filter((instance) => !selected.includes(instance));
            initialiseBoxes()
            app.colourUpdate = true;
            updateText();
            showStructure();
        }

        /**
         * Move the camera to a new position
         */
        function setView(direction = [0, 0, 1], up = [0, 1, 0]) {
            // Use the initial position to determine the desired distance from viewpoint
            const selected = app.boxes.filter((box) => box.selected);

            if (selected.length) {
                selected.forEach((box) => box.setWorldPosition());
                const lookAt = scale(add(...selected.map((box) => box.transforms.translation)), 1 / selected.length);
                const size = Math.max(...selected.map((box) => Math.hypot(...subtract(add(box.transforms.translation, box.size), lookAt))));
                const dist = size / Math.tan(180 * app.fov / Math.PI);
                const position = sum(lookAt, scale(direction, dist));
                moveCamera(position, lookAt, up);
            } else {
                const lookAt = app.initial.lookAt;
                const viewVector = subtract(app.initial.lookAt, app.initial.position);
                const dist = Math.hypot(...viewVector);
                const offset = scale(direction, dist);
                const position = sum(lookAt, offset);
                moveCamera(position, lookAt, up);
            }

        }

        /**
         * Rotate the camera to a new position
         */
        function upright() {
            // Get the current directions and distance to view point.
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            const newX = cross([0, 1, 0], zAxis);
            const up = cross(zAxis, newX);
            moveCamera(app.camera.position, app.camera.lookAt, up);
        }

        /**
         * Move the camera based on the updated position, lookAt and 'up' vectors
         */
        function moveCamera(position, lookAt, up) {
            // Get the current directions and distance to view point.
            const { xAxis, yAxis, zAxis, distance } = viewVectors();

            const direction = subtract(lookAt, position);
            const endDistance = Math.hypot(...direction);
            app.movement = {
                state: 'start',
                start: null,
                duration: 1000,
                lookAt: {
                    start: app.camera.lookAt,
                    delta: subtract(lookAt, app.camera.lookAt),
                },
                distance: {
                    start: distance,
                    delta: endDistance - distance,
                },
                direction: scale(zAxis, -1),
            };

            // Calculate the axis and angle from the cross product of the view directions
            const axis = cross(zAxis, normalised(direction));
            const opposite = Math.sign(dot(zAxis, direction)) || 1;
            const deg = -180 * Math.asin(Math.hypot(...axis)) / Math.PI;
            // Allow for angles greater than 90 degrees
            const angle = opposite < 0 ? 180 + deg : deg;
            if (Math.abs(angle) < 0.001) {
                axis[1] = 1;
            }
            app.movement.rotation = { angle, axis: normalised(scale(axis, opposite)), };
            const rotation = getRotation(app.movement.rotation.angle, app.movement.rotation.axis);
            const endUp = applyTransform(yAxis, rotation);
            const x1 = normalised(cross(up, direction));
            const x2 = normalised(cross(endUp, direction));
            // Calculate the axis and angle from the cross product of the view directions
            const rollAxis = cross(x1, x2);
            const accute = dot(x1, x2) || 1;
            const sign = Math.sign(dot(rollAxis, direction));
            const roll1 = -180 * sign * Math.asin(Math.hypot(...rollAxis)) / Math.PI;
            const roll = accute < 0 ? -180 - roll1 : roll1;
            // Check for 180 degree rotation
            if (Math.abs(roll) < 0.1 && dot(endUp, up) < 0) {
                app.movement.roll = 180;
            } else {
                app.movement.roll = roll;
            }
            app.movement.up = yAxis;
            app.movement.timing = (input) => 0.5 - 0.5 * Math.cos(input * Math.PI);
        }

        /**
         * Reset the view and clear the points
         */
        function reset() {
            moveCamera(app.initial.position, app.initial.lookAt, app.initial.up);

            app.fov = app.initial.fov;
            app.near = app.initial.near;
            app.far = app.initial.far;
            app.aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;

            app.points = [];
        }

        /**
         * Add actions for the movement controls
         */
        function addMovementControls() {
            document.getElementById('anti-clockwise').addEventListener('click', (event) => clockwise(-1));
            document.getElementById('move-up').addEventListener('click', (event) => up());
            document.getElementById('clockwise').addEventListener('click', (event) => clockwise());

            document.getElementById('move-left').addEventListener('click', (event) => right(-1));
            document.getElementById('clear').addEventListener('click', (event) => reset());
            document.getElementById('move-right').addEventListener('click', (event) => right());

            document.getElementById('move-forward').addEventListener('click', (event) => forward());
            document.getElementById('move-down').addEventListener('click', (event) => up(-1));
            document.getElementById('move-backwards').addEventListener('click', (event) => forward(-1));
        }

        /**
         * Create matrix control.
         */
        function viewControl() {
            const container = document.getElementById('view-vectors');

            const update = () => {
                const { xAxis, yAxis, zAxis, distance } = viewVectors();
                app.camera.up = yAxis; // Ensure 'up' is perpendicular to look direction
                app.viewMatrix = viewMatrix(app.camera.position, app.camera.lookAt, app.camera.up);
            }

            const vectorControl = (attribute, name) => {
                app.camera[attribute].forEach((value, index) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = value;
                    input.id = `${name}-${index}`;
                    input.classList.add('matrix-input');
                    input.addEventListener('input', (event) => {
                        app.camera[attribute][index] = input.valueAsNumber;
                        update();
                    });
                    input.addEventListener('focus', (event) => app.editingViewControls = true);
                    input.addEventListener('blur', (event) => app.editingViewControls = false);
                    container.appendChild(input);
                });
            };
            app.camera.position = [0, 0, 15];
            app.camera.lookAt = [0, 0, 0];
            app.camera.up = [0, 1, 0];
            viewVectors();
            vectorControl('position', 'camera-position')
            vectorControl('lookAt', 'look-at');
            vectorControl('up', 'up');
            update();
            app.camera.updateViewControls = () => {
                if (!app.editingViewControls) {
                    document.getElementById('camera-position-0').value = app.camera.position[0].toFixed(1);
                    document.getElementById('camera-position-1').value = app.camera.position[1].toFixed(1);
                    document.getElementById('camera-position-2').value = app.camera.position[2].toFixed(1);

                    document.getElementById('look-at-0').value = app.camera.lookAt[0].toFixed(1);
                    document.getElementById('look-at-1').value = app.camera.lookAt[1].toFixed(1);
                    document.getElementById('look-at-2').value = app.camera.lookAt[2].toFixed(1);

                    document.getElementById('up-0').value = app.camera.up[0].toFixed(2);
                    document.getElementById('up-1').value = app.camera.up[1].toFixed(2);
                    document.getElementById('up-2').value = app.camera.up[2].toFixed(2);
                }
            }
        }

        /**
         * This script manages a single gl context so intialise here for simplicity.
         */
        const canvas = document.getElementById('main-canvas');
        const gl = canvas.getContext('webgl2');

        /**
         * Utility function to parse and report errors
         */
        function glErrors(context = '') {
            const err = gl.getError();

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.trace();
                console.log(context, errors[err]);
            }
        }

        /**
         * App object to minimise global namespace polution.
         */
        const app = {
            mode: 'view',
            camera: {
                position: [0, 0, 15],
                lookAt: [0, 0, 0],
                up: [0, 1, 0],
            },
            initial: {
                position: [0, 0, 15],
                lookAt: [0, 0, 0],
                up: [0, 1, 0],
                fov: 30,
                aspect: gl.canvas.clientWidth / gl.canvas.clientHeight,
                near: 1,
                far: 10000,
            },
            movement: {},
            projectionMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            viewMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            boxes: [],
            cylinders: [],
            quads: [],
            objs: [],
            stock: {},
            nodes: [],
            points: [],
            connections: [],
            text: [],
            roots: [],
            wireframe: false,
            cullFaces: true,
            cornerOrigin: true,
            velocity: [0, 0, 0],
            rotation: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        };

        const shaderSource = {
            vertex: document.querySelector("#vertex-shader").innerHTML,
            fragment: document.querySelector("#fragment-shader").innerHTML,
        }
        const textShaderSource = {
            vertex: document.querySelector("#text-vertex-shader").innerHTML,
            fragment: document.querySelector("#text-fragment-shader").innerHTML,
        }
        const pbrShaderSource = {
            vertex: document.querySelector("#pbr-vertex-shader").innerHTML,
            fragment: document.querySelector("#pbr-fragment-shader").innerHTML,
        }

        /**
         * Create and compile a shader of the specified type using the source provided.
         */
        function makeShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source.trim());
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return;
            }
            return shader;
        }

        /**
         * Compile shaders into a program.
         */
        function makeProgram(source, attributes = [], uniforms = []) {
            const vertex = makeShader(gl.VERTEX_SHADER, source.vertex);
            const fragment = makeShader(gl.FRAGMENT_SHADER, source.fragment);

            // Create a program instance for the shaders
            if (vertex && fragment) {
                const shader = {
                    program: gl.createProgram(),
                };
                gl.attachShader(shader.program, vertex);
                gl.attachShader(shader.program, fragment);
                gl.linkProgram(shader.program);

                // See if it linked successfully
                if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
                    alert('Unable to initialise the shader program: ' + gl.getProgramInfoLog(shader.program));
                    return null;
                }

                uniforms.forEach((uniform) => shader[uniform] = gl.getUniformLocation(shader.program, uniform));
                attributes.forEach((attribute) => shader[attribute] = gl.getAttribLocation(shader.program, attribute));

                return shader;
            }
        }

        /**
         * Generate the vertex data for a quad.
         */
        function makeQuad() {
            const positions = [
                [-1, -1, 0,],
                [1, -1, 0,],
                [-1, 1, 0,],
                [1, 1, 0,],
            ].map((v) => v.map((i) => i / 2));

            /*
            *       4 ------ 5
            *      /|        | \
            *    0 ------------ 1
            *    |  |        |  |
            *    |  |        |  |
            *    |  |        |  |
            *    |  6 ------ 7  |
            *    | /          \ |
            *    2 ------------ 3
            */

            const triangles = [
                { p1: positions[0], p2: positions[1], p3: positions[2], n: [0, 0, 1] },
                { p1: positions[1], p2: positions[3], p3: positions[2], n: [0, 0, 1] },
            ];
            const lines = [
                positions[0], positions[1],
                positions[1], positions[3],
                positions[3], positions[2],
                positions[2], positions[0],
            ];
            return [...triangles.flatMap((t) => [...t.p1, ...t.n, ...t.p2, ...t.n, ...t.p3, ...t.n]),
            ...lines.flatMap((p) => [...p, ...normalised(p)])];
        }

        /**
         * Generate the vertex data for a cube.
         */
        function makeCube() {
            const positions = [
                [-1, -1, -1,],
                [1, -1, -1,],
                [-1, 1, -1,],
                [1, 1, -1,],
                [-1, -1, 1,],
                [1, -1, 1,],
                [-1, 1, 1,],
                [1, 1, 1,],
            ].map((v) => v.map((i) => i / 2));
            const normals = [
                [-1, 0, 0,],
                [0, -1, 0,],
                [0, 0, -1,],
                [1, 0, 0,],
                [0, 1, 0,],
                [0, 0, 1,],
            ];

            /*
            *       4 ------ 5
            *      /|        | \
            *    0 ------------ 1
            *    |  |        |  |
            *    |  |        |  |
            *    |  |        |  |
            *    |  6 ------ 7  |
            *    | /          \ |
            *    2 ------------ 3
            */

            const triangles = [
                { p1: positions[0], p2: positions[1], p3: positions[2], n: normals[2] },
                { p1: positions[1], p2: positions[3], p3: positions[2], n: normals[2] },

                { p1: positions[0], p2: positions[4], p3: positions[5], n: normals[1] },
                { p1: positions[5], p2: positions[1], p3: positions[0], n: normals[1] },

                { p1: positions[4], p2: positions[6], p3: positions[7], n: normals[5] },
                { p1: positions[5], p2: positions[4], p3: positions[7], n: normals[5] },

                { p1: positions[6], p2: positions[2], p3: positions[3], n: normals[4] },
                { p1: positions[7], p2: positions[6], p3: positions[3], n: normals[4] },

                { p1: positions[3], p2: positions[1], p3: positions[5], n: normals[3] },
                { p1: positions[5], p2: positions[7], p3: positions[3], n: normals[3] },

                { p1: positions[6], p2: positions[4], p3: positions[0], n: normals[0] },
                { p1: positions[6], p2: positions[0], p3: positions[2], n: normals[0] },
            ];
            const lines = [
                positions[0], positions[1],
                positions[1], positions[3],
                positions[3], positions[2],
                positions[2], positions[0],

                positions[0], positions[4],
                positions[1], positions[5],
                positions[2], positions[6],
                positions[3], positions[7],

                positions[4], positions[5],
                positions[5], positions[7],
                positions[7], positions[6],
                positions[6], positions[4],
            ];
            return [...triangles.flatMap((t) => [...t.p1, ...t.n, ...t.p2, ...t.n, ...t.p3, ...t.n]),
            ...lines.flatMap((p) => [...p, ...normalised(p)])];
        }

        /**
         * Generate the vertex data for a cylinder.
         */
        function makeCylinder(sides) {
            const triangles = [];
            for (let i = 0; i < sides; ++i) {
                const angle1 = Math.PI * 2 * i / sides;
                const angle2 = Math.PI * 2 * (i + 1) / sides;
                triangles.push(
                    0, -1, 0, 0, -1, 0,
                    Math.sin(angle1), -1, Math.cos(angle1), 0, -1, 0,
                    Math.sin(angle2), -1, Math.cos(angle2), 0, -1, 0,

                    Math.sin(angle1), -1, Math.cos(angle1), Math.sin(angle1), 0, Math.cos(angle1),
                    Math.sin(angle1), 1, Math.cos(angle1), Math.sin(angle1), 0, Math.cos(angle1),
                    Math.sin(angle2), 1, Math.cos(angle2), Math.sin(angle2), 0, Math.cos(angle2),

                    Math.sin(angle2), 1, Math.cos(angle2), Math.sin(angle2), 0, Math.cos(angle2),
                    Math.sin(angle2), -1, Math.cos(angle2), Math.sin(angle2), 0, Math.cos(angle2),
                    Math.sin(angle1), -1, Math.cos(angle1), Math.sin(angle1), 0, Math.cos(angle1),

                    0, 1, 0, 0, 1, 0,
                    Math.sin(angle1), 1, Math.cos(angle1), 0, 1, 0,
                    Math.sin(angle2), 1, Math.cos(angle2), 0, 1, 0,
                );
            }
            return triangles;
        }

        /**
         * Generate the vertex data for a cylinder.
         */
        function makeOffsetCylinder(sides) {
            const triangles = [];
            for (let i = 0; i < sides; ++i) {
                const angle1 = Math.PI * 2 * i / sides;
                const angle2 = Math.PI * 2 * i / sides;
                const angle3 = Math.PI * 2 * i / sides;
                const angle4 = Math.PI * 2 * i / sides;
                vertices.push([Math.sin(angle), 1, Math.cos(angle)]);
            }
        }


        /**
         * Generate the vertex data for a rectangle.
         */
        function makeBanner() {
            return [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
        }


        /**
         * Tessellate a face into triangles.
         * 
         * This is simple tessellation based on forming triangles from the starting point,
         * it doesn't necessarily generate an optimum tessellation.
         */
        function tessellate(points) {
            const indices = [];

            // Ensure data is of right type
            //points = points.map(v => Vector3d.createFromObject(v));
            const winding = [0, 0, 0];
            const segments = [];

            function det(u, v) {
                return u.x * v.z - u.z * v.x;
            }

            // Return true if point p is inside the triangle with a vertices at V0 
            // and sides defined by D1 and d2
            //
            function inside(v0, d1, d2, p) {
                const a = (det(p, d2) - det(v0, d2)) / det(d1, d2);
                const b = (det(v0, d1) - det(p, d1)) / det(d1, d2);

                return (a > 0) && (b > 0) && (a + b < 1);;
            }


            // Return false if any of the points are within the triangle with a vertices at V0 
            // and sides defined by d1 and d2
            //
            function empty(v0, d1, d2) {
                for (var i = 0; i < points.length; ++i) {
                    if (inside(v0, d1, d2, points[i])) {
                        return false;
                    }
                }
                return true;
            }

            const grads = points.map((v, i, a) => {
                const p = (i + a.length - 1) % a.length;
                const n = (i + 1) % a.length;
                const d1 = subtract(v, a[p]);
                const d2 = subtract(a[n], v);
                const grad = cross(d1, d2);
                add(winding, grad);
                segments.push({
                    start: i,
                    end: n,
                });

                return grad;
            });

            var i = 0;
            var c = 0;
            while (segments.length && c < 1000) {
                const n = (i + 1) % segments.length;
                if (segments[i].end !== segments[n].start) {
                    console.log('error tessellating');
                    break;
                }
                const v = points[segments[i].end];
                const d1 = subtract(v, points[segments[i].start]);
                const d2 = subtract(points[segments[n].end], v);
                const g = cross(d1, d2);
                const sgn = dot(g, winding);

                if (sgn > 0 && empty(v, scale(d1, -1), d2)) {
                    indices.push([segments[i].start, segments[i].end, segments[n].end]);
                    segments[i].end = segments[n].end;
                    segments.splice(n, 1);
                }
                i = (i + 1) % segments.length;
                ++c;
            }

            return { winding, indices }
        }

        /**
         * Load a texture from a url.
         */
        function loadTexture(url) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Because images have to be downloaded over the internet
            // they might take a moment until they are ready.
            // Until then put a single pixel in the texture so we can
            // use it immediately. When the image has finished downloading
            // we'll update the texture with the contents of the image.
            const level = 0;
            const internalFormat = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
            gl.texImage2D(
                gl.TEXTURE_2D,
                level,
                internalFormat,
                width,
                height,
                border,
                srcFormat,
                srcType,
                pixel,
            );

            const image = new Image();
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    level,
                    internalFormat,
                    srcFormat,
                    srcType,
                    image,
                );
                gl.generateMipmap(gl.TEXTURE_2D);
            };
            image.src = url;

            return texture;
        }

        /**
         * Get a texture, loading it if necessary.
         */
        const textures = {};
        function getTexture(url) {
            const texture = textures[url] || loadTexture(url);
            textures[url] = texture;
            return texture;
        }


        /**
         * Material management class
         */
        class Material {
            static makeMaterial() {
                return new Material();
            }
            constructor() {
            }
        }


        /**
         * Process data in wavefront mtl file format.
         */
        function processMtl(text, path) {
            const materials = {};
            const root = path.split(/\//g).slice(0, -1).join('/') + '/';

            let material;
            const lines = text.split(/\r?\n/g);

            const textureOptions = `
-blendu on | off                       # set horizontal texture blending (default on)
-blendv on | off                       # set vertical texture blending (default on)
-boost float_value                     # boost mip-map sharpness
-mm base_value gain_value              # modify texture map values (default 0 1)
                                       #     base_value = brightness, gain_value = contrast
-o u [v [w]]                           # Origin offset             (default 0 0 0)
-s u [v [w]]                           # Scale                     (default 1 1 1)
-t u [v [w]]                           # Turbulence                (default 0 0 0)
-texres resolution                     # texture resolution to create
-clamp on | off                        # only render texels in the clamped 0-1 range (default off)
                                       #   When unclamped, textures are repeated across a surface,
                                       #   when clamped, only texels which fall within the 0-1
                                       #   range are rendered.
-bm mult_value                         # bump multiplier (for bump maps only)

-imfchan r | g | b | m | l | z         # specifies which channel of the file is used to 
                                       # create a scalar or bump texture. r:red, g:green,
                                       # b:blue, m:matte, l:luminance, z:z-depth.. 
                                       # (the default for bump is 'l' and for decal is 'm')`;

            const pbr = `
            Pr/map_Pr     # roughness
Pm/map_Pm     # metallic
Ps/map_Ps     # sheen
Pc            # clearcoat thickness
Pcr           # clearcoat roughness
Ke/map_Ke     # emissive
aniso         # anisotropy
anisor        # anisotropy rotation
norm          # normal map (RGB components represent XYZ components of the surface normal)`;


            lines.forEach((line, i) => {
                const trimmed = line.replace(/#.*/, '').trim();
                const [command, ...value] = trimmed.split(/\s+/g);

                if (command === 'newmtl') {
                    material = {};
                    materials[value] = material;
                } else if (command === 'Ka') {
                    material.ambientColour = value.map((value) => parseFloat(value));
                } else if (command === 'Kd') {
                    material.diffuseColour = value.map((value) => parseFloat(value));
                } else if (command === 'Ks') {
                    material.specularColour = value.map((value) => parseFloat(value));
                } else if (command === 'Ns') {
                    material.specularExponent = parseFloat(value[0]);
                } else if (command === 'd') {
                    material.opacity = parseFloat(value[0]);
                } else if (command === 'Tr') {
                    material.opacity = 1 - parseFloat(value[0]);
                } else if (command === 'Tf') {
                    material.transmissionFilter = value.map((value) => parseFloat(value));
                } else if (command === 'Ni') {
                    material.refractiveIndex = parseFloat(value[0]);
                } else if (command === 'illum') {
                    material.illuminationModel = [
                        'Color on and Ambient off',
                        'Color on and Ambient on',
                        'Highlight on',
                        'Reflection on and Ray trace on',
                        'Transparency: Glass on, Reflection: Ray trace on',
                        'Reflection: Fresnel on and Ray trace on',
                        'Transparency: Refraction on, Reflection: Fresnel off and Ray trace on',
                        'Transparency: Refraction on, Reflection: Fresnel on and Ray trace on',
                        'Reflection on and Ray trace off',
                        'Transparency: Glass on, Reflection: Ray trace off',
                        'Casts shadows onto invisible surfaces'][parseFloat(value[0])];
                } else if (command === 'map_Ka') {
                    material.ambientTexture = loadTexture(root + value[0]);
                } else if (command === 'map_Kd') {
                    material.diffuseTexture = loadTexture(root + value[0]);
                } else if (command === 'map_Ks') {
                    material.specularTexture = loadTexture(root + value[0]);
                } else if (command === 'map_Ns') {
                    material.specularTexture = loadTexture(root + value[0]);
                } else if (command === 'map_d') {
                    material.specularTexture = loadTexture(root + value[0]);
                } else if (command === 'map_bump') {
                    material.specularTexture = loadTexture(root + value[0]);
                } else if (command === 'bump') {
                } else if (command === 'disp') {
                    material.displacementTexture = loadTexture(root + value[0]);
                } else if (command === 'deca') {
                    material.stencilTexture = loadTexture(root + value[0]);

                }
            });

            return materials;
        }

        /**
         * Load materials from a wavefront mtl file.
         */
        async function loadMaterials(url) {
            const response = await fetch(url);
            if (response.ok) {
                const content = await response.text();
                return processMtl(content, url);
            }
        }


        /**
         * Process data in wavefront obj file format.
         */
        async function processOBJ(text, path, obj) {
            const positions = [];
            const normals = [];
            const texture = [];
            const parameters = [];
            const colours = [];
            const polyLines = [];
            const materials = {
                initial: {
                    ambientColour: [1, 1, 0],
                    diffuseColour: [0.2, 0.2, 0.2],
                    specularColour: [0.5, 1, 1],
                    specularExponent: [1, 1, 0],
                    opacity: [1, 1, 0],
                }
            }

            const promisedMaterials = [];
            let materialName;
            // A patch represents a group of faces in the same material.
            let faces = [];
            const patches = { initial: { faces } };

            const lines = text.split(/\r?\n/g);
            lines.map(async (line, i) => {
                const trimmed = line.replace(/#.*/, '').trim();
                const [command, ...stringValues] = trimmed.split(/\s+/g);
                const values = stringValues.map((str) => parseFloat(str));
                if (command === 'vn') {
                    const start = values.length;
                    values.length = 3;
                    normals.push(normalised(values.fill(0, start)));
                } else if (command === 'vt') {
                    texture.push(values);
                } else if (command === 'vp') {
                    parameters.push(value);
                } else if (command === 'v') {
                    if (values.length > 4) {
                        const colour = values.slice(4);
                        positions.push(values.slice(0, 3));
                        colour.length = 3;
                        colours.push(colour.fill(0, start))
                    } else if (values.length === 4) {
                        positions.push(values.slice(0, 3).map((v) => v / values[3]));
                    } else {
                        const start = values.length;
                        values.length = 3;
                        positions.push(values.fill(0, start));
                    }
                } else if (command === 'f') {
                    faces.push(stringValues.map((string) => {
                        const values = string.split(/\//).map((str) => parseInt(str));

                        return {
                            positionIndex: values[0] < 0 ? positions.length - values[0] : values[0] - 1,
                            textureIndex: values[1] < 0 ? texture.length - values[1] : values[1] - 1,
                            normalIndex: values[2] < 0 ? normals.length - values[2] : values[2] - 1
                        };
                    }));
                } else if (command === 'o') {
                } else if (command === 'g') {
                } else if (command === 'mtllib') {
                    const root = path.split(/\//g).slice(0, -1).join('/') + '/';
                    promisedMaterials.push(loadMaterials(root + stringValues[0].replace(/\^.\//, '')));
                } else if (command === 'usemtl') {
                    materialName = stringValues[0];
                    const patch = patches[materialName] || { faces: [] };
                    faces = patch.faces;
                    patches[materialName] = patch;
                }
                if ((i % 1000) === 0) {
                    console.log(i);
                }
            });

            await Promise.all(promisedMaterials).then((values) =>
                values.forEach((value) => Object.assign(materials, value)));

            const buffers = {
                vertex: gl.createBuffer(),
                instances: gl.createBuffer(),
            };
            const vertexData = [];

            Object.entries(patches).slice(1).forEach(([materialName, patch]) => {
                let len = patch.faces.length;
                const triangles = patch.faces.flatMap((face, i) => {
                    /*
                    if ((i % 1000) === 0) {
                        console.log(`${(100 * i / len).toFixed(2)}% ${i} / ${len}`);
                    }
                        */

                    if (face.length === 3) {
                        return [face];
                    } else if (face.length === 4) {
                        return [[face[0], face[1], face[2]], [face[2], face[3], face[0]]];
                    }

                    const points = face.map((vertex) => positions[vertex.positionIndex]);
                    const tessellation = tessellate(points);
                    return tessellation.indices.map((triangle) => triangle.map((index) => face[index]));
                });
                patch.offset = vertexData.length / 6;
                for (const triangle of triangles) {
                    vertexData.push(...positions[triangle[0].positionIndex], ...normals[triangle[0].normalIndex]);
                    vertexData.push(...positions[triangle[1].positionIndex], ...normals[triangle[1].normalIndex]);
                    vertexData.push(...positions[triangle[2].positionIndex], ...normals[triangle[2].normalIndex]);
                }

                patch.points = triangles.length * 3;

                patch.objBuffer = gl.createVertexArray();
                gl.bindVertexArray(patch.objBuffer);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);

                // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
                gl.vertexAttribPointer(app.pbrShader.position, 3, gl.FLOAT, false, 24, 0);
                gl.enableVertexAttribArray(app.pbrShader.position);

                gl.vertexAttribPointer(app.pbrShader.normal, 3, gl.FLOAT, false, 24, 12);
                gl.enableVertexAttribArray(app.pbrShader.normal);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.instances);

                const matrix = identityMatrix();
                matrix.push(1, 0, 0, 0, 1, 0, 0, 0, 1);
                // Matrices are passed as 4 vertex attributes
                for (let j = 0; j < 10; ++j) {
                    matrix[14] = j * 2;
                    for (let i = 0; i < 4; ++i) {
                        const location = app.pbrShader.model + i;
                        // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                        gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * (16 + 12), i * 16);
                        gl.vertexAttribDivisor(location, 1);
                        gl.enableVertexAttribArray(location);
                    }
                    for (let i = 0; i < 3; ++i) {
                        const location = app.pbrShader.normalMatrix + i;
                        // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                        gl.vertexAttribPointer(location, 3, gl.FLOAT, false, 4 * (16 + 12), i * 12);
                        gl.vertexAttribDivisor(location, 1);
                        gl.enableVertexAttribArray(location);
                    }
                }
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(matrix), gl.DYNAMIC_DRAW);

                patch.material = materials[materialName];

                /*
                    gl.disableVertexAttribArray(app.shader.ambientColour);
                    //gl.vertexAttrib3f(app.shader.ambientColour, ...scale(patch.material.ambientColour, 0.1));
                    gl.vertexAttrib3f(app.shader.ambientColour, ...patch.material.diffuseColour);


                    gl.disableVertexAttribArray(app.shader.diffuseColour);
                    gl.vertexAttrib3f(app.shader.diffuseColour, ...patch.material.diffuseColour);

                    gl.disableVertexAttribArray(app.shader.specularColour);
                    gl.vertexAttrib3f(app.shader.specularColour, ...patch.material.specularColour);

                    gl.disableVertexAttribArray(app.shader.specularIntensity);
                    gl.vertexAttrib1f(app.shader.specularIntensity, patch.material.specularExponent ?? 20);

                    gl.disableVertexAttribArray(app.shader.opacity);
                    gl.vertexAttrib1f(app.shader.opacity, patch.material.opacity ?? 1);
                    */
            });

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.DYNAMIC_DRAW);

            const segments = Object.values(patches).flatMap((patch) => patch.faces.length ? patch : []);
            obj.instances = 1;
            obj.render = function () {
                return segments.forEach((patch) => {
                    gl.bindVertexArray(patch.objBuffer);

                    gl.disableVertexAttribArray(app.pbrShader.colour);
                    gl.vertexAttrib3f(app.pbrShader.colour, ...patch.material.colour ?? [0.8, 0.1, 0.7]);

                    gl.disableVertexAttribArray(app.pbrShader.emissivityColour);
                    gl.vertexAttrib3f(app.pbrShader.emissivityColour, ...patch.material.emissivityColour ?? [0, 0, 0]);

                    gl.disableVertexAttribArray(app.pbrShader.roughness);
                    gl.vertexAttrib1f(app.pbrShader.roughness, patch.material.roughness ?? 0.5);

                    gl.disableVertexAttribArray(app.pbrShader.reflectivity);
                    gl.vertexAttrib3f(app.pbrShader.reflectivity, ...patch.material.reflectivity ?? [0.04, 0.04, 0.04]);

                    gl.disableVertexAttribArray(app.pbrShader.opacity);
                    gl.vertexAttrib1f(app.pbrShader.opacity, patch.material.opacity ?? 1);

                    gl.disableVertexAttribArray(app.pbrShader.metallic);
                    gl.vertexAttrib1f(app.pbrShader.metallic, patch.material.metallic ?? 0);

                    gl.drawArraysInstanced(gl.TRIANGLES, patch.offset, patch.points, this.instances);
                })
            };
            obj.scale = (scale) => {
                const transform = [
                    scale[0], 0, 0, 0,
                    0, scale[1], 0, 0,
                    0, 0, scale[2], 0,
                    0, 0, 0, 1
                ]
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.instances);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(transform), gl.DYNAMIC_DRAW);
            }
        }

        /**
         * Load data from a wavefront obj file
         */
        async function loadOBJ(url) {
            const size = [1, 1, 1];
            const obj = { scale(...scale) { size.push(...scale) }, render() { }, };
            const response = await fetch(url);
            if (response.ok) {
                const content = await response.text();
                Object.assign(obj, processOBJ(content, url, obj));
                obj.scale(size);
            }
            app.objs.push(obj);
        }

        /**
         * Update the gl buffers used to define the base object used for instancing.
         */
        function updateObject() {

        }

        /**
         * Initialise Boxes
         */
        function initialiseBoxes() {
            const matrices = [];
            const reversed = app.boxes.filter((box) => !box.hidden).toReversed();
            reversed.forEach((box) => matrices.push(...box.transform));

            app.modelMatrix = new Float32Array(matrices); // 4 bytes per float, 16 floats per matrix
            reversed.forEach((box, index) =>
                box.matrix = new Float32Array(app.modelMatrix.buffer, index * 16 * 4, 16));

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.boxes);
            gl.bufferData(gl.ARRAY_BUFFER, app.modelMatrix.byteLength, gl.DYNAMIC_DRAW);

            app.colourUpdate = true;

            app.boxesChanged = true;
            app.boxCount = reversed.length;
        }

        /**
         * Initialise Cylinders
         */
        function initialiseCylinders() {
            const matrices = [];
            const reversed = app.cylinders.filter((cylinder) => !cylinder.hidden).toReversed();
            reversed.forEach((cylinder) => matrices.push(...cylinder.transform));

            app.cylinderData = new Float32Array(matrices); // 4 bytes per float, 16 floats per matrix
            reversed.forEach((cylinder, index) =>
                cylinder.matrix = new Float32Array(app.cylinderData.buffer, index * 16 * 4, 16));

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.cylinders);
            gl.bufferData(gl.ARRAY_BUFFER, app.cylinderData, gl.DYNAMIC_DRAW);

            app.colourUpdate = true;

            app.cylindersChanged = true;
            app.cylinderCount = reversed.length;
        }

        /**
         * Initialise Quads
         */
        function initialiseQuads() {
            const matrices = [];
            const quads = app.quads.filter((quad) => !quad.hidden);
            quads.forEach((quad) => matrices.push(...quad.transform));

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.quads);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(matrices), gl.DYNAMIC_DRAW);

            app.colourUpdate = true;
            app.quadsChanged = true;
        }

        /**
         * Update the colour data for the instances.
         */
        function updateColours() {
            const colourBuffer = [];
            const setTransparency = (box) => {
                box.state.transparent = box.content.reduce((result, box) => result || (setSelected(box)), 1);
                return box.state.transparent || box.selected;
            }
            app.roots.forEach((box) => setTransparency(box));
            app.boxes.filter((box) => !box.hidden).toReversed().forEach((box, index) => {
                if (box.state.ghost) {
                    colourBuffer.push(0.3, 0.3, 0.3);
                    colourBuffer.push(0.3, 0.3, 0.3);
                    colourBuffer.push(0.1, 0.1, 0.1);
                    colourBuffer.push(box.specular);
                    colourBuffer.push(0.05);
                } else if (box.state.set) {
                    colourBuffer.push(0.3, 0.0, 0.0);
                    colourBuffer.push(0.3, 0.0, 0.0);
                    colourBuffer.push(0.1, 0.0, 0.0);
                    colourBuffer.push(box.specular);
                    colourBuffer.push(0.1);
                } else if (box.state.constraint) {
                    colourBuffer.push(0.3, 1.0, 0.3);
                    colourBuffer.push(0.3, 1.0, 0.3);
                    colourBuffer.push(0.1, 1.0, 0.1);
                    colourBuffer.push(box.specular);
                    colourBuffer.push(0.1);
                } else if (box.state.hit) {
                    colourBuffer.push(1.0, 0.0, 0.0);
                    colourBuffer.push(1.0, 0.0, 0.0);
                    colourBuffer.push(1.0, 0.0, 0.0);
                    colourBuffer.push(box.specular);
                    colourBuffer.push(1.0);
                } else {
                    const colour = box.selected ? [1, 1, 1] : (box.statusColour ?? box.colour);
                    colourBuffer.push(...colour.map((v) => v * 0.3));
                    colourBuffer.push(...colour.map((v) => v * 0.3));
                    colourBuffer.push(...colour.map((v) => v * 1.0));
                    colourBuffer.push(box.specular);
                    const opacity = ((app.solid && !box.state.transparent) || box.state.moving) ? 1 : app.wireframe ? 0.1 : box.content.length > 0 ? 0.5 : 1;
                    colourBuffer.push(opacity);
                }
            });
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colourBuffer), gl.STATIC_DRAW);
        }

        /**
         * Update the point data.
         */
        function updatePoints() {
            const points = app.points.flatMap((point) => [...point.position, 1, 1, 1]);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.DYNAMIC_DRAW);
        }

        /**
         * Initialise the text data
         */
        function initialiseText() {
            gl.useProgram(app.textShader.program);
            app.textVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.textVertexArray);

            const shape = makeBanner();
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textInstance);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);

            gl.vertexAttribPointer(app.textShader.offset, 2, gl.FLOAT, false, 4 * 2, 0);
            gl.enableVertexAttribArray(app.textShader.offset);

            const stride = 4 * (3 + 2 + 2 + 2 + 4 + 16);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textItems);

            gl.vertexAttribPointer(app.textShader.position, 3, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(app.textShader.position);
            gl.vertexAttribDivisor(app.textShader.position, 1);

            gl.vertexAttribPointer(app.textShader.size, 2, gl.FLOAT, false, stride, 4 * 3);
            gl.enableVertexAttribArray(app.textShader.size);
            gl.vertexAttribDivisor(app.textShader.size, 1);

            gl.vertexAttribPointer(app.textShader.textureSize, 2, gl.FLOAT, false, stride, 4 * (3 + 2));
            gl.enableVertexAttribArray(app.textShader.textureSize);
            gl.vertexAttribDivisor(app.textShader.textureSize, 1);

            gl.vertexAttribPointer(app.textShader.textureOrigin, 2, gl.FLOAT, false, stride, 4 * (3 + 2 + 2));
            gl.enableVertexAttribArray(app.textShader.textureOrigin);
            gl.vertexAttribDivisor(app.textShader.textureOrigin, 1);

            gl.vertexAttribPointer(app.textShader.colour, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2));
            gl.enableVertexAttribArray(app.textShader.colour);
            gl.vertexAttribDivisor(app.textShader.colour, 1);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.textShader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2 + 4 + i * 4));
                gl.enableVertexAttribArray(location);
                gl.vertexAttribDivisor(location, 1);
            }
        }

        /**
         * Initialise a texture and copy an image from the specified canvas.
         */
        function copyTexture(canvas) {
            app.textTexture = app.textTexture ?? gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, app.textTexture);

            // target, level, internalFormat, srcFormat, srcType, source
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);

            glErrors(gl, 'Load Texture');
        }

        /**
         * Update text data
         */
        function updateText() {
            const width = 2048;
            if (!app.textureCanvas) {
                app.textureCanvas = document.createElement('canvas');
                app.textureCanvas.classList.add('texture-canvas', 'hide');
                document.body.appendChild(app.textureCanvas);
            }
            const context = app.textureCanvas.getContext('2d');
            app.textureCanvas.width = width;
            app.textureCanvas.height = 2048;

            context.fillStyle = 'white';
            context.font = '24px sans-serif';
            context.textBaseline = 'hanging';

            let x = y = 0;
            let lineHeight = 0;

            // Create dictionary of all labels
            const labels = new Set(app.boxes.map((box) => box.name));

            // Determine size of canvas required
            labels.forEach((label) => {
                const metrics = context.measureText(label);
                const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                if (x + metrics.width + (fontHeight * 2) > width) {
                    x = 0;
                    y += lineHeight;
                    lineHeight = 0;
                }
                x += metrics.width + (fontHeight * 2);
                lineHeight = Math.max(lineHeight, fontHeight);
            });

            if (y + lineHeight > context.height) {
                context.height = app.textureCanvas.height = y + lineHeight;
                context.clearRect(0, 0, app.textureCanvas.width, app.textureCanvas.height);

                context.fillStyle = 'white';
                context.font = '24px sans-serif';

                context.textBaseline = 'hanging';
            }

            context.clearRect(0, 0, app.textureCanvas.width, app.textureCanvas.height);

            lineHeight = x = y = 0;
            app.text = {};
            labels.forEach((label) => {
                const metrics = context.measureText(label);

                const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;

                if (x + metrics.width + (fontHeight * 2) > width) {
                    x = 0;
                    y += lineHeight;
                    lineHeight = 0;
                }
                const radius = fontHeight / 2;
                const textureOrigin = [x, y];
                context.fillStyle = 'rgb(0, 0, 80, 0.9)';
                context.beginPath();
                context.moveTo(x + radius, y);
                context.lineTo(x + radius + metrics.width, y);

                context.arcTo(x + radius * 2 + metrics.width, y, x + radius * 2 + metrics.width, y + radius, radius);
                context.arcTo(x + radius * 2 + metrics.width, y + fontHeight, x + radius + metrics.width, y + fontHeight, radius);

                context.lineTo(x + radius + metrics.width, y + fontHeight);
                context.lineTo(x + radius, y + fontHeight);

                context.arcTo(x, y + fontHeight, x, y + radius, radius);
                context.arcTo(x, y, x + radius, y, radius);

                context.fill();

                context.fillStyle = 'white';
                context.fillText(label, x + radius, y + 2);
                x += metrics.width + fontHeight;
                lineHeight = Math.max(lineHeight, fontHeight);

                app.text[label] = {
                    size: [metrics.width + fontHeight, fontHeight],
                    textureOrigin,
                    canvas: app.textureCanvas,
                }
            });

            copyTexture(app.textureCanvas);
            updateTextBuffer();
        }

        /**
         * Update the buffer containing the text instance data.
         */
        function updateTextBuffer() {
            const data = [];
            const visible = app.boxes.filter((box) => !box.hidden);
            const selected = app.showNames ? visible : visible.filter((box) => box.selected);
            if (app.showName && !selected.includes(app.showName)) {
                selected.push(app.showName);
            }
            selected.filter((box) => app.text[box.name])
                .forEach((box) => {
                    const text = app.text[box.name];
                    const position = box.labelPosition ?? [0.0, 0.0, 0.0];
                    const scale = box.labelScale ?? 1;
                    const size = [scale * text.size[0], scale * text.size[1]];
                    const colour = box.labelColour ?? [1, 1, 1, 1];
                    data.push(...position);
                    data.push(size[0] / gl.canvas.clientWidth, size[1] / gl.canvas.clientHeight); // image size
                    data.push(size[0] / text.canvas.width, size[1] / text.canvas.height);  // Texture Size
                    data.push(text.textureOrigin[0] / text.canvas.width, text.textureOrigin[1] / text.canvas.height); // Texture origin
                    data.push(...colour);
                    data.push(...box.origin);
                });
            app.textItemCount = selected.length;
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textItems);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        }

        /**
         * Calculate the product of 2 4 x 4 matrices and store the result in the third.
         */
        function multiply(a, b, matrix) {
            matrix = matrix || Array(16);
            matrix[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
            matrix[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
            matrix[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
            matrix[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

            matrix[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
            matrix[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
            matrix[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
            matrix[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

            matrix[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
            matrix[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
            matrix[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
            matrix[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

            matrix[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
            matrix[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
            matrix[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
            matrix[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
            return matrix;
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateBoxes(time) {
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.boxes);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, app.modelMatrix);
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateLines(time) {
            const vertices = [];
            app.connections.flatMap((connection) => connection.addVertices(vertices));
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.lines);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateQuads(time) {
            const matrices = [];
            const boxes = app.boxes.filter((box) => box.highlight)
            boxes.forEach((box) => matrices.push(...box.transform));
            app.faceCount = boxes.length;

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.quads);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(matrices), gl.DYNAMIC_DRAW);

            //app.colourUpdate = true;
            //app.quadsChanged = true;

        }

        /**
         * Update the object definition and the instances if required.
         */
        function updateBuffers(time) {
            if (app.colourUpdate) {
                updateColours();
                app.updateColours = false;
            }
            if (app.objectChanged) {
                updateObject(time);
            }
            if (app.boxesChanged) {
                updateBoxes(time);
                app.boxesChanged = false;
            }
            updateQuads(time);
            updateLines(time);
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            const f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zNear + zFar) / (zNear - zFar), -1,
                0, 0, 2 * (zFar * zNear) / (zNear - zFar), 0,
            ];
        }

        /**
         * Calculate a view matrix from camera position, focus point and up vecotrs.
         */
        function viewMatrix(cameraPosition, lookAt, up) {
            const negate = (v) => { v[0] *= -1; v[1] *= -1; v[2] *= -1; };
            const zaxis = normalised(subtract(lookAt, cameraPosition));
            const xaxis = normalised(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, cameraPosition), -dot(yaxis, cameraPosition), -dot(zaxis, cameraPosition), 1,
            ];
        }

        /**
         * Set Attribute pointers for drawing boxes.
         */
        function setBoxAttributes() {
            app.boxVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.boxVertexArray);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.normal);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.boxes);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);
        }

        /**
         * Set attribute pointers for drawing cylinders.
         */
        function setCylinderAttributes() {
            app.cylinderVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.cylinderVertexArray);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.normal);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.cylinders);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);
        }

        /**
         * Set Attribute pointers for drawing boxes.
         */
        function setQuadAttributes() {
            app.quadVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.quadVertexArray);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.normal);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.quads);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);
        }

        /**
         * Set Attribute pointers for drawing points.
         */
        function setPointAttributes() {
            app.pointVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.pointVertexArray);

            gl.disableVertexAttribArray(app.shader.normal);
            gl.vertexAttrib3f(app.shader.normal, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.model);
            gl.disableVertexAttribArray(app.shader.model + 1);
            gl.disableVertexAttribArray(app.shader.model + 2);
            gl.disableVertexAttribArray(app.shader.model + 3);
            gl.vertexAttrib4f(app.shader.model, 1, 0, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 1, 0, 1, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 2, 0, 0, 1, 0);
            gl.vertexAttrib4f(app.shader.model + 3, 0, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttrib1f(app.shader.specularIntensity, 1);

            gl.disableVertexAttribArray(app.shader.opacity);
            gl.vertexAttrib1f(app.shader.opacity, 1);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);

            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.ambientColour);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.specularColour);
        }


        /**
         * Set Attribute pointers for drawing boxes.
         */
        function setLineAttributes() {
            app.lineVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.lineVertexArray);

            gl.disableVertexAttribArray(app.shader.normal);
            gl.vertexAttrib3f(app.shader.normal, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.model);
            gl.vertexAttrib4f(app.shader.model, 1, 0, 0, 0);

            gl.disableVertexAttribArray(app.shader.model + 1);
            gl.vertexAttrib4f(app.shader.model + 1, 0, 1, 0, 0);

            gl.disableVertexAttribArray(app.shader.model + 2);
            gl.vertexAttrib4f(app.shader.model + 2, 0, 0, 1, 0);

            gl.disableVertexAttribArray(app.shader.model + 3);
            gl.vertexAttrib4f(app.shader.model + 3, 0, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttrib1f(app.shader.specularIntensity, 1);

            gl.disableVertexAttribArray(app.shader.opacity);
            gl.vertexAttrib1f(app.shader.opacity, 1);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.lines);

            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.ambientColour);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.specularColour);
        }


        /**
         * Render loop function to update the display
         */
        let start;
        function render(time) {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            app.aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            if (start) {
                if (app.movement.state === 'start') {
                    app.movement.start = time;
                    app.movement.state = 'running';
                }
                if (app.movement.state === 'running') {
                    const timing = app.movement.timing ?? ((i) => i);
                    const linear = (time - app.movement.start) / app.movement.duration;
                    const progress = timing(linear);

                    app.camera.lookAt = sum(app.movement.lookAt.start, scale(app.movement.lookAt.delta, progress));
                    const dist = app.movement.distance.start + progress * app.movement.distance.delta;
                    app.movement.distance.remaining = (1 - progress) * app.movement.distance.delta;
                    const view = scale(app.movement.direction, dist);
                    const rotation = getRotation(app.movement.rotation.angle * progress, app.movement.rotation.axis);
                    const offset = applyTransform(view, rotation);
                    app.camera.position = sum(app.camera.lookAt, offset);

                    const roll = getRotation(app.movement.roll * progress, offset);
                    app.camera.up = applyTransform(applyTransform(app.movement.up, rotation), roll);

                    if (linear >= 1.0) {
                        app.movement.state = 'complete';
                        app.movement.distance.remaining = 0;
                    }
                }
                const delta = time - start;

                app.camera.position = sum(app.camera.position, scale(app.velocity, delta / 1000));
                app.camera.lookAt = sum(app.camera.lookAt, scale(app.velocity, delta / 1000));
                const direction = applyTransform(subtract(app.camera.lookAt, app.camera.position), app.rotation);
                app.rotation = scaleMatrix(app.rotation, 0.1);
                app.camera.lookAt = sum(app.camera.position, direction);

                app.camera.updateViewControls();
                app.viewMatrix = viewMatrix(app.camera.position, app.camera.lookAt, app.camera.up);
                app.velocity = scale(app.velocity, 0.9);
                updateBuffers(time);

                gl.useProgram(app.shader.program);
                gl.bindVertexArray(app.boxVertexArray);

                gl.uniformMatrix4fv(app.shader.projection, false, app.projectionMatrix);
                gl.uniformMatrix4fv(app.shader.view, false, app.viewMatrix);
                gl.uniform3fv(app.shader.cameraPosition, app.camera.position);
                gl.uniform3fv(app.shader.lightPosition1, app.lightPosition1);
                gl.uniform3fv(app.shader.lightPosition2, app.lightPosition2);
                gl.uniform3fv(app.shader.lightPosition3, app.lightPosition3);

                if (!app.wireframe) {
                    gl.drawArraysInstanced(gl.TRIANGLES, 0, 36, app.boxCount);
                }
                if (app.wireframe || !app.solid) {
                    gl.drawArraysInstanced(gl.LINES, 36, 24, app.boxCount);
                }
                if (!app.wireframe) {
                    gl.bindVertexArray(app.cylinderVertexArray);
                    gl.drawArraysInstanced(gl.TRIANGLES, 60, 12 * CYLINDER_SIDES, app.cylinderCount);
                }
                /*
                                if (app.quads.length > 0) {
                                    gl.bindVertexArray(app.quadVertexArray);
                                    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, app.quads.length);
                                    if (app.wireframe || !app.solid) {
                                        //gl.drawArraysInstanced(gl.LINES_STRIP, 5, 24, app.quadCount);
                                    }
                                }
                */
                if (app.icosphere) {
                    app.icosphere.render();
                }

                if (app.connections.length > 0) {
                    gl.bindVertexArray(app.lineVertexArray);
                    app.connections.forEach((connection) =>
                        gl.drawArrays(gl.LINE_STRIP, connection.first, connection.length));
                }

                if (app.objs.length > 0) {
                    gl.useProgram(app.pbrShader.program);

                    gl.uniformMatrix4fv(app.pbrShader.projection, false, app.projectionMatrix);
                    gl.uniformMatrix4fv(app.pbrShader.view, false, app.viewMatrix);
                    gl.uniform3fv(app.pbrShader.cameraPosition, app.camera.position);

                    gl.uniform3fv(app.pbrShader.lightPosition1, app.lightPosition1);
                    gl.uniform3fv(app.pbrShader.lightColour1, app.lightColour1);

                    gl.uniform3fv(app.pbrShader.lightPosition2, app.lightPosition2);
                    gl.uniform3fv(app.pbrShader.lightColour2, app.lightColour2);

                    gl.uniform3fv(app.pbrShader.lightPosition3, app.lightPosition3);
                    gl.uniform3fv(app.pbrShader.lightColour3, app.lightColour3);

                    app.objs.forEach((item) => item.render());
                }

                gl.disable(gl.DEPTH_TEST);

                app.boxes.forEach((box) => {
                    if (box.highlight) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
                        gl.disableVertexAttribArray(app.shader.ambientColour);
                        gl.vertexAttrib3f(app.shader.ambientColour, 1, 1, 1);
                        gl.drawArraysInstanced(gl.TRIANGLES, 6 * (box.highlight - 1), 6, app.faceCount);

                        gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
                        gl.enableVertexAttribArray(app.shader.ambientColour);
                        gl.vertexAttribDivisor(app.shader.ambientColour, 1);
                    }
                });

                if (app.textItemCount > 0) {
                    gl.colorMask(true, true, true, false);

                    gl.useProgram(app.textShader.program);
                    gl.bindVertexArray(app.textVertexArray);

                    gl.uniformMatrix4fv(app.textShader.projection, false, app.projectionMatrix);
                    gl.uniformMatrix4fv(app.textShader.view, false, app.viewMatrix);
                    gl.uniform1i(app.textShader.texture, gl.TEXTURE0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, app.textTexture);

                    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, app.textItemCount);

                    gl.colorMask(true, true, true, true);
                }
                if (app.points.length > 0) {
                    gl.bindVertexArray(app.pointVertexArray);
                    gl.drawArrays(gl.POINTS, 0, app.points.length);
                }
                gl.enable(gl.DEPTH_TEST);

                glErrors();
            } else {
                start = time;
            }
            if (app.savePNG) {
                savePNG(canvas);
                app.savePNG = false;
            }
            requestAnimationFrame(render);
        }

        /**
         * translate a touch event into a simplified mouse event.
         */
        function touch(event) {
            event.preventDefault();
            event.stopPropagation();
            return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
        }


        /**
         * Evaluate the element passed in.
         */
        function evaluate(item) {
            return item;
            if (Array.isArray(item)) {
                return item.map((element) => evaluate(element));
            }
            if (typeof item === 'string') {
                item = item.replace(/^\s*\{/, '').replace(/}\s*$/, '');
                const func = makeFunction([], item);
                return func();
            }
            const num = Number(item);
            if (isNaN(num)) {
                item = item.replace(/^\s*\{/, '').replace(/}\s*$/, '');
                const func = makeFunction([], item);
                return func();
            }
            return num;
        }

        /**
         * Get the path for an item.
         */
        function getPath(node) {
            const path = [];
            while (node) {
                path.unshift(node);
                node = node[meta].parent;
            }
            return path;
        }


        /**
         * Load the comments (if any) for the selected item
         */
        async function loadComments(item, node) {
            const path = getPath(item.data).map((element) => element[meta].name[0]).join('/');
            const url = `comments/${path}/comments.txt`;
            const response = await fetch(url);
            if (response.ok) {
                const comments = await response.text();
                node.value = comments;
            }
        }

        /**
         * Return an attribute value, doing a breadth first search of the types.
         */
        function getAttribute(item, attribute) {
            if (item[attribute] !== undefined) {
                return item[attribute];
            }
            if (item[meta].type) {
                const stack = [...item[meta].type];
                while (stack.length > 0) {
                    const prototype = stack.shift();
                    if (prototype[attribute] !== undefined) {
                        return prototype[attribute];
                    }
                    stack.push(...prototype[meta].type);
                }
            }
        }

        /**
         * Base class for 3D Transformations.
         */
        class Transform {
            constructor(reference, offset = [0, 0, 0], angle = 0, axis = [0, 1, 0], scale = [1, 1, 1]) {
                this.reference = reference;

                this.offset = offset;
                this.scale = scale;
                this.angle = angle;
                this.axis = normalised((axis) || [0, 1, 0]);

                this.state = {};
            }

            /**
             * Calculate the local transform from the offset, orientation and scale
             */
            get local() {
                const translation = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    this.offset[0],
                    this.offset[1],
                    this.offset[2], 1
                ];
                this.rotation = getRotation(this.angle, this.axis);

                return multiply(this.rotation, translation)
            }
            /**
             * Calculate the transform from local to world co-ordinates
             */
            get world() {
                if (this._world) {
                    return this._world;
                }
                const reference = this.reference ? this.reference.world : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                this._world = multiply(this.local, reference);
                return this._world;
            }
            get path() {
                if (this.reference) {
                    return [...this.reference.path, this];
                }
                return [this];
            }
        }

        /**
         * Base class for 3D shapes.
         */
        class Shape extends Transform {
            constructor(parent, name, position, size, angle, axis, offset, colour, opacity, specular, data = {}) {
                super(parent, position, angle, axis, [1, 1, 1]);
                this.parent = parent;
                const ancestors = [];
                let modelParent = data;
                while (modelParent) {
                    ancestors.unshift(modelParent);
                    modelParent = modelParent[meta].parent;
                }
                const context = Object.assign({}, ...ancestors);

                this.name = name ?? `Block ${app.boxes.length + 1}`;
                this.position = position || [0, 0, 0];
                this.size = size || [1, 1, 1];
                this.offset = offset || [0, 0, 0];
                this.angle = angle || 0;
                this.axis = normalised(axis || [0, 1, 0]);
                this.colour = colour || [1, 1, 0.5];
                this.opacity = opacity ?? 0.8;
                this.specular = specular ?? 10;
                this.data = data;
                this.labelPosition = product(this.size, offset);

                this.origin = Array(16);
                this.content = [];
                this.rate = 0;
                this.setTransform();
                this.state = {};
            }
            setWorldPosition() {
                this.transforms = decompose(this.origin);
                add(this.transforms.translation, product(this.size, this.offset));
            }
            asString() {
                const getVector = (vector, places = 2) => vector.map((v) => v.toFixed(places)).join(', ');
                const local = this.parent ? invert(this.parent.transform) : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                const parentScale = getScale(extractScale(local).map((v) => 1 / v));
                const transform = matrixMultiply(this.transform, matrixMultiply(local, parentScale));
                const { translation, scale, angle, axis } = decompose(transform);
                const attributes = [
                    this.name,
                    getVector(translation),
                    getVector(scale),
                    angle,
                    getVector(axis),
                    getVector(this.colour),
                    this.specular,
                    this.opacity,
                ];
                return attributes.join('; ');
            }
            showInfo() {
                const container = document.getElementById('info');
                container.classList.remove('hide');
                container.innerHTML = `
                <h2 class="all-columns">${this.name}</h2>
                <span class="all-columns">/${this.path.map((shape) => shape.name).join('/')}</span>
                <span>P/N:</span><span>${this.partNumber}</span>
                <span>S/N:</span><span>${this.serialNumber}</span>
                <span>Notes:</span>`;
                const notes = document.createElement('textarea');
                notes.value = this.notes || '';
                notes.classList.add('all-columns')
                notes.addEventListener('blur', (event) => {
                    this.notes = notes.value;
                });
                if (location.protocol !== 'file:') {
                    loadComments(this, notes);
                }
                container.append(notes);
            }
            get path() {
                if (this.parent) {
                    return [...this.parent.path, this];
                }
                return [this];
            }
            getModelName() {
                const item = this.data;
                const path = [];
                let parent = item;
                while (parent) {
                    path.unshift(parent[meta].name[0]);
                    parent = parent.parent;
                }
                return path.join('/');
            }
            /**
             * Set the transform of a shape based on its position, rotation and scale.
             * 
             * Calculate the origin for content of the shape
             */
            setTransform() {
                const parent = this.parent || { origin: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
                const origin = parent.origin;
                const angle = this.angle * Math.PI / 360;
                const qw = Math.cos(angle);
                const axis = normalised(this.axis);
                const qx = axis[0] * Math.sin(angle);
                const qy = axis[1] * Math.sin(angle);
                const qz = axis[2] * Math.sin(angle);

                const translation = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    this.position[0],
                    this.position[1],
                    this.position[2], 1
                ];
                this.rotation = [
                    1 - 2 * qy * qy - 2 * qz * qz,
                    2 * qx * qy - 2 * qz * qw,
                    2 * qx * qz + 2 * qy * qw,
                    0,

                    2 * qx * qy + 2 * qz * qw,
                    1 - 2 * qx * qx - 2 * qz * qz,
                    2 * qy * qz - 2 * qx * qw,
                    0,

                    2 * qx * qz - 2 * qy * qw,
                    2 * qy * qz + 2 * qx * qw,
                    1 - 2 * qx * qx - 2 * qy * qy,
                    0,

                    0, 0, 0, 1
                ];

                const rotationTranslate = multiply(this.rotation, translation);
                this.origin = multiply(rotationTranslate, origin);
            }
            get transform() {
                const offset = getTranslation(product(this.size, this.offset));
                const scaleMatrix = getScale(this.size);
                return multiply(scaleMatrix, multiply(offset, this.origin));
            }
            apply(action) {
                action(this);
                this.content.forEach((child) => child.apply(action));
            }
            update(child) {
                for (let i = 0; i < 16; ++i) {
                    this.matrix[i] = this.transform[i];
                }
                this.content.forEach((child) => child.update(true));
                app.boxesChanged = true;
                this.updateNodes();
                if (!child) {
                    app.colourUpdate = true;
                    updateTextBuffer();
                }
            }
            updateNodes() {
                const local = this.parent ? invert(this.parent.origin) : identityMatrix();
                const transform = matrixMultiply(this.transform, local);
                const { translation, scale, angle, axis } = decompose(transform);
                const nodes = this.nodes;
                nodes[0].innerHTML = this.name;
                nodes[2].innerHTML = translation[0].toFixed(2);
                nodes[3].innerHTML = translation[1].toFixed(2);
                nodes[4].innerHTML = translation[2].toFixed(2);

                nodes[5].innerHTML = scale[0].toFixed(2);
                nodes[6].innerHTML = scale[1].toFixed(2);
                nodes[7].innerHTML = scale[2].toFixed(2);

                nodes[8].innerHTML = angle.toFixed(2);
                nodes[9].innerHTML = axis[0].toFixed(2);
                nodes[10].innerHTML = axis[1].toFixed(2);
                nodes[11].innerHTML = axis[2].toFixed(2);
            }
            translate(vector) {
                const translation = getTranslation(vector);
                this.origin = matrixMultiply(this.origin, translation);
                this.updateNodes();
                app.boxesChanged = true;
            }
            rotate(angle, axis) {
                const rotation = getRotation(angle, axis);
                const offset = extractTranslation(this.origin);
                const translation = getTranslation(offset);
                const translationBack = getTranslation(scale(offset, -1));
                const transform = matrixMultiply(translationBack, matrixMultiply(rotation, translation));

                this.apply((shape) =>
                    shape.origin = matrixMultiply(shape.origin, transform));

                this.update();
                this.updateNodes();
                app.boxesChanged = true;
            }
            delete() {
                const content = [...this.content];
                content.forEach((child) => child.delete);
                if (this.parent) {
                    const position = this.parent.content.indexOf(this);
                    this.parent.content.splice(position, 1);
                } else {
                    const position = app.roots.indexOf(this);
                    app.roots.splice(position, 1);
                }
            }
            get siblings() {
                const list = this.parent ? this.parent.content : app.roots;
                return list.filter((child) => child !== this)
            }
            get nodes() {
                return app.nodeMap.get(this);
            }
            overlap(position, other) {
                const otherPosition = extractTranslation(other.origin);
                return ((position[0] + this.size[0]) >= otherPosition[0])
                    && (position[0] <= (otherPosition[0] + other.size[0]))
                    && ((position[1] + this.size[1]) >= otherPosition[1])
                    && (position[1] <= (otherPosition[1] + other.size[1]))
                    && ((position[2] + this.size[2]) >= otherPosition[2])
                    && (position[2] <= (otherPosition[2] + other.size[2]));
            }
            move(vector) {
                this.siblings.forEach((sibling) => {
                    sibling.state.constraint = true;
                    sibling.state.hit = false;

                    const requestedPosition = sum(this.start, vector);
                    if (this.overlap(requestedPosition, sibling)) {
                        const delta = [0, 0, 0];
                        const siblingPosition = extractTranslation(sibling.origin);

                        for (let i = 0; i < 3; ++i) {
                            const d1 = siblingPosition[i] - requestedPosition[i] - this.size[i];
                            const d2 = siblingPosition[i] + sibling.size[i] - requestedPosition[i];
                            delta[i] = Math.abs(d1) < Math.abs(d2) ? d1 : d2;
                        }
                        if (Math.abs(delta[1]) < Math.abs(delta[0])) {
                            delta[0] = 0;
                            if (Math.abs(delta[2]) < Math.abs(delta[1])) {
                                delta[1] = 0;
                            } else {
                                delta[2] = 0;
                            }
                        } else {
                            delta[1] = 0;
                            if (Math.abs(delta[0]) < Math.abs(delta[2])) {
                                delta[2] = 0;
                            } else {
                                delta[0] = 0;
                            }
                        }
                        vector = sum(vector, delta);
                        sibling.state.hit = true;
                    }
                });
                // update position
                this.apply((shape) => {
                    shape.origin[12] = shape.start[0] + vector[0];
                    shape.origin[13] = shape.start[1] + vector[1];
                    shape.origin[14] = shape.start[2] + vector[2];
                });

                this.update();
                app.colourUpdate = true;
            }
            promote() {
                if (this.parent) {
                    const siblings = this.parent.content;
                    const position = siblings.indexOf(this);
                    const content = siblings.splice(position, siblings.length - position);
                    content.shift();
                    this.content.push(...content);
                    content.forEach((child) => child.parent = this);
                    this.update();
                    const list = this.parent.parent ? this.parent.parent.content : app.roots;
                    const pos = list.indexOf(this.parent);
                    list.splice(pos + 1, 0, this);
                    this.parent = this.parent.parent;
                }
            }
            demote() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position > 1) {
                    list.splice(position, 1);
                    list[position - 1].content.unshift(this);
                    this.parent = list[position - 1];
                    this.update();
                }
            }
            down() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position < list.length - 1) {
                    list.splice(position, 1);
                    list.splice(position + 1, 0, this);
                    this.update();
                }
            }
            up() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position > 0) {
                    list.splice(position, 1);
                    list.splice(position - 1, 0, this);
                    this.update();
                }
            }
            intersects(line, all) {
                const transform = this.transform;
                const radius = Math.hypot(...this.size);

                const centre = applyTransform([0, 0, 0], transform);

                if (radius === 0) {
                    return this.content.filter((child) => child.intersects(line)).length > 0;
                } else {
                    const l = dot(line.direction, subtract(centre, line.point));
                    const n = l / line.direction.reduce((s, v) => s + v * v, 0);
                    const p = sum(line.point, scale(line.direction, n));
                    const v = subtract(p, centre);
                    const dist = Math.hypot(...v);
                    if (dist < radius) {
                        const corner1 = applyTransform([-0.5, -0.5, -0.5], transform);
                        const corner2 = applyTransform([0.5, 0.5, 0.5], transform);
                        const rotation = extractRotation(transform);
                        const planes = [
                            { point: corner1, normal: applyTransform([-1, 0, 0], rotation) },
                            { point: corner1, normal: applyTransform([0, -1, 0], rotation) },
                            { point: corner1, normal: applyTransform([0, 0, -1], rotation) },
                            { point: corner2, normal: applyTransform([1, 0, 0], rotation) },
                            { point: corner2, normal: applyTransform([0, 1, 0], rotation) },
                            { point: corner2, normal: applyTransform([0, 0, 1], rotation) },
                        ];
                        const points = convexHullIntercept(line, planes);
                        if (points && (all || points[0] > 0 || points[1] > 0)) {
                            const p1 = sum(line.point, scale(line.direction, points[0]));
                            const p2 = sum(line.point, scale(line.direction, points[1]));

                            this.points = [p1, p2];
                            return true;
                        }
                    }
                }
            }
        }

        /**
         * Manage boxes.
         */
        class Box extends Shape {
            static make(parent, node) {
                return new Box(
                    parent,
                    node[meta].name[0],
                    getAttribute(node, 'position') || [0, 0, 0],
                    getAttribute(node, 'size') || [1, 1, 1],
                    getAttribute(node, 'angle') || 0,
                    getAttribute(node, 'axis') || [0, 1, 0],
                    getAttribute(node, 'offset') || [0, 0, 0],
                    getAttribute(node, 'colour'),
                    getAttribute(node, 'opacity'),
                    getAttribute(node, 'specular'),
                    node);
            }
            constructor(parent, name, position, size, angle, axis, offset, colour, opacity, specular, data = {}) {
                super(parent, name, position, size, angle, axis, offset, colour, opacity, specular, data);
            }
            asString() {
                const getVector = (vector, places = 2) => vector.map((v) => v.toFixed(places)).join(', ');
                const local = this.parent ? invert(this.parent.transform) : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                const parentScale = getScale(extractScale(local).map((v) => 1 / v));
                const transform = matrixMultiply(this.transform, matrixMultiply(local, parentScale));
                const { translation, scale, angle, axis } = decompose(transform);
                const attributes = [
                    this.name,
                    getVector(translation),
                    getVector(scale),
                    angle,
                    getVector(axis),
                    getVector(this.colour),
                    this.specular,
                    this.opacity,
                ];
                return attributes.join('; ');
            }
            showInfo() {
                const container = document.getElementById('info');
                container.classList.remove('hide');
                container.innerHTML = `
                <h2 class="all-columns">${this.name}</h2>
                <span class="all-columns">/${this.path.map((shape) => shape.name).join('/')}</span>
                <span>P/N:</span><span>${this.partNumber}</span>
                <span>S/N:</span><span>${this.serialNumber}</span>
                <span>Notes:</span>`;
                const notes = document.createElement('textarea');
                notes.value = this.notes || '';
                notes.classList.add('all-columns')
                notes.addEventListener('blur', (event) => {
                    this.notes = notes.value;
                });
                if (location.protocol !== 'file:') {
                    loadComments(this, notes);
                }
                container.append(notes);
            }
            get path() {
                if (this.parent) {
                    return [...this.parent.path, this];
                }
                return [this];
            }
            getModelName() {
                const item = this.data;
                const path = [];
                let parent = item;
                while (parent) {
                    path.unshift(parent[meta].name[0]);
                    parent = parent.parent;
                }
                return path.join('/');
            }
            /**
             * Set the transform of a shape based on its position, rotation and scale.
             * 
             * Calculate the origin for content of the shape
             */
            setTransform() {
                const parent = this.parent || { origin: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
                const origin = parent.origin;
                const angle = this.angle * Math.PI / 360;
                const qw = Math.cos(angle);
                const axis = normalised(this.axis);
                const qx = axis[0] * Math.sin(angle);
                const qy = axis[1] * Math.sin(angle);
                const qz = axis[2] * Math.sin(angle);

                const translation = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    this.position[0],
                    this.position[1],
                    this.position[2], 1
                ];
                this.rotation = [
                    1 - 2 * qy * qy - 2 * qz * qz,
                    2 * qx * qy - 2 * qz * qw,
                    2 * qx * qz + 2 * qy * qw,
                    0,

                    2 * qx * qy + 2 * qz * qw,
                    1 - 2 * qx * qx - 2 * qz * qz,
                    2 * qy * qz - 2 * qx * qw,
                    0,

                    2 * qx * qz - 2 * qy * qw,
                    2 * qy * qz + 2 * qx * qw,
                    1 - 2 * qx * qx - 2 * qy * qy,
                    0,

                    0, 0, 0, 1
                ];

                const rotationTranslate = multiply(this.rotation, translation);
                this.origin = multiply(rotationTranslate, origin);
            }
            update(child) {
                for (let i = 0; i < 16; ++i) {
                    this.matrix[i] = this.transform[i];
                }
                this.content.forEach((child) => child.update(true));
                app.boxesChanged = true;
                this.updateNodes();
                if (!child) {
                    app.colourUpdate = true;
                    updateTextBuffer();
                }
            }
            updateNodes() {
                const local = this.parent ? invert(this.parent.origin) : identityMatrix();
                const transform = matrixMultiply(this.transform, local);
                const { translation, scale, angle, axis } = decompose(transform);
                const nodes = this.nodes;
                nodes[0].innerHTML = this.name;
                nodes[2].innerHTML = translation[0].toFixed(2);
                nodes[3].innerHTML = translation[1].toFixed(2);
                nodes[4].innerHTML = translation[2].toFixed(2);

                nodes[5].innerHTML = scale[0].toFixed(2);
                nodes[6].innerHTML = scale[1].toFixed(2);
                nodes[7].innerHTML = scale[2].toFixed(2);

                nodes[8].innerHTML = angle.toFixed(2);
                nodes[9].innerHTML = axis[0].toFixed(2);
                nodes[10].innerHTML = axis[1].toFixed(2);
                nodes[11].innerHTML = axis[2].toFixed(2);
            }
            translate(vector) {
                const translation = getTranslation(vector);
                this.origin = matrixMultiply(this.origin, translation);
                this.updateNodes();
                app.boxesChanged = true;
            }
            rotate(angle, axis) {
                const rotation = getRotation(angle, axis);
                const offset = extractTranslation(this.origin);
                const translation = getTranslation(offset);
                const translationBack = getTranslation(scale(offset, -1));
                const transform = matrixMultiply(translationBack, matrixMultiply(rotation, translation));

                this.apply((shape) =>
                    shape.origin = matrixMultiply(shape.origin, transform));

                this.update();
                this.updateNodes();
                app.boxesChanged = true;
            }
            delete() {
                const content = [...this.content];
                content.forEach((child) => child.delete);
                if (this.parent) {
                    const position = this.parent.content.indexOf(this);
                    this.parent.content.splice(position, 1);
                } else {
                    const position = app.roots.indexOf(this);
                    app.roots.splice(position, 1);
                }
            }
            get siblings() {
                const list = this.parent ? this.parent.content : app.roots;
                return list.filter((child) => child !== this)
            }
            get nodes() {
                return app.nodeMap.get(this);
            }
            overlap(position, other) {
                const otherPosition = extractTranslation(other.origin);
                return ((position[0] + this.size[0]) >= otherPosition[0])
                    && (position[0] <= (otherPosition[0] + other.size[0]))
                    && ((position[1] + this.size[1]) >= otherPosition[1])
                    && (position[1] <= (otherPosition[1] + other.size[1]))
                    && ((position[2] + this.size[2]) >= otherPosition[2])
                    && (position[2] <= (otherPosition[2] + other.size[2]));
            }
            highlightFace(line) {
                return;
                const local = invert(this.origin);
                const local2 = invert(this.rotation);
                // Convert the line to local space
                const line2 = { point: applyTransform(line.point, local), direction: applyTransform(line.direction, this.rotation) };

                const getPoint = (line, plane) => {
                    const dist = planeIntercept(line, plane);
                    return { dist, point: sum(line.point, scale(line.direction, dist)), };
                };
                const size = scale(this.size, 0.5);
                const size1 = scale(this.size, -0.5);

                const points = [
                    { point: size1, normal: [0, 0, -1], },
                    { point: size1, normal: [0, 1, 0], },

                    { point: size, normal: [0, 0, 1], },
                    { point: size, normal: [0, -1, 0], },

                    { point: size, normal: [-1, 0, 0], },
                    { point: size1, normal: [1, 0, 0], },

                ].map((plane) => getPoint(line, plane)).flatMap((hit, index) =>
                    ((Math.abs(hit.point[0]) <= size[0]) &&
                        (Math.abs(hit.point[1]) <= size[1]) &&
                        (Math.abs(hit.point[2]) <= size[2])) ? { hit, index } : []
                );

                if (points.length) {
                    points.sort((a, b) => a.hit.dist - b.hit.dist);
                    this.highlight = points[0].index + 1;
                    //app.points.push({ position: applyTransform(points[0].hit.point, this.transform), colour: [1, 1, 1] });
                    report(this.highlight);
                }
            }
            move(vector) {
                this.siblings.forEach((sibling) => {
                    sibling.state.constraint = true;
                    sibling.state.hit = false;

                    const requestedPosition = sum(this.start, vector);
                    if (this.overlap(requestedPosition, sibling)) {
                        const delta = [0, 0, 0];
                        const siblingPosition = extractTranslation(sibling.origin);

                        for (let i = 0; i < 3; ++i) {
                            const d1 = siblingPosition[i] - requestedPosition[i] - this.size[i];
                            const d2 = siblingPosition[i] + sibling.size[i] - requestedPosition[i];
                            delta[i] = Math.abs(d1) < Math.abs(d2) ? d1 : d2;
                        }
                        if (Math.abs(delta[1]) < Math.abs(delta[0])) {
                            delta[0] = 0;
                            if (Math.abs(delta[2]) < Math.abs(delta[1])) {
                                delta[1] = 0;
                            } else {
                                delta[2] = 0;
                            }
                        } else {
                            delta[1] = 0;
                            if (Math.abs(delta[0]) < Math.abs(delta[2])) {
                                delta[2] = 0;
                            } else {
                                delta[0] = 0;
                            }
                        }
                        vector = sum(vector, delta);
                        sibling.state.hit = true;
                    }
                });
                // update position
                this.apply((shape) => {
                    shape.origin[12] = shape.start[0] + vector[0];
                    shape.origin[13] = shape.start[1] + vector[1];
                    shape.origin[14] = shape.start[2] + vector[2];
                });

                this.update();
                app.colourUpdate = true;
            }
            promote() {
                if (this.parent) {
                    const siblings = this.parent.content;
                    const position = siblings.indexOf(this);
                    const content = siblings.splice(position, siblings.length - position);
                    content.shift();
                    this.content.push(...content);
                    content.forEach((child) => child.parent = this);
                    this.update();
                    const list = this.parent.parent ? this.parent.parent.content : app.roots;
                    const pos = list.indexOf(this.parent);
                    list.splice(pos + 1, 0, this);
                    this.parent = this.parent.parent;
                }
            }
            demote() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position > 1) {
                    list.splice(position, 1);
                    list[position - 1].content.unshift(this);
                    this.parent = list[position - 1];
                    this.update();
                }
            }
            down() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position < list.length - 1) {
                    list.splice(position, 1);
                    list.splice(position + 1, 0, this);
                    this.update();
                }
            }
            up() {
                const list = this.parent ? this.parent.content : app.roots;
                const position = list.indexOf(this);
                if (position > 0) {
                    list.splice(position, 1);
                    list.splice(position - 1, 0, this);
                    this.update();
                }
            }
        }

        /**
         * Manage a box.
         */
        class Cylinder extends Shape {
            static make(parent, node) {
                return new Cylinder(
                    parent,
                    node[meta].name,
                    getAttribute(node, 'position'),
                    getAttribute(node, 'height'),
                    getAttribute(node, 'radius'),
                    getAttribute(node, 'angle') || 0,
                    getAttribute(node, 'axis') || [0, 1, 0],
                    getAttribute(node, 'offset') || [0, 0, 0],
                    getAttribute(node, 'colour') || parent?.colour || [1, 0, 1],
                    getAttribute(node, 'opacity') ?? parent?.opacity ?? 1,
                    getAttribute(node, 'specular') ?? parent?.specular ?? 10,
                    node);
            }
            constructor(parent, name, position, height, radius, angle, axis, offset, colour, opacity, specular, data = {}) {
                super(parent, name, position, [radius, height / 2, radius], angle, axis, offset, colour, opacity, specular, data);
            }
            highlightFace(line) {

            }
        }

        /**
         * Manage Icospheres
         */
        class Icosphere extends Shape {

            static getFaces(subdivisions) {
                const points = [];
                let faces = [];
                let edges = [];

                function divideEdge(edge) {
                    const midpoint = normalised(sum(points[edge.p1], points[edge.p2]));
                    edge.midpoint = points.length;
                    points.push(midpoint);
                    edge.split = [
                        { p1: edge.p1, p2: edge.midpoint },
                        { p1: edge.midpoint, p2: edge.p2 }];
                    return edge.split;
                }

                points.push([0, 1, 0]);
                points.push([0, -1, 0]);

                const r = 1 / Math.sqrt(5);
                const y = 0.5 * r;
                for (let i = 0; i < 5; ++i) {
                    const x1 = r * Math.cos(Math.PI * 2 * i / 5);
                    const z1 = r * Math.sin(Math.PI * 2 * i / 5);
                    const x2 = r * Math.cos(Math.PI * 2 * (i + 0.5) / 5);
                    const z2 = r * Math.sin(Math.PI * 2 * (i + 0.5) / 5);
                    points.push(normalised([x1, y, z1]));
                    points.push(normalised([x2, -y, z2]));

                    edges.push({ p1: 0, p2: 2 + i * 2 });
                    edges.push({ p1: 1, p2: 3 + i * 2 });

                    edges.push({ p1: 2 + i * 2, p2: 3 + i * 2 });
                    edges.push({ p1: 2 + ((i + 1) % 5) * 2, p2: 3 + i * 2 });

                    edges.push({ p1: 2 + i * 2, p2: 2 + ((i + 1) % 5) * 2 });
                    edges.push({ p1: 3 + i * 2, p2: 3 + ((i + 1) % 5) * 2 });
                }

                for (let i = 0; i < 5; ++i) {
                    const n = i * 6;
                    faces.push([edges[n + 0], edges[n + 4], edges[(n + 6) % 30]]);
                    faces.push([edges[n + 1], edges[n + 5], edges[(n + 7) % 30]]);
                    faces.push([edges[n + 2], edges[n + 3], edges[n + 4]]);
                    faces.push([edges[n + 3], edges[n + 5], edges[(n + 8) % 30]]);
                }

                function divideFace(face) {
                    const faces = [];
                    const newFace = [
                        { p1: face[0].midpoint, p2: face[1].midpoint },
                        { p1: face[1].midpoint, p2: face[2].midpoint },
                        { p1: face[2].midpoint, p2: face[0].midpoint },
                    ];
                    edges.push(...newFace);
                    const points = Array.from(new Set(face.flatMap((edge) => [edge.p1, edge.p2])));
                    const splits = face.flatMap((edge) => edge.split);
                    faces.push(...points.map((point) => {
                        const s = splits.filter((split) => split.p1 === point || split.p2 === point);
                        const p1 = s[0].p1 === point ? s[0].p2 : s[0].p1;
                        const p2 = s[1].p1 === point ? s[1].p2 : s[1].p1;
                        s.push(newFace.find((edge) => ((edge.p1 === p1) || (edge.p1 === p2)) && ((edge.p2 === p1) || (edge.p2 === p2))));
                        return s;
                    }));
                    /*
                    faces.push([face[0].split[0], newFace[2], face[2].split[1]]);
                    faces.push([face[1].split[0], newFace[0], face[0].split[1]]);
                    faces.push([face[2].split[0], newFace[1], face[1].split[1]]);
                    */
                    faces.push(newFace);
                    return faces;
                }

                for (let i = 0; i < subdivisions; ++i) {
                    edges = edges.flatMap((edge) => divideEdge(edge));
                    faces = faces.flatMap((face) => divideFace(face));
                }

                Icosphere.buffers = {
                    vertices: gl.createBuffer(),
                    indices: gl.createBuffer(),
                    instances: gl.createBuffer(),
                }
                const positions = points.flatMap((point) => point);
                gl.bindBuffer(gl.ARRAY_BUFFER, Icosphere.buffers.vertices);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                const indices = faces.flatMap((face) => Array.from(new Set(face.flatMap((edge) => [edge.p1, edge.p2]))));
                //const indices = edges.flatMap((edge) => [edge.p1, edge.p2]);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Icosphere.buffers.indices);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                Icosphere.numPoints = indices.length;

                const matrix = identityMatrix();
                matrix.push(1, 0, 0, 0, 1, 0, 0, 0, 1);
                gl.bindBuffer(gl.ARRAY_BUFFER, Icosphere.buffers.instances);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(matrix), gl.DYNAMIC_DRAW);

                return { points, faces: faces.flatMap((face) => [face[0].p1, face[1].p1, face[2].p2,]) };
            }
            static make(parent, node) {
                return new Icosphere(
                    parent,
                    node[meta].name,
                    getAttribute(node, 'position'),
                    getAttribute(node, 'height'),
                    getAttribute(node, 'radius'),
                    getAttribute(node, 'angle') || 0,
                    getAttribute(node, 'axis') || [0, 1, 0],
                    getAttribute(node, 'offset') || [0, 0, 0],
                    getAttribute(node, 'colour') || parent?.colour || [1, 0, 1],
                    getAttribute(node, 'opacity') ?? parent?.opacity ?? 1,
                    getAttribute(node, 'specular') ?? parent?.specular ?? 10,
                    node);
            }
            constructor(parent, name, position, radius, angle, axis, offset, colour, opacity, specular, data = {}) {
                super(parent, name, position, [radius, radius, radius], angle, axis, offset, colour, opacity, specular, data);
            }
            highlightFace(line) {

            }
            render() {
                {
                    gl.useProgram(app.shader.program);
                    gl.uniformMatrix4fv(app.shader.projection, false, app.projectionMatrix);
                    gl.uniformMatrix4fv(app.shader.view, false, app.viewMatrix);
                    gl.uniform3fv(app.shader.cameraPosition, app.camera.position);
                    gl.uniform3fv(app.shader.lightPosition1, app.lightPosition1);
                    gl.uniform3fv(app.shader.lightPosition2, app.lightPosition2);
                    gl.uniform3fv(app.shader.lightPosition3, app.lightPosition3);

                    gl.bindBuffer(gl.ARRAY_BUFFER, Icosphere.buffers.vertices);
                    gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 12, 0);
                    gl.enableVertexAttribArray(app.shader.position);

                    gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 12, 0);
                    gl.enableVertexAttribArray(app.shader.normal);

                    gl.disableVertexAttribArray(app.shader.model);
                    gl.disableVertexAttribArray(app.shader.model + 1);
                    gl.disableVertexAttribArray(app.shader.model + 2);
                    gl.disableVertexAttribArray(app.shader.model + 3);
                    gl.vertexAttrib4f(app.shader.model, 1, 0, 0, 0);
                    gl.vertexAttrib4f(app.shader.model + 1, 0, 1, 0, 0);
                    gl.vertexAttrib4f(app.shader.model + 2, 0, 0, 1, 0);
                    gl.vertexAttrib4f(app.shader.model + 3, 0, 0, 0, 1);

                    gl.disableVertexAttribArray(app.shader.specularIntensity);
                    gl.vertexAttrib1f(app.shader.specularIntensity, 10);

                    gl.disableVertexAttribArray(app.shader.opacity);
                    gl.vertexAttrib1f(app.shader.opacity, 1);

                    gl.disableVertexAttribArray(app.shader.ambientColour);
                    gl.vertexAttrib3f(app.shader.ambientColour, 0.1, 0.1, 0.1);

                    gl.disableVertexAttribArray(app.shader.diffuseColour);
                    gl.vertexAttrib3f(app.shader.diffuseColour, 1, 0.1, 0.3);

                    gl.disableVertexAttribArray(app.shader.specularColour);
                    gl.vertexAttrib3f(app.shader.specularColour, 1, 1, 1);
  
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Icosphere.buffers.indices);

                    gl.drawElements(gl.TRIANGLES, Icosphere.numPoints, gl.UNSIGNED_SHORT, 0);
                    //gl.drawElements(gl.LINES, Icosphere.numPoints, gl.UNSIGNED_SHORT, 0);

                    //gl.drawElements(gl.LINES, 0, Icosphere.numPoints);
                }
                gl.useProgram(app.pbrShader.program);

                gl.uniformMatrix4fv(app.pbrShader.projection, false, app.projectionMatrix);
                gl.uniformMatrix4fv(app.pbrShader.view, false, app.viewMatrix);

                gl.uniform3fv(app.pbrShader.cameraPosition, app.camera.position);

                gl.uniform3fv(app.pbrShader.lightPosition1, app.lightPosition1);
                gl.uniform3fv(app.pbrShader.lightColour1, app.lightColour1);

                gl.uniform3fv(app.pbrShader.lightPosition2, app.lightPosition2);
                gl.uniform3fv(app.pbrShader.lightColour2, app.lightColour2);

                gl.uniform3fv(app.pbrShader.lightPosition3, app.lightPosition3);
                gl.uniform3fv(app.pbrShader.lightColour3, app.lightColour3);

                gl.bindBuffer(gl.ARRAY_BUFFER, Icosphere.buffers.vertices);

                // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4, offset = 0
                gl.vertexAttribPointer(app.pbrShader.position, 3, gl.FLOAT, false, 12, 0);
                gl.enableVertexAttribArray(app.pbrShader.position);

                gl.vertexAttribPointer(app.pbrShader.normal, 3, gl.FLOAT, true, 12, 0);
                gl.enableVertexAttribArray(app.pbrShader.normal);

                gl.bindBuffer(gl.ARRAY_BUFFER, Icosphere.buffers.instances);
                return;

                // Matrices are passed as 4 vertex attributes
                for (let j = 0; j < 10; ++j) {
                    for (let i = 0; i < 4; ++i) {
                        const location = app.pbrShader.model + i;
                        // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                        gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * (16 + 12), i * 16);
                        //gl.vertexAttribDivisor(location, 1);
                        gl.enableVertexAttribArray(location);
                    }
                    for (let i = 0; i < 3; ++i) {
                        const location = app.pbrShader.normalMatrix + i;
                        // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride (bytes), offset
                        gl.vertexAttribPointer(location, 3, gl.FLOAT, false, 4 * (16 + 12), i * 12);
                        gl.vertexAttribDivisor(location, 1);
                        gl.enableVertexAttribArray(location);
                    }
                }

                const material = {};
                gl.disableVertexAttribArray(app.pbrShader.colour);
                gl.vertexAttrib3f(app.pbrShader.colour, ...material.colour ?? [0.8, 0.1, 0.7]);

                gl.disableVertexAttribArray(app.pbrShader.emissivityColour);
                gl.vertexAttrib3f(app.pbrShader.emissivityColour, ...material.emissivityColour ?? [0, 0, 0]);

                gl.disableVertexAttribArray(app.pbrShader.roughness);
                gl.vertexAttrib1f(app.pbrShader.roughness, material.roughness ?? 0.5);

                gl.disableVertexAttribArray(app.pbrShader.reflectivity);
                gl.vertexAttrib3f(app.pbrShader.reflectivity, ...material.reflectivity ?? [0.04, 0.04, 0.04]);

                gl.disableVertexAttribArray(app.pbrShader.opacity);
                gl.vertexAttrib1f(app.pbrShader.opacity, material.opacity ?? 1);

                gl.disableVertexAttribArray(app.pbrShader.metallic);
                gl.vertexAttrib1f(app.pbrShader.metallic, material.metallic ?? 0);

                //gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Icosphere.buffers.indices);
                //gl.drawElements(gl.TRIANGLES, 60, gl.UNSIGNED_SHORT, 0);
                //gl.drawArrays(gl.TRIANGLES, 0, 60);
                //gl.drawArraysInstanced(gl.POINTS, 0, 12, 1);

            }
        }

        /**
         * Manage quads.
         */
        class Quad extends Shape {
            static make(parent, node) {
                return new Quad(
                    parent,
                    node[meta].name,
                    getAttribute(node, 'position'),
                    getAttribute(node, 'width'),
                    getAttribute(node, 'height'),
                    getAttribute(node, 'angle') || 0,
                    getAttribute(node, 'axis') || [0, 1, 0],
                    getAttribute(node, 'offset') || [0, 0, 0],
                    getAttribute(node, 'colour') || parent?.colour || [1, 0, 1],
                    getAttribute(node, 'opacity') ?? parent?.opacity ?? 1,
                    getAttribute(node, 'specular') ?? parent?.specular ?? 10,
                    getAttribute(node, 'image') ?? parent?.image,
                    node);
            }
            constructor(parent, name, position, width, height, angle, axis, offset, colour, opacity, specular, image, data = {}) {
                super(parent, name, position, [width, height, 1], angle, axis, offset, colour, opacity, specular, data);
                this.texture = getTexture(image);
            }
        }

        /**
         * Convert a position to client window space
         */
        function toClientSpace(point) {
            const view = applyTransform4([...point, 1], app.viewMatrix);
            const norm = applyTransform4(view, app.projectionMatrix);
            const nx = norm[0] / norm[3];
            const ny = norm[1] / norm[3];

            return {
                x: canvas.width * (1 + nx) * 0.5,
                y: canvas.height * (1 + ny) * 0.5,
            };
        }

        /**
         * Manage a connection between two instances
         */
        class Connection {
            constructor(start, end, points = [[], [], []]) {
                this.start = start;
                this.end = end;
                this.points = points;
                this.colour = [1, 1, 0];
                this.startColour = [0, 1, 0.5];
                this.endColour = [0.5, 1, 0];
                this.getSegments();
            }
            get context() {
                const startPath = this.start.path;
                const endPath = this.end.path;
                const path = [];
                while (startPath[0] === endPath[0] && startPath.length && endPath.length) {
                    path.push(startPath.shift);
                    endPath.shift();
                }
                return path.at(-1);
            }
            addVertices(vertices) {
                this.first = vertices.length / 6;
                this.length = 0;
                const startColour = this.selected ? [1, 0.5, 0.5] : (this.startColour ?? this.colour);
                const colour = this.selected ? [1, 0.5, 0.5] : this.colour;
                const endColour = this.selected ? [1, 0.5, 0.5] : (this.endColour ?? this.colour);
                if (this.points[0].length) {
                    this.points[0].forEach((point) => {
                        vertices.push(...applyTransform(point, this.start.origin));
                        vertices.push(...startColour);
                    });
                    this.length += this.points[0].length;
                } else {
                    vertices.push(...applyTransform([0, 0, 0], this.start.origin));
                    vertices.push(...startColour);
                    this.length += 1;
                }
                const context = this.context;
                this.points[1].forEach((point) => {
                    vertices.push(...applyTransform(point, context.origin));
                    vertices.push(...colour);
                });
                this.length += this.points[1].length;

                if (this.points[2].length) {
                    this.points[2].forEach((point) => {
                        vertices.push(...applyTransform(point, this.end.origin));
                        vertices.push(...endColour);
                    });
                    this.length += this.points[2].length;
                } else {
                    vertices.push(...applyTransform([0, 0, 0], this.end.origin));
                    vertices.push(...endColour);
                    this.length += 1;
                }
            }
            getSegments() {
                const vertices = [];
                if (this.points[0].length) {
                    this.points[0].forEach((point) =>
                        vertices.push(applyTransform(point, this.start.origin)));
                } else {
                    vertices.push(applyTransform([0, 0, 0], this.start.origin));
                }
                const context = this.context;
                this.points[1].forEach((point) =>
                    vertices.push(applyTransform(point, context.origin)));

                if (this.points[2].length) {
                    this.points[2].forEach((point) =>
                        vertices.push(applyTransform(point, this.end.origin)));
                } else {
                    vertices.push(applyTransform([0, 0, 0], this.end.origin));
                }
                this.segments = vertices.flatMap((point, index) => {
                    if (index + 1 < vertices.length) {
                        return { point, direction: subtract(vertices[index + 1], point) };
                    }
                    return [];
                });
            }
            getDist(line) {
                this.getSegments();
                const dists = this.segments.map((segment) => {
                    const [t, s] = shortestLine(segment, line);
                    const t1 = Math.max(0, Math.min(1, t));
                    const p1 = sum(segment.point, scale(segment.direction, t1));
                    const p2 = sum(line.point, scale(line.direction, s));
                    if (app.showPoints) {
                        app.points.push({ position: p1 }, { position: p2 });
                    }
                    const s1 = toClientSpace(p1);
                    const s2 = toClientSpace(p2);
                    return Math.hypot(s1.x - s2.x, s1.y - s2.y);
                });
                dists.sort((a, b) => a - b);
                return dists[0];
            }
        }

        const action = {};
        const history = [];
        let historyPosition;

        /**
         * Highlight the face under the mouse pointer
         */
        function highlightFace(event) {
            const line = getRay(event.clientX, event.clientY);
            app.boxes.forEach((box) => box.highlight = 0);
            const hits = sortSelection(getIntersection(line));
            if (hits.length > 0) {
                hits[0].highlightFace(line);
                app.showName = hits[0];
                report(hits[0].data[meta].name[0]);
            } else {
                app.showName = null;
            }
            updateTextBuffer();
        }

        /**
         * End a mouse movement and store change in history.
         */
        function endMove(event) {
            if (action.moved) {
                const instances = new Set();
                app.boxes.filter((instance) => instance.selected)
                    .forEach((instance) => instance.apply((instance) => instances.add(instance)));
                const undo = Array.from(instances).map((instance) => ({
                    instance, start: [...instance.start],
                }));
                const redo = Array.from(instances).map((instance) => ({
                    instance, end: extractTranslation(action.selected.origin),
                }));
                const start = [...action.selected.start];
                const end = extractTranslation(action.selected.origin);
                history.push({
                    undo: () =>
                        undo.forEach((action) => {
                            action.instance.origin[12] = action.start[0];
                            action.instance.origin[13] = action.start[1];
                            action.instance.origin[14] = action.start[2];
                            action.instance.update();
                        }),
                    redo: () => redo.forEach((action) => {
                        action.instance.origin[12] = action.end[0];
                        action.instance.origin[13] = action.end[1];
                        action.instance.origin[14] = action.end[2];
                        action.instance.update();
                    }),
                });
            } else if (action.selected.data.url) {
                if (action.selected.data.click === 'load page') {
                    location = action.selected.data.url;
                } else if (action.selected.data.click === 'reset') {
                    load(action.selected.data.url, undefined, true);
                    updateText();
                    showStructure();
                    showStock();
                } else if (event.crtlKey || action.selected?.data.load !== true) {
                    load(action.selected.data.url, action.selected, event.shiftKey);
                    action.selected.data.load = true;
                }
            }
            action.move = highlightFace;
            historyPosition = null;
            app.boxes.forEach((instance) => {
                instance.state = {};
            });
        }

        const completeAction = (event) => {
            if (action.end) {
                action.end(event);
                action.end = null;
            }
        }
        document.body.addEventListener('mousemove', (event) => action.move?.(event));
        document.body.addEventListener('mouseup', completeAction);

        document.body.addEventListener('touchmove', (event) => action.move?.(touch(event)));
        document.body.addEventListener('touchend', completeAction);


        /**
         * Show Model
         */
        function showModel(model) {
            const container = document.getElementById('model');
            container.innerHTML = '';
            const table = document.createElement('table');
            container.append(table);
            const head = document.createElement('thead');
            const body = document.createElement('tbody');
            table.append(head, body);

            columns = new Set();
            const stack = [[model, 0]];
            while (stack.length) {
                const [item, level] = stack.shift();
                stack.unshift(...item[content].map((item) => [item, level + 1]));
                Object.getOwnPropertyNames(item).forEach((property) => columns.add(property));

                columns.delete('name');
                const row = document.createElement('tr');
                body.append(row);
                const cell = document.createElement('td');
                cell.classList.add('title');
                cell.innerText = item[meta].name[0];
                if (item[meta].representation) {
                    cell.classList.add('displayed');
                }
                cell.style.paddingLeft = `${level}em`;
                row.append(cell);

                columns.forEach((column) => {
                    const cell = document.createElement('td');
                    cell.innerText = item[column] ?? '';
                    if (item[column] === undefined) {
                        if (item[meta].inherited[column] === undefined) {
                            cell.classList.add('undefined');
                        } else {
                            cell.innerText = item[meta].inherited[column];
                            cell.classList.add('inherited');
                        }
                    }
                    row.append(cell);
                });

            }
            const row = document.createElement('tr');
            head.append(row);
            const cell = document.createElement('th');
            cell.innerText = 'Name';
            row.append(cell);
            columns.forEach((column) => {
                const cell = document.createElement('th');
                cell.innerText = column;
                row.append(cell);
            });

            for (const node of body.children) {
                for (let i = node.children.length - 1; i < columns.size; ++i) {
                    const cell = document.createElement('td');
                    cell.classList.add('undefined');
                    node.append(cell);
                }
            }
        }

        /**
         * Show structure
         */
        function showStructure() {
            const structure = document.getElementById('structure');
            structure.innerHTML = `
                <span class="value two-rows">Name</span>
                <span class="value three-columns">Position</span>
                <span class="value three-columns">Size</span>
                <span class="value two-rows">Angle</span>
                <span class="value three-columns">Axis</span>
                <span class="value two-rows">Colour</span>
                <span class="value two-rows">Specular</span>
                <span class="value two-rows">Opacity</span>

                <span class="value">x</span>
                <span class="value">y</span>
                <span class="value">z</span>

                <span class="value">x</span>
                <span class="value">y</span>
                <span class="value">z</span>

                <span class="value">x</span>
                <span class="value">y</span>
                <span class="value">z</span>`;

            app.nodeMap = new Map();
            const addInstance = (instance, level = 0) => {
                const nodes = [];
                const addControls = (node, item, element, scaled) => {
                    node.contentEditable = true;
                    node.addEventListener('focus', (event) => {
                        if (!event.shiftKey) {
                            app.boxes.forEach((instance) => instance.selected = false);
                        }
                        instance.selected = true;
                        app.colourUpdate = true;
                    });

                    node.addEventListener('blur', (event) => {
                        if (isNaN(Number(item[element]))) {
                            item[element] = node.innerText;
                        } else {
                            item[element] = Number(node.innerText);
                        }
                    });
                    node.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            if (isNaN(Number(item[element]))) {
                                node.innerHTML = item[element];
                            } else {
                                node.innerHTML = item[element].toFixed();
                            }
                        }
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            if (event.shiftKey) {
                                const definition = {
                                    [meta]: { name: [getUniqueName()] },
                                    position: [0, 0, 0],
                                    size: scale(instance.size, 0.5),
                                }
                                const box = Box.make(instance, definition);
                                app.boxes.push(box);
                                instance.content.push(box);
                                initialiseBoxes();
                                showStructure();
                            } else {
                                if (isNaN(Number(node.innerText))) {
                                    item[element] = node.innerText;
                                } else {
                                    item[element] = Number(node.innerText);
                                }
                                instance.update();
                            }
                        }
                        if (event.ctrlKey) {
                            if (event.key === 'ArrowLeft') {
                                instance.promote();
                                showStructure();
                            }
                            if (event.key === 'ArrowRight') {
                                instance.demote();
                                showStructure();
                            }
                            if (event.key === 'ArrowUp') {
                                instance.up();
                                showStructure();
                            }
                            if (event.key === 'ArrowDown') {
                                instance.down();
                                showStructure();
                            }
                        }
                    });

                    if (!isNaN(Number(item[element]))) {
                        const places = Math.floor(Math.log10(1 / scaled));
                        node.addEventListener('mousedown', (event) => {
                            action.last = event.clientY;
                            action.moved = false;
                            action.move = (event) => {
                                action.moved = true;
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.setTransform();
                                instance.update();
                            };
                            const initial = item[element];
                            action.end = () => {
                                action.move = highlightFace;
                                if (action.moved) {
                                    const end = item[element];
                                    history.push({
                                        undo: () => {
                                            item[element] = initial;
                                            instance.setTransform();
                                            instance.update();
                                        },
                                        redo: () => {
                                            item[element] = initial;
                                            instance.setTransform();
                                            instance.update();
                                        },
                                    });
                                }
                            };
                        });
                        node.addEventListener('touchstart', (event) => {
                            event = touch(event);
                            action.last = event.clientY;
                            action.moved = false;
                            action.move = (event) => {
                                action.moved = true;
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.update();
                            };
                            const initial = item[element];
                            action.end = () => {
                                action.move = highlightFace;
                                if (action.moved) {
                                    const end = item[element];
                                    history.push({
                                        undo: () => {
                                            item[element] = initial;
                                            instance.update();
                                        },
                                        redo: () => {
                                            item[element] = initial;
                                            instance.update();
                                        },
                                    });
                                }
                            };
                        });
                    }
                }
                const addSpan = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    const node = document.createElement('span');
                    nodes.push(node);
                    if (scaled < 0 || isNaN(Number(instance[argument]))) {
                        node.innerHTML = instance[argument];
                    } else {
                        node.innerHTML = instance[argument].toFixed();
                        node.classList.add('value');
                    }
                    addControls(node, instance, argument, scaled);
                    return node;
                }
                const addColour = (argument, scaled = 0.1) => {
                    const node = document.createElement('input');
                    nodes.push(node);
                    node.type = 'color';
                    const value = instance[argument];
                    const string = `#${toHex(value[0] * 255, 2)}${toHex(value[1] * 255, 2)}${toHex(value[2] * 255, 2)}`;
                    node.value = string;

                    node.addEventListener('change', (event) => {
                        const string = node.value;
                        const value = [parseInt(string.slice(1, 3), 16) / 255, parseInt(string.slice(3, 5), 16) / 255, parseInt(string.slice(5), 16) / 255];
                        instance[argument] = value;
                        app.colourUpdate = true;
                    });
                    return node;
                }
                const addVec = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    return instance[argument].map((item, index) => {
                        const node = document.createElement('span');
                        nodes.push(node);
                        node.classList.add('value');
                        node.innerHTML = item.toFixed(places);
                        addControls(node, instance[argument], index, scaled);
                        return node;
                    });
                }


                if (instance.nodes) {
                    structure.append(...instance.nodes);
                    instance.content.map((child) => addInstance(child, level + 1));
                } else {
                    const expander = document.createElement('span');
                    expander.innerHTML = instance.content.length ? '&#9660;' : '';
                    expander.classList.add('expander');

                    const name = document.createElement('span');
                    name.style.whiteSpace = 'pre';
                    name.append(''.padStart(level * 2, ' '), expander, addSpan('name', -1));

                    nodes.push(name);
                    app.nodeMap.set(instance, nodes);
                    structure.append(name,
                        ...addVec('position'),
                        ...addVec('size'),
                        addSpan('angle'),
                        ...addVec('axis'),
                        addColour('colour'),
                        addSpan('specular'),
                        addSpan('opacity'));
                    instance.content.map((child) => addInstance(child, level + 1));

                    const descend = (node, action) => {
                        action(node);
                        node.content.forEach((child) => descend(child, action));
                    }

                    expander.addEventListener('click', (event) => {
                        const recursive = event.ctrlKey;
                        expander.classList.toggle('collapsed');
                        if (expander.classList.contains('collapsed')) {
                            expander.innerHTML = instance.content.length ? '&#9654;' : '';
                            instance.content.forEach((child) =>
                                descend(child, (node) => {
                                    if (recursive && node.content.length > 0) {
                                        node.nodes[1].querySelector('.expander').classList.add('collapsed');
                                    }
                                    node.nodes.forEach((node) => node.classList.add('hide'));
                                }));
                        } else {
                            expander.innerHTML = instance.content.length ? '&#9660;' : '';
                            instance.content.forEach((child) =>
                                descend(child, (node) => {
                                    if (recursive && node.content.length > 0) {
                                        node.nodes[1].querySelector('.expander').classList.remove('collapsed');
                                    }
                                    if (!node.nodes[1].querySelector('.expander').classList.contains('collapsed')) {
                                        node.nodes.forEach((node) => node.classList.remove('hide'));
                                    }
                                }));
                        }
                    });
                }
            }
            app.roots.forEach((child) => addInstance(child));
        }

        /**
         * Utility function to make a node draggable
         */
        function makeDraggable(node, type, data) {
            node.draggable = true;
            node.addEventListener('dragstart', (event) => {
                event.dataTransfer.setData(type, data);
            });
        }

        /**
         * Display the stock by Part / serial number and it's location
         */
        function showStock() {
            const container = document.getElementById('stock');
            const parts = Object.keys(app.stock);
            parts.sort((a, b) => a.localeCompare(b));
            parts.forEach((part) => {
                const partNode = document.createElement('details');
                partNode.innerHTML = `<summary>${part}</summary>`;
                container.append(partNode);
                const items = app.stock[part];
                const locations = items.entries().reduce((locations, [item, loc]) => {
                    locations[loc] = locations[loc] || [];
                    locations[loc].push(item);
                    return locations;
                }, {});
                Object.entries(locations).forEach(([name, items]) => {
                    const locationNode = document.createElement('details');
                    partNode.append(locationNode);
                    locationNode.innerHTML = `<summary>${name}</summary>`;
                    items.sort((a, b) => a.localeCompare(b));
                    const list = document.createElement('ul');
                    items.forEach((item) => {
                        const itemNode = document.createElement('li');
                        makeDraggable(itemNode, part, item);
                        itemNode.innerHTML = item;
                        list.append(itemNode);
                    });
                    locationNode.append(list);
                });
            });
        }

        const commands = {
            'camera position'(value) {
                app.initial.position = value.split(/,/g).map((v) => parseFloat(v));
                app.camera.position = [...app.initial.position];
            },
            'look at'(value) {
                app.initial.lookAt = value.split(/,/g).map((v) => parseFloat(v));
                app.camera.lookAt = [...app.initial.lookAt];
            },
            up(value) {
                app.initial.up = value.split(/,/g).map((v) => parseFloat(v));
                app.camera.up = [...app.initial.up];
            },
            fov(value) {
                app.initial.fov = parseFloat(value);
                app.fov = app.initial.fov;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
                document.getElementById('field-of-view').valueAsNumber = app.fov;
            },
            near(value) {
                app.initial.near = parseFloat(value);
                app.near = app.initial.near;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
                document.getElementById('near').valueAsNumber = app.near;
            },
            far(value) {
                app.initial.far = parseFloat(value);
                app.far = app.initial.far;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
                document.getElementById('far').valueAsNumber = app.far;
            },
            transform(value) {
                app.transform = value.split(/\s*,\s*/g).map((v) => parseFloat(v));
            },
            background(value) {
                const colour = value.split(/\s*,\s*/g).map((v) => parseFloat(v));
                gl.clearColor(...colour, 1.0);
            }
        }

        /**
         * Convert a string to the best canonical object
         */
        function interpret(string) {
            if (string === undefined) {
                return;
            } else if (typeof string !== 'string') {
                return string;
            }
            const trimmed = string.trim();
            if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
                return string.replace(/^\s*"/, '').replace(/"\s*$/, '');
            }
            const datePattern = /(?<day>[0-9]{1,4})[-\._\/](?<month>[0-9]{1,2})[-\._\/](?<year>[0-9]{2,4})/;
            const dateMatch = string.match(datePattern);
            if (dateMatch) {
                const [p1, month, p3] = dateMatch.slice(1).map((v) => parseInt(v));
                const [year, day] = p1 > 31 ? [p1, p3] : [p3, p1];
                return new Date((year < 2000 ? year + 2000 : year), month - 1, day);
            }
            if (!isNaN(Number(string))) {
                return Number(string);
            }
            const parts = string.split(/\s*,\s*/g);
            if (parts.length > 1) {
                return parts.map((part) => interpret(part));
            }
            return string;
        }

        /**
         * Determine the shortest line joining two lines
         */
        function shortestLine(line1, line2) {
            const p1 = line1.point;
            const d1 = line1.direction;
            const p2 = line2.point;
            const d2 = line2.direction;

            const denom = dot(d1, d1) * dot(d2, d2) - dot(d1, d2) * dot(d1, d2);
            const nom = dot(d2, d2) * (dot(d1, p2) - dot(d1, p1)) + dot(d1, d2) * (dot(d2, p1) - dot(d2, p2));
            const t = nom / denom;
            const s = (dot(d2, p1) - dot(d2, p2) + t * dot(d1, d2)) / dot(d2, d2);
            return [t, s];
        }

        /**
         * Load a definition file
         */
        async function load(url, parent, replace) {
            document.body.style.cursor = 'progress';
            const response = await fetch(url);
            const content = await response.text();
            processText(content, parent, replace);
            document.body.style.cursor = 'auto';
        }

        const meta = Symbol('meta');
        const content = Symbol('content');
        const connections = Symbol('connections');

        /**
         * Convert lines to objects
         */
        function processText(text, parent, replace) {
            if (replace) {
                app.boxes = [];
                app.roots = [];
                app.stock = {};
            }

            const lines = text.split(/\r?\n/g);
            const roots = [];
            const stack = [];

            const getLevel = (line) => {
                let level = 0;
                for (let i = 0; i < line.length; ++i) {
                    if (line[i] === ' ' || line[i] === '\t') {
                        level += line[i] === '\t' ? 4 - (level % 4) : 1;
                    } else {
                        break;
                    }
                }
                return level;
            }

            let process = true;
            // Create a tree structure based on indentation
            lines.forEach((line, lineNumber) => {
                if (line === '!stop') {
                    process = false;
                }
                if (process && line.trim() !== '' && !/^\s*#/.test(line)) {
                    const level = getLevel(line);
                    while (stack.length && level <= stack.at(-1).level) {
                        stack.pop();
                    }
                    const item = { line, lineNumber, level, parent: stack.at(-1), content: [], functions: {} };
                    if (stack.length) {
                        stack.at(-1).content.push(item);
                    } else {
                        roots.push(item);
                    }
                    stack.push(item);
                }
            });

            const groupPattern = /^\[([^\]]+)\]\s*(.*)/;
            const templatePattern = /\s*\[([^\]]+)\]$/;
            const expand = (item, instance = []) => {
                const line = item.line.trim();
                const group = line.match(groupPattern);
                if (group) {
                    const instances = getList(group[1]);
                    const label = group[2];
                    return instances.flatMap((name, index) =>
                        item.content.flatMap((child) => expand(child, [{ label, name, index }, ...instance])));
                } else {
                    const template = line.match(templatePattern);
                    const instances = template ? getList(template[1]) : undefined;
                    const value = line.replace(groupPattern, '').replace(templatePattern, '');
                    if (instances) {
                        return instances.flatMap((name, index) => ({
                            [meta]: {
                                value,
                                lineNumber: item.lineNumber,
                                content: item.content.flatMap((child) => expand(child, [{ name, index }, ...instance])),
                                instance: [{ name, index }, ...instance],
                                name: [],
                                type: [],
                                inherited: {},
                                common: item,
                            },
                            [content]: [],
                        }));
                    }
                    return {
                        [meta]: {
                            value,
                            lineNumber: item.lineNumber,
                            content: item.content.flatMap((child) => expand(child, instance)),
                            instance,
                            name: [],
                            type: [],
                            inherited: {},
                            common: item,
                        },
                        [content]: [],
                    };
                }
            };

            const expanded = roots.flatMap((item) => expand(item));

            const find = (string) => {
                if (!string.split) return;
                const path = string.split(/\/\./g);
                let target;
                while (path.length) {
                    if (target) {
                        const name = path.shift();
                        target = target.content.find((child) => child[meta].name.includes(name)) ?? target.attrs[name];
                    } else {
                        target = named[path.shift()];
                    }
                }
            }

            const named = {};
            const customFunctions = {
                zeroPad: (string, chars) => (string + '').padStart(chars, '0'),
            }
            const graph = {
                [meta]: { name: '', inherited: {} },
                [content]: [],
            }
            const contextStack = [{ object: graph, name: 0, defaultParameters: [], }];
            /*
             * lines starting with '>' provide app settings
             * lines starting with '!' control context to modify object interpretation
             * other lines are either objects or values
             * lines starting with '`' are unparsed values
             */
            const evaluate = (node) => {
                const line = node[meta];
                const context = Object.assign({}, contextStack.at(-1));
                context.parameters = [...context.defaultParameters];

                const add = (item) => {
                    const arg = context.parameter ?? content;
                    if (Array.isArray(context.object[arg])) {
                        context.object[arg].push(item);
                    } else if (context.object[arg] === undefined) {
                        context.object[arg] = item;
                    } else {
                        context.object[arg] = [context.object[arg], item];
                    }
                }

                if (line.value.startsWith('`')) {
                    add(line.value);
                } else if (line.value.startsWith("'")) {
                    add(line.value);
                } else if (line.value.startsWith('>')) {
                    const [command, value] = line.value.replace(/^>\s*/, '').split('=').map((v) => v.trim());
                    if (!parent && commands[command]) {
                        commands[command](value);
                    }
                } else if (line.value.startsWith('?')) {
                    const testStr = line.value.replace(/^\?\s*/, '');
                    try {
                        const instance = node[meta].instance;
                        const attrs = instance.filter((instance) => instance.label);
                        attrs.push(...instance.filter((instance) => instance.label).map((attr) => ({ label: `${attr.label}_n`, name: attr.index })));
                        const test = line.common.functions[testStr] || makeFunction(attrs.map((attr) => attr.label), testStr);
                        line.common.functions[testStr] = test;
                        if (test(...attrs.map((attr) => attr.name))) {
                            line.content.forEach((child) => evaluate(child));
                        }
                    } catch (error) {
                        report(`${line.lineNumber + 1}: ${error.message}`);
                    }
                } else {
                    // Options
                    // 1 component
                    //   assignment
                    //     has content
                    //       - assign value as first element of array
                    //     no content
                    //       - assign value to parameter
                    //   value
                    //     has content
                    //       - assign content as elements
                    //     no content
                    //       unused context parameters
                    //         - assign to next content parameter
                    //       no unused parameters
                    //         - assign as specified by context
                    // multiple components
                    //  - create object and update context
                    const components = line.value.split(/\s*[;\|\t\u{1f}]\s*/ug);

                    const addComponent = (component, first, last) => {

                        const getTarget = (name) => name.startsWith('&') ?
                            [context.object[meta], name.replace(/^&\s*/, '')] :
                            [context.object, name];

                        if (component.includes('=>')) {
                            const [name, value] = component.split(/\s*=>\s*/);
                            const expr = value.replace(/<([0-9]*)>/g, (match, num) => 'context[meta].instance[parseInt(num) || 0]?.name')
                                .replace(/<n([0-9]*)>/g, (match, num) => 'context[meta].instance[parseInt(num) || 0]?.index');
                            const func = makeFunction([], expr);
                            const [target, arg] = getTarget(name);

                            Object.defineProperties(target, arg, {
                                enumerable: true,
                                get() {
                                    return func(this);
                                }
                            });
                        } else if (component.includes('=')) {
                            const [name, value] = component.split(/\s*=\s*/);
                            const [target, arg] = getTarget(name);
                            //target[arg] = interpret(value);
                            target[arg] = value;
                        } else {
                            const name = context.parameters.shift()?.name ?? context.parameter;
                            if (name) {
                                const [target, arg] = getTarget(name);
                                if (Array.isArray(target[arg])) {
                                    target[arg].push(interpret(component));
                                } else if (target[arg] === undefined) {
                                    ///target[arg] = interpret(component);
                                    target[arg] = component;
                                } else {
                                    //target[arg] = [target[arg], interpret(component)];
                                    target[arg] = [target[arg], component];
                                }
                            } else if (first) {
                                context.object[meta].name.push(component);
                            } else if (last) {
                                context.parameter = component;
                            } else {
                                const [target, arg] = getTarget(component);
                                target[arg] = target[arg] ?? true;
                            }
                        }
                    }

                    if (components[0] === '') {
                        components.shift();
                        components.forEach((element, index) => {
                            const [name, value] = element.split(/\s*=\s*/);
                            //context.defaultParameters[index] = { name, value: interpret(value) };
                            context.defaultParameters[index] = { name, value: value };
                        });
                        contextStack.push(context);
                        line.content.forEach((child) => evaluate(child));
                        contextStack.pop();
                    } else if (components.length === 1) {
                        if (components[0].endsWith('=')) {
                            context.parameter = components[0].replace(/\s*=$/, '');
                            contextStack.at(-1).object[context.parameter] = contextStack.at(-1).object[context.parameter] || [];
                            contextStack.push(context);
                            line.content.forEach((item) => evaluate(item));
                            contextStack.pop();
                        } else if (line.value.includes(':') && !line.value.includes('=')) {
                            add(node);
                            node[meta].parent = context.object;
                            context.object = node;
                            const [name, ...typeNames] = (line.value ?? '').split(/\s*:\s*/g);

                            node[meta].name.push(name);
                            node[meta].type.push(...typeNames.flatMap((type) => (named[type] || find(type)) ?? []));
                            node[meta].type.push(...(node.type || []).flatMap((type) =>
                                typeof type === 'object' ? type : (named[type] || find(type)) ?? []));
                            named[name] = node;

                            contextStack.push(context);
                            line.content.forEach((item) => evaluate(item));
                            contextStack.pop();
                        } else if (components[0].includes('--')) {
                            const [start, type, end] = components[0].split(/\s*([<]?--[>]?)\s*/);
                            contextStack.push(context);
                            components.forEach((component, index) => addComponent(component, index === 0, index === components.length - 1));
                            line.content.forEach((item) => evaluate(item));
                        } else {
                            addComponent(components[0], false, true);
                            line.content.forEach((item) => evaluate(item));
                        }
                    } else if (components.length > 1) {
                        if (components[0].includes('--')) {
                            context.parameter = 'connections';
                            context.object.connections = context.object.connections || [];
                            const [start, type, end] = components[0].split(/\s*([<]?--[>]?)\s*/);
                            node.start = start;
                            node.end = end;
                            node.connectionType = type;
                        }
                        add(node);
                        node[meta].parent = context.object;
                        context.object = node;
                        if (components.at(-1).endsWith('=')) {
                            context.parameter = components.at(-1).replace(/\s*=$/, '');
                            components.pop();
                        }

                        contextStack.push(context);
                        components.forEach((component, index) => addComponent(component, index === 0, index === components.length - 1));

                        //const qualifiedName = node[meta].name[0] ?? node.name ?? components[0];
                        const qualifiedName = node.name ?? components[0];

                        line.content.forEach((item) => evaluate(item));

                        const [name, ...typeNames] = (qualifiedName + '').split(/\s*:\s*/g);
                        if (node.name) {
                            node.name = name;
                        }
                        node[meta].name.push(name);

                        node[meta].type = node[meta].type.flatMap((typeName) =>
                            (named[typeName] || find(typeName)) ?? []);

                        node[meta].type.push(...typeNames.flatMap((typeName) => (named[typeName] || find(tytypeNamepe)) ?? []));
                        if (node.type) {
                            node.type = [node.type].flatMap((type) => type);
                            node[meta].type.push(...(node.type.flatMap((type) =>
                                typeof type === 'object' ? type : (named[type] || find(type)) ?? [])));
                        }
                        node[meta].type.forEach((type) =>
                            type[content].forEach((typeComponent) =>
                                evaluate({ [meta]: typeComponent[meta], [content]: typeComponent[content] })));

                        contextStack.pop();

                        named[name] = node;
                        // Add remaining default values
                        while (context.parameters.length) {
                            const parameter = context.parameters.shift();
                            if (parameter.value !== undefined) {
                                context.object[parameter.name] = parameter.value;
                            }
                        }
                    }
                }
            };

            expanded.flatMap((node) => evaluate(node));

            const addInheritedProperties = (node) => {
                const stack = [node];
                node[meta].inherited[content] = [];
                while (stack.length > 0) {
                    const base = stack.shift();
                    node[meta].inherited[content].push(...base[meta].content)
                    stack.push(...base[meta].type);
                    Object.getOwnPropertyNames(base).forEach((property) =>
                        node[meta].inherited[property] = node[meta].inherited[property] ?? base[property]);
                }
                node[content].forEach((node) => addInheritedProperties(node));
            }

            graph[content].forEach((node) => addInheritedProperties(node));

            const interpretValues = (node) => {
                const instance = node[meta].instance;
                const attrs = instance.filter((instance) => instance.label);
                attrs.push(...instance.filter((instance) => instance.label).map((attr) => ({ label: `${attr.label}_n`, name: attr.index })));
                const instanceVariables = attrs.reduce((obj, attr) => {
                    obj[attr.label] = attr.name;
                    return obj;
                }, {});

                const resolve = (string) =>
                    string.replace ?
                        string.replace(/<([0-9]*)>/g, (match, num) => instance[parseInt(num) || 0]?.name ?? match)
                            .replace(/<n([0-9]*)>/g, (match, num) => instance[parseInt(num) || 0]?.index ?? match)
                            .replace(/<([^>]+)>/g, (match, val) => instanceVariables[val] ?? match)
                            .replace(/\{([^\}]+)\}/g, (match, expr) => {
                                try {
                                    const func = node[meta].common.functions[expr] || makeFunction(attrs.map((attr) => attr.label), expr);
                                    node[meta].common.functions[expr] = func;
                                    return func(...attrs.map((attr) => attr.name));
                                } catch (err) {
                                    report(err.message);
                                    return `${err.message}: ${match}`;
                                }
                            }) : string;
                Object.getOwnPropertyNames(node).forEach((property) =>
                    node[property] = interpret(resolve(node[property])));
                Object.getOwnPropertyNames(node[meta].inherited).forEach((property) =>
                    node[meta].inherited[property] = interpret(resolve(node[meta].inherited[property])));

                node[content].forEach(interpretValues);
                node[meta].name[0] = resolve(node[meta].name[0]);
            };

            graph[content].forEach(interpretValues);

            const addItems = (parent, node) => {
                node[content].forEach((node) => {
                    const getAttribute = (node, attribute) => node[attribute] || node[meta].inherited[attribute];
                    let item = parent;
                    if (getAttribute(node, 'position')) {
                        if (getAttribute(node, 'obj')) {
                            node[meta].representation = loadOBJ(getAttribute(node, 'obj'));
                            item = node[meta].representation;
                        } else if (getAttribute(node, 'size')) {
                            const box = Box.make(parent, node);
                            parent.content.push(box);
                            app.boxes.push(box);
                            node[meta].representation = box;
                            item = box;
                        } else if (getAttribute(node, 'radius')) {
                            const cylinder = Cylinder.make(parent, node);
                            parent.content.push(cylinder);
                            app.cylinders.push(cylinder);
                            node[meta].representation = cylinder;
                            item = cylinder;
                        } else {
                            const shape = new Box(parent,
                                node[meta].name,
                                getAttribute(node, 'position'),
                                [0, 0, 0],
                                0,
                                [0, 1, 0],
                                [0, 0, 0],
                                [1, 0, 1],
                                0.1,
                                10,
                                node);
                            parent.content.push(shape);
                            item = shape;
                        }
                    }
                    addItems(item, node);
                });
                (node.connections || []).forEach((connection) => {
                    if (connection.start && connection.end) {
                        const start = node[content].find((node) => node[meta].name.includes(connection.start));
                        const end = node[content].find((node) => node[meta].name.includes(connection.end));
                        if (start && end) {
                            app.connections.push(new Connection(start[meta].representation, end[meta].representation));
                        }
                    }
                })
            }
            graph[content].forEach((node) => {
                if (node.position) {
                    let root;
                    if (getAttribute(node, 'obj')) {
                        loadOBJ(getAttribute(node, 'obj'));
                        //node[meta].representation = root;
                    } else if (getAttribute(node, 'size')) {
                        root = Box.make(parent, node);
                        app.boxes.push(root);
                    } else if (getAttribute(node, 'radius')) {
                        root = Cylinder.make(parent, node);
                        app.cylinders.push(root);
                    }
                    if (parent) {
                        parent.content.push(root);
                    }
                    if (root) {
                        node[meta].representation = root;
                        app.roots.push(root);
                        addItems(root, node);
                    }
                }
            });
            showModel(graph);
            initialiseBoxes();
            initialiseCylinders();
            updateText();
            showStructure();
            showStock();
        }

        /**
         * Convert a range specifier to a list.
         */
        function getList(definition) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*:\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(definition);
            const list = [];
            if (isNaN(count)) {
                list.push(...definition.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return item.trim();
                }));
            } else {
                for (let i = 1; i <= count; ++i) {
                    list.push(i);
                }
            }
            return list;
        }

        const mathFunctions = Object.getOwnPropertyNames(Math).reduce((context, key) => {
            context[key] = Math[key];
            return context;
        }, {});

        function zeroPad(string, chars) {
            return (string + '').padStart(chars, '0');
        }

        /**
         * Create a function from the given string include math functions.
         */
        const exprFunctions = [...Object.keys(mathFunctions), 'zeroPad'];
        const exprParameters = [...Object.values(mathFunctions), zeroPad];
        function makeFunction(args, expr) {
            try {
                const func = new Function(...exprFunctions, ...args, `return ${expr};`);
                return (...args) =>
                    func(...exprParameters, ...args);
            } catch (error) {
                report(error.message);
            }
        }


        /**
         * Make a test graph.
         */
        function makeGraph(source, replace) {
            if (source) {
                if (replace) {
                    app.boxes = [];
                    app.roots = [];
                    app.stock = {};
                }
                app.nodes.forEach((node) => {
                    const items = node.content.filter((child) => child[meta].name[0].startsWith('#'));
                    if (items.length) {
                        app.stock[node[meta].name[0]] = app.stock[node[meta].name[0]] || new Map();

                        items.forEach((item) => {
                            const [name, loc] = item[meta].name[0].replace(/^#\s*/, '').split(/\s*->\s*/);
                            if (app.stock[node[meta].name[0]].has(name) && loc !== app.stock[node[meta].name[0]].get(name)) {
                                report(`Warning part ${name} in two locations (${app.stock[node[meta].name[0]].get(name)} and ${loc})!`);
                            } else {
                                app.stock[node[meta].name[0]].set(name, loc);
                            }
                        });
                    }
                });

                const addNode = (parent, node) => {
                    if (node[meta].name[0].startsWith('~')) {
                        parent.parts = parent.parts || [];
                        parent.parts.push(node[meta].name[0].replace(/^~\s*/, '').toLowerCase());
                    } else {
                        const box = Box.make(parent, node);
                        parent.content.push(box);
                        app.boxes.push(box);
                        node.content.forEach((node) => addNode(box, node));
                    }
                }
                source.forEach((node) => {
                    const root = Box.make(undefined, node);
                    app.boxes.add(root);
                    app.roots.add(root);
                    node.content.forEach((child) => addNode(root, child));
                });
                initialiseBoxes();
                initialiseCylinders();
            } else {
                const root = Box.make({
                    [meta]: { name: ['cube'] },
                    [content]: [],
                    name: 'cube',
                    position: [0, 0, 0],    // Position
                    size: [1, 1, 1]
                });
                app.boxes.push(root);
                app.roots.push(root);
            }

            //app.quads.push(new Quad(undefined, 'Quad', [0, 0, 0], [1, 2, 0]));
            initialiseQuads();
            showStructure();
            updateText();
        }

        /**
         * Return a normalised version of the given vector.
         */
        function normalised(vector) {
            const l = Math.hypot(...vector);
            return vector.map((i) => i / l);
        }

        /**
         * Return vector A scaled by s
         */
        function scale(vector, scale) {
            return vector.map((v) => v * scale);
        }

        /**
         * Return matrix scaled by s to the unity matrix
         */
        function scaleMatrix(matrix, scale) {
            const ident = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            return matrix.map((v, i) => v + (ident[i] - v) * scale);
        }

        /**
         * Component-wise sum of vectors
         */
        function sum(...vectors) {
            const length = Math.max(...vectors.map((v) => v.length));
            const result = [];
            for (let i = 0; i < length; ++i) {
                result.push(vectors.reduce((s, v) => s + (v[i] ?? 0), 0));
            }
            return result;
        }

        /**
         * Component-wise sum of vectors
         */
        function add(target, ...vectors) {
            const length = Math.max(...vectors.map((v) => v.length));
            vectors.forEach((vector) => vector.forEach((value, index) => target[index] += (value ?? 0)));
            return target;
        }

        /**
         * Return vector A minus vector B
         */
        function subtract(a, b) {
            return a.map((v, i) => v - b[i]);
        }

        /**
         * Component-wise product of vectors
         */
        function product(v1, v2) {
            return v1.map((v, i) => v * v2[i]);
        }

        /**
         * Return the dot product of two vectors
         */
        function dot(v1, v2) {
            return v1.reduce((s, v, i) => s + v * v2[i], 0);
        }

        /**
         * Return the cross product of two vectors
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0],
            ];
        }

        /**
         * Apply a transform by multiplying a vector by a matrix
         */
        function applyTransform(vector, matrix) {
            return [
                matrix[0] * vector[0] + matrix[4] * vector[1] + matrix[8] * vector[2] + matrix[12],
                matrix[1] * vector[0] + matrix[5] * vector[1] + matrix[9] * vector[2] + matrix[13],
                matrix[2] * vector[0] + matrix[6] * vector[1] + matrix[10] * vector[2] + matrix[14],
            ];
        }

        /**
         * Apply a transform by multiplying a vector by a matrix
         */
        function applyTransform4(vector, matrix) {
            return [
                matrix[0] * vector[0] + matrix[4] * vector[1] + matrix[8] * vector[2] + matrix[12] * vector[3],
                matrix[1] * vector[0] + matrix[5] * vector[1] + matrix[9] * vector[2] + matrix[13] * vector[3],
                matrix[2] * vector[0] + matrix[6] * vector[1] + matrix[10] * vector[2] + matrix[14] * vector[3],
                matrix[3] * vector[0] + matrix[7] * vector[1] + matrix[11] * vector[2] + matrix[15] * vector[3],
            ];
        }

        /**
         * Return the result of multiplying 2 4x4 matrices
         */
        function matrixMultiply(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
            ];
        }

        /**
         * Calculate the inverse of a 4x4 matrix.
         * 
         * Input: 16 element array
         * Output: 16 element array
         */
        function invert(matrix) {
            const a0 = matrix[0] * matrix[5] - matrix[1] * matrix[4];
            const a1 = matrix[0] * matrix[6] - matrix[2] * matrix[4];
            const a2 = matrix[0] * matrix[7] - matrix[3] * matrix[4];
            const a3 = matrix[1] * matrix[6] - matrix[2] * matrix[5];
            const a4 = matrix[1] * matrix[7] - matrix[3] * matrix[5];
            const a5 = matrix[2] * matrix[7] - matrix[3] * matrix[6];
            const b0 = matrix[8] * matrix[13] - matrix[9] * matrix[12];
            const b1 = matrix[8] * matrix[14] - matrix[10] * matrix[12];
            const b2 = matrix[8] * matrix[15] - matrix[11] * matrix[12];
            const b3 = matrix[9] * matrix[14] - matrix[10] * matrix[13];
            const b4 = matrix[9] * matrix[15] - matrix[11] * matrix[13];
            const b5 = matrix[10] * matrix[15] - matrix[11] * matrix[14];
            const invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

            return [
                (+matrix[5] * b5 - matrix[6] * b4 + matrix[7] * b3) * invdet,
                (-matrix[1] * b5 + matrix[2] * b4 - matrix[3] * b3) * invdet,
                (+matrix[13] * a5 - matrix[14] * a4 + matrix[15] * a3) * invdet,
                (-matrix[9] * a5 + matrix[10] * a4 - matrix[11] * a3) * invdet,
                (-matrix[4] * b5 + matrix[6] * b2 - matrix[7] * b1) * invdet,
                (+matrix[0] * b5 - matrix[2] * b2 + matrix[3] * b1) * invdet,
                (-matrix[12] * a5 + matrix[14] * a2 - matrix[15] * a1) * invdet,
                (+matrix[8] * a5 - matrix[10] * a2 + matrix[11] * a1) * invdet,
                (+matrix[4] * b4 - matrix[5] * b2 + matrix[7] * b0) * invdet,
                (-matrix[0] * b4 + matrix[1] * b2 - matrix[3] * b0) * invdet,
                (+matrix[12] * a4 - matrix[13] * a2 + matrix[15] * a0) * invdet,
                (-matrix[8] * a4 + matrix[9] * a2 - matrix[11] * a0) * invdet,
                (-matrix[4] * b3 + matrix[5] * b1 - matrix[6] * b0) * invdet,
                (+matrix[0] * b3 - matrix[1] * b1 + matrix[2] * b0) * invdet,
                (-matrix[12] * a3 + matrix[13] * a1 - matrix[14] * a0) * invdet,
                (+matrix[8] * a3 - matrix[9] * a1 + matrix[10] * a0) * invdet];
        }


        /**
         * Extract translation from a transformation matrix
         */
        function extractTranslation(matrix) {
            return [matrix[12], matrix[13], matrix[14]];
        }

        /**
         * Extract scale vector from a transformation matrix
         */
        function extractScale(matrix) {
            return [
                Math.hypot(matrix[0], matrix[1], matrix[2]),
                Math.hypot(matrix[4], matrix[5], matrix[6]),
                Math.hypot(matrix[8], matrix[9], matrix[10])];
        }

        /**
         * Extract rotation from a transformation matrix
         */
        function extractRotation(matrix, scale) {
            scale = scale || extractScale(matrix);
            return [
                matrix[0] / scale[0], matrix[1] / scale[0], matrix[2] / scale[0], 0,
                matrix[4] / scale[1], matrix[5] / scale[1], matrix[6] / scale[1], 0,
                matrix[8] / scale[2], matrix[9] / scale[2], matrix[10] / scale[2], 0,
                0, 0, 0, 1,
            ];
        }

        /**
         * Extract quaternion from a rotation matrix
         */
        function extractQuaternion(rotation) {
            const tr = rotation[0] + rotation[5] + rotation[10];
            const quaternion = {};

            // From: https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
            if (tr > 0) {
                const S = Math.sqrt(tr + 1.0) * 2; // S=4*quaternion.w 
                quaternion.w = 0.25 * S;
                quaternion.x = (rotation[9] - rotation[6]) / S;
                quaternion.y = (rotation[2] - rotation[8]) / S;
                quaternion.z = (rotation[4] - rotation[1]) / S;
            } else if ((rotation[0] > rotation[5]) & (rotation[0] > rotation[10])) {
                const S = Math.sqrt(1.0 + rotation[0] - rotation[5] - rotation[10]) * 2; // S=4*quaternion.x 
                quaternion.w = (rotation[9] - rotation[6]) / S;
                quaternion.x = 0.25 * S;
                quaternion.y = (rotation[1] + rotation[4]) / S;
                quaternion.z = (rotation[2] + rotation[8]) / S;
            } else if (rotation[5] > rotation[10]) {
                const S = Math.sqrt(1.0 + rotation[5] - rotation[0] - rotation[10]) * 2; // S=4*quaternion.y
                quaternion.w = (rotation[2] - rotation[8]) / S;
                quaternion.x = (rotation[1] + rotation[4]) / S;
                quaternion.y = 0.25 * S;
                quaternion.z = (rotation[6] + rotation[9]) / S;
            } else {
                const S = Math.sqrt(1.0 + rotation[10] - rotation[0] - rotation[5]) * 2; // S=4*quaternion.z
                quaternion.w = (rotation[4] - rotation[1]) / S;
                quaternion.x = (rotation[2] + rotation[8]) / S;
                quaternion.y = (rotation[6] + rotation[9]) / S;
                quaternion.z = 0.25 * S;
            }
            return quaternion;
        }

        /**
         * Get angle and axis from a quaternion
         */
        function getAngleAxis(quaternion) {
            const radians = Math.acos(quaternion.w);
            const angle = 360 * radians / Math.PI;
            if (Math.abs(angle) > 0.0001) {
                const s = 1 / Math.sin(radians);
                const axis = [quaternion.x * s, quaternion.y * s, quaternion.z * s];
                return { angle, axis };
            }
            return { angle: 0, axis: [0, 1, 0] };
        }

        /**
         * Decompose a transform matrix into a translation, rotation and scale
         */
        function decompose(matrix) {
            const translation = extractTranslation(matrix);
            const scale = extractScale(matrix);
            const rotation = extractRotation(matrix, scale);
            const quaternion = extractQuaternion(rotation);
            const { angle, axis } = getAngleAxis(quaternion);
            return { translation, scale, angle, axis };
        }

        /**
         * Return the translation matrix based on vector transation.
         */
        function getTranslation(vector) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                vector[0], vector[1], vector[2], 1
            ];
        }

        /**
         * Return the scale matrix based on vector scales.
         */
        function getScale(vector) {
            return [
                vector[0], 0, 0, 0,
                0, vector[1], 0, 0,
                0, 0, vector[2], 0,
                0, 0, 0, 1
            ];
        }

        /**
         * Return the rotation matrix based on angle and axis.
         */
        function getRotation(angle, axis) {
            angle = angle * Math.PI / 360;
            const qw = Math.cos(angle);
            axis = normalised(axis);
            const qx = axis[0] * Math.sin(angle);
            const qy = axis[1] * Math.sin(angle);
            const qz = axis[2] * Math.sin(angle);

            return [
                1 - 2 * qy * qy - 2 * qz * qz,
                2 * qx * qy - 2 * qz * qw,
                2 * qx * qz + 2 * qy * qw,
                0,

                2 * qx * qy + 2 * qz * qw,
                1 - 2 * qx * qx - 2 * qz * qz,
                2 * qy * qz - 2 * qx * qw,
                0,

                2 * qx * qz - 2 * qy * qw,
                2 * qy * qz + 2 * qx * qw,
                1 - 2 * qx * qx - 2 * qy * qy,
                0,

                0, 0, 0, 1
            ];
        }

        /**
         * Get ray from screen position
         */
        function getRay(x, y) {
            const f = 1 / Math.tan(app.fov * Math.PI / 360);

            const w = canvas.clientWidth / 2;
            const h = canvas.clientHeight / 2;

            const zAxis = normalised(subtract(app.camera.lookAt, app.camera.position));
            const yAxis = normalised(app.camera.up);
            const xAxis = cross(zAxis, yAxis);

            const position = sum(scale(xAxis, x - w), scale(yAxis, h - y), scale(zAxis, h * f));
            const direction = normalised(position);

            return { point: app.camera.position, direction };
        }

        /**
         * Get the point of intersection of a plane and line
         */
        function planeIntercept(line, plane) {
            const v = subtract(plane.point, line.point);
            const n = dot(plane.normal, v) / dot(plane.normal, line.direction);
            return n;
        }

        /**
         * Determine the intercept of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalised(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start && start > -Infinity) {
                return [start, end];
            }
        }

        /**
         * Return a list of view objects the are intersected by the given line.
         * 
         * If 'all' is true include parents that are intersected, otherwise only the 'lowest' content that is intersected.
         * 
         */
        function getIntersection(line, all = false) {
            // Check whether a line passes within the radius of the bounding sphere
            const hits = [];
            const test = (instance) => {
                if (instance.intersects(line)) {
                    if (!instance.hidden && app.solid && !instance.state.transparent) {
                        hits.push(instance);
                    } else {
                        const content = instance.content.filter((child) => test(child));
                        if (!instance.hidden && (all || content.length === 0)) {
                            hits.push(instance);
                        }
                    }
                    return true;
                }
            };

            app.roots.forEach((instance) => test(instance));
            return hits;
        }

        /**
         * Sort the objects based on selection order
         */
        function sortSelection(hits) {
            const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));

            // Remove hits behind the camera. 
            //hits = hits.filter((child) => dot(app.camera.lookAt, subtract(child.points[0], app.camera.position) > 1));

            // Find the closest to the view position that isn't a parent
            const cmp = (a, b) => {
                if (a.content.length === 0 && b.content.length > 0) {
                    return -1;
                } else if (a.content.length > 0 && b.content.length === 0) {
                    return 1;
                }
                return dist(app.camera.position, a.points[0]) - dist(app.camera.position, b.points[0]);
            }
            hits.sort(cmp);
            return hits;
        }

        /**
         * Find the intersection of a ray and objects
         */
        function setSelected(hits) {
            if (hits.length) {
                hits = sortSelection(hits);
                if (event.shiftKey) {
                    if (event.ctrlKey) {
                        hits.forEach((shape) => shape.selected = true);
                    } else {
                        hits[0].selected = true;
                    }
                } else {
                    app.boxes.forEach((shape) => shape.selected = shape === hits[0]);
                }
                return hits;
            }
            app.boxes.forEach((shape) => shape.selected = false);
        }

        /**
         * Utility function to support downloading generated content.
         */
        function downloadText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }

        /**
         * Save the current state
         */
        function save() {
            const lines = [];
            lines.push(`>eye position = ${app.camera.position.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push(`>look at = ${app.camera.lookAt.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push(`>up = ${app.camera.up.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push('');

            const addInstance = (instance, level = 0) => {
                lines.push(`${''.padStart(level * 2, ' ')}${instance.asString()}`);
                instance.content.forEach((child) => addInstance(child, level + 1));
            };
            app.roots.forEach((root) => addInstance(root));
            downloadText(lines.join('\n'));
        }

        /**
         * Clear Selection
         */
        function clearSelection() {
            app.boxes.forEach((instance) => instance.selected = false);
            document.getElementById('info').innerHTML = '';
            document.getElementById('info').classList.add('hide');
            updateTextBuffer();
            app.colourUpdate = true;
        }

        /**
         * Rotate the selected item
         */
        function rotateSelected(angle, axis, local) {
            app.boxes.filter((instance) => instance.selected)
                .forEach((instance) => {
                    if (local) {
                        axis = applyTransform(axis, extractRotation(instance.origin));
                    }
                    instance.rotate(angle, axis);
                });
        }

        /**
         * Selected item(s) parent.
         */
        function selectParent() {
            const parents = app.boxes.flatMap((instance) => instance.selected ? (instance.parent ?? []) : []);
            if (!event.shiftKey) {
                app.boxes.forEach((instance) => instance.selected = false);
            }
            parents.forEach((instance) => instance.selected = true);
            app.boxesChanged = true;
            updateText();
            app.colourUpdate = true;
        }

        /**
         * 'Hide' the selected item(s).
         */
        function hideSelected() {
            app.boxes.filter((box) => box.selected)
                .forEach((box) => box.hidden = !box.hidden);
            app.boxes.forEach((box) => {
                const node = app.nodeMap.get(box)[0];
                if (box.hidden) {
                    node.classList.add('hidden');
                } else {
                    node.classList.remove('hidden');
                }
            });
            initialiseBoxes();
            initialiseCylinders();
        }

        /**
         * 'Hide' the unselected item(s).
         */
        function hideOthers() {
            app.boxes.forEach((box) => {
                box.hidden = !box.path.some((box) => box.selected);
                const node = app.nodeMap.get(box)[0];
                if (box.hidden) {
                    node.classList.add('hidden');
                } else {
                    node.classList.remove('hidden');
                }
            });
            initialiseBoxes();
            initialiseCylinders();
        }

        /**
         * 'Hide' the selected item(s).
         */
        function showAll() {
            app.boxes.forEach((box) => box.hidden = false);
            app.boxes.forEach((box) => {
                const node = app.nodeMap.get(box)[0];
                node.classList.remove('hidden');
            });
            initialiseBoxes();
            initialiseCylinders();
        }

        /**
         * Undo the last action
         */
        function undo() {
            historyPosition = historyPosition ?? history.length;
            if (historyPosition) {
                historyPosition -= 1;
            }
            if (history[historyPosition]) {
                history[historyPosition].undo();
            }
        }

        /**
         * Re do an action
         */
        function redo() {
            if (history[historyPosition]) {
                history[historyPosition].redo();
                historyPosition += 1;
            }
        }

        /**
         * Add the event handlers for the canvas.
         */
        function addCanvasEvents(canvas) {
            canvas.tabIndex = 0;
            canvas.addEventListener('keydown', (event) => {
                report(event.key);
                const altShiftMapping = {
                    X: (event) => rotateSelected(-45, [1, 0, 0], true),
                    Y: (event) => rotateSelected(-45, [0, 1, 0], true),
                    Z: (event) => rotateSelected(-45, [0, 0, 1], true),
                }

                const shiftMapping = {
                    ArrowUp: (event) => up(),
                    ArrowDown: (event) => up(-1),
                    ArrowLeft: (event) => right(-1),
                    ArrowRight: (event) => right(),
                    '+': (event) => newBlock(),
                    R: (event) => reset(),
                    W: (event) => app.solid = !app.solid,
                    X: (event) => rotateSelected(-45, [1, 0, 0]),
                    Y: (event) => rotateSelected(-45, [0, 1, 0]),
                    Z: (event) => rotateSelected(-45, [0, 0, 1]),
                }
                const ctrlMapping = {
                    ArrowUp: (event) => addBlocks([0, 1, 0]),
                    ArrowDown: (event) => addBlocks([0, -1, 0]),
                    ArrowLeft: (event) => addBlocks([-1, 0, 0]),
                    ArrowRight: (event) => addBlocks([1, 0, 0]),
                    l: (event) => document.getElementById('load-file').click(),
                    r: (event) => processDefinition(app.definition, true),
                    z: (event) => undo(),
                    Z: (event) => redo(),
                }
                const altMapping = {
                    ArrowUp: (event) => addBlocks([0, 0, -1]),
                    ArrowDown: (event) => addBlocks([0, 0, 1]),
                    ArrowLeft: (event) => addBlocks([-1, 0, 0]),
                    ArrowRight: (event) => addBlocks([1, 0, 0]),
                    x: (event) => rotateSelected(45, [1, 0, 0], true),
                    y: (event) => rotateSelected(45, [0, 1, 0], true),
                    z: (event) => rotateSelected(45, [0, 0, 1], true),
                }
                const mapping = {
                    ArrowUp: (event) => forward(),
                    ArrowDown: (event) => forward(-1),
                    ArrowLeft: (event) => rotateRight(-1),
                    ArrowRight: (event) => rotateRight(),
                    Escape: (event) => clearSelection(),
                    Delete: (event) => deleteBlocks(event),
                    a: (event) => showAll(event),
                    A: (event) => { app.showNames = !app.showNames; updateTextBuffer() },
                    b: (event) => setView([0, -1, 0], [0, 0, -1]),
                    c: (event) => { app.points = []; updatePoints(); },
                    f: (event) => setView([0, 0, 1]),
                    h: (event) => hideSelected(event),
                    H: (event) => hideOthers(event),
                    i: (event) => { app.solid = !app.solid; app.colourUpdate = true; },
                    l: (event) => setView([-1, 0, 0]),
                    p: (event) => selectParent(event),
                    q: (event) => document.querySelector('.texture-canvas').classList.toggle('hide'),
                    r: (event) => setView([1, 0, 0]),
                    s: (event) => save(),
                    t: (event) => setView([0, 1, 0], [0, 0, -1]),
                    u: (event) => upright(),
                    w: (event) => app.wireframe = !app.wireframe,
                    x: (event) => rotateSelected(45, [1, 0, 0]),
                    y: (event) => rotateSelected(45, [0, 1, 0]),
                    z: (event) => rotateSelected(45, [0, 0, 1]),
                }

                if (event.ctrlKey && ctrlMapping[event.key]) {
                    event.preventDefault();
                    ctrlMapping[event.key](event);
                } else if (event.shiftKey && event.altKey && altShiftMapping[event.key]) {
                    altShiftMapping[event.key](event);
                } else if (event.shiftKey && shiftMapping[event.key]) {
                    shiftMapping[event.key](event);
                } else if (event.altKey && altMapping[event.key]) {
                    event.preventDefault();
                    altMapping[event.key](event);
                } else {
                    mapping[event.key]?.(event);
                }
            });

            const mouseDown = (event) => {
                action.lastX = event.clientX;
                action.lastY = event.clientY;
                const mouseLine = getRay(event.clientX, event.clientY);
                const hits = setSelected(getIntersection(mouseLine));
                if (app.connections) {
                    app.connections.forEach((connection) => connection.selected = (connection.getDist(mouseLine) < 5));
                }
                for (const node of document.body.querySelectorAll('.selected')) {
                    node.classList.remove('selected');
                }
                if (hits && action.selected && event.ctrlKey) {
                    hits.forEach((hit) =>
                        app.connections.push(new Connection(action.selected, hit)));
                }
                action.selected = null;
                action.moved = false;
                if (event.button === 0 && hits) {
                    // Move the clicked object
                    const { xAxis, yAxis, zAxis, distance } = viewVectors();
                    action.selected = hits[0];
                    action.selected.showInfo();

                    action.selected.nodes[0].scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
                    if (action.selected.serialNumber) {

                    } else {
                        action.selected.state.selected = true;

                        report(action.selected.getModelName());
                        app.nodeMap.get(action.selected).forEach((node) => node.classList.add('selected'));
                        action.plane = { point: action.selected.points[0] };
                        if (Math.abs(dot(app.camera.up, [0, 1, 0])) > 0.9) {
                            action.plane.normal = zAxis;
                        } else {
                            action.plane.normal = [0, 1, 0];
                        }
                        const apply = (instance, action) => {
                            action(instance);
                            instance.content.forEach((child) => apply(child, action));
                        }
                        const selected = app.boxes.filter((instance) => instance.selected);
                        selected.forEach((instance) =>
                            instance.apply((instance) => instance.start = extractTranslation(instance.origin)));
                        if (app.mode === 'edit') {
                            action.move = (event) => {
                                app.boxes.forEach((instance) => instance.state.ghost = true);
                                action.selected.siblings.forEach((instance) => instance.state.constraint = true);
                                action.selected.state.moving = true;

                                action.moved = true;
                                const mouseLine = getRay(event.clientX, event.clientY);
                                const n = planeIntercept(mouseLine, action.plane);
                                const point = sum(mouseLine.point, scale(mouseLine.direction, n));
                                const delta = subtract(point, action.plane.point);

                                selected.forEach((selected) => {
                                    selected.statusColour = null;
                                    selected.move(delta);
                                    selected.update();
                                });
                            };
                        }
                        action.end = endMove;
                    }
                } else {
                    // Rotate the view
                    action.move = (event) => {
                        action.moved = true;
                        const deltaX = event.clientX - action.lastX;
                        const deltaY = event.clientY - action.lastY;
                        action.lastX = event.clientX;
                        action.lastY = event.clientY;
                        const sightLine = subtract(app.camera.lookAt, app.camera.position);
                        const xAxis = cross(sightLine, app.camera.up);
                        const yAxis = cross(sightLine, xAxis);
                        if (event.shiftKey) {
                            const dist = Math.hypot(...sightLine) / -1000;
                            const movement = sum(scale(normalised(xAxis), deltaX * dist), scale(normalised(yAxis), deltaY * dist));
                            app.camera.position = sum(app.camera.position, movement);
                            app.camera.lookAt = sum(app.camera.lookAt, movement);
                        } else {
                            const xRotation = getRotation(deltaY * Math.PI / 30, xAxis);
                            const yRotation = getRotation(deltaX * Math.PI / 30, app.camera.up);
                            const rotation = multiply(xRotation, yRotation);
                            app.camera.position = subtract(app.camera.lookAt, applyTransform(sightLine, rotation));
                            app.camera.up = applyTransform(app.camera.up, rotation);
                        }
                        app.viewMatrix = viewMatrix(app.camera.position, app.camera.lookAt, app.camera.up);
                        app.camera.updateViewControls();
                    };
                    const start = {
                        position: [...app.camera.position],
                        lookAt: [...app.camera.lookAt],
                        up: [...app.camera.up],
                    };
                    action.end = () => {
                        action.move = highlightFace;
                        const end = {
                            position: [...app.camera.position],
                            lookAt: [...app.camera.lookAt],
                            up: [...app.camera.up],
                        };
                        if (action.moved) {
                            history.push({
                                undo: () => moveCamera(start.position, start.lookAt, start.up),
                                redo: () => moveCamera(end.position, end.lookAt, end.up),
                            });
                        }
                    }
                }
                app.colourUpdate = true;
                updateTextBuffer();
                updatePoints();
            };
            canvas.addEventListener('mousedown', (event) => mouseDown(event));
            canvas.addEventListener('touchstart', (event) => mouseDown(touch(event)));
            canvas.addEventListener('wheel', (event) => {
                report(`Wheel (${event.deltaY})`);
                event.preventDefault();
                const dist = -event.deltaY / 30;

                const sightLine = subtract(app.camera.lookAt, app.camera.position);

                const current = (app.movement?.distance?.remaining ?? 0) / Math.hypot(...sightLine);
                const offset = scale(sightLine, dist);
                const position = add(app.camera.position, offset);
                const lookAt = add(app.camera.lookAt, offset);

                moveCamera(position, lookAt, app.camera.up);
            });

            /**
             * Process a dropped file
             */
            function dropHandler(event) {
                dragPart = false;
                app.boxes.forEach((instance) => instance.state = {});

                event.preventDefault();
                const replace = event.shiftKey;

                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        app.definition = reader.result;
                        processDefinition(app.definition, replace);
                    });
                    reader.readAsText(file);
                }

                if (event.dataTransfer.items) {
                    [...event.dataTransfer.items].forEach((item, index) => {
                        if (item.kind === 'file') {
                            const file = item.getAsFile();
                            loadFile(file);
                            item.getAsFileSystemHandle().then((handle) => {
                                //saveFileHandles([{ name: file.name, handle }]);
                            });
                        }
                    });
                } else {
                    // Use DataTransfer interface to access the file(s)
                    [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
                }
                const types = event.dataTransfer.types;
                if (types.length) {
                    const mouseLine = getRay(event.clientX, event.clientY);
                    const hits = getIntersection(mouseLine).filter((instance) => instance.parts?.includes(types[0]));
                    if (hits.length) {
                        const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));
                        hits.sort((a, b) => dist(app.camera.position, a.points[0]) - dist(app.camera.position, b.points[0]));
                        if (hits[0]) {
                            hits[0].serialNumber = event.dataTransfer.getData(types[0]);
                            hits[0].colour = [1, 0, 0];
                            hits[0].showInfo();
                        }
                    }
                }
                app.colourUpdate = true;
            }

            let dragPart = false;
            function dragOverHandler(event) {
                // Prevent default behavior (Prevent file from being opened)
                event.preventDefault();
                const types = event.dataTransfer.types;
                if (types.length) {
                    const mouseLine = getRay(event.clientX, event.clientY);
                    const hits = getIntersection(mouseLine).filter((instance) => instance.parts?.includes(types[0]));
                    if (hits.length) {
                        const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));
                        hits.sort((a, b) => dist(app.camera.position, a.points[0]) - dist(app.camera.position, b.points[0]));
                    }
                    app.boxes.forEach((instance) => {
                        instance.state.highlight = instance === hits[0];
                        instance.state.hasPart = instance.serialNumber;
                        instance.state.constraint = instance.parts?.includes(types[0]);
                        instance.state.ghost = true;
                    });
                    app.colourUpdate = true;
                }
            }

            canvas.addEventListener('dragover', dragOverHandler);
            canvas.addEventListener('drop', dropHandler);
        }

        /**
         * Process definition
         */
        function processDefinition(definition, replace) {
            processText(definition, undefined, replace);
            const { xAxis, yAxis, zAxis, distance } = viewVectors();
            app.camera.up = yAxis;
        }

        /**
         * Load file
         */
        async function loadFile(url) {
            const result = await fetch(url);
            const content = await result.text();
            processDefinition(content);
        }

        /**
         * Perform all once off set-up (e.g. creating buffer etc.)
         */
        function initialise() {
            addMovementControls();
            projectionControl();
            addLightControls();
            viewControl(document.getElementById('view-vectors'));
            addCanvasEvents(canvas);

            // Set clear color to black, fully opaque
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            // Should be update to track canvas size changes
            gl.canvas.width = gl.canvas.clientWidth;
            gl.canvas.height = gl.canvas.clientHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            const attributes = ['position', 'normal', 'model', 'ambientColour', 'diffuseColour', 'specularColour', 'specularIntensity', 'opacity'];
            app.shader = makeProgram(shaderSource, attributes, ['projection', 'view', 'lightPosition1', 'lightPosition2', 'lightPosition3', 'cameraPosition']);
            app.textShader = makeProgram(textShaderSource, ['position', 'model', 'offset', 'size', 'textureSize', 'textureOrigin', 'colour',],
                ['projection', 'view', 'texture']);


            app.pbrShader = makeProgram(pbrShaderSource,
                ['model', 'normalMatrix', 'position', 'normal', 'colour', 'emissivityColour', 'roughness', 'reflectivity', 'opacity', 'metallic'],
                ['projection', 'view', 'lightPosition1', 'lightColour1', 'lightPosition2', 'lightColour2', 'lightPosition3', 'lightColour3', 'cameraPosition']
            );

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            app.buffers = {
                vertex: gl.createBuffer(),
                colour: gl.createBuffer(),
                boxes: gl.createBuffer(),
                cylinders: gl.createBuffer(),
                quads: gl.createBuffer(),
                points: gl.createBuffer(),
                lines: gl.createBuffer(),
                textInstance: gl.createBuffer(),
                textItems: gl.createBuffer(),
            };
            app.textTexture = gl.createTexture();
            initialiseText();

            const shape = makeCube();
            shape.push(...makeCylinder(CYLINDER_SIDES));
            shape.push(...makeQuad());

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);
            setBoxAttributes();
            setCylinderAttributes();
            setQuadAttributes();
            setPointAttributes();
            setLineAttributes();
            if (location.protocol === 'http:') {
                const source = location?.hash.replace(/^#/, '') || 'start.txt';
                loadFile(source);
            } else {
                makeGraph();
            }
            initialiseBoxes();
            initialiseCylinders();

            Icosphere.getFaces(5);
            app.icosphere = new Icosphere(undefined, 'icosphere', [1, 1, 1], 1, 0, [0, 1, 0], [0, 0, 0], [1, 0, 1], 1, 1, { [meta]: {} });

            const fileSelection = document.getElementById('load-file');
            fileSelection.addEventListener('change', (event) => {
                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        processText(reader.result);
                    });
                    reader.readAsText(file);
                }
                for (const file of fileSelection.files) {
                    loadFile(file);
                }
            });
            const save = document.getElementById('save');
            save.addEventListener('click', (event) => app.savePNG = true);

            addEventListener("hashchange", (event) => {
                const source = location?.hash.replace(/^#/, '') || 'start.txt';
                loadFile(source);
            });
        }

        /**
         * Called once html has loaded.
         *
         * Create the Webgl context, set up the buffers and call the event loop.
         */
        function main(event) {
            initialise();
            requestAnimationFrame(render);
            report(location.protocol);
        }

        window.addEventListener('load', main);
    </script>
</body>

</html>
