<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Instances</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            overflow: hidden;
        }

        #main-canvas {
            width: 100dvw;
            height: 100dvh;
        }

        #projection-control {
            position: absolute;
            background-color: white;
            display: grid;
            grid-template-columns: repeat(2, max-content);
            grid-template-rows: repeat(4, max-content);
            left: 0;
            top: 0;
        }

        #view-control {
            position: absolute;
            background-color: white;
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            right: 0;
            top: 0;
        }

        .matrix-input {
            width: 5em;
        }

        #projection-control>details {
            grid-column: 1 / -1;
        }

        #structure {
            display: grid;
            grid-template-columns: 10em repeat(7, max-content);
            grid-gap: 3px;
        }

        #structure span {
            text-align: center;
        }
    </style>
</head>

<body>
    <canvas id="main-canvas" tabindex="1">HTML canvas not supported!</canvas>

    <div id="projection-control">
        Field of View<input id="field-of-view" type="number" />
        Aspect<input id="aspect" type="number" />
        Near<input id="near" type="number" />
        Far<input id="far" type="number" />
        <details>
            <summary>Structure</summary>
            <div id="structure">
                <span>Name</span>
                <span>Position</span>
                <span>Size</span>
                <span>Angle</span>
                <span>Axis</span>
                <span>Colour</span>
                <span>Specular</span>
                <span>opacity</span>
            </div>
        </details>

    </div>
    <div id="view-control"></div>

    <script type="x-shader/x-vertex" id="vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in vec3 normal;
    in mat4 model;
    in vec3 ambientColour;
    in vec3 diffuseColour;
    in vec3 specularColour;
    in float specularIntensity;
    in float opacity;

    out vec4 v_vertex;
    out vec4 v_normal;
    out vec3 v_ambientColour;
    out vec3 v_diffuseColour;
    out vec3 v_specularColour;
    out float v_opacity;
    out float v_specularIntensity;

    void main() {
        v_vertex = model * vec4(position, 1.0);
        gl_Position = projection * view * v_vertex;
        v_normal = model * vec4(normal, 0.0);
        v_ambientColour = ambientColour;
        v_diffuseColour = diffuseColour;
        v_specularColour = specularColour;
        v_opacity = opacity;
        v_specularIntensity = specularIntensity;

        gl_PointSize = 50.0 * model[0][0];
    }
  </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
    #version 300 es
    precision highp float;
    uniform vec3 lightPosition1;
    uniform vec3 lightPosition2;
    uniform vec3 lightPosition3;
    uniform vec3 eyePosition;

    in vec4 v_vertex;
    in vec4 v_normal;
    in vec3 v_ambientColour;
    in vec3 v_diffuseColour;
    in vec3 v_specularColour;
    in float v_specularIntensity;
    in float v_opacity;

    out vec4 fragmentColour;

    void main() {
        vec3 toLight1 = normalize(lightPosition1 - v_vertex.xyz);
        vec3 toLight2 = normalize(lightPosition2 - v_vertex.xyz);
        vec3 toLight3 = normalize(lightPosition3 - v_vertex.xyz);
        vec3 normal = normalize(v_normal.xyz);

        float df = max(0.0, dot(normal, toLight1)) + 0.2 * max(0.0, dot(normal, toLight2)) + 0.1 * max(0.0, dot(normal, toLight3));

        vec3 reflection1 = normalize(2.0 * dot(normal, toLight1) * normal - toLight1);
        vec3 reflection2 = normalize(2.0 * dot(normal, toLight2) * normal - toLight2);
        vec3 reflection3 = normalize(2.0 * dot(normal, toLight3) * normal - toLight3);
        vec3 toEye = normalize(eyePosition - v_vertex.xyz);
        float sf = clamp(dot(reflection1, toEye), 0.0, 1.0) + 0.2 * clamp(dot(reflection2, toEye), 0.0, 1.0) + 0.1 * clamp(dot(reflection3, toEye), 0.0, 1.0);
        sf = pow(sf, v_specularIntensity);

        vec3 colour = v_ambientColour + v_diffuseColour * df + v_specularColour * sf;
        //fragmentColour = vec4(colour, v_opacity);
        if (v_opacity > 0.0 && dot(normal, toEye) > -0.1) {
            discard;
            return;
        }
        fragmentColour = vec4(colour, 1.0);
    }
  </script>

    <script>
        /**
         * Create matrix control.
         */
        function projectionControl() {
            const fov = document.getElementById('field-of-view');
            fov.value = 90;
            const aspect = document.getElementById('aspect');
            aspect.value = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const near = document.getElementById('near');
            near.value = 0;
            const far = document.getElementById('far');
            far.value = 10;

            const update = () => {
                app.projectionMatrix = perspective(
                    fov.valueAsNumber,
                    aspect.valueAsNumber,
                    near.valueAsNumber,
                    far.valueAsNumber);
            }
            fov.addEventListener('change', (event) => update());
            aspect.addEventListener('change', (event) => update());
            near.addEventListener('change', (event) => update());
            far.addEventListener('change', (event) => update());
            update();
        }

        /**
         * Create matrix control.
         */
        function viewControl() {
            const container = document.getElementById('view-control');

            const update = () => {
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
            }

            const vectorControl = (vector, name) => {
                vector.forEach((value, index) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = value;
                    input.id = `${name}-${index}`;
                    input.classList.add('matrix-input');
                    input.addEventListener('change', (event) => {
                        vector[index] = input.valueAsNumber;
                        update();
                    });
                    container.appendChild(input);
                });
            };
            app.eyePosition = [0, 0, 2];
            app.lookAt = [0, 0, 0];
            app.up = [0, 1, 0];
            vectorControl(app.eyePosition, 'eye-position')
            vectorControl(app.lookAt, 'look-at');
            vectorControl(app.up, 'up');
            update();
            app.updateViewControls = () => {
                document.getElementById('eye-position-0').value = app.eyePosition[0].toFixed(1);
                document.getElementById('eye-position-1').value = app.eyePosition[1].toFixed(1);
                document.getElementById('eye-position-2').value = app.eyePosition[2].toFixed(1);

                document.getElementById('look-at-0').value = app.lookAt[0].toFixed(1);
                document.getElementById('look-at-1').value = app.lookAt[1].toFixed(1);
                document.getElementById('look-at-2').value = app.lookAt[2].toFixed(1);

                document.getElementById('up-0').value = app.up[0].toFixed(1);
                document.getElementById('up-1').value = app.up[1].toFixed(1);
                document.getElementById('up-2').value = app.up[2].toFixed(1);
            }
        }


        /**
         * This script manages a single gl context so intialise here for simplicity.
         */
        const canvas = document.getElementById('main-canvas');
        const gl = canvas.getContext('webgl2');

        /**
         * Utility function to parse and report errors
         */
        function glErrors(context = '') {
            const err = gl.getError();

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.trace();
                console.log(context, errors[err]);
            }
        }

        /**
         * App object to minimise global namespace polution.
         */
        const app = {
            projectionMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            viewMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            instances: [],
            scale: 0.001,
            roots: [],
            wireframe: false,
            cullFaces: true,
            addRoot(position, size, rotation, axis, colour, opacity, specular) {
                const root = new Instance(
                    undefined,
                    position,
                    size,
                    rotation,
                    axis,
                    colour,
                    opacity,
                    specular);
                this.instances.push(root);
                this.roots.push(root);
                return root;
            },
        };
        const shaderSource = {
            vertex: document.querySelector("#vertex-shader").innerHTML,
            fragment: document.querySelector("#fragment-shader").innerHTML,
        }


        /**
         * Create and compile a shader of the specified type using the source provided.
         */
        function makeShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source.trim());
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return;
            }
            return shader;
        }

        /**
         * Compile shaders into a program.
         */
        function makeProgram(source, attributes = [], uniforms = []) {
            const vertex = makeShader(gl.VERTEX_SHADER, source.vertex);
            const fragment = makeShader(gl.FRAGMENT_SHADER, source.fragment);

            // Create a program instance for the shaders
            if (vertex && fragment) {
                const shader = {
                    program: gl.createProgram(),
                };
                gl.attachShader(shader.program, vertex);
                gl.attachShader(shader.program, fragment);
                gl.linkProgram(shader.program);

                // See if it linked successfully
                if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
                    alert('Unable to initialise the shader program: ' + gl.getProgramInfoLog(shader.program));
                    return null;
                }

                uniforms.forEach((uniform) => shader[uniform] = gl.getUniformLocation(shader.program, uniform));
                attributes.forEach((attribute) => shader[attribute] = gl.getAttribLocation(shader.program, attribute));

                return shader;
            }
        }

        /**
         * Generate the vertex data for a cube.
         */
        function makeCube() {
            const positions = [
                [-1, -1, -1,],
                [1, -1, -1,],
                [-1, 1, -1,],
                [1, 1, -1,],
                [-1, -1, 1,],
                [1, -1, 1,],
                [-1, 1, 1,],
                [1, 1, 1,],
            ].map((v) => v.map((i) => i / 2));
            const normals = [
                [-1, 0, 0,],
                [0, -1, 0,],
                [0, 0, -1,],
                [1, 0, 0,],
                [0, 1, 0,],
                [0, 0, 1,],
            ];

            /*
            *       4 ------ 5
            *      /|        | \
            *    0 ------------ 1
            *    |  |        |  |
            *    |  |        |  |
            *    |  |        |  |
            *    |  6 ------ 7  |
            *    | /          \ |
            *    2 ------------ 3
            */

            const triangles = [
                { p1: positions[0], p2: positions[1], p3: positions[2], n: normals[2] },
                { p1: positions[1], p2: positions[3], p3: positions[2], n: normals[2] },

                { p1: positions[0], p2: positions[4], p3: positions[5], n: normals[1] },
                { p1: positions[5], p2: positions[1], p3: positions[0], n: normals[1] },

                { p1: positions[4], p2: positions[6], p3: positions[7], n: normals[5] },
                { p1: positions[5], p2: positions[4], p3: positions[7], n: normals[5] },

                { p1: positions[6], p2: positions[2], p3: positions[3], n: normals[4] },
                { p1: positions[7], p2: positions[6], p3: positions[3], n: normals[4] },

                { p1: positions[3], p2: positions[1], p3: positions[5], n: normals[3] },
                { p1: positions[5], p2: positions[7], p3: positions[3], n: normals[3] },

                { p1: positions[6], p2: positions[4], p3: positions[0], n: normals[0] },
                { p1: positions[6], p2: positions[0], p3: positions[2], n: normals[0] },
            ];
            const lines = [
                positions[0], positions[1],
                positions[1], positions[3],
                positions[3], positions[2],
                positions[2], positions[0],

                positions[0], positions[4],
                positions[1], positions[5],
                positions[2], positions[6],
                positions[3], positions[7],

                positions[4], positions[5],
                positions[5], positions[7],
                positions[7], positions[6],
                positions[6], positions[4],
            ];
            const normalised = ([x, y, z]) => {
                const l = Math.hypot(x, y, z);
                return [x / l, y / l, z / l];
            };
            return [...triangles.flatMap((t) => [...t.p1, ...t.n, ...t.p2, ...t.n, ...t.p3, ...t.n]),
            ...lines.flatMap((p) => [...p, ...normalised(p)])];
        }

        /**
         * Update the gl buffers used to define the base object used for instancing.
         */
        function updateObject() {

        }

        /**
         * Initialise Instances
         */
        function initialiseRandomInstances(instanceCount = 1) {
            const matrices = [];
            for (let i = 0; i < instanceCount; ++i) {
                matrices.push(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            }
            app.modelMatrix = new Float32Array(matrices); // 4 bytes per float, 16 floats per matrix
            app.modelMatrices = [];
            for (let i = 0; i < instanceCount; ++i) {
                app.modelMatrices.push(new Float32Array(app.modelMatrix.buffer, i * 16 * 4, 16));
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferData(gl.ARRAY_BUFFER, app.modelMatrix.byteLength, gl.DYNAMIC_DRAW);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }
            // setup colors, one per instance
            const colours = [
                [1, 0, 0],  // red
                [0, 1, 0],  // green
                [0, 0, 1],  // blue
                [1, 0, 1],  // magenta
                [0, 1, 1],  // cyan
            ];
            const colourBuffer = [];
            for (i = 0; i < instanceCount; ++i) {
                colourBuffer.push(...colours[Math.floor(Math.random() * colours.length)].map((v) => v * 0.3));
                colourBuffer.push(...colours[Math.floor(Math.random() * colours.length)].map((v) => v * 0.3));
                colourBuffer.push(...colours[Math.floor(Math.random() * colours.length)].map((v) => v * 1.0));
                colourBuffer.push(0.1 + 128 * Math.random());
                colourBuffer.push(Math.random());
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(colourBuffer),
                gl.STATIC_DRAW);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);

            app.instancesChanged = true;
            app.instances = [];
            const normalised = ([x, y, z]) => {
                const l = Math.hypot(x, y, z);
                return [x / l, y / l, z / l];
            };

            for (i = 0; i < instanceCount; ++i) {
                app.instances.push({
                    position: [1 - 2 * Math.random(), 1 - 2 * Math.random(), 2 * Math.random()].map((v) => v * 3),
                    size: [0.5 + 2 * Math.random(), 0.5 + 2 * Math.random(), 0.5 + 2 * Math.random()],
                    axis: normalised([Math.random(), Math.random(), Math.random()]),
                    rate: 1 - 2 * Math.random(),
                    offset: 10 * Math.random(),
                    matrix: new Float32Array(app.modelMatrix.buffer, i * 16 * 4, 16),
                });
            }
        }

        /**
         * Initialise Instances
         */
        function initialiseInstances() {
            const matrices = [];
            app.instances.forEach((instance) => matrices.push(...instance.transform));

            app.modelMatrix = new Float32Array(matrices); // 4 bytes per float, 16 floats per matrix
            app.instances.forEach((instance, index) =>
                instance.matrix = new Float32Array(app.modelMatrix.buffer, index * 16 * 4, 16));

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferData(gl.ARRAY_BUFFER, app.modelMatrix.byteLength, gl.DYNAMIC_DRAW);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }

            const colourBuffer = [];
            app.instances.forEach((instance, index) => {
                colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                colourBuffer.push(...instance.colour.map((v) => v * 1.0));
                colourBuffer.push(instance.specular);
                colourBuffer.push(app.wireframe || !app.cullFaces ? 0 : instance.children.length);
            });
            app.buffers.colour = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(colourBuffer),
                gl.STATIC_DRAW);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);

            app.instancesChanged = true;
        }


        /**
         * Add instance
         */
        function addInstance(size, position, rotation) {


        }

        /**
         * Calculate the product of 2 4 x 4 matrices and store the result in the third.
         */
        function multiply(a, b, matrix) {
            matrix = matrix || Array(16);
            matrix[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
            matrix[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
            matrix[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
            matrix[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

            matrix[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
            matrix[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
            matrix[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
            matrix[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

            matrix[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
            matrix[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
            matrix[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
            matrix[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

            matrix[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
            matrix[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
            matrix[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
            matrix[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
            return matrix;
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateInstances(time) {
            /*
            app.instances.forEach((instance, index) => {
                const matrix = instance.matrix;
                const scale = Math.sin(instance.offset + instance.rate * time / 3000);
                const angle = instance.rate * time / 2000;
                const qw = Math.cos(angle / 2)
                const qx = instance.axis[0] * Math.sin(angle / 2)
                const qy = instance.axis[1] * Math.sin(angle / 2)
                const qz = instance.axis[2] * Math.sin(angle / 2)

                function multiply(a, b) {
                    matrix[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
                    matrix[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
                    matrix[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
                    matrix[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

                    matrix[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
                    matrix[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
                    matrix[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
                    matrix[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

                    matrix[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
                    matrix[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
                    matrix[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
                    matrix[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

                    matrix[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
                    matrix[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
                    matrix[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
                    matrix[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
                }

                multiply([
                    1 - 2 * qy * qy - 2 * qz * qz,
                    2 * qx * qy - 2 * qz * qw,
                    2 * qx * qz + 2 * qy * qw,
                    0,

                    2 * qx * qy + 2 * qz * qw,
                    1 - 2 * qx * qx - 2 * qz * qz,
                    2 * qy * qz - 2 * qx * qw,
                    0,

                    2 * qx * qz - 2 * qy * qw,
                    2 * qy * qz + 2 * qx * qw,
                    1 - 2 * qx * qx - 2 * qy * qy,
                    0,

                    instance.position[0],
                    instance.position[1],
                    scale * instance.position[2],
                    1
                ], [
                    1 * instance.size[0], 0, 0, 0,
                    0, 1 * instance.size[1], 0, 0,
                    0, 0, 1 * instance.size[2], 0,
                    0, 0, 0, 1
                ]);
            });
            */
            app.instances.forEach((instance) => instance.transform.forEach((value, index) => instance.matrix[index] = value));
            // update the matrix data
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, app.modelMatrix);
        }

        /**
         * Update the object definition and the instances if required.
         */
        function updateBuffers(time) {
            if (app.objectChanged) {
                updateObject(time);
            }
            if (app.instancesChanged) {
                updateInstances(time);
                //app.instancesChanged = false;
            }
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            const f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zFar + zNear) / (zNear - zFar), -1,
                0, 0, (2 * zFar * zNear) / (zNear - zFar), 1,
            ];
        }

        /**
         * Calculate a view matrix from eye position, focus point and up vecotrs.
         */
        function viewMatrix(eyePosition, lookAt, up) {
            const normalised = ([x, y, z]) => {
                const l = Math.hypot(x, y, z);
                return [x / l, y / l, z / l];
            };
            const subtract = (v1, v2) => [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
            const dot = (v1, v2) => v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
            const cross = (v1, v2) => [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0],
            ];
            const negate = (v) => { v[0] = -v[0]; v[1] = -v[1]; v[2] = -v[2]; };
            const zaxis = normalised(subtract(lookAt, eyePosition));
            const xaxis = normalised(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eyePosition), -dot(yaxis, eyePosition), -dot(zaxis, eyePosition), 1
            ];
        }

        /**
         * Render loop function to update the display
         */
        let start;
        function render(time) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            if (start) {
                updateBuffers(time);
                gl.useProgram(app.shader.program);

                gl.uniformMatrix4fv(app.shader.projection, false, app.projectionMatrix);
                gl.uniformMatrix4fv(app.shader.view, false, app.viewMatrix);
                gl.uniform3fv(app.shader.eyePosition, app.eyePosition);
                gl.uniform3fv(app.shader.lightPosition1, [5, 5, 5]);
                gl.uniform3fv(app.shader.lightPosition2, [0.5, -0.5, 5]);
                gl.uniform3fv(app.shader.lightPosition3, [1, 15, 1]);

                if (!app.wireframe) {
                    gl.drawArraysInstanced(gl.TRIANGLES, 0, app.vertexCount, app.instances.length);
                }
                gl.drawArraysInstanced(gl.LINES, 36, 24, app.instances.length);
                glErrors();
            } else {
                start = time;
            }
            requestAnimationFrame(render);
        }


        /**
         * Manage an instance.
         */
        class Instance {
            constructor(parent, position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour = [0.5, 0.5, 0.5], opacity = 1, specular = 10) {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                this.parent = parent;
                if (position.name) {
                    this.name = position.name;
                    this.position = position.position;
                    this.size = position.size;
                    this.angle = position.angle;
                    this.axis = normalised(position.axis);
                    this.colour = position.colour;
                    this.opacity = position.opacity;
                    this.specular = position.specular;
                } else {
                    this.name = `Instance ${app.instances.length + 1}`;
                    this.position = position;
                    this.size = size;
                    this.angle = angle;
                    this.axis = normalised(axis);
                    this.colour = colour;
                    this.opacity = opacity;
                    this.specular = specular;
                }
                this.origin = Array(16);
                this.children = [];
                this.rate = 0;
                this.offset = 0;
                this.setTransform();
            }
            /**
             * Set the transform of a shape based on its position, rotation and scale.
             * 
             * Calculate the origin for children of the shape
             */
            setTransform() {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                const parent = this.parent || { origin: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
                const origin = parent.origin;
                const angle = this.angle * Math.PI / 360;
                const qw = Math.cos(angle);
                const axis = normalised(this.axis);
                const qx = axis[0] * Math.sin(angle);
                const qy = axis[1] * Math.sin(angle);
                const qz = axis[2] * Math.sin(angle);

                const translation = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    app.scale * this.position[0], app.scale * this.position[1], app.scale * this.position[2], 1
                ];
                const rotation = [
                    1 - 2 * qy * qy - 2 * qz * qz,
                    2 * qx * qy - 2 * qz * qw,
                    2 * qx * qz + 2 * qy * qw,
                    0,

                    2 * qx * qy + 2 * qz * qw,
                    1 - 2 * qx * qx - 2 * qz * qz,
                    2 * qy * qz - 2 * qx * qw,
                    0,

                    2 * qx * qz - 2 * qy * qw,
                    2 * qy * qz + 2 * qx * qw,
                    1 - 2 * qx * qx - 2 * qy * qy,
                    0,

                    0, 0, 0, 1
                ];
                const scale = [
                    app.scale * this.size[0], 0, 0, 0,
                    0, app.scale * this.size[1], 0, 0,
                    0, 0, app.scale * this.size[2], 0,
                    0, 0, 0, 1
                ];

                const rotationTranslate = multiply(rotation, translation);
                this.origin = multiply(rotationTranslate, origin);
                this.transform = multiply(scale, this.origin);
            }
            update(child) {
                this.setTransform();
                this.children.forEach((child) => child.update(true));
                app.instancesChanged = true;
                if (!child) {
                    const colourBuffer = [];
                    app.instances.forEach((instance, index) => {
                        colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                        colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                        colourBuffer.push(...instance.colour.map((v) => v * 1.0));
                        colourBuffer.push(instance.specular);
                        colourBuffer.push(app.wireframe || !app.cullFaces ? 0 : instance.children.length);
                    });
                    gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
                    gl.bufferData(gl.ARRAY_BUFFER,
                        new Float32Array(colourBuffer),
                        gl.STATIC_DRAW);
                }
            }
            addChild(position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour, opacity, specular) {
                const newInstance = new Instance(
                    this,
                    position,
                    size,
                    angle,
                    axis,
                    colour || this.colour,
                    opacity || this.opacity,
                    specular || this.specular);
                this.children.push(newInstance);
                app.instances.push(newInstance);
                return newInstance;
            }
            promote() {
                if (this.parent) {
                    const siblings = this.parent.children;
                    const position = siblings.indexOf(this);
                    const children = siblings.splice(position, siblings.length - position);
                    children.shift();
                    this.children.push(...children);
                    children.forEach((child) => child.parent = this);
                    this.update();
                    const list = this.parent.parent ? this.parent.parent.children : app.roots;
                    const pos = list.indexOf(this.parent);
                    list.splice(pos + 1, 0, this);
                    this.parent = this.parent.parent;
                }
            }
            demote() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position > 1) {
                    list.splice(position, 1);
                    list[position - 1].children.unshift(this);
                    this.parent = list[position - 1];
                    this.update();
                }
            }
            down() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position < list.length - 1) {
                    list.splice(position, 1);
                    list.splice(position + 1, 0, this);
                    this.update();
                }
            }
            up() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position > 0) {
                    list.splice(position, 1);
                    list.splice(position - 1, 0, this);
                    this.update();
                }
            }
        }

        const action = {};
        document.body.addEventListener('mousemove', (event) => action.move?.(event));
        document.body.addEventListener('mouseup', (event) => action.move = null);
        /**
         * Show structure
         */
        function showStructure() {
            const structure = document.getElementById('structure');
            structure.innerHTML = `<span>Name</span>
                <span>Position</span>
                <span>Size</span>
                <span>Angle</span>
                <span>Axis</span>
                <span>Colour</span>
                <span>Specular</span>
                <span>opacity</span>`;

            const addInstance = (instance, level = 0) => {
                const addControls = (node, item, element, scale) => {
                    node.contentEditable = true;
                    node.addEventListener('blur', (event) => {
                        if (isNaN(Number(item[element]))) {
                            item[element] = node.innerText;
                        } else {
                            item[element] = Number(node.innerText);
                        }
                    });
                    node.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            if (isNaN(Number(item[element]))) {
                                node.innerHTML = item[element];
                            } else {
                                node.innerHTML = item[element].toFixed();
                            }
                        }
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            if (event.shiftKey) {
                                instance.addChild([0, 0, 0], [1, 1, 1]);
                                initialiseInstances();
                                showStructure();
                            } else {
                                if (isNaN(Number(node.innerText))) {
                                    item[element] = node.innerText;
                                } else {
                                    item[element] = Number(node.innerText);
                                }
                                instance.update();
                            }
                        }
                        if (event.ctrlKey) {
                            if (event.key === 'ArrowLeft') {
                                instance.promote();
                                showStructure();
                            }
                            if (event.key === 'ArrowRight') {
                                instance.demote();
                                showStructure();
                            }
                            if (event.key === 'ArrowUp') {
                                instance.up();
                                showStructure();
                            }
                            if (event.key === 'ArrowDown') {
                                instance.down();
                                showStructure();
                            }
                        }
                    });

                    if (!isNaN(Number(item[element]))) {
                        const places = Math.floor(Math.log10(1 / scale));
                        node.addEventListener('mousedown', (event) => {
                            action.last = event.clientY;
                            action.move = (event) => {
                                const delta = (event.clientY - action.last) * scale;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.update();
                            };
                        });
                    }
                }
                const addSpan = (argument, scale = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scale));

                    const node = document.createElement('span');
                    if (isNaN(Number(instance[argument]))) {
                        node.innerHTML = instance[argument];
                    } else {
                        node.innerHTML = instance[argument].toFixed();
                    }
                    addControls(node, instance, argument, scale);
                    return node;
                }
                const addVec = (argument, scale = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scale));

                    const container = document.createElement('div');
                    instance[argument].forEach((item, index) => {
                        const node = document.createElement('span');
                        node.innerHTML = item.toFixed(places);
                        addControls(node, instance[argument], index, scale);
                        container.append(node, ', ');
                    });
                    return container;
                }
                const name = document.createElement('span');
                name.style.whiteSpace = 'pre';
                name.append(''.padStart(level * 2, ' '), addSpan('name'));
                structure.append(name,
                    addVec('position'),
                    addVec('size'),
                    addSpan('angle'),
                    addVec('axis'),
                    addVec('colour', 0.01),
                    addSpan('specular'),
                    addSpan('opacity'));
                instance.children.forEach((child) => addInstance(child, level + 1));
            }

            app.roots.forEach((child) => addInstance(child));
        }


        /**
         * Convert text to objects
         */
        function getObjects(text) {
            const lines = text.split(/\r?\n/g);
            return lines.flatMap((line) => {
                if (line.trim() !== '' && !line.trim().startsWith('#')) {
                    const [indentedName, positionStr, sizeStr, angleStr, axisStr, colourStr, specularStr, opacityStr, instances] = line.split(/\s*;\s*/);
                    const indent = indentedName.replace(/\S.*/, '');
                    const rangeName = indentedName.replace(/^\s+/, '');
                    const match = rangeName.match(/(\[(?<instances>[^\]]+)\]\s*)?(?<name>.*)/);
                    const name = match.groups.name;

                    let level = 0;
                    for (let i = 0; i < indent.length; ++i) {
                        if (indent[i] === '\t') {
                            level += 4 - (level % 4);
                        } else {
                            level += 1;
                        }
                    }
                    const position = positionStr ? positionStr.split(',') : null;
                    const size = sizeStr ? sizeStr.split(',') : null;
                    const angle = angleStr ? angleStr : null;
                    const axis = axisStr ? axisStr.split(',') : null;
                    const colour = colourStr ? colourStr.split(',') : null;
                    const specular = specularStr ? specularStr : null;
                    const opacity = opacityStr ? opacityStr : null;
                    return {
                        name, level, position, size, angle, axis, colour, specular, opacity, instances: instances ?? match.groups.instances, children: [],
                    };
                }
                return [];
            });
        }

        /**
         * Convert a list of objects into a tree structure based on the level of the objects
         */
        function getTree(objs) {
            const roots = [];
            const stack = [];
            const named = {};
            objs.forEach((obj) => {
                named[obj.name] = obj;
                const [name, type] = obj.name.split(/\s*:\s*/);
                if (type && named[type]) {
                    Object.getOwnPropertyNames(obj).forEach((property) => {
                        obj[property] = obj[property] ?? named[type][property];
                    });
                    obj.children.push(...named[type].children.map((child) => Object.assign({}, child)));
                }
                while (stack.length && obj.level <= stack[0].level) {
                    stack.shift();
                }
                if (stack.length > 0) {
                    stack[0].children.push(obj);
                    obj.parent = stack[0];
                } else {
                    roots.push(obj);
                }
                stack.unshift(obj);
            });
            return roots;
        }


        /**
         * Convert a range specifier to a list.
         */
        function getList(definition) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*:\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(definition);
            const list = [];
            if (isNaN(count)) {
                list.push(...definition.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return Number(item.trim());
                }));
            } else {
                for (let i = 1; i <= count; ++i) {
                    list.push(i);
                }
            }
            return list;
        }

        /**
         * Expand a template graph to a full graph.
         */
        function expandGraph(templateGraph) {
            const expand = (node, context = []) => {
                const resolve = (value, context) => {
                    if (isNaN(Number(value))) {
                        value = value.replace(/<([0-9]*)>/g, (match, level) => context[parseInt(level) || 0]);
                        const func = new Function(`return ${value};`);
                        return func();
                    }
                    return Number(value);
                }
                const makeInstance = (node, context) => ({
                    name: node.name,
                    position: node.position.map((v) => resolve(v, context)),
                    size: node.size.map((v) => resolve(v, context)),
                    angle: resolve(node.angle, context),
                    axis: node.axis.map((v) => resolve(v, context)),
                    colour: node.colour.map((v) => resolve(v, context)),
                    specular: resolve(node.specular, context),
                    opacity: resolve(node.opacity, context),
                    children: node.children.flatMap((child) => expand(child, context)),
                });

                if (node.instances) {
                    const instances = getList(node.instances);
                    if (node.position) {
                        return instances.flatMap((instance) => makeInstance(node, [instance, ...context]));
                    } else {
                        return instances.flatMap((instance, index) => node.children.flatMap((child) => expand(child, [instance, ...context])));
                    }
                } else if (node.position) {
                    return makeInstance(node, context);
                }
                return [];
            }

            return templateGraph.flatMap((node) => expand(node));
        }

        /**
         * Make a test graph.
         */
        function makeGraph(source, replace) {
            if (source) {
                if (replace) {
                    app.instances = [];
                    app.roots = [];
                }
                const addNode = (parent, node) => {
                    const child = parent.addChild(node);
                    node.children.forEach((node) => addNode(child, node));
                }
                source.forEach((node) => {
                    const root = app.addRoot(node);
                    node.children.forEach((child) => addNode(root, child));
                });
                initialiseInstances();
                showStructure();
            } else {
                const root = app.addRoot(
                    [0, 0, 0],    // Position
                    [1, 1, 1],    // Size
                    0,            // Rotation
                    [0, 1, 0],    // Axis
                    [1, 1, 0],    // Colour
                    1.0,          // opacity
                    10.0);        // Specular
                const child = root.addChild([0, 0.75, 0], [0.5, 0.5, 0.5], 30);
                const grandchild = child.addChild([0.75, 0, 0], [1, 0.5, 0.5], 45, [1, 0, 0], [1, 0, 0]);
                const grandchild2 = child.addChild([0, 0, 0.5], [0.5, 0.5, 0.5]);
                const greatgrandchild = grandchild.addChild([0.25, 1.1, 0], [0.5, 1.5, 0.5]);
                showStructure();
            }
        }

        /**
         * Return a normalised version of the given vector.
         */
        function normalised(vector) {
            const l = Math.hypot(...vector);
            return vector.map((i) => i / l);
        }

        /**
         * Return vector A plus vector B
         */
        function add(a, b) {
            return a.map((v, i) => v + b[i]);
        }

        /**
         * Return vector A minus vector B
         */
        function subtract(a, b) {
            return a.map((v, i) => v - b[i]);
        }

        /**
         * Return the cross product of two vectors
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0],
            ];
        }

        /**
         * Apply a transform by multiplying a vector by a matrix
         */
        function transform(v, matrix) {
            return [
                matrix[0] * v[0] + matrix[4] * v[1] + matrix[8] * v[2] + matrix[12],
                matrix[1] * v[0] + matrix[5] * v[1] + matrix[9] * v[2] + matrix[13],
                matrix[2] * v[0] + matrix[6] * v[1] + matrix[10] * v[2] + matrix[14],
            ];
        }

        /**
         * Return the rotation matrix based on angle and axis.
         */
        function getRotation(angle, axis) {
            angle = angle * Math.PI / 180;
            const qw = Math.cos(angle);
            axis = normalised(axis);
            const qx = axis[0] * Math.sin(angle);
            const qy = axis[1] * Math.sin(angle);
            const qz = axis[2] * Math.sin(angle);

            return [
                1 - 2 * qy * qy - 2 * qz * qz,
                2 * qx * qy - 2 * qz * qw,
                2 * qx * qz + 2 * qy * qw,
                0,

                2 * qx * qy + 2 * qz * qw,
                1 - 2 * qx * qx - 2 * qz * qz,
                2 * qy * qz - 2 * qx * qw,
                0,

                2 * qx * qz - 2 * qy * qw,
                2 * qy * qz + 2 * qx * qw,
                1 - 2 * qx * qx - 2 * qy * qy,
                0,

                0, 0, 0, 1
            ];
        }


        /**
         * Add the event handlers for the canvas.
         */
        function addCanvasEvents(canvas) {
            canvas.tabIndex = 0;
            canvas.addEventListener('keydown', (event) => {
                if (event.key === 'w') {
                    app.wireframe = !app.wireframe;
                }
                if (event.key === 'i') {
                    app.cullFaces = !app.cullFaces;
                }
            });
            canvas.addEventListener('mousedown', (event) => {
                action.lastX = event.clientX;
                action.lastY = event.clientY;
                action.move = (event) => {
                    const deltaX = event.clientX - action.lastX;
                    const deltaY = event.clientY - action.lastY;
                    action.lastX = event.clientX;
                    action.lastY = event.clientY;
                    const sightLine = subtract(app.lookAt, app.eyePosition);
                    const xAxis = cross(sightLine, app.up);

                    const xRotation = getRotation(deltaY * Math.PI / 60, xAxis);
                    const yRotation = getRotation(deltaX * Math.PI / 60, app.up);
                    const rotation = multiply(xRotation, yRotation);
                    app.eyePosition = subtract(app.lookAt, transform(sightLine, rotation));
                    app.up = transform(app.up, rotation);
                    app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                    app.updateViewControls();
                };
            });
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const dist = Math.pow(2, event.deltaY / 100);
                const sightLine = subtract(app.lookAt, app.eyePosition);
                const move = sightLine.map((v) => v * dist);
                app.eyePosition = subtract(app.lookAt, move);
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                app.updateViewControls();
            });



            /**
             * Process a dropped file
             */
            function dropHandler(event) {
                event.preventDefault();
                const replace = event.shiftKey;

                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        const objs = getObjects(reader.result);
                        const tree = getTree(objs);
                        const graph = expandGraph(tree);
                        makeGraph(graph, replace);
                    });
                    reader.readAsText(file);
                }

                if (event.dataTransfer.items) {
                    [...event.dataTransfer.items].forEach((item, index) => {
                        if (item.kind === 'file') {
                            const file = item.getAsFile();
                            loadFile(file);
                            item.getAsFileSystemHandle().then((handle) => {
                                //saveFileHandles([{ name: file.name, handle }]);
                            });
                        }
                    });
                } else {
                    // Use DataTransfer interface to access the file(s)
                    [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
                }
            }

            function dragOverHandler(event) {
                // Prevent default behavior (Prevent file from being opened)
                event.preventDefault();
            }

            canvas.addEventListener('dragover', dragOverHandler);
            canvas.addEventListener('drop', dropHandler);
        }

        /**
         * Perform all once off set-up (e.g. creating buffer etc.)
         */
        function initialise() {
            projectionControl();
            viewControl(document.getElementById('view-control'));
            addCanvasEvents(canvas);

            // Set clear color to black, fully opaque
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            // Should be update to track canvas size changes
            gl.canvas.width = gl.canvas.clientWidth;
            gl.canvas.height = gl.canvas.clientHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            const attributes = ['position', 'normal', 'model', 'ambientColour', 'diffuseColour', 'specularColour', 'specularIntensity', 'opacity'];
            app.shader = makeProgram(shaderSource, attributes, ['projection', 'view', 'lightPosition1', 'lightPosition2', 'lightPosition3', 'eyePosition']);

            app.buffers = {
                vertex: gl.createBuffer(),
                instances: gl.createBuffer(),
                colours: gl.createBuffer(),
            };
            app.vertexCount = 36;
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            const shape = makeCube();
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);
            // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride = 3 * 4 * 2,  offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.normal);

            makeGraph();
            initialiseInstances();
            //initialiseRandomInstances();
            //gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);
        }

        /**
         * Called once html has loaded.
         * 
         * Create the Webgl contect, set up the buffers and call the event loop.
         */
        function main(event) {
            initialise();
            requestAnimationFrame(render);
        }

        window.addEventListener('load', main);
    </script>
</body>

</html>