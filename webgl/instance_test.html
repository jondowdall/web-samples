<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Instances</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            overflow: hidden;
        }

        #main-canvas {
            width: 100dvw;
            height: 100dvh;
        }

        #projection-control {
            position: absolute;
            background-color: white;
            display: grid;
            grid-template-columns: repeat(2, max-content);
            grid-template-rows: repeat(4, max-content);
            left: 0;
            top: 0;
        }

        #controls {
            position: absolute;
            right: 0;
            top: 0;
            display: flex;
            flex-direction: column;
            align-items: end;
        }

        #movement {
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            background-color: white;
        }

        #view-vectors {
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            background-color: white;
        }

        .matrix-input {
            width: 5em;
        }

        #projection-control>details {
            grid-column: 1 / -1;
        }

        #structure {
            display: grid;
            grid-template-columns: 10em repeat(7, max-content);
            grid-gap: 3px;
            overflow: auto;
            max-height: 50vh;
        }

        #structure .value {
            text-align: center;
        }

        #state {
            position: fixed;
            bottom: 1em;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 0.5em;
            padding: 0.3em;
        }

        #load-file {
            display: none;
        }

        .texture-canvas {
            display: none;
            position: fixed;
            top: 0;
            left: 400px;
            z-index: 1000;
        }

        .selected {
            font-weight: bold;
        }
    </style>
</head>

<body>
    <canvas id="main-canvas" tabindex="1">HTML canvas not supported!</canvas>

    <div id="projection-control">
        Field of View<input id="field-of-view" type="number" />
        Aspect<input id="aspect" type="number" />
        Near<input id="near" type="number" />
        Far<input id="far" type="number" />
        <details>
            <summary>Structure</summary>
            <div id="structure">
                <span>Name</span>
                <span>Position</span>
                <span>Size</span>
                <span>Angle</span>
                <span>Axis</span>
                <span>Colour</span>
                <span>Specular</span>
                <span>opacity</span>
            </div>
        </details>

    </div>
    <div id="controls">
        <input type="file" id="load-file" multiple />
        <div id="view-vectors"></div>
        <div id="movement">
            <button id="anti-clockwise">&#8634;</button>
            <button id="move-up">&#8593;</button>
            <button id="clockwise">&#8635;</button>

            <button id="move-left">&#8592;</button>
            <button id="clear">&#9114;</button>
            <button id="move-right">&#8594;</button>

            <button id="move-forward">&#8634;</button>
            <button id="move-down">&#8595;</button>
            <button id="move-backwards">&#8634;</button>
        </div>
    </div>
    <div id="state"></div>

    <script type="x-shader/x-vertex" id="vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in vec3 normal;
    in mat4 model;
    in vec3 ambientColour;
    in vec3 diffuseColour;
    in vec3 specularColour;
    in float specularIntensity;
    in float opacity;

    out vec4 v_vertex;
    out vec4 v_normal;
    out vec3 v_ambientColour;
    out vec3 v_diffuseColour;
    out vec3 v_specularColour;
    out float v_opacity;
    out float v_specularIntensity;

    void main() {
        v_vertex = model * vec4(position, 1.0);
        gl_Position = projection * view * v_vertex;
        v_normal = model * vec4(normal, 0.0);
        v_ambientColour = ambientColour;
        v_diffuseColour = diffuseColour;
        v_specularColour = specularColour;
        v_opacity = opacity;
        v_specularIntensity = specularIntensity;

        gl_PointSize = 5.0;//50.0 * model[0][0];
    }
    </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
    #version 300 es
    precision highp float;
    uniform vec3 lightPosition1;
    uniform vec3 lightPosition2;
    uniform vec3 lightPosition3;
    uniform vec3 eyePosition;

    in vec4 v_vertex;
    in vec4 v_normal;
    in vec3 v_ambientColour;
    in vec3 v_diffuseColour;
    in vec3 v_specularColour;
    in float v_specularIntensity;
    in float v_opacity;

    out vec4 fragmentColour;

    void main() {
        vec3 toLight1 = normalize(lightPosition1 - v_vertex.xyz);
        vec3 toLight2 = normalize(lightPosition2 - v_vertex.xyz);
        vec3 toLight3 = normalize(lightPosition3 - v_vertex.xyz);
        vec3 normal = normalize(v_normal.xyz);

        float df = max(0.0, dot(normal, toLight1)) + 0.2 * max(0.0, dot(normal, toLight2)) + 0.1 * max(0.0, dot(normal, toLight3));

        vec3 reflection1 = normalize(2.0 * dot(normal, toLight1) * normal - toLight1);
        vec3 reflection2 = normalize(2.0 * dot(normal, toLight2) * normal - toLight2);
        vec3 reflection3 = normalize(2.0 * dot(normal, toLight3) * normal - toLight3);
        vec3 toEye = normalize(eyePosition - v_vertex.xyz);
        float sf = clamp(dot(reflection1, toEye), 0.0, 1.0) + 0.2 * clamp(dot(reflection2, toEye), 0.0, 1.0) + 0.1 * clamp(dot(reflection3, toEye), 0.0, 1.0);
        sf = pow(sf, v_specularIntensity);

        vec3 colour = v_ambientColour + v_diffuseColour * df + v_specularColour * sf;
        fragmentColour = vec4(colour, v_opacity);
        /*
        if (v_opacity > 0.0 && dot(normal, toEye) > -0.1) {
            discard;
            return;
        }
        fragmentColour = vec4(colour, 1.0);
        */
    }
    </script>
    <script type="x-shader/x-fragment" id="text-vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in mat4 model;

    in vec2 offset;
    in vec2 size;
    in vec2 textureSize;
    in vec2 textureOrigin;

    in vec4 colour;

    out vec4 v_colour;
    out vec2 v_textureCoordinate;

    void main() {
        gl_Position = projection * view * model * vec4(position, 1.0);
        gl_Position = vec4(gl_Position.xy + offset * size * gl_Position.w, gl_Position.zw);

        vec2 textureOffset = (offset + vec2(1.0, -1.0)) / vec2(2.0, -2.0);
        v_textureCoordinate = textureOrigin + textureOffset * textureSize;

        v_colour = colour;
        gl_PointSize = 10.0;// * model[0][0];

    }
    </script>
    <script type="x-shader/x-fragment" id="text-fragment-shader">
    #version 300 es
    precision highp float;
    uniform sampler2D source;

    in vec2 v_textureCoordinate;
    in vec4 v_colour;

    out vec4 fragmentColour;

    void main() {
        fragmentColour = v_colour * texture(source, v_textureCoordinate);
                
        if (fragmentColour.r < 0.1) {
            discard;
            return;
        }
    }
    </script>

    <script>
        /**
         * Update report display.
         */
        function report(...text) {
            document.getElementById('state').innerText = text.join();
        }

        /**
         * Create matrix control.
         */
        function projectionControl() {
            const fov = document.getElementById('field-of-view');
            fov.value = 30;
            const aspect = document.getElementById('aspect');
            aspect.value = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const near = document.getElementById('near');
            near.value = 1;
            const far = document.getElementById('far');
            far.value = 10000;

            const update = () => {
                app.fov = fov.valueAsNumber;
                app.aspect = aspect.valueAsNumber;
                app.near = near.valueAsNumber;
                app.far = far.valueAsNumber;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            }
            fov.addEventListener('change', (event) => update());
            aspect.addEventListener('change', (event) => update());
            near.addEventListener('change', (event) => update());
            far.addEventListener('change', (event) => update());
            update();
        }

        /**
         * Get view vectors
         */
        function viewVectors() {
            const viewVector = subtract(app.lookAt, app.eyePosition);
            const scaled = Math.hypot(...viewVector) / 1000;
            const zAxis = normalised(viewVector);
            const xAxis = normalised(cross(zAxis, app.up));
            const yAxis = normalised(cross(xAxis, zAxis));
            return { xAxis, yAxis, zAxis, scaled };
        }

        /**
         * Move Forward.
         */
        function forward(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            app.velocity = add(app.velocity, scale(zAxis, amount * scaled));
        }

        /**
         * Move right.
         */
        function right(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            app.velocity = add(app.velocity, scale(xAxis, amount * scaled));
        }

        /**
         * Move up.
         */
        function up(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            app.velocity = add(app.velocity, scale(yAxis, -amount * scaled));
        }

        /**
         * Move up.
         */
        function clockwise(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            const rotation = getRotation(amount * -2, zAxis);
            app.up = applyTransform(yAxis, rotation);
            app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
            app.updateViewControls();
        }

        /**
         * Rotate right
         */
        function rotateRight(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            const rotation = getRotation(amount * -0.5, yAxis);
            app.rotation = multiply(app.rotation, rotation);
        }

        /**
         * Add a new block
         */
        function newBlock(offset) {
            const selected = app.instances.filter((instance) => instance.selected);
            if (selected.length) {

            } else {
                const newInstance = app.addRoot();
            }
            initialiseInstances()
            updateColours();
            showStructure();
        }

        /**
         * Add a block next to the current block
         */
        function addBlocks(offset) {
            const selected = app.instances.filter((instance) => instance.selected);
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            selected.forEach((selected) => {
                offset = applyTransform(offset, selected.rotation);
                const position = add(selected.position, product(selected.size, offset));
                const attributes = [
                    position,
                    selected.size,
                    selected.angle,
                    selected.axis,
                    selected.colour,
                    selected.opacity,
                    selected.specular
                ];
                if (selected.parent) {
                    const newInstance = selected.parent.addChild(...attributes);
                    newInstance.selected = true;
                } else {
                    const newInstance = app.addRoot(...attributes);
                    newInstance.selected = true;
                }
                selected.selected = false;
            });
            initialiseInstances()
            updateColours();
            updateText();
            showStructure();
        }

        /**
         * Add a block next to the current block
         */
        function deleteBlocks(offset) {
            const selected = app.instances.filter((instance) => instance.selected);
            selected.forEach((selected) => {
                selected.delete();
            });
            app.instances = app.instances.filter((instance) => !selected.includes(instance));
            initialiseInstances()
            updateColours();
            showStructure();
        }

        /**
         * Reset the view and clear teh points
         */
        function reset() {
            app.eyePosition = [0, 0, 15];
            app.lookAt = [0, 0, 0];
            app.up = [0, 1, 0];
            app.points = [];
        }

        /**
         * Add actions for the movement controls
         */
        function addMovementControls() {
            document.getElementById('anti-clockwise').addEventListener('click', (event) => clockwise(-1));
            document.getElementById('move-up').addEventListener('click', (event) => up());
            document.getElementById('clockwise').addEventListener('click', (event) => clockwise());

            document.getElementById('move-left').addEventListener('click', (event) => right(-1));
            document.getElementById('clear').addEventListener('click', (event) => reset());
            document.getElementById('move-right').addEventListener('click', (event) => right());

            document.getElementById('move-forward').addEventListener('click', (event) => forward());
            document.getElementById('move-down').addEventListener('click', (event) => up(-1));
            document.getElementById('move-backwards').addEventListener('click', (event) => forward(-1));
        }

        /**
         * Create matrix control.
         */
        function viewControl() {
            const container = document.getElementById('view-vectors');

            const update = () => {
                const { xAxis, yAxis, zAxis, scaled } = viewVectors();
                app.up = yAxis; // Ensure 'up' is perpendicular to look direction
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
            }

            const vectorControl = (attribute, name) => {
                app[attribute].forEach((value, index) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = value;
                    input.id = `${name}-${index}`;
                    input.classList.add('matrix-input');
                    input.addEventListener('input', (event) => {
                        app[attribute][index] = input.valueAsNumber;
                        update();
                    });
                    input.addEventListener('focus', (event) => app.editingViewControls = true);
                    input.addEventListener('blur', (event) => app.editingViewControls = false);
                    container.appendChild(input);
                });
            };
            app.eyePosition = [0, 0, 15];
            app.lookAt = [0, 0, 0];
            app.up = [0, 1, 0];
            viewVectors();
            vectorControl('eyePosition', 'eye-position')
            vectorControl('lookAt', 'look-at');
            vectorControl('up', 'up');
            update();
            app.updateViewControls = () => {
                if (!app.editingViewControls) {
                    document.getElementById('eye-position-0').value = app.eyePosition[0].toFixed(1);
                    document.getElementById('eye-position-1').value = app.eyePosition[1].toFixed(1);
                    document.getElementById('eye-position-2').value = app.eyePosition[2].toFixed(1);

                    document.getElementById('look-at-0').value = app.lookAt[0].toFixed(1);
                    document.getElementById('look-at-1').value = app.lookAt[1].toFixed(1);
                    document.getElementById('look-at-2').value = app.lookAt[2].toFixed(1);

                    document.getElementById('up-0').value = app.up[0].toFixed(1);
                    document.getElementById('up-1').value = app.up[1].toFixed(1);
                    document.getElementById('up-2').value = app.up[2].toFixed(1);
                }
            }
        }

        /**
         * This script manages a single gl context so intialise here for simplicity.
         */
        const canvas = document.getElementById('main-canvas');
        const gl = canvas.getContext('webgl2');

        /**
         * Utility function to parse and report errors
         */
        function glErrors(context = '') {
            const err = gl.getError();

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.trace();
                console.log(context, errors[err]);
            }
        }

        /**
         * App object to minimise global namespace polution.
         */
        const app = {
            projectionMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            viewMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            instances: [],
            points: [],
            text: [],
            scale: 1, //0.001,
            roots: [],
            wireframe: false,
            cullFaces: true,
            cornerOrigin: true,
            velocity: [0, 0, 0],
            rotation: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            addRoot(position, size, rotation, axis, colour, opacity, specular) {
                const root = new Instance(
                    undefined,
                    position,
                    size,
                    rotation,
                    axis,
                    colour,
                    opacity,
                    specular);
                this.instances.push(root);
                this.roots.push(root);
                return root;
            },
        };

        const shaderSource = {
            vertex: document.querySelector("#vertex-shader").innerHTML,
            fragment: document.querySelector("#fragment-shader").innerHTML,
        }
        const textShaderSource = {
            vertex: document.querySelector("#text-vertex-shader").innerHTML,
            fragment: document.querySelector("#text-fragment-shader").innerHTML,
        }

        /**
         * Create and compile a shader of the specified type using the source provided.
         */
        function makeShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source.trim());
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return;
            }
            return shader;
        }

        /**
         * Compile shaders into a program.
         */
        function makeProgram(source, attributes = [], uniforms = []) {
            const vertex = makeShader(gl.VERTEX_SHADER, source.vertex);
            const fragment = makeShader(gl.FRAGMENT_SHADER, source.fragment);

            // Create a program instance for the shaders
            if (vertex && fragment) {
                const shader = {
                    program: gl.createProgram(),
                };
                gl.attachShader(shader.program, vertex);
                gl.attachShader(shader.program, fragment);
                gl.linkProgram(shader.program);

                // See if it linked successfully
                if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
                    alert('Unable to initialise the shader program: ' + gl.getProgramInfoLog(shader.program));
                    return null;
                }

                uniforms.forEach((uniform) => shader[uniform] = gl.getUniformLocation(shader.program, uniform));
                attributes.forEach((attribute) => shader[attribute] = gl.getAttribLocation(shader.program, attribute));

                return shader;
            }
        }

        /**
         * Generate the vertex data for a cube.
         */
        function makeCube() {
            const positions = [
                [-1, -1, -1,],
                [1, -1, -1,],
                [-1, 1, -1,],
                [1, 1, -1,],
                [-1, -1, 1,],
                [1, -1, 1,],
                [-1, 1, 1,],
                [1, 1, 1,],
            ].map((v) => v.map((i) => i / 2));
            const normals = [
                [-1, 0, 0,],
                [0, -1, 0,],
                [0, 0, -1,],
                [1, 0, 0,],
                [0, 1, 0,],
                [0, 0, 1,],
            ];

            /*
            *       4 ------ 5
            *      /|        | \
            *    0 ------------ 1
            *    |  |        |  |
            *    |  |        |  |
            *    |  |        |  |
            *    |  6 ------ 7  |
            *    | /          \ |
            *    2 ------------ 3
            */

            const triangles = [
                { p1: positions[0], p2: positions[1], p3: positions[2], n: normals[2] },
                { p1: positions[1], p2: positions[3], p3: positions[2], n: normals[2] },

                { p1: positions[0], p2: positions[4], p3: positions[5], n: normals[1] },
                { p1: positions[5], p2: positions[1], p3: positions[0], n: normals[1] },

                { p1: positions[4], p2: positions[6], p3: positions[7], n: normals[5] },
                { p1: positions[5], p2: positions[4], p3: positions[7], n: normals[5] },

                { p1: positions[6], p2: positions[2], p3: positions[3], n: normals[4] },
                { p1: positions[7], p2: positions[6], p3: positions[3], n: normals[4] },

                { p1: positions[3], p2: positions[1], p3: positions[5], n: normals[3] },
                { p1: positions[5], p2: positions[7], p3: positions[3], n: normals[3] },

                { p1: positions[6], p2: positions[4], p3: positions[0], n: normals[0] },
                { p1: positions[6], p2: positions[0], p3: positions[2], n: normals[0] },
            ];
            const lines = [
                positions[0], positions[1],
                positions[1], positions[3],
                positions[3], positions[2],
                positions[2], positions[0],

                positions[0], positions[4],
                positions[1], positions[5],
                positions[2], positions[6],
                positions[3], positions[7],

                positions[4], positions[5],
                positions[5], positions[7],
                positions[7], positions[6],
                positions[6], positions[4],
            ];
            const normalised = ([x, y, z]) => {
                const l = Math.hypot(x, y, z);
                return [x / l, y / l, z / l];
            };
            return [...triangles.flatMap((t) => [...t.p1, ...t.n, ...t.p2, ...t.n, ...t.p3, ...t.n]),
            ...lines.flatMap((p) => [...p, ...normalised(p)])];
        }

        /**
         * Generate the vertex data for a cube.
         */
        function makeBanner() {
            return [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
        }

        /**
         * Update the gl buffers used to define the base object used for instancing.
         */
        function updateObject() {

        }

        /**
         * Initialise Instances
         */
        function initialiseInstances() {
            const matrices = [];
            const reversed = app.instances.toReversed();
            reversed.forEach((instance) => matrices.push(...instance.transform));

            app.modelMatrix = new Float32Array(matrices); // 4 bytes per float, 16 floats per matrix
            reversed.forEach((instance, index) =>
                instance.matrix = new Float32Array(app.modelMatrix.buffer, index * 16 * 4, 16));

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferData(gl.ARRAY_BUFFER, app.modelMatrix.byteLength, gl.DYNAMIC_DRAW);

            updateColours();

            app.instancesChanged = true;
        }

        /**
         * Update the colour data from the instances.
         */
        function updateColours() {
            const colourBuffer = [];
            app.instances.toReversed().forEach((instance, index) => {
                const colour = instance.selected ? [1, 1, 1] : (instance.statusColour ?? instance.colour);
                colourBuffer.push(...colour.map((v) => v * 0.3));
                colourBuffer.push(...colour.map((v) => v * 0.3));
                colourBuffer.push(...colour.map((v) => v * 1.0));
                colourBuffer.push(instance.specular);
                const opacity = app.solid ? 1 : app.wireframe ? 0.1 : instance.children.length > 0 ? 0.5 : 1;
                //colourBuffer.push(app.wireframe || !app.cullFaces ? 0 : instance.children.length);
                colourBuffer.push(opacity);
            });
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colourBuffer), gl.STATIC_DRAW);
        }

        /**
         * Update the colour data from the instances.
         */
        function updatePoints() {
            const points = app.points.flatMap((point) => [...point.position, 1, 1, 1]);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.DYNAMIC_DRAW);
        }

        /**
         * Initialise the text data
         */
        function initialiseText() {
            gl.useProgram(app.textShader.program);
            app.textVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.textVertexArray);

            const shape = makeBanner();
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textInstance);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);

            gl.vertexAttribPointer(app.textShader.offset, 2, gl.FLOAT, false, 4 * 2, 0);
            gl.enableVertexAttribArray(app.textShader.offset);

            const stride = 4 * (3 + 2 + 2 + 2 + 4 + 16);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textItems);

            gl.vertexAttribPointer(app.textShader.position, 3, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(app.textShader.position);
            gl.vertexAttribDivisor(app.textShader.position, 1);

            gl.vertexAttribPointer(app.textShader.size, 2, gl.FLOAT, false, stride, 4 * 3);
            gl.enableVertexAttribArray(app.textShader.size);
            gl.vertexAttribDivisor(app.textShader.size, 1);

            gl.vertexAttribPointer(app.textShader.textureSize, 2, gl.FLOAT, false, stride, 4 * (3 + 2));
            gl.enableVertexAttribArray(app.textShader.textureSize);
            gl.vertexAttribDivisor(app.textShader.textureSize, 1);

            gl.vertexAttribPointer(app.textShader.textureOrigin, 2, gl.FLOAT, false, stride, 4 * (3 + 2 + 2));
            gl.enableVertexAttribArray(app.textShader.textureOrigin);
            gl.vertexAttribDivisor(app.textShader.textureOrigin, 1);

            gl.vertexAttribPointer(app.textShader.colour, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2));
            gl.enableVertexAttribArray(app.textShader.colour);
            gl.vertexAttribDivisor(app.textShader.colour, 1);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.textShader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2 + 4 + i * 4));
                gl.enableVertexAttribArray(location);
                gl.vertexAttribDivisor(location, 1);
            }
        }

        /**
         * Initialise a texture and copy an image from the specified canvas.
         */
        function copyTexture(canvas) {
            app.textTexture = app.textTexture ?? gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, app.textTexture);

            // target, level, internalFormat, srcFormat, srcType, source
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            /*
                        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                        gl.generateMipmap(gl.TEXTURE_2D);
                        */
            glErrors(gl, 'Load Texture');
        }

        /**
         * Update text data
         */
        function updateText() {
            const width = 500;
            if (!app.textureCanvas) {
                app.textureCanvas = document.createElement('canvas');
                app.textureCanvas.classList.add('texture-canvas');
                document.body.appendChild(app.textureCanvas);
            }
            const context = app.textureCanvas.getContext('2d');
            context.width = app.textureCanvas.width = width;
            context.height = app.textureCanvas.height = app.instances.length * 30;

            context.clearRect(0, 0, app.textureCanvas.width, app.textureCanvas.height);

            context.fillStyle = 'white';
            context.font = '24px sans-serif';
            context.textBaseline = 'hanging';

            let x = y = 0;
            let lineHeight = 0;
            app.text = app.instances.map((instance) => {
                const metrics = context.measureText(instance.name);
                const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                if (x + metrics.width > width) {
                    x = 0;
                    y += lineHeight;
                    lineHeight = 0;
                }
                x += metrics.width;
                lineHeight = Math.max(lineHeight, fontHeight);
            });

            if (y + lineHeight > context.height) {
                context.height = app.textureCanvas.height = y + lineHeight;
                context.clearRect(0, 0, app.textureCanvas.width, app.textureCanvas.height);

                context.fillStyle = 'white';
                context.font = '24px sans-serif';
                context.textBaseline = 'hanging';
            }

            lineHeight = x = y = 0;
            app.text = app.instances.map((instance) => {
                const metrics = context.measureText(instance.name);

                const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;

                if (x + metrics.width > width) {
                    x = 0;
                    y += lineHeight;
                    lineHeight = 0;
                }
                const textureOrigin = [x, y];
                context.fillText(instance.name, x, y);
                x += metrics.width;

                lineHeight = Math.max(lineHeight, fontHeight);
                const scale = instance.labelScale ?? 1;
                return {
                    position: instance.labelPosition ?? [0.0, 0.0, 0.0],
                    size: [scale * metrics.width, scale * fontHeight],
                    textureOrigin,
                    colour: instance.labelColour ?? [1, 1, 1, 1],
                    instance,
                    canvas: app.textureCanvas,
                }
            });

            copyTexture(app.textureCanvas);
            updateTextBuffer();
        }

        /**
         * Update the buffer containing the text instance data.
         */
        function updateTextBuffer() {
            const data = [];
            const selected = app.showNames ? app.text : app.text.filter((item) => item.instance.selected);
            selected.forEach((text) => {
                data.push(...text.position);
                data.push(text.size[0] / gl.canvas.clientWidth, text.size[1] / gl.canvas.clientHeight); // image size
                data.push(text.size[0] / text.canvas.width, text.size[1] / text.canvas.height);  // Texture Size
                data.push(text.textureOrigin[0] / text.canvas.width, text.textureOrigin[1] / text.canvas.height); // Texture origin
                data.push(...text.colour);
                data.push(...text.instance.transform);
            });
            app.textItemCount = selected.length;
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textItems);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        }

        /**
         * Add instance
         */
        function addInstance(size, position, rotation) {

        }

        /**
         * Calculate the product of 2 4 x 4 matrices and store the result in the third.
         */
        function multiply(a, b, matrix) {
            matrix = matrix || Array(16);
            matrix[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
            matrix[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
            matrix[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
            matrix[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

            matrix[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
            matrix[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
            matrix[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
            matrix[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

            matrix[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
            matrix[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
            matrix[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
            matrix[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

            matrix[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
            matrix[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
            matrix[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
            matrix[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
            return matrix;
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateInstances(time) {
            app.instances.forEach((instance) => instance.transform.forEach((value, index) => instance.matrix[index] = value));
            // update the matrix data
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, app.modelMatrix);
        }

        /**
         * Update the object definition and the instances if required.
         */
        function updateBuffers(time) {
            if (app.objectChanged) {
                updateObject(time);
            }
            if (app.instancesChanged) {
                updateInstances(time);
                //app.instancesChanged = false;
            }
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            const f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zNear + zFar) / (zNear - zFar), -1,
                0, 0, 2 * (zFar * zNear) / (zNear - zFar), 0,
            ];
        }

        /**
         * Calculate a view matrix from eye position, focus point and up vecotrs.
         */
        function viewMatrix(eyePosition, lookAt, up) {
            const negate = (v) => { v[0] *= -1; v[1] *= -1; v[2] *= -1; };
            const zaxis = normalised(subtract(lookAt, eyePosition));
            const xaxis = normalised(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eyePosition), -dot(yaxis, eyePosition), -dot(zaxis, eyePosition), 1,
            ];
        }

        /**
         * Set Attribute pointers for drawing boxes.
         */
        function setBoxAttributes() {
            app.boxVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.boxVertexArray);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride = 3 * 4 * 2,  offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.normal);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);

        }

        /**
         * Set Attribute pointers for drawing points.
         */
        function setPointAttributes() {
            app.pointVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.pointVertexArray);

            gl.disableVertexAttribArray(app.shader.normal);
            gl.vertexAttrib3f(app.shader.normal, 0.0, 0.0, 1.0);

            gl.disableVertexAttribArray(app.shader.model);
            gl.disableVertexAttribArray(app.shader.model + 1);
            gl.disableVertexAttribArray(app.shader.model + 2);
            gl.disableVertexAttribArray(app.shader.model + 3);
            gl.vertexAttrib4f(app.shader.model, 1, 0, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 1, 0, 1, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 2, 0, 0, 1, 0);
            gl.vertexAttrib4f(app.shader.model + 3, 0, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttrib1f(app.shader.specularIntensity, 1.0);

            gl.disableVertexAttribArray(app.shader.opacity);
            gl.vertexAttrib1f(app.shader.opacity, 0.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);

            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.ambientColour);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.specularColour);
        }

        /**
         * Render Text
         */
        function renderText() {
            gl.useProgram(app.textShader.program);
            app.textVertexArray = gl.createVertexArray();
            gl.bindVertexArray(app.textVertexArray);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textInstance);
            gl.vertexAttribPointer(app.textShader.offset, 2, gl.FLOAT, false, 4 * 2, 0);
            gl.enableVertexAttribArray(app.textShader.offset);

            const stride = 4 * (3 + 2 + 2 + 2 + 4 + 16);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.textItems);

            gl.vertexAttribPointer(app.textShader.position, 3, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(app.textShader.position);
            gl.vertexAttribDivisor(app.textShader.position, 1);

            gl.vertexAttribPointer(app.textShader.size, 2, gl.FLOAT, false, stride, 4 * 3);
            gl.enableVertexAttribArray(app.textShader.size);
            gl.vertexAttribDivisor(app.textShader.size, 1);

            gl.vertexAttribPointer(app.textShader.textureSize, 2, gl.FLOAT, false, stride, 4 * (3 + 2));
            gl.enableVertexAttribArray(app.textShader.textureSize);
            gl.vertexAttribDivisor(app.textShader.textureSize, 1);

            gl.vertexAttribPointer(app.textShader.textureOrigin, 2, gl.FLOAT, false, stride, 4 * (3 + 2));
            gl.enableVertexAttribArray(app.textShader.textureOrigin);
            gl.vertexAttribDivisor(app.textShader.textureOrigin, 1);

            gl.vertexAttribPointer(app.textShader.colour, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2));
            gl.enableVertexAttribArray(app.textShader.colour);
            gl.vertexAttribDivisor(app.textShader.colour, 1);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.textShader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, stride, 4 * (3 + 2 + 2 + 2 + i * 4));
                gl.enableVertexAttribArray(location);
                gl.vertexAttribDivisor(location, 1);
            }
        }

        /**
         * Render loop function to update the display
         */
        let start;
        function render(time) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            if (start) {
                const delta = time - start;
                app.eyePosition = add(app.eyePosition, scale(app.velocity, delta / 1000));
                app.lookAt = add(app.lookAt, scale(app.velocity, delta / 1000));
                const direction = applyTransform(subtract(app.lookAt, app.eyePosition), app.rotation);
                app.rotation = scaleMatrix(app.rotation, 0.1);
                app.lookAt = add(app.eyePosition, direction);
                app.updateViewControls();
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                app.velocity = scale(app.velocity, 0.9);
                updateBuffers(time);

                gl.useProgram(app.shader.program);
                gl.bindVertexArray(app.boxVertexArray);

                gl.uniformMatrix4fv(app.shader.projection, false, app.projectionMatrix);
                gl.uniformMatrix4fv(app.shader.view, false, app.viewMatrix);
                gl.uniform3fv(app.shader.eyePosition, app.eyePosition);
                gl.uniform3fv(app.shader.lightPosition1, [5000, 5000, 5000]);
                gl.uniform3fv(app.shader.lightPosition2, [500, -500, 5000]);
                gl.uniform3fv(app.shader.lightPosition3, [1000, 15000, 1000]);

                if (!app.wireframe) {
                    gl.drawArraysInstanced(gl.TRIANGLES, 0, app.vertexCount, app.instances.length);
                }
                gl.drawArraysInstanced(gl.LINES, 36, 24, app.instances.length);

                if (app.points.length > 0) {
                    setPointAttributes();
                    gl.bindVertexArray(app.pointVertexArray);
                    gl.drawArrays(gl.POINTS, 0, app.points.length);
                }

                if (app.textItemCount > 0) {
                    gl.disable(gl.DEPTH_TEST);
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    gl.colorMask(true, true, true, false);

                    gl.useProgram(app.textShader.program);
                    gl.bindVertexArray(app.textVertexArray);

                    gl.uniformMatrix4fv(app.textShader.projection, false, app.projectionMatrix);
                    gl.uniformMatrix4fv(app.textShader.view, false, app.viewMatrix);
                    gl.uniform1i(app.textShader.texture, gl.TEXTURE0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, app.textTexture);

                    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, app.textItemCount);

                    gl.enable(gl.DEPTH_TEST);
                    gl.colorMask(true, true, true, true);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                }
                glErrors();
            } else {
                start = time;
            }
            requestAnimationFrame(render);
        }

        /**
         * translate a touch event into a simplified mouse event.
         */
        function touch(event) {
            event.preventDefault();
            event.stopPropagation();
            return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
        }

        /**
         * Manage an instance.
         */
        class Instance {
            constructor(parent, position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour = [0.5, 0.5, 0.5], opacity = 1, specular = 10) {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                this.parent = parent;
                if (position.name) {
                    this.name = position.name;
                    this.position = position.position;
                    this.size = position.size;
                    this.angle = position.angle;
                    this.axis = normalised(position.axis);
                    this.colour = position.colour;
                    this.opacity = position.opacity;
                    this.specular = position.specular;
                } else {
                    this.name = `Instance ${app.instances.length + 1}`;
                    this.position = position;
                    this.size = size;
                    this.angle = angle;
                    this.axis = normalised(axis);
                    this.colour = colour;
                    this.opacity = opacity;
                    this.specular = specular;
                }
                this.origin = Array(16);
                this.children = [];
                this.rate = 0;
                this.offset = 0;
                this.setTransform();
            }
            asString() {
                const getVector = (vector, places = 2) => vector.map((v) => v.toFixed(places)).join(', ');
                const attributes = [
                    this.name,
                    getVector(this.position),
                    getVector(this.size),
                    this.angle,
                    getVector(this.axis),
                    getVector(this.colour),
                    this.specular,
                    this.opacity,
                ];
                return attributes.join('; ');
            }
            /**
             * Set the transform of a shape based on its position, rotation and scale.
             * 
             * Calculate the origin for children of the shape
             */
            setTransform() {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                const parent = this.parent || { origin: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
                const origin = parent.origin;
                const angle = this.angle * Math.PI / 360;
                const qw = Math.cos(angle);
                const axis = normalised(this.axis);
                const qx = axis[0] * Math.sin(angle);
                const qy = axis[1] * Math.sin(angle);
                const qz = axis[2] * Math.sin(angle);

                const translation = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    app.scale * this.position[0],
                    app.scale * this.position[1],
                    app.scale * this.position[2], 1
                ];
                this.rotation = [
                    1 - 2 * qy * qy - 2 * qz * qz,
                    2 * qx * qy - 2 * qz * qw,
                    2 * qx * qz + 2 * qy * qw,
                    0,

                    2 * qx * qy + 2 * qz * qw,
                    1 - 2 * qx * qx - 2 * qz * qz,
                    2 * qy * qz - 2 * qx * qw,
                    0,

                    2 * qx * qz - 2 * qy * qw,
                    2 * qy * qz + 2 * qx * qw,
                    1 - 2 * qx * qx - 2 * qy * qy,
                    0,

                    0, 0, 0, 1
                ];
                const scale = [
                    app.scale * this.size[0], 0, 0, 0,
                    0, app.scale * this.size[1], 0, 0,
                    0, 0, app.scale * this.size[2], 0,
                    0, 0, 0, 1
                ];

                const rotationTranslate = multiply(this.rotation, translation);
                this.origin = multiply(rotationTranslate, origin);
                this.transform = multiply(scale, this.origin);
            }
            update(child) {
                this.setTransform();
                this.children.forEach((child) => child.update(true));
                app.instancesChanged = true;
                if (!child) {
                    updateColours();
                    updateTextBuffer();
                }
            }
            addChild(position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour, opacity, specular) {
                const newInstance = new Instance(
                    this,
                    position,
                    size,
                    angle,
                    axis,
                    colour || this.colour,
                    opacity || this.opacity,
                    specular || this.specular);
                this.children.push(newInstance);
                app.instances.push(newInstance);
                return newInstance;
            }
            delete() {
                const children = [...this.children];
                children.forEach((child) => child.delete);
                if (this.parent) {
                    const position = this.parent.children.indexOf(this);
                    this.parent.children.splice(position, 1);
                } else {
                    const position = app.roots.indexOf(this);
                    app.roots.splice(position, 1);
                }
            }
            get siblings() {
                const list = this.parent ? this.parent.children : app.roots;
                return list.filter((child) => child !== this)
            }
            overlap(position, other) {
                return ((position[0] + this.size[0]) >= other.position[0])
                    && (position[0] <= (other.position[0] + other.size[0]))
                    && ((position[1] + this.size[1]) >= other.position[1])
                    && (position[1] <= (other.position[1] + other.size[1]))
                    && ((position[2] + this.size[2]) >= other.position[2])
                    && (position[2] <= (other.position[2] + other.size[2]));
            }
            move(vector) {
                this.siblings.forEach((sibling) => {
                    const requestedPosition = add(this.start, vector);
                    if (this.overlap(requestedPosition, sibling)) {
                        const delta = [0, 0, 0];
                        for (let i = 0; i < 3; ++i) {
                            const d1 = sibling.position[i] - requestedPosition[i] - this.size[i];
                            const d2 = sibling.position[i] + sibling.size[i] - requestedPosition[i];
                            delta[i] = Math.abs(d1) < Math.abs(d2) ? d1 : d2;
                        }
                        if (Math.abs(delta[1]) < Math.abs(delta[0])) {
                            delta[0] = 0;
                            if (Math.abs(delta[2]) < Math.abs(delta[1])) {
                                delta[1] = 0;
                            } else {
                                delta[2] = 0;
                            }
                        } else {
                            delta[1] = 0;
                            if (Math.abs(delta[0]) < Math.abs(delta[2])) {
                                delta[2] = 0;
                            } else {
                                delta[0] = 0;
                            }
                        }

                        vector = add(vector, delta);

                        sibling.statusColour = [1, 0, 0];
                    }
                });
                this.position = add(this.start, vector);
                updateColours();
            }
            promote() {
                if (this.parent) {
                    const siblings = this.parent.children;
                    const position = siblings.indexOf(this);
                    const children = siblings.splice(position, siblings.length - position);
                    children.shift();
                    this.children.push(...children);
                    children.forEach((child) => child.parent = this);
                    this.update();
                    const list = this.parent.parent ? this.parent.parent.children : app.roots;
                    const pos = list.indexOf(this.parent);
                    list.splice(pos + 1, 0, this);
                    this.parent = this.parent.parent;
                }
            }
            demote() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position > 1) {
                    list.splice(position, 1);
                    list[position - 1].children.unshift(this);
                    this.parent = list[position - 1];
                    this.update();
                }
            }
            down() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position < list.length - 1) {
                    list.splice(position, 1);
                    list.splice(position + 1, 0, this);
                    this.update();
                }
            }
            up() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position > 0) {
                    list.splice(position, 1);
                    list.splice(position - 1, 0, this);
                    this.update();
                }
            }
        }

        const action = {};
        document.body.addEventListener('mousemove', (event) => action.move?.(event));
        document.body.addEventListener('mouseup', (event) => {
            action.move = null;
            //showStructure();
        });

        document.body.addEventListener('touchmove', (event) => action.move?.(touch(event)));
        document.body.addEventListener('touchend', (event) => action.move = null);
        /**
         * Show structure
         */
        function showStructure() {
            const structure = document.getElementById('structure');
            structure.innerHTML = `<span>Name</span>
                <span class="value">Position</span>
                <span class="value">Size</span>
                <span class="value">Angle</span>
                <span class="value">Axis</span>
                <span class="value">Colour</span>
                <span class="value">Specular</span>
                <span class="value">opacity</span>`;

            app.nodeMap = new Map();
            const addInstance = (instance, level = 0) => {
                const nodes = [];
                const addControls = (node, item, element, scaled) => {
                    node.contentEditable = true;
                    node.addEventListener('focus', (event) => {
                        instance.selected = true;
                        updateColours();
                    });

                    node.addEventListener('blur', (event) => {
                        if (isNaN(Number(item[element]))) {
                            item[element] = node.innerText;
                        } else {
                            item[element] = Number(node.innerText);
                        }
                    });
                    node.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            if (isNaN(Number(item[element]))) {
                                node.innerHTML = item[element];
                            } else {
                                node.innerHTML = item[element].toFixed();
                            }
                        }
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            if (event.shiftKey) {
                                instance.addChild([0, 0, 0], scale(instance.size, 0.5));
                                initialiseInstances();
                                showStructure();
                            } else {
                                if (isNaN(Number(node.innerText))) {
                                    item[element] = node.innerText;
                                } else {
                                    item[element] = Number(node.innerText);
                                }
                                instance.update();
                            }
                        }
                        if (event.ctrlKey) {
                            if (event.key === 'ArrowLeft') {
                                instance.promote();
                                showStructure();
                            }
                            if (event.key === 'ArrowRight') {
                                instance.demote();
                                showStructure();
                            }
                            if (event.key === 'ArrowUp') {
                                instance.up();
                                showStructure();
                            }
                            if (event.key === 'ArrowDown') {
                                instance.down();
                                showStructure();
                            }
                        }
                    });

                    if (!isNaN(Number(item[element]))) {
                        const places = Math.floor(Math.log10(1 / scaled));
                        node.addEventListener('mousedown', (event) => {
                            action.last = event.clientY;
                            action.move = (event) => {
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.update();
                            };
                        });
                        node.addEventListener('touchstart', (event) => {
                            event = touch(event);
                            action.last = event.clientY;
                            action.move = (event) => {
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.update();
                            };
                        });
                    }
                }
                const addSpan = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    const node = document.createElement('span');
                    nodes.push(node);
                    if (isNaN(Number(instance[argument]))) {
                        node.innerHTML = instance[argument];
                    } else {
                        node.innerHTML = instance[argument].toFixed();
                        node.classList.add('value');
                    }
                    addControls(node, instance, argument, scaled);
                    return node;
                }
                const addVec = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    const container = document.createElement('div');
                    instance[argument].forEach((item, index) => {
                        const node = document.createElement('span');
                        nodes.push(node);
                        node.classList.add('value');
                        node.innerHTML = item.toFixed(places);
                        addControls(node, instance[argument], index, scaled);
                        container.append(node, ', ');
                    });
                    return container;
                }
                const name = document.createElement('span');
                name.style.whiteSpace = 'pre';
                name.append(''.padStart(level * 2, ' '), addSpan('name'));
                app.nodeMap.set(instance, nodes);
                structure.append(name,
                    addVec('position'),
                    addVec('size'),
                    addSpan('angle'),
                    addVec('axis'),
                    addVec('colour', 0.01),
                    addSpan('specular'),
                    addSpan('opacity'));
                instance.children.forEach((child) => addInstance(child, level + 1));
            }
            app.roots.forEach((child) => addInstance(child));
        }

        const commands = {
            'eye position'(value) {
                app.eyePosition = value.split(/,/g).map((v) => parseFloat(v));
            },
            'look at'(value) {
                app.lookAt = value.split(/,/g).map((v) => parseFloat(v));
            },
            up(value) {
                app.up = value.split(/,/g).map((v) => parseFloat(v));
            },
            fov(value) {
                app.fov = parseFloat(value);
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            aspect(value) {
                app.aspect = parseFloat(value);
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            near(value) {
                app.near = parseFloat(value);
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            far(value) {
                app.far = parseFloat(value);
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            },
            background(value) {
                const colour = value.split(/,/g).map((v) => parseFloat(v));
                gl.clearColor(...colour, 1.0);
            }
        }

        /**
         * Convert text to objects
         */
        function getObjects(text) {
            const lines = text.split(/\r?\n/g);
            let processLine = true;
            return lines.flatMap((line) => {
                if (line === '!stop') {
                    processLine = false;
                }
                if (processLine && line.trim() !== '' && !line.trim().startsWith('#')) {
                    if (line.startsWith('>')) {
                        const [command, value] = line.replace(/^>\s*/, '').split('=').map((v) => v.trim());
                        if (commands[command]) {
                            commands[command](value);
                        }
                        return [];
                    }
                    const [indentedName, positionStr, sizeStr, angleStr, axisStr, colourStr, specularStr, opacityStr, instances] = line.split(/\s*;\s*/);
                    const indent = indentedName.replace(/\S.*/, '');
                    const rangeName = indentedName.replace(/^\s+/, '');
                    const match = rangeName.match(/(\[(?<instances>[^\]]+)\]\s*)?(?<name>.*)/);
                    const qualifiedName = match.groups.name;
                    const [name, ...types] = qualifiedName.split(/\s*:\s*/);

                    let level = 0;
                    for (let i = 0; i < indent.length; ++i) {
                        if (indent[i] === '\t') {
                            level += 4 - (level % 4);
                        } else {
                            level += 1;
                        }
                    }
                    const position = positionStr ? positionStr.split(',') : null;
                    const size = sizeStr ? sizeStr.split(',') : null;
                    const angle = angleStr ? angleStr : null;
                    const axis = axisStr ? axisStr.split(',') : null;
                    const colour = colourStr ? colourStr.split(',') : null;
                    const specular = specularStr ? specularStr : null;
                    const opacity = opacityStr ? opacityStr : null;
                    const obj = {
                        name,
                        types,
                        level,
                        position,
                        size,
                        angle,
                        axis,
                        colour,
                        specular,
                        opacity,
                        instances: instances ?? match.groups.instances, children: [],
                    }
                    return obj;
                }
                return [];
            });
        }

        /**
         * Convert a list of objects into a tree structure based on the level of the objects
         */
        function getTree(objs) {
            const roots = [];
            const stack = [];
            const named = {};
            objs.forEach((obj) => {
                named[obj.name] = obj;
                obj.types = obj.types.map((type) => named[type]);

                if (obj.types.length) {
                    Object.getOwnPropertyNames(obj).filter((property) => obj[property] === null)
                        .forEach((property) => {
                            const stack = [...obj.types];
                            while (obj[property] === null && stack.length) {
                                const type = stack.shift();
                                stack.push(...type.types);
                                obj[property] = type[property];
                            }
                        });
                    obj.types.forEach((type) =>
                        obj.children.push(...type.children.map((child) => Object.assign({}, child))));
                }
                while (stack.length && obj.level <= stack[0].level) {
                    stack.shift();
                }
                if (stack.length > 0) {
                    stack[0].children.push(obj);
                    obj.parent = stack[0];
                } else {
                    roots.push(obj);
                }
                stack.unshift(obj);
            });
            return roots;
        }

        /**
         * Convert a range specifier to a list.
         */
        function getList(definition) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*:\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(definition);
            const list = [];
            if (isNaN(count)) {
                list.push(...definition.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return Number(item.trim());
                }));
            } else {
                for (let i = 1; i <= count; ++i) {
                    list.push(i);
                }
            }
            return list;
        }

        /**
         * Expand a template graph to a full graph.
         */
        function expandGraph(templateGraph) {
            const expand = (node, context = []) => {
                const resolve = (value, context) => {
                    if (isNaN(Number(value))) {
                        value = value.replace(/<([0-9]*)>/g, (match, level) => (context[parseInt(level) || 0].instance) ?? 0)
                            .replace(/<n([0-9]*)>/g, (match, level) => (context[parseInt(level) || 0].idx) ?? 0)
                            .replace(/<i([0-9]*)>/g, (match, level) => (context[parseInt(level) || 0].index) ?? 0);
                        const func = new Function(`return ${value};`);
                        return func();
                    }
                    return Number(value);
                }
                const makeInstance = (node, context) => ({
                    name: node.name.replace(/<([0-9]*)>/g, (match, level) => context[parseInt(level) || 0].instance),
                    position: node.position.map((v) => resolve(v, context)),
                    size: node.size.map((v) => resolve(v, context)),
                    angle: resolve(node.angle, context),
                    axis: node.axis.map((v) => resolve(v, context)),
                    colour: node.colour.map((v) => resolve(v, context)),
                    specular: resolve(node.specular, context),
                    opacity: resolve(node.opacity, context),
                    children: node.children.flatMap((child, index) => expand(child, [{ index }, ...context])),
                });

                if (node.instances) {
                    const instances = getList(node.instances);
                    if (node.position) {
                        return instances.flatMap((instance, idx) => {
                            context[0].instance = instance;
                            context[0].idx = idx;
                            return makeInstance(node, [{ instance, idx }, ...context]);
                        });
                    } else {
                        return instances.flatMap((instance, idx) =>
                            node.children.flatMap((child, index) => expand(child, [{ instance, index, idx }, ...context])));
                    }
                } else if (node.position) {
                    return makeInstance(node, context);
                }
                return [];
            }

            return templateGraph.flatMap((node, index) => expand(node, [{ index }]));
        }

        /**
         * Make a test graph.
         */
        function makeGraph(source, replace) {
            if (source) {
                if (replace) {
                    app.instances = [];
                    app.roots = [];
                }
                const adjustOrigin = (node, offset = [0, 0, 0]) => {
                    if (app.cornerOrigin) {
                        node.position = add(node.position, scale(node.size, 0.5), offset);
                        node.children.forEach((child) => adjustOrigin(child, scale(node.size, -0.5)));
                    }
                }

                source.forEach((node) => adjustOrigin(node));

                const addNode = (parent, node) => {
                    const child = parent.addChild(node);
                    node.children.forEach((node) => addNode(child, node));
                }
                source.forEach((node) => {
                    const root = app.addRoot(node);
                    node.children.forEach((child) => addNode(root, child));
                });
                initialiseInstances();
            } else {
                const root = app.addRoot(
                    [0, 0, 0],    // Position
                    [1, 1, 1],    // Size
                    0,            // Rotation
                    [0, 1, 0],    // Axis
                    [1, 1, 0],    // Colour
                    1.0,          // opacity
                    10.0);        // Specular
                /*
            const child = root.addChild([0, 750, 0], [500, 500, 500], 30);
            const grandchild = child.addChild([750, 0, 0], [1000, 500, 500], 45, [1, 0, 0], [1, 0, 0]);
            const grandchild2 = child.addChild([0, 0, 500], [500, 500, 500]);
            const greatgrandchild = grandchild.addChild([250, 1100, 0], [500, 1500, 500]);
            */
            }

            showStructure();
            updateText();
        }

        /**
         * Return a normalised version of the given vector.
         */
        function normalised(vector) {
            const l = Math.hypot(...vector);
            return vector.map((i) => i / l);
        }

        /**
         * Return vector A scaled by s
         */
        function scale(vector, scale) {
            return vector.map((v) => v * scale);
        }

        /**
         * Return matrix scaled by s to the unity matrix
         */
        function scaleMatrix(matrix, scale) {
            const ident = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            return matrix.map((v, i) => v + (ident[i] - v) * scale);
        }

        /**
         * Componentwise sum of vectors
         */
        function add(...vectors) {
            const length = Math.max(...vectors.map((v) => v.length));
            const result = [];
            for (let i = 0; i < length; ++i) {
                result.push(vectors.reduce((s, v) => s + (v[i] ?? 0), 0));
            }
            return result;
        }

        /**
         * Return vector A minus vector B
         */
        function subtract(a, b) {
            return a.map((v, i) => v - b[i]);
        }

        /**
         * Componentwise product of vectors
         */
        function product(v1, v2) {
            return v1.map((v, i) => v * v2[i]);
        }


        /**
         * Return the dot product of two vectors
         */
        function dot(v1, v2) {
            return v1.reduce((s, v, i) => s + v * v2[i], 0);
        }

        /**
         * Return the cross product of two vectors
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0],
            ];
        }

        /**
         * Apply a transform by multiplying a vector by a matrix
         */
        function applyTransform(vector, matrix) {
            return [
                matrix[0] * vector[0] + matrix[4] * vector[1] + matrix[8] * vector[2] + matrix[12],
                matrix[1] * vector[0] + matrix[5] * vector[1] + matrix[9] * vector[2] + matrix[13],
                matrix[2] * vector[0] + matrix[6] * vector[1] + matrix[10] * vector[2] + matrix[14],
            ];
        }

        /**
         * Return the rotation matrix based on angle and axis.
         */
        function getRotation(angle, axis) {
            angle = angle * Math.PI / 180;
            const qw = Math.cos(angle);
            axis = normalised(axis);
            const qx = axis[0] * Math.sin(angle);
            const qy = axis[1] * Math.sin(angle);
            const qz = axis[2] * Math.sin(angle);

            return [
                1 - 2 * qy * qy - 2 * qz * qz,
                2 * qx * qy - 2 * qz * qw,
                2 * qx * qz + 2 * qy * qw,
                0,

                2 * qx * qy + 2 * qz * qw,
                1 - 2 * qx * qx - 2 * qz * qz,
                2 * qy * qz - 2 * qx * qw,
                0,

                2 * qx * qz - 2 * qy * qw,
                2 * qy * qz + 2 * qx * qw,
                1 - 2 * qx * qx - 2 * qy * qy,
                0,

                0, 0, 0, 1
            ];
        }

        /**
         * Get ray from screen position
         */
        function getRay(x, y) {
            const f = 1 / Math.tan(app.fov * Math.PI / 360);

            const w = canvas.clientWidth / 2;
            const h = canvas.clientHeight / 2;

            const zAxis = normalised(subtract(app.lookAt, app.eyePosition));
            const yAxis = normalised(app.up);
            const xAxis = cross(zAxis, yAxis);

            const position = add(scale(xAxis, x - w), scale(yAxis, h - y), scale(zAxis, h * f));
            const direction = normalised(position);

            return { point: app.eyePosition, direction };
        }

        /**
         * Get the point of intersection of a plane and line
         */
        function planeIntercept(line, plane) {
            const v = subtract(plane.point, line.point);
            const n = dot(plane.normal, v) / dot(plane.normal, line.direction);
            return n;
        }

        /**
         * Determine the intecept of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalised(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start && start > -Infinity) {
                return [start, end];
            }
        }

        /**
         * Find the intersection of a ray and objects
         */
        function getIntersection(line) {
            // Check whether a line passes within the radius of the bounding sphere
            const hits = app.instances.filter((instance) => {
                const size = scale(instance.size, 0.5 * app.scale);
                const origin = [0, 0, 0];
                const centre = applyTransform(origin, instance.origin);
                const radius = Math.hypot(...size);

                const l = dot(line.direction, subtract(centre, line.point));
                const n = l / line.direction.reduce((s, v) => s + v * v, 0);
                const p = add(line.point, scale(line.direction, n));
                const v = subtract(p, centre);
                const dist = Math.hypot(...v);
                if (dist < radius) {
                    const corner1 = applyTransform(scale(size, -1), instance.origin);
                    const corner2 = applyTransform(size, instance.origin);
                    const planes = [
                        { point: corner1, normal: applyTransform([-1, 0, 0], instance.rotation) },
                        { point: corner1, normal: applyTransform([0, -1, 0], instance.rotation) },
                        { point: corner1, normal: applyTransform([0, 0, -1], instance.rotation) },
                        { point: corner2, normal: applyTransform([1, 0, 0], instance.rotation) },
                        { point: corner2, normal: applyTransform([0, 1, 0], instance.rotation) },
                        { point: corner2, normal: applyTransform([0, 0, 1], instance.rotation) },
                    ];
                    const points = convexHullIntercept(line, planes);
                    if (points) {
                        const p1 = add(line.point, scale(line.direction, points[0]));
                        const p2 = add(line.point, scale(line.direction, points[1]));
                        //app.points.push({ position: p1 }, { position: p2 });
                        instance.points = [p1, p2];
                        return points;
                    }
                }
            });
            if (hits.length) {
                const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));
                // Find the closest to the view position that isn't a parent
                const hit = hits.filter((hit) => hit.children.filter((child) => hits.includes(child)).length === 0);
                hit.sort((a, b) => dist(app.eyePosition, a.points[0]) - dist(app.eyePosition, b.points[0]));
                if (event.shiftKey) {
                    if (event.ctrlKey) {
                        hit.forEach((instance) => instance.selected = true);
                    } else {
                        hit[0].selected = true;
                    }
                } else {
                    app.instances.forEach((instance) => instance.selected = instance === hit[0]);
                }
                updateColours();
                updateTextBuffer();
                updatePoints();
                return hit;
            } else {
                app.instances.forEach((instance) => instance.selected = false);
            }
        }

        /**
         * Utility function to support downloading generated content.
         */
        function downloadText(text, name = '') {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            link.setAttribute('download', name);

            document.body.appendChild(link);
            link.click();
            link.remove();
        }

        /**
         * Save the current state
         */
        function save() {
            const lines = [];
            lines.push(`>eye position = ${app.eyePosition.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push(`>look at = ${app.lookAt.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push(`>up = ${app.up.map((v) => v.toFixed(2)).join(', ')}`);
            lines.push('');

            const addInstance = (instance, level = 0) => {
                lines.push(`${''.padStart(level * 2, ' ')}${instance.asString()}`);
                instance.children.forEach((child) => child.addInstance(child, level + 1));
            };
            app.roots.forEach((root) => addInstance(root));
            downloadText(lines.join('\n'));
        }

        /**
         * Clear Selection
         */
        function clearSelection() {
            app.selected = null;
            app.instances.forEach((instance) => instance.selected = false);
            updateTextBuffer();
            updateColours();
        }


        /**
         * Add the event handlers for the canvas.
         */
        function addCanvasEvents(canvas) {
            canvas.tabIndex = 0;
            canvas.addEventListener('keydown', (event) => {
                report(event.key);
                /*
                                if (event.key === 'w') {
                                    app.wireframe = !app.wireframe;
                                }
                                if (event.key === 'i') {
                                    app.cullFaces = !app.cullFaces;
                                    updateColours();
                                }
                                if (event.key === 'c') {
                                    app.points = [];
                                    updatePoints();
                                }
                                    */
                const shiftMapping = {
                    ArrowUp: (event) => up(),
                    ArrowDown: (event) => up(-1),
                    ArrowLeft: (event) => right(-1),
                    ArrowRight: (event) => right(),
                    '+': (event) => newBlock(),
                    r: (event) => reset(),
                }
                const ctrlMapping = {
                    ArrowUp: (event) => addBlocks([0, -1, 0]),
                    ArrowDown: (event) => addBlocks([0, 1, 0]),
                    ArrowLeft: (event) => addBlocks([-1, 0, 0]),
                    ArrowRight: (event) => addBlocks([1, 0, 0]),
                    l: (event) => document.getElementById('load-file').click(),
                }
                const altMapping = {
                    ArrowUp: (event) => addBlocks([0, 0, -1]),
                    ArrowDown: (event) => addBlocks([0, 0, 1]),
                    ArrowLeft: (event) => addBlocks([-1, 0, 0]),
                    ArrowRight: (event) => addBlocks([1, 0, 0]),
                }
                const mapping = {
                    ArrowUp: (event) => forward(),
                    ArrowDown: (event) => forward(-1),
                    ArrowLeft: (event) => rotateRight(-1),
                    ArrowRight: (event) => rotateRight(),
                    Escape: (event) => clearSelection(),
                    Delete: (event) => deleteBlocks(event),
                    a: (event) => { app.showNames = !app.showNames; updateTextBuffer() },
                    b: (event) => { app.eyePosition = [0, 0, -15]; app.lookAt = [0, 0, 0]; app.up = [0, 1, 0]; },
                    c: (event) => { app.points = []; updatePoints(); },
                    f: (event) => { app.eyePosition = [0, 0, 15]; app.lookAt = [0, 0, 0]; app.up = [0, 1, 0]; },
                    i: (event) => { app.solid = !app.solid; updateColours(); },
                    l: (event) => { app.eyePosition = [-15, 0, 0]; app.lookAt = [0, 0, 0]; app.up = [0, 1, 0]; },
                    r: (event) => { app.eyePosition = [15, 0, 0]; app.lookAt = [0, 0, 0]; app.up = [0, 1, 0]; },
                    s: (event) => save(),
                    t: (event) => { app.eyePosition = [0, 15, 0]; app.lookAt = [0, 0, 0]; app.up = [0, 0, 1]; },
                    w: (event) => app.wireframe = !app.wireframe,
                }

                if (event.shiftKey) {
                    shiftMapping[event.key]?.(event);
                } else if (event.ctrlKey && ctrlMapping[event.key]) {
                    event.preventDefault();
                    ctrlMapping[event.key](event);
                } else if (event.altKey && altMapping[event.key]) {
                    event.preventDefault();
                    altMapping[event.key](event);

                } else {
                    mapping[event.key]?.(event);
                }
            });

            const mouseDown = (event) => {
                action.lastX = event.clientX;
                action.lastY = event.clientY;
                const mouseLine = getRay(event.clientX, event.clientY);
                const hits = getIntersection(mouseLine);
                for (const node of document.body.querySelectorAll('.selected')) {
                    node.classList.remove('selected');
                }
                if (hits) {
                    // Move the clicked object
                    const { xAxis, yAxis, zAxis, scaled } = viewVectors();
                    action.selected = hits[0];
                    report(action.selected.name);
                    app.nodeMap.get(action.selected).forEach((node) => node.classList.add('selected'));
                    action.plane = { point: action.selected.points[0] };
                    if (Math.abs(dot(app.up, [0, 1, 0])) > 0.9) {
                        action.plane.normal = zAxis;
                    } else {
                        action.plane.normal = [0, 1, 0];
                    }
                    const selected = app.instances.filter((instance) => instance.selected);
                    selected.forEach((instance) => instance.start = [...instance.position]);
                    action.move = (event) => {
                        const mouseLine = getRay(event.clientX, event.clientY);
                        const n = planeIntercept(mouseLine, action.plane);
                        const point = add(mouseLine.point, scale(mouseLine.direction, n));
                        const delta = subtract(point, action.plane.point);

                        selected.forEach((selected) => {
                            selected.statusColour = null;
                            selected.move(delta);
                            selected.update();
                        });
                    };
                } else {
                    // Rotate the view
                    action.move = (event) => {
                        const deltaX = event.clientX - action.lastX;
                        const deltaY = event.clientY - action.lastY;
                        action.lastX = event.clientX;
                        action.lastY = event.clientY;
                        const sightLine = subtract(app.lookAt, app.eyePosition);
                        const xAxis = cross(sightLine, app.up);
                        const yAxis = cross(sightLine, xAxis);
                        if (event.shiftKey) {
                            const dist = Math.hypot(...sightLine) / -1000;
                            const movement = add(scale(normalised(xAxis), deltaX * dist), scale(normalised(yAxis), deltaY * dist));
                            app.eyePosition = add(app.eyePosition, movement);
                            app.lookAt = add(app.lookAt, movement);
                        } else {
                            const xRotation = getRotation(deltaY * Math.PI / 60, xAxis);
                            const yRotation = getRotation(deltaX * Math.PI / 60, app.up);
                            const rotation = multiply(xRotation, yRotation);
                            app.eyePosition = subtract(app.lookAt, applyTransform(sightLine, rotation));
                            app.up = applyTransform(app.up, rotation);
                        }
                        app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                        app.updateViewControls();
                    };
                }
            };
            canvas.addEventListener('mousedown', (event) => mouseDown(event));
            canvas.addEventListener('touchstart', (event) => mouseDown(touch(event)));
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const dist = Math.pow(2, event.deltaY / 100);
                const sightLine = subtract(app.lookAt, app.eyePosition);
                const move = sightLine.map((v) => v * dist);
                app.eyePosition = subtract(app.lookAt, move);
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                app.updateViewControls();
            });

            /**
             * Process a dropped file
             */
            function dropHandler(event) {
                event.preventDefault();
                const replace = event.shiftKey;

                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        const objs = getObjects(reader.result);
                        const tree = getTree(objs);
                        const graph = expandGraph(tree);
                        makeGraph(graph, replace);
                    });
                    reader.readAsText(file);
                }

                if (event.dataTransfer.items) {
                    [...event.dataTransfer.items].forEach((item, index) => {
                        if (item.kind === 'file') {
                            const file = item.getAsFile();
                            loadFile(file);
                            item.getAsFileSystemHandle().then((handle) => {
                                //saveFileHandles([{ name: file.name, handle }]);
                            });
                        }
                    });
                } else {
                    // Use DataTransfer interface to access the file(s)
                    [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
                }
            }

            function dragOverHandler(event) {
                // Prevent default behavior (Prevent file from being opened)
                event.preventDefault();
            }

            canvas.addEventListener('dragover', dragOverHandler);
            canvas.addEventListener('drop', dropHandler);
        }

        /**
         * Perform all once off set-up (e.g. creating buffer etc.)
         */
        function initialise() {
            addMovementControls();
            projectionControl();
            viewControl(document.getElementById('view-vectors'));
            addCanvasEvents(canvas);

            // Set clear color to black, fully opaque
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            // Should be update to track canvas size changes
            gl.canvas.width = gl.canvas.clientWidth;
            gl.canvas.height = gl.canvas.clientHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            const attributes = ['position', 'normal', 'model', 'ambientColour', 'diffuseColour', 'specularColour', 'specularIntensity', 'opacity'];
            app.shader = makeProgram(shaderSource, attributes, ['projection', 'view', 'lightPosition1', 'lightPosition2', 'lightPosition3', 'eyePosition']);
            app.textShader = makeProgram(textShaderSource, ['position', 'model', 'offset', 'size', 'textureSize', 'textureOrigin', 'colour',],
                ['projection', 'view', 'texture']);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

            app.buffers = {
                vertex: gl.createBuffer(),
                instances: gl.createBuffer(),
                colour: gl.createBuffer(),
                points: gl.createBuffer(),
                textInstance: gl.createBuffer(),
                textItems: gl.createBuffer(),
            };
            app.textTexture = gl.createTexture();
            app.vertexCount = 36;
            initialiseText();
            const shape = makeCube();
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);
            setBoxAttributes();

            makeGraph();
            initialiseInstances();

            const fileSelection = document.getElementById('load-file');
            fileSelection.addEventListener('change', (event) => {
                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        const objs = getObjects(reader.result);
                        const tree = getTree(objs);
                        const graph = expandGraph(tree);
                        makeGraph(graph, true);
                    });
                    reader.readAsText(file);
                }
                for (const file of fileSelection.files) {
                    loadFile(file);
                }
            });
        }

        /**
         * Called once html has loaded.
         *
         * Create the Webgl contect, set up the buffers and call the event loop.
         */
        function main(event) {
            initialise();
            requestAnimationFrame(render);
        }

        window.addEventListener('load', main);
    </script>
</body>

</html>