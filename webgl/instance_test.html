<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Instances</title>
    <style>
        html {
            box-sizing: border-box;
            font-family: sans-serif;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            overflow: hidden;
        }

        #main-canvas {
            width: 100dvw;
            height: 100dvh;
        }

        #projection-control {
            position: absolute;
            background-color: white;
            display: grid;
            grid-template-columns: repeat(2, max-content);
            grid-template-rows: repeat(4, max-content);
            left: 0;
            top: 0;
        }

        #controls {
            position: absolute;
            right: 0;
            top: 0;
            display: flex;
            flex-direction: column;
            align-items: end;
        }

        #movement {
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            background-color: white;
        }

        #view-vectors {
            display: grid;
            grid-template-columns: repeat(3, max-content);
            grid-template-rows: repeat(3, max-content);
            background-color: white;
        }

        .matrix-input {
            width: 5em;
        }

        #projection-control>details {
            grid-column: 1 / -1;
        }

        #structure {
            display: grid;
            grid-template-columns: 10em repeat(7, max-content);
            grid-gap: 3px;
            overflow: auto;
            max-height: 50vh;
        }

        #structure .value {
            text-align: center;
        }

        #state {
            position: fixed;
            bottom: 1em;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 0.5em;
            padding: 0.3em;
        }
    </style>
</head>

<body>
    <canvas id="main-canvas" tabindex="1">HTML canvas not supported!</canvas>

    <div id="projection-control">
        Field of View<input id="field-of-view" type="number" />
        Aspect<input id="aspect" type="number" />
        Near<input id="near" type="number" />
        Far<input id="far" type="number" />
        <details>
            <summary>Structure</summary>
            <div id="structure">
                <span>Name</span>
                <span>Position</span>
                <span>Size</span>
                <span>Angle</span>
                <span>Axis</span>
                <span>Colour</span>
                <span>Specular</span>
                <span>opacity</span>
            </div>
        </details>

    </div>
    <div id="controls">
        <div id="view-vectors"></div>
        <div id="movement">
            <button id="anti-clockwise">&#8634;</button>
            <button id="move-up">&#8593;</button>
            <button id="clockwise">&#8635;</button>

            <button id="move-left">&#8592;</button>
            <button id="clear">&#9114;</button>
            <button id="move-right">&#8594;</button>

            <button id="move-forward">&#8634;</button>
            <button id="move-down">&#8595;</button>
            <button id="move-backwards">&#8634;</button>
        </div>
    </div>
    <div id="state"></div>

    <script type="x-shader/x-vertex" id="vertex-shader">
    #version 300 es
    precision highp float;

    uniform mat4 projection;
    uniform mat4 view;

    in vec3 position;
    in vec3 normal;
    in mat4 model;
    in vec3 ambientColour;
    in vec3 diffuseColour;
    in vec3 specularColour;
    in float specularIntensity;
    in float opacity;

    out vec4 v_vertex;
    out vec4 v_normal;
    out vec3 v_ambientColour;
    out vec3 v_diffuseColour;
    out vec3 v_specularColour;
    out float v_opacity;
    out float v_specularIntensity;

    void main() {
        v_vertex = model * vec4(position, 1.0);
        //vec4 world = view * v_vertex;
        gl_Position = projection * view * v_vertex;
        v_normal = model * vec4(normal, 0.0);
        v_ambientColour = ambientColour;
        v_diffuseColour = diffuseColour;
        v_specularColour = specularColour;
        v_opacity = opacity;
        v_specularIntensity = specularIntensity;

        gl_PointSize = 5.0;//50.0 * model[0][0];
    }
  </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
    #version 300 es
    precision highp float;
    uniform vec3 lightPosition1;
    uniform vec3 lightPosition2;
    uniform vec3 lightPosition3;
    uniform vec3 eyePosition;

    in vec4 v_vertex;
    in vec4 v_normal;
    in vec3 v_ambientColour;
    in vec3 v_diffuseColour;
    in vec3 v_specularColour;
    in float v_specularIntensity;
    in float v_opacity;

    out vec4 fragmentColour;

    void main() {
        vec3 toLight1 = normalize(lightPosition1 - v_vertex.xyz);
        vec3 toLight2 = normalize(lightPosition2 - v_vertex.xyz);
        vec3 toLight3 = normalize(lightPosition3 - v_vertex.xyz);
        vec3 normal = normalize(v_normal.xyz);

        float df = max(0.0, dot(normal, toLight1)) + 0.2 * max(0.0, dot(normal, toLight2)) + 0.1 * max(0.0, dot(normal, toLight3));

        vec3 reflection1 = normalize(2.0 * dot(normal, toLight1) * normal - toLight1);
        vec3 reflection2 = normalize(2.0 * dot(normal, toLight2) * normal - toLight2);
        vec3 reflection3 = normalize(2.0 * dot(normal, toLight3) * normal - toLight3);
        vec3 toEye = normalize(eyePosition - v_vertex.xyz);
        float sf = clamp(dot(reflection1, toEye), 0.0, 1.0) + 0.2 * clamp(dot(reflection2, toEye), 0.0, 1.0) + 0.1 * clamp(dot(reflection3, toEye), 0.0, 1.0);
        sf = pow(sf, v_specularIntensity);

        vec3 colour = v_ambientColour + v_diffuseColour * df + v_specularColour * sf;
        //fragmentColour = vec4(colour, v_opacity);
        if (v_opacity > 0.0 && dot(normal, toEye) > -0.1) {
            discard;
            return;
        }
        fragmentColour = vec4(colour, 1.0);
    }
    </script>

    <script>
        /**
         * Update report display.
         */
        function report(...text) {
            document.getElementById('state').innerText = text.join();
        }

        /**
         * Create matrix control.
         */
        function projectionControl() {
            const fov = document.getElementById('field-of-view');
            fov.value = 30;
            const aspect = document.getElementById('aspect');
            aspect.value = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const near = document.getElementById('near');
            near.value = 1;
            const far = document.getElementById('far');
            far.value = 10000;

            const update = () => {
                app.fov = fov.valueAsNumber;
                app.aspect = aspect.valueAsNumber;
                app.near = near.valueAsNumber;
                app.far = far.valueAsNumber;
                app.projectionMatrix = perspective(app.fov, app.aspect, app.near, app.far);
            }
            fov.addEventListener('change', (event) => update());
            aspect.addEventListener('change', (event) => update());
            near.addEventListener('change', (event) => update());
            far.addEventListener('change', (event) => update());
            update();
        }

        /**
         * Get view vectors
         */
        function viewVectors() {
            const viewVector = subtract(app.lookAt, app.eyePosition);
            const scaled = Math.hypot(...viewVector) / 1000;
            const zAxis = normalised(viewVector);
            const xAxis = normalised(cross(zAxis, app.up));
            const yAxis = normalised(cross(zAxis, xAxis));
            return { xAxis, yAxis, zAxis, scaled };
        }

        /**
         * Move Forward.
         */
        function forward(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            app.velocity = add(app.velocity, scale(zAxis, amount * scaled));
        }

        /**
         * Move right.
         */
        function right(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            app.velocity = add(app.velocity, scale(xAxis, amount * scaled));
        }

        /**
         * Move up.
         */
        function up(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            app.velocity = add(app.velocity, scale(yAxis, -amount * scaled));
        }

        /**
         * Move up.
         */
        function clockwise(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            const rotation = getRotation(amount * -2, zAxis);
            app.up = applyTransform(yAxis, rotation);
            app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
            app.updateViewControls();
        }

        /**
         * Rotate right
         */
        function rotateRight(amount = 1) {
            const { xAxis, yAxis, zAxis, scaled } = viewVectors();
            const rotation = getRotation(amount * -0.5, yAxis);
            app.rotation = multiply(app.rotation, rotation);
        }

        /**
         * Add actions for the movement controls
         */
        function addMovementControls() {
            document.getElementById('anti-clockwise').addEventListener('click', (event) => clockwise(-1));
            document.getElementById('move-up').addEventListener('click', (event) => up());
            document.getElementById('clockwise').addEventListener('click', (event) => clockwise());

            document.getElementById('move-left').addEventListener('click', (event) => right(-1));
            document.getElementById('clear').addEventListener('click', (event) => clear());
            document.getElementById('move-right').addEventListener('click', (event) => right());

            document.getElementById('move-forward').addEventListener('click', (event) => forward());
            document.getElementById('move-down').addEventListener('click', (event) => up(-1));
            document.getElementById('move-backwards').addEventListener('click', (event) => forward(-1));
        }

        /**
         * Create matrix control.
         */
        function viewControl() {
            const container = document.getElementById('view-vectors');

            const update = () => {
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
            }

            const vectorControl = (attribute, name) => {
                app[attribute].forEach((value, index) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = value;
                    input.id = `${name}-${index}`;
                    input.classList.add('matrix-input');
                    input.addEventListener('input', (event) => {
                        app[attribute][index] = input.valueAsNumber;
                        update();
                    });
                    input.addEventListener('focus', (event) => app.editingViewControls = true);
                    input.addEventListener('blur', (event) => app.editingViewControls = false);
                    container.appendChild(input);
                });
            };
            app.eyePosition = [0, 0, 15];
            app.lookAt = [0, 0, 0];
            app.up = [0, 1, 0];
            vectorControl('eyePosition', 'eye-position')
            vectorControl('lookAt', 'look-at');
            vectorControl('up', 'up');
            update();
            app.updateViewControls = () => {
                if (!app.editingViewControls) {
                    document.getElementById('eye-position-0').value = app.eyePosition[0].toFixed(1);
                    document.getElementById('eye-position-1').value = app.eyePosition[1].toFixed(1);
                    document.getElementById('eye-position-2').value = app.eyePosition[2].toFixed(1);

                    document.getElementById('look-at-0').value = app.lookAt[0].toFixed(1);
                    document.getElementById('look-at-1').value = app.lookAt[1].toFixed(1);
                    document.getElementById('look-at-2').value = app.lookAt[2].toFixed(1);

                    document.getElementById('up-0').value = app.up[0].toFixed(1);
                    document.getElementById('up-1').value = app.up[1].toFixed(1);
                    document.getElementById('up-2').value = app.up[2].toFixed(1);
                }
            }
        }

        /**
         * This script manages a single gl context so intialise here for simplicity.
         */
        const canvas = document.getElementById('main-canvas');
        const gl = canvas.getContext('webgl2');

        /**
         * Utility function to parse and report errors
         */
        function glErrors(context = '') {
            const err = gl.getError();

            if (err) {
                const errors = [];
                errors[gl.INVALID_ENUM] = `An unacceptable value has been specified for an enumerated argument. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_VALUE] = `A numeric argument is out of range. The command is ignored and the error flag is set.`;
                errors[gl.INVALID_OPERATION] = 'The specified command is not allowed for the current state. The command is ignored and the error flag is set.';
                errors[gl.INVALID_FRAMEBUFFER_OPERATION] = 'The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.';
                errors[gl.OUT_OF_MEMORY] = 'Not enough memory is left to execute the command.';
                errors[gl.CONTEXT_LOST_WEBGL] = 'If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.';
                console.trace();
                console.log(context, errors[err]);
            }
        }

        /**
         * App object to minimise global namespace polution.
         */
        const app = {
            projectionMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            viewMatrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            instances: [],
            points: [],
            scale: 1, //0.001,
            roots: [],
            wireframe: false,
            cullFaces: true,
            cornerOrigin: true,
            velocity: [0, 0, 0],
            rotation: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            addRoot(position, size, rotation, axis, colour, opacity, specular) {
                const root = new Instance(
                    undefined,
                    position,
                    size,
                    rotation,
                    axis,
                    colour,
                    opacity,
                    specular);
                this.instances.push(root);
                this.roots.push(root);
                return root;
            },
        };
        const shaderSource = {
            vertex: document.querySelector("#vertex-shader").innerHTML,
            fragment: document.querySelector("#fragment-shader").innerHTML,
        }

        /**
         * Create and compile a shader of the specified type using the source provided.
         */
        function makeShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source.trim());
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return;
            }
            return shader;
        }

        /**
         * Compile shaders into a program.
         */
        function makeProgram(source, attributes = [], uniforms = []) {
            const vertex = makeShader(gl.VERTEX_SHADER, source.vertex);
            const fragment = makeShader(gl.FRAGMENT_SHADER, source.fragment);

            // Create a program instance for the shaders
            if (vertex && fragment) {
                const shader = {
                    program: gl.createProgram(),
                };
                gl.attachShader(shader.program, vertex);
                gl.attachShader(shader.program, fragment);
                gl.linkProgram(shader.program);

                // See if it linked successfully
                if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
                    alert('Unable to initialise the shader program: ' + gl.getProgramInfoLog(shader.program));
                    return null;
                }

                uniforms.forEach((uniform) => shader[uniform] = gl.getUniformLocation(shader.program, uniform));
                attributes.forEach((attribute) => shader[attribute] = gl.getAttribLocation(shader.program, attribute));

                return shader;
            }
        }

        /**
         * Generate the vertex data for a cube.
         */
        function makeCube() {
            const positions = [
                [-1, -1, -1,],
                [1, -1, -1,],
                [-1, 1, -1,],
                [1, 1, -1,],
                [-1, -1, 1,],
                [1, -1, 1,],
                [-1, 1, 1,],
                [1, 1, 1,],
            ].map((v) => v.map((i) => i / 2));
            const normals = [
                [-1, 0, 0,],
                [0, -1, 0,],
                [0, 0, -1,],
                [1, 0, 0,],
                [0, 1, 0,],
                [0, 0, 1,],
            ];

            /*
            *       4 ------ 5
            *      /|        | \
            *    0 ------------ 1
            *    |  |        |  |
            *    |  |        |  |
            *    |  |        |  |
            *    |  6 ------ 7  |
            *    | /          \ |
            *    2 ------------ 3
            */

            const triangles = [
                { p1: positions[0], p2: positions[1], p3: positions[2], n: normals[2] },
                { p1: positions[1], p2: positions[3], p3: positions[2], n: normals[2] },

                { p1: positions[0], p2: positions[4], p3: positions[5], n: normals[1] },
                { p1: positions[5], p2: positions[1], p3: positions[0], n: normals[1] },

                { p1: positions[4], p2: positions[6], p3: positions[7], n: normals[5] },
                { p1: positions[5], p2: positions[4], p3: positions[7], n: normals[5] },

                { p1: positions[6], p2: positions[2], p3: positions[3], n: normals[4] },
                { p1: positions[7], p2: positions[6], p3: positions[3], n: normals[4] },

                { p1: positions[3], p2: positions[1], p3: positions[5], n: normals[3] },
                { p1: positions[5], p2: positions[7], p3: positions[3], n: normals[3] },

                { p1: positions[6], p2: positions[4], p3: positions[0], n: normals[0] },
                { p1: positions[6], p2: positions[0], p3: positions[2], n: normals[0] },
            ];
            const lines = [
                positions[0], positions[1],
                positions[1], positions[3],
                positions[3], positions[2],
                positions[2], positions[0],

                positions[0], positions[4],
                positions[1], positions[5],
                positions[2], positions[6],
                positions[3], positions[7],

                positions[4], positions[5],
                positions[5], positions[7],
                positions[7], positions[6],
                positions[6], positions[4],
            ];
            const normalised = ([x, y, z]) => {
                const l = Math.hypot(x, y, z);
                return [x / l, y / l, z / l];
            };
            return [...triangles.flatMap((t) => [...t.p1, ...t.n, ...t.p2, ...t.n, ...t.p3, ...t.n]),
            ...lines.flatMap((p) => [...p, ...normalised(p)])];
        }

        /**
         * Update the gl buffers used to define the base object used for instancing.
         */
        function updateObject() {

        }

        /**
         * Initialise Instances
         */
        function initialiseInstances() {
            const matrices = [];
            app.instances.forEach((instance) => matrices.push(...instance.transform));

            app.modelMatrix = new Float32Array(matrices); // 4 bytes per float, 16 floats per matrix
            app.instances.forEach((instance, index) =>
                instance.matrix = new Float32Array(app.modelMatrix.buffer, index * 16 * 4, 16));

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferData(gl.ARRAY_BUFFER, app.modelMatrix.byteLength, gl.DYNAMIC_DRAW);

            const colourBuffer = [];
            app.instances.forEach((instance, index) => {
                colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                colourBuffer.push(...instance.colour.map((v) => v * 1.0));
                colourBuffer.push(instance.specular);
                colourBuffer.push(app.wireframe || !app.cullFaces ? 0 : instance.children.length);
            });
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colourBuffer), gl.STATIC_DRAW);

            app.instancesChanged = true;
        }

        /**
         * Update the colour data from the instances.
         */
        function updateColours() {
            const colourBuffer = [];
            app.instances.forEach((instance, index) => {
                const colour = instance.selected ? [1, 1, 1] : instance.colour;
                colourBuffer.push(...colour.map((v) => v * 0.3));
                colourBuffer.push(...colour.map((v) => v * 0.3));
                colourBuffer.push(...colour.map((v) => v * 1.0));
                colourBuffer.push(instance.specular);
                colourBuffer.push(app.wireframe || !app.cullFaces ? 0 : instance.children.length);
            });
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colourBuffer), gl.STATIC_DRAW);
        }

        /**
         * Update the colour data from the instances.
         */
        function updatePoints() {
            const points = app.points.flatMap((point) => [...point.position, 1, 1, 1]);
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.DYNAMIC_DRAW);
        }

        /**
         * Add instance
         */
        function addInstance(size, position, rotation) {

        }

        /**
         * Calculate the product of 2 4 x 4 matrices and store the result in the third.
         */
        function multiply(a, b, matrix) {
            matrix = matrix || Array(16);
            matrix[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
            matrix[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
            matrix[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
            matrix[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

            matrix[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
            matrix[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
            matrix[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
            matrix[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

            matrix[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
            matrix[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
            matrix[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
            matrix[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

            matrix[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
            matrix[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
            matrix[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
            matrix[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
            return matrix;
        }

        /**
         * Update the gl buffers used to define each instance of an object.
         */
        function updateInstances(time) {
            app.instances.forEach((instance) => instance.transform.forEach((value, index) => instance.matrix[index] = value));
            // update the matrix data
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, app.modelMatrix);
        }

        /**
         * Update the object definition and the instances if required.
         */
        function updateBuffers(time) {
            if (app.objectChanged) {
                updateObject(time);
            }
            if (app.instancesChanged) {
                updateInstances(time);
                //app.instancesChanged = false;
            }
        }

        /**
         * Calculate a perspective matrix
         */
        function perspective(fieldOfView, aspect, zNear, zFar) {
            const f = 1 / Math.tan(fieldOfView * Math.PI / 360);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zNear + zFar) / (zNear - zFar), -1,
                0, 0, 2 * (zFar * zNear) / (zNear - zFar), 0,
            ];
        }

        /**
         * Calculate a view matrix from eye position, focus point and up vecotrs.
         */
        function viewMatrix(eyePosition, lookAt, up) {
            const negate = (v) => { v[0] *= -1; v[1] *= -1; v[2] *= -1; };
            const zaxis = normalised(subtract(lookAt, eyePosition));
            const xaxis = normalised(cross(zaxis, up));
            const yaxis = cross(xaxis, zaxis);

            negate(zaxis);

            return [
                xaxis[0], yaxis[0], zaxis[0], 0,
                xaxis[1], yaxis[1], zaxis[1], 0,
                xaxis[2], yaxis[2], zaxis[2], 0,
                -dot(xaxis, eyePosition), -dot(yaxis, eyePosition), -dot(zaxis, eyePosition), 1,
            ];
        }

        /**
         * Set Attribute pointers for drawing boxes.
         */
        function setBoxAttributes() {
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride = 3 * 4 * 2,  offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.normal, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.normal);


            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.instances);

            // Matrices are passed as 4 vertex attributes
            for (let i = 0; i < 4; ++i) {
                const location = app.shader.model + i;
                // attribute index, numComponents = 3, type = gl.FLOAT,  normalise = false,  stride (bytes),  offset
                gl.vertexAttribPointer(location, 4, gl.FLOAT, false, 4 * 16, i * 16);
                gl.vertexAttribDivisor(location, 1);
                gl.enableVertexAttribArray(location);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.ambientColour);
            gl.vertexAttribDivisor(app.shader.ambientColour, 1);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);
            gl.vertexAttribDivisor(app.shader.diffuseColour, 1);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 4 * (3 * 3 + 2), 0);
            gl.enableVertexAttribArray(app.shader.specularColour);
            gl.vertexAttribDivisor(app.shader.specularColour, 1);

            gl.vertexAttribPointer(app.shader.specularIntensity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 36);
            gl.enableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttribDivisor(app.shader.specularIntensity, 1);

            gl.vertexAttribPointer(app.shader.opacity, 1, gl.FLOAT, false, 4 * (3 * 3 + 2), 40);
            gl.enableVertexAttribArray(app.shader.opacity);
            gl.vertexAttribDivisor(app.shader.opacity, 1);
        }

        /**
         * Set Attribute pointers for drawing points.
         */
        function setPointAttributes() {
            gl.disableVertexAttribArray(app.shader.normal);
            gl.vertexAttrib3f(app.shader.normal, 0.0, 0.0, 1.0);

            gl.disableVertexAttribArray(app.shader.model);
            gl.disableVertexAttribArray(app.shader.model + 1);
            gl.disableVertexAttribArray(app.shader.model + 2);
            gl.disableVertexAttribArray(app.shader.model + 3);
            gl.vertexAttrib4f(app.shader.model, 1, 0, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 1, 0, 1, 0, 0);
            gl.vertexAttrib4f(app.shader.model + 2, 0, 0, 1, 0);
            gl.vertexAttrib4f(app.shader.model + 3, 0, 0, 0, 1);

            gl.disableVertexAttribArray(app.shader.specularIntensity);
            gl.vertexAttrib1f(app.shader.specularIntensity, 1.0);

            gl.disableVertexAttribArray(app.shader.opacity);
            gl.vertexAttrib1f(app.shader.opacity, 0.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.points);

            // attribute index, numComponents = 3, type = gl.FLOAT, normalise = false, stride = 3 * 4 * 2, offset = 0
            gl.vertexAttribPointer(app.shader.position, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(app.shader.position);

            gl.vertexAttribPointer(app.shader.ambientColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.ambientColour);

            gl.vertexAttribPointer(app.shader.diffuseColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.diffuseColour);

            gl.vertexAttribPointer(app.shader.specularColour, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(app.shader.specularColour);
        }

        /**
         * Render loop function to update the display
         */
        let start;
        function render(time) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            if (start) {
                const delta = time - start;
                app.eyePosition = add(app.eyePosition, scale(app.velocity, delta / 1000));
                app.lookAt = add(app.lookAt, scale(app.velocity, delta / 1000));
                const direction = applyTransform(subtract(app.lookAt, app.eyePosition), app.rotation);
                app.rotation = scaleMatrix(app.rotation, 0.1);
                app.lookAt = add(app.eyePosition, direction);
                app.updateViewControls();
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                app.velocity = scale(app.velocity, 0.9);
                updateBuffers(time);
                gl.useProgram(app.shader.program);

                gl.uniformMatrix4fv(app.shader.projection, false, app.projectionMatrix);
                gl.uniformMatrix4fv(app.shader.view, false, app.viewMatrix);
                gl.uniform3fv(app.shader.eyePosition, app.eyePosition);
                gl.uniform3fv(app.shader.lightPosition1, [5000, 5000, 5000]);
                gl.uniform3fv(app.shader.lightPosition2, [500, -500, 5000]);
                gl.uniform3fv(app.shader.lightPosition3, [1000, 15000, 1000]);

                setBoxAttributes();
                if (!app.wireframe) {
                    gl.drawArraysInstanced(gl.TRIANGLES, 0, app.vertexCount, app.instances.length);
                }
                gl.drawArraysInstanced(gl.LINES, 36, 24, app.instances.length);

                if (app.points.length > 0) {
                    setPointAttributes();
                    gl.drawArrays(gl.POINTS, 0, app.points.length);
                }
                glErrors();
            } else {
                start = time;
            }
            requestAnimationFrame(render);
        }

        /**
         * translate a touch event into a simplified mouse event.
         */
        function touch(event) {
            event.preventDefault();
            event.stopPropagation();
            return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
        }

        /**
         * Manage an instance.
         */
        class Instance {
            constructor(parent, position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour = [0.5, 0.5, 0.5], opacity = 1, specular = 10) {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                this.parent = parent;
                if (position.name) {
                    this.name = position.name;
                    this.position = position.position;
                    this.size = position.size;
                    this.angle = position.angle;
                    this.axis = normalised(position.axis);
                    this.colour = position.colour;
                    this.opacity = position.opacity;
                    this.specular = position.specular;
                } else {
                    this.name = `Instance ${app.instances.length + 1}`;
                    this.position = position;
                    this.size = size;
                    this.angle = angle;
                    this.axis = normalised(axis);
                    this.colour = colour;
                    this.opacity = opacity;
                    this.specular = specular;
                }
                this.origin = Array(16);
                this.children = [];
                this.rate = 0;
                this.offset = 0;
                this.setTransform();
            }
            /**
             * Set the transform of a shape based on its position, rotation and scale.
             * 
             * Calculate the origin for children of the shape
             */
            setTransform() {
                const normalised = ([x, y, z]) => {
                    const l = Math.hypot(x, y, z);
                    return [x / l, y / l, z / l];
                };

                const parent = this.parent || { origin: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
                const origin = parent.origin;
                const angle = this.angle * Math.PI / 360;
                const qw = Math.cos(angle);
                const axis = normalised(this.axis);
                const qx = axis[0] * Math.sin(angle);
                const qy = axis[1] * Math.sin(angle);
                const qz = axis[2] * Math.sin(angle);

                const translation = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    app.scale * this.position[0],
                    app.scale * this.position[1],
                    app.scale * this.position[2], 1
                ];
                this.rotation = [
                    1 - 2 * qy * qy - 2 * qz * qz,
                    2 * qx * qy - 2 * qz * qw,
                    2 * qx * qz + 2 * qy * qw,
                    0,

                    2 * qx * qy + 2 * qz * qw,
                    1 - 2 * qx * qx - 2 * qz * qz,
                    2 * qy * qz - 2 * qx * qw,
                    0,

                    2 * qx * qz - 2 * qy * qw,
                    2 * qy * qz + 2 * qx * qw,
                    1 - 2 * qx * qx - 2 * qy * qy,
                    0,

                    0, 0, 0, 1
                ];
                const scale = [
                    app.scale * this.size[0], 0, 0, 0,
                    0, app.scale * this.size[1], 0, 0,
                    0, 0, app.scale * this.size[2], 0,
                    0, 0, 0, 1
                ];

                const rotationTranslate = multiply(this.rotation, translation);
                this.origin = multiply(rotationTranslate, origin);
                this.transform = multiply(scale, this.origin);
            }
            update(child) {
                this.setTransform();
                this.children.forEach((child) => child.update(true));
                app.instancesChanged = true;
                if (!child) {
                    const colourBuffer = [];
                    app.instances.forEach((instance, index) => {
                        colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                        colourBuffer.push(...instance.colour.map((v) => v * 0.3));
                        colourBuffer.push(...instance.colour.map((v) => v * 1.0));
                        colourBuffer.push(instance.specular);
                        colourBuffer.push(app.wireframe || !app.cullFaces ? 0 : instance.children.length);
                    });
                    gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.colour);
                    gl.bufferData(gl.ARRAY_BUFFER,
                        new Float32Array(colourBuffer),
                        gl.STATIC_DRAW);
                }
            }
            addChild(position = [0, 0, 0], size = [1, 1, 1], angle = 0, axis = [0, 1, 0], colour, opacity, specular) {
                const newInstance = new Instance(
                    this,
                    position,
                    size,
                    angle,
                    axis,
                    colour || this.colour,
                    opacity || this.opacity,
                    specular || this.specular);
                this.children.push(newInstance);
                app.instances.push(newInstance);
                return newInstance;
            }
            promote() {
                if (this.parent) {
                    const siblings = this.parent.children;
                    const position = siblings.indexOf(this);
                    const children = siblings.splice(position, siblings.length - position);
                    children.shift();
                    this.children.push(...children);
                    children.forEach((child) => child.parent = this);
                    this.update();
                    const list = this.parent.parent ? this.parent.parent.children : app.roots;
                    const pos = list.indexOf(this.parent);
                    list.splice(pos + 1, 0, this);
                    this.parent = this.parent.parent;
                }
            }
            demote() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position > 1) {
                    list.splice(position, 1);
                    list[position - 1].children.unshift(this);
                    this.parent = list[position - 1];
                    this.update();
                }
            }
            down() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position < list.length - 1) {
                    list.splice(position, 1);
                    list.splice(position + 1, 0, this);
                    this.update();
                }
            }
            up() {
                const list = this.parent ? this.parent.children : app.roots;
                const position = list.indexOf(this);
                if (position > 0) {
                    list.splice(position, 1);
                    list.splice(position - 1, 0, this);
                    this.update();
                }
            }
        }

        const action = {};
        document.body.addEventListener('mousemove', (event) => action.move?.(event));
        document.body.addEventListener('mouseup', (event) => action.move = null);

        document.body.addEventListener('touchmove', (event) => action.move?.(touch(event)));
        document.body.addEventListener('touchend', (event) => action.move = null);
        /**
         * Show structure
         */
        function showStructure() {
            const structure = document.getElementById('structure');
            structure.innerHTML = `<span>Name</span>
                <span class="value">Position</span>
                <span class="value">Size</span>
                <span class="value">Angle</span>
                <span class="value">Axis</span>
                <span class="value">Colour</span>
                <span class="value">Specular</span>
                <span class="value">opacity</span>`;

            const addInstance = (instance, level = 0) => {
                const addControls = (node, item, element, scaled) => {
                    node.contentEditable = true;
                    node.addEventListener('blur', (event) => {
                        if (isNaN(Number(item[element]))) {
                            item[element] = node.innerText;
                        } else {
                            item[element] = Number(node.innerText);
                        }
                    });
                    node.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            if (isNaN(Number(item[element]))) {
                                node.innerHTML = item[element];
                            } else {
                                node.innerHTML = item[element].toFixed();
                            }
                        }
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            if (event.shiftKey) {
                                instance.addChild([0, 0, 0], scale(instance.size, 0.5));
                                initialiseInstances();
                                showStructure();
                            } else {
                                if (isNaN(Number(node.innerText))) {
                                    item[element] = node.innerText;
                                } else {
                                    item[element] = Number(node.innerText);
                                }
                                instance.update();
                            }
                        }
                        if (event.ctrlKey) {
                            if (event.key === 'ArrowLeft') {
                                instance.promote();
                                showStructure();
                            }
                            if (event.key === 'ArrowRight') {
                                instance.demote();
                                showStructure();
                            }
                            if (event.key === 'ArrowUp') {
                                instance.up();
                                showStructure();
                            }
                            if (event.key === 'ArrowDown') {
                                instance.down();
                                showStructure();
                            }
                        }
                    });

                    if (!isNaN(Number(item[element]))) {
                        const places = Math.floor(Math.log10(1 / scaled));
                        node.addEventListener('mousedown', (event) => {
                            action.last = event.clientY;
                            action.move = (event) => {
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.update();
                            };
                        });
                        node.addEventListener('touchstart', (event) => {
                            event = touch(event);
                            action.last = event.clientY;
                            action.move = (event) => {
                                const delta = (event.clientY - action.last) * scaled;
                                action.last = event.clientY;
                                item[element] += delta;
                                node.innerText = item[element].toFixed(places);
                                instance.update();
                            };
                        });
                    }
                }
                const addSpan = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    const node = document.createElement('span');
                    if (isNaN(Number(instance[argument]))) {
                        node.innerHTML = instance[argument];
                    } else {
                        node.innerHTML = instance[argument].toFixed();
                        node.classList.add('value');
                    }
                    addControls(node, instance, argument, scaled);
                    return node;
                }
                const addVec = (argument, scaled = 0.1) => {
                    const places = Math.floor(Math.log10(1 / scaled));

                    const container = document.createElement('div');
                    instance[argument].forEach((item, index) => {
                        const node = document.createElement('span');
                        node.classList.add('value');
                        node.innerHTML = item.toFixed(places);
                        addControls(node, instance[argument], index, scaled);
                        container.append(node, ', ');
                    });
                    return container;
                }
                const name = document.createElement('span');
                name.style.whiteSpace = 'pre';
                name.append(''.padStart(level * 2, ' '), addSpan('name'));
                structure.append(name,
                    addVec('position'),
                    addVec('size'),
                    addSpan('angle'),
                    addVec('axis'),
                    addVec('colour', 0.01),
                    addSpan('specular'),
                    addSpan('opacity'));
                instance.children.forEach((child) => addInstance(child, level + 1));
            }
            app.roots.forEach((child) => addInstance(child));
        }

        const commands = {
            'eye position'(value) {
                app.eyePosition = value.split(/,/g).map((v) => parseFloat(v));
            },
            'look at'(value) {
                app.lookAt = value.split(/,/g).map((v) => parseFloat(v));
            }
        }


        /**
         * Convert text to objects
         */
        function getObjects(text) {
            const lines = text.split(/\r?\n/g);
            let processLine = true;
            return lines.flatMap((line) => {
                if (line === '!stop') {
                    processLine = false;
                }
                if (processLine && line.trim() !== '' && !line.trim().startsWith('#')) {
                    if (line.startsWith('>')) {
                        const [command, value] = line.replace(/^>\s*/, '').split('=').map((v) => v.trim());
                        if (commands[command]) {
                            commands[command](value);
                        }
                        return [];
                    }
                    const [indentedName, positionStr, sizeStr, angleStr, axisStr, colourStr, specularStr, opacityStr, instances] = line.split(/\s*;\s*/);
                    const indent = indentedName.replace(/\S.*/, '');
                    const rangeName = indentedName.replace(/^\s+/, '');
                    const match = rangeName.match(/(\[(?<instances>[^\]]+)\]\s*)?(?<name>.*)/);
                    const name = match.groups.name;

                    let level = 0;
                    for (let i = 0; i < indent.length; ++i) {
                        if (indent[i] === '\t') {
                            level += 4 - (level % 4);
                        } else {
                            level += 1;
                        }
                    }
                    const position = positionStr ? positionStr.split(',') : null;
                    const size = sizeStr ? sizeStr.split(',') : null;
                    const angle = angleStr ? angleStr : null;
                    const axis = axisStr ? axisStr.split(',') : null;
                    const colour = colourStr ? colourStr.split(',') : null;
                    const specular = specularStr ? specularStr : null;
                    const opacity = opacityStr ? opacityStr : null;
                    return {
                        name, level, position, size, angle, axis, colour, specular, opacity, instances: instances ?? match.groups.instances, children: [],
                    };
                }
                return [];
            });
        }

        /**
         * Convert a list of objects into a tree structure based on the level of the objects
         */
        function getTree(objs) {
            const roots = [];
            const stack = [];
            const named = {};
            objs.forEach((obj) => {
                named[obj.name] = obj;
                const [name, type] = obj.name.split(/\s*:\s*/);
                if (type && named[type]) {
                    Object.getOwnPropertyNames(obj).forEach((property) => {
                        obj[property] = obj[property] ?? named[type][property];
                    });
                    obj.children.push(...named[type].children.map((child) => Object.assign({}, child)));
                }
                while (stack.length && obj.level <= stack[0].level) {
                    stack.shift();
                }
                if (stack.length > 0) {
                    stack[0].children.push(obj);
                    obj.parent = stack[0];
                } else {
                    roots.push(obj);
                }
                stack.unshift(obj);
            });
            return roots;
        }

        /**
         * Convert a range specifier to a list.
         */
        function getList(definition) {
            const rangePattern = /^(?<start>[0-9]+(\.[0-9]+)?)\s*\.\.\s*(?<end>[0-9]+(\.[0-9]+)?)(\s*:\s*(?<step>[0-9]+(\.[0-9]+)?))?/;
            const count = Number(definition);
            const list = [];
            if (isNaN(count)) {
                list.push(...definition.split(',').filter((item) => item).flatMap((item) => {
                    const range = item.match(rangePattern);
                    if (range) {
                        const start = Number(range.groups.start);
                        const end = Number(range.groups.end);
                        const step = Number(range.groups.step || 1);
                        const values = [];
                        for (let i = start; i <= end; i += step) {
                            values.push(i);
                        }
                        return values;
                    }
                    return Number(item.trim());
                }));
            } else {
                for (let i = 1; i <= count; ++i) {
                    list.push(i);
                }
            }
            return list;
        }

        /**
         * Expand a template graph to a full graph.
         */
        function expandGraph(templateGraph) {
            const expand = (node, context = []) => {
                const resolve = (value, context) => {
                    if (isNaN(Number(value))) {
                        value = value.replace(/<([0-9]*)>/g, (match, level) => context[parseInt(level) || 0]);
                        const func = new Function(`return ${value};`);
                        return func();
                    }
                    return Number(value);
                }
                const makeInstance = (node, context) => ({
                    name: node.name.replace(/<([0-9]*)>/g, (match, level) => context[parseInt(level) || 0]),
                    position: node.position.map((v) => resolve(v, context)),
                    size: node.size.map((v) => resolve(v, context)),
                    angle: resolve(node.angle, context),
                    axis: node.axis.map((v) => resolve(v, context)),
                    colour: node.colour.map((v) => resolve(v, context)),
                    specular: resolve(node.specular, context),
                    opacity: resolve(node.opacity, context),
                    children: node.children.flatMap((child) => expand(child, context)),
                });

                if (node.instances) {
                    const instances = getList(node.instances);
                    if (node.position) {
                        return instances.flatMap((instance) => makeInstance(node, [instance, ...context]));
                    } else {
                        return instances.flatMap((instance, index) => node.children.flatMap((child) => expand(child, [instance, ...context])));
                    }
                } else if (node.position) {
                    return makeInstance(node, context);
                }
                return [];
            }

            return templateGraph.flatMap((node) => expand(node));
        }

        /**
         * Make a test graph.
         */
        function makeGraph(source, replace) {
            if (source) {
                if (replace) {
                    app.instances = [];
                    app.roots = [];
                }
                const adjustOrigin = (node, offset = [0, 0, 0]) => {
                    if (app.cornerOrigin) {
                        node.position = add(node.position, scale(node.size, 0.5), offset);
                        node.children.forEach((child) => adjustOrigin(child, scale(node.size, -0.5)));
                    }
                }

                source.forEach((node) => adjustOrigin(node));

                const addNode = (parent, node) => {
                    const child = parent.addChild(node);
                    node.children.forEach((node) => addNode(child, node));
                }
                source.forEach((node) => {
                    const root = app.addRoot(node);
                    node.children.forEach((child) => addNode(root, child));
                });
                initialiseInstances();
                showStructure();
            } else {
                const root = app.addRoot(
                    [0, 0, 0],    // Position
                    [1, 1, 1],    // Size
                    0,            // Rotation
                    [0, 1, 0],    // Axis
                    [1, 1, 0],    // Colour
                    1.0,          // opacity
                    10.0);        // Specular
                /*
            const child = root.addChild([0, 750, 0], [500, 500, 500], 30);
            const grandchild = child.addChild([750, 0, 0], [1000, 500, 500], 45, [1, 0, 0], [1, 0, 0]);
            const grandchild2 = child.addChild([0, 0, 500], [500, 500, 500]);
            const greatgrandchild = grandchild.addChild([250, 1100, 0], [500, 1500, 500]);
            */
                showStructure();
            }
        }

        /**
         * Return a normalised version of the given vector.
         */
        function normalised(vector) {
            const l = Math.hypot(...vector);
            return vector.map((i) => i / l);
        }

        /**
         * Return vector A scaled by s
         */
        function scale(vector, scale) {
            return vector.map((v) => v * scale);
        }

        /**
         * Return matrix scaled by s to the unity matrix
         */
        function scaleMatrix(matrix, scale) {
            const ident = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            return matrix.map((v, i) => v + (ident[i] - v) * scale); 
        }

        /**
         * Componentwise some of vectors
         */
        function add(...vectors) {
            const length = Math.max(...vectors.map((v) => v.length));
            const result = [];
            for (let i = 0; i < length; ++i) {
                result.push(vectors.reduce((s, v) => s + (v[i] ?? 0), 0));
            }
            return result;
        }
        /**
         * Return vector A minus vector B
         */
        function subtract(a, b) {
            return a.map((v, i) => v - b[i]);
        }

        /**
         * Return the dot product of two vectors
         */
        function dot(v1, v2) {
            return v1.reduce((s, v, i) => s + v * v2[i], 0);
        }

        /**
         * Return the cross product of two vectors
         */
        function cross(v1, v2) {
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0],
            ];
        }

        /**
         * Apply a transform by multiplying a vector by a matrix
         */
        function applyTransform(vector, matrix) {
            return [
                matrix[0] * vector[0] + matrix[4] * vector[1] + matrix[8] * vector[2] + matrix[12],
                matrix[1] * vector[0] + matrix[5] * vector[1] + matrix[9] * vector[2] + matrix[13],
                matrix[2] * vector[0] + matrix[6] * vector[1] + matrix[10] * vector[2] + matrix[14],
            ];
        }

        /**
         * Return the rotation matrix based on angle and axis.
         */
        function getRotation(angle, axis) {
            angle = angle * Math.PI / 180;
            const qw = Math.cos(angle);
            axis = normalised(axis);
            const qx = axis[0] * Math.sin(angle);
            const qy = axis[1] * Math.sin(angle);
            const qz = axis[2] * Math.sin(angle);

            return [
                1 - 2 * qy * qy - 2 * qz * qz,
                2 * qx * qy - 2 * qz * qw,
                2 * qx * qz + 2 * qy * qw,
                0,

                2 * qx * qy + 2 * qz * qw,
                1 - 2 * qx * qx - 2 * qz * qz,
                2 * qy * qz - 2 * qx * qw,
                0,

                2 * qx * qz - 2 * qy * qw,
                2 * qy * qz + 2 * qx * qw,
                1 - 2 * qx * qx - 2 * qy * qy,
                0,

                0, 0, 0, 1
            ];
        }

        /**
         * Get ray from screen position
         */
        function getRay(x, y) {
            const f = 1 / Math.tan(app.fov * Math.PI / 360);

            const w = canvas.clientWidth / 2;
            const h = canvas.clientHeight / 2;

            const zAxis = normalised(subtract(app.lookAt, app.eyePosition));
            const yAxis = normalised(app.up);
            const xAxis = cross(zAxis, yAxis);

            const position = add(scale(xAxis, x - w), scale(yAxis, h - y), scale(zAxis, h * f));
            const direction = normalised(position);

            return { point: app.eyePosition, direction };
        }

        /**
         * Get the point of intersection of a plane and line
         */
        function planeIntercept(line, plane) {
            const v = subtract(plane.point, line.point);
            const n = dot(plane.normal, v) / dot(plane.normal, line.direction);
            return n;
        }

        /**
         * Determine the intecept of a line and convex hull defined by a list of planes
         */
        function convexHullIntercept(line, planes) {
            let start = -Infinity, end = Infinity;
            line.direction = normalised(line.direction);
            planes.forEach((plane) => {
                const d = planeIntercept(line, plane);
                if (d !== undefined) {
                    const moveEnd = dot(line.direction, plane.normal) > 0;
                    if (moveEnd) {
                        end = Math.min(end, d);
                    } else {
                        start = Math.max(start, d);
                    }
                }
            });
            if (end < Infinity && end > start && start > -Infinity) {
                return [start, end];
            }
        }

        /**
         * Find the intersection of a ray and objects
         */
        function getIntersection(line) {
            // Check whether a line passes within the radius of the bounding sphere
            const hits = app.instances.filter((instance) => {
                const size = scale(instance.size, 0.5 * app.scale);
                const origin = [0, 0, 0];
                const centre = applyTransform(origin, instance.origin);
                const radius = Math.hypot(...size);

                const l = dot(line.direction, subtract(centre, line.point));
                const n = l / line.direction.reduce((s, v) => s + v * v, 0);
                const p = add(line.point, scale(line.direction, n));
                const v = subtract(p, centre);
                const dist = Math.hypot(...v);
                if (dist < radius) {
                    const corner1 = applyTransform(scale(size, -1), instance.origin);
                    const corner2 = applyTransform(size, instance.origin);
                    const planes = [
                        { point: corner1, normal: applyTransform([-1, 0, 0], instance.rotation) },
                        { point: corner1, normal: applyTransform([0, -1, 0], instance.rotation) },
                        { point: corner1, normal: applyTransform([0, 0, -1], instance.rotation) },
                        { point: corner2, normal: applyTransform([1, 0, 0], instance.rotation) },
                        { point: corner2, normal: applyTransform([0, 1, 0], instance.rotation) },
                        { point: corner2, normal: applyTransform([0, 0, 1], instance.rotation) },
                    ];
                    const points = convexHullIntercept(line, planes);
                    if (points) {
                        const p1 = add(line.point, scale(line.direction, points[0]));
                        const p2 = add(line.point, scale(line.direction, points[1]));
                        //app.points.push({ position: p1 }, { position: p2 });
                        instance.points = [p1, p2];
                        return points;
                    }
                }
            });
            if (hits.length) {
                const dist = (p1, p2) => Math.hypot(...subtract(p1, p2));
                // Find the closest to the view position that isn't a parent
                const hit = hits.filter((hit) => hit.children.filter((child) => hits.includes(child)).length === 0);
                hit.sort((a, b) => dist(app.eyePosition, a.points[0]) - dist(app.eyePosition, b.points[0]));
                app.instances.forEach((instance) => instance.selected = instance === hit[0]);
                report(hit[0].name);
                updateColours();
                updatePoints();
                return hits;
            }
        }

        /**
         * Add the event handlers for the canvas.
         */
        function addCanvasEvents(canvas) {
            canvas.tabIndex = 0;
            canvas.addEventListener('keydown', (event) => {
                if (event.key === 'w') {
                    app.wireframe = !app.wireframe;
                }
                if (event.key === 'i') {
                    app.cullFaces = !app.cullFaces;
                    updateColours();
                }
                if (event.key === 'c') {
                    app.points = [];
                    updatePoints();
                }
                const shiftMapping = {
                    ArrowUp: (event) => up(),
                    ArrowDown: (event) => up(-1),
                    ArrowLeft: (event) => right(-1),
                    ArrowRight: (event) => right(),
                }
                const mapping = {
                    ArrowUp: (event) => forward(),
                    ArrowDown: (event) => forward(-1),
                    ArrowLeft: (event) => rotateRight(-1),
                    ArrowRight: (event) => rotateRight(),
                }

                if (event.shiftKey) {
                    shiftMapping[event.key]?.(event);
                } else {
                    mapping[event.key]?.(event);
                }
            });

            const mouseDown = (event) => {
                action.lastX = event.clientX;
                action.lastY = event.clientY;
                const mouseLine = getRay(event.clientX, event.clientY);
                const hits = getIntersection(mouseLine);
                if (hits) {
                    // Move the clicked object
                    const { xAxis, yAxis, zAxis, scaled } = viewVectors();
                    action.selected = hits[0];
                    action.plane = { point: action.selected.points[0] };
                    if (Math.abs(dot(app.up, [0, 1, 0])) > 0.9) {
                        action.plane.normal = zAxis;
                    } else {
                        action.plane.normal = [0, 1, 0];
                    }
                    action.move = (event) => {
                        const mouseLine = getRay(event.clientX, event.clientY);
                        const n = planeIntercept(mouseLine, action.plane);
                        const point = add(mouseLine.point, scale(mouseLine.direction, n));
                        const delta = subtract(point, action.plane.point);

                        action.plane.point = point;
                        action.selected.position = add(action.selected.position, delta);
                        action.selected.update();
                    };
                } else {
                    // Rotate the view
                    action.move = (event) => {
                        const deltaX = event.clientX - action.lastX;
                        const deltaY = event.clientY - action.lastY;
                        action.lastX = event.clientX;
                        action.lastY = event.clientY;
                        const sightLine = subtract(app.lookAt, app.eyePosition);
                        const xAxis = cross(sightLine, app.up);
                        const yAxis = cross(sightLine, xAxis);
                        if (event.shiftKey) {
                            const dist = Math.hypot(...sightLine) / -1000;
                            const movement = add(scale(normalised(xAxis), deltaX * dist),   scale(normalised(yAxis), deltaY * dist));
                            app.eyePosition = add(app.eyePosition, movement);
                            app.lookAt = add(app.lookAt, movement);
                        } else {
                            const xRotation = getRotation(deltaY * Math.PI / 60, xAxis);
                            const yRotation = getRotation(deltaX * Math.PI / 60, app.up);
                            const rotation = multiply(xRotation, yRotation);
                            app.eyePosition = subtract(app.lookAt, applyTransform(sightLine, rotation));
                            app.up = applyTransform(app.up, rotation);
                        }
                        app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                        app.updateViewControls();
                    };
                }
            };
            canvas.addEventListener('mousedown', (event) => mouseDown(event));
            canvas.addEventListener('touchstart', (event) => mouseDown(touch(event)));
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const dist = Math.pow(2, event.deltaY / 100);
                const sightLine = subtract(app.lookAt, app.eyePosition);
                const move = sightLine.map((v) => v * dist);
                app.eyePosition = subtract(app.lookAt, move);
                app.viewMatrix = viewMatrix(app.eyePosition, app.lookAt, app.up);
                app.updateViewControls();
            });

            /**
             * Process a dropped file
             */
            function dropHandler(event) {
                event.preventDefault();
                const replace = event.shiftKey;

                function loadFile(file) {
                    const reader = new FileReader();
                    reader.addEventListener('load', (event) => {
                        app.filename = file.name;
                        const objs = getObjects(reader.result);
                        const tree = getTree(objs);
                        const graph = expandGraph(tree);
                        makeGraph(graph, replace);
                    });
                    reader.readAsText(file);
                }

                if (event.dataTransfer.items) {
                    [...event.dataTransfer.items].forEach((item, index) => {
                        if (item.kind === 'file') {
                            const file = item.getAsFile();
                            loadFile(file);
                            item.getAsFileSystemHandle().then((handle) => {
                                //saveFileHandles([{ name: file.name, handle }]);
                            });
                        }
                    });
                } else {
                    // Use DataTransfer interface to access the file(s)
                    [...event.dataTransfer.files].forEach((file, i) => loadFile(file));
                }
            }

            function dragOverHandler(event) {
                // Prevent default behavior (Prevent file from being opened)
                event.preventDefault();
            }

            canvas.addEventListener('dragover', dragOverHandler);
            canvas.addEventListener('drop', dropHandler);
        }

        /**
         * Perform all once off set-up (e.g. creating buffer etc.)
         */
        function initialise() {
            addMovementControls();
            projectionControl();
            viewControl(document.getElementById('view-vectors'));
            addCanvasEvents(canvas);

            // Set clear color to black, fully opaque
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            // Should be update to track canvas size changes
            gl.canvas.width = gl.canvas.clientWidth;
            gl.canvas.height = gl.canvas.clientHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            const attributes = ['position', 'normal', 'model', 'ambientColour', 'diffuseColour', 'specularColour', 'specularIntensity', 'opacity'];
            app.shader = makeProgram(shaderSource, attributes, ['projection', 'view', 'lightPosition1', 'lightPosition2', 'lightPosition3', 'eyePosition']);

            app.buffers = {
                vertex: gl.createBuffer(),
                instances: gl.createBuffer(),
                colour: gl.createBuffer(),
                points: gl.createBuffer(),
                text: gl.createBuffer(),
            };
            app.vertexCount = 36;
            const shape = makeCube();
            gl.bindBuffer(gl.ARRAY_BUFFER, app.buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shape), gl.STATIC_DRAW);

            makeGraph();
            initialiseInstances();
        }

        /**
         * Called once html has loaded.
         *
         * Create the Webgl contect, set up the buffers and call the event loop.
         */
        function main(event) {
            initialise();
            requestAnimationFrame(render);
        }

        window.addEventListener('load', main);
    </script>
</body>

</html>